- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nZSHZLE(1)\t\t    General Commands Manual\t\t     ZSHZLE(1)\n\nNAME\n       zshzle - zsh command line editor\n\nDESCRIPTION\n       If the ZLE option is set (which it is by default in interactive shells)\n       and the shell input is attached to the terminal, the user is able to\n       edit command lines.\n\n       There are two display modes.  The first, multiline mode, is the\n       default.  It only works if the TERM parameter is set to a valid\n       terminal type that can move the cursor up.  The second, single line\n       mode, is used if TERM is invalid or incapable of moving the cursor up,\n       or if the SINGLE_LINE_ZLE option is set.  This mode is similar to ksh,\n       and uses no termcap sequences.  If TERM is \"emacs\", the ZLE option will\n       be unset by default.\n\n       The parameters BAUD, COLUMNS, and LINES are also used by the line\n       editor. See Parameters Used By The Shell in zshparam(1).\n\n       The parameter zle_highlight is also used by the line editor; see\n       Character Highlighting below.  Highlighting of special characters and\n       the region between the cursor and the mark (as set with\n       set-mark-command in Emacs mode, or by visual-mode in Vi mode) is\n       enabled by default; consult this reference for more information.\n       Irascible conservatives will wish to know that all highlighting may be\n       disabled by the following setting:\n\n\t      zle_highlight=(none)\n\n       In many places, references are made to the numeric argument.  This can\n       by default be entered in emacs mode by holding the alt key and typing a\n       number, or pressing escape before each digit, and in vi command mode by\n       typing the number before entering a command.  Generally the numeric\n       argument causes the next command entered to be repeated the specified\n       number of times, unless otherwise noted below; this is implemented by\n       the digit-argument widget. See also the Arguments subsection of the\n       Widgets section for some other ways the numeric argument can be\n       modified.\n\nKEYMAPS\n       A keymap in ZLE contains a set of bindings between key sequences and\n       ZLE commands.  The empty key sequence cannot be bound.\n\n       There can be any number of keymaps at any time, and each keymap has one\n       or more names.  If all of a keymap's names are deleted, it disappears.\n       bindkey can be used to manipulate keymap names.\n\n       Initially, there are eight keymaps:\n\n       emacs  EMACS emulation\n       viins  vi emulation - insert mode\n       vicmd  vi emulation - command mode\n       viopp  vi emulation - operator pending\n       visual vi emulation - selection active\n       isearch\n\t      incremental search mode\n       command\n\t      read a command name\n       .safe  fallback keymap\n\n       The `.safe' keymap is special.  It can never be altered, and the name\n       can never be removed.  However, it can be linked to other names, which\n       can be removed.\tIn the future other special keymaps may be added;\n       users should avoid using names beginning with `.' for their own\n       keymaps.\n\n       In addition to these names, either `emacs' or `viins' is also linked to\n       the name `main'.  If one of the VISUAL or EDITOR environment variables\n       contain the string `vi' when the shell starts up then it will be\n       `viins', otherwise it will be `emacs'.  bindkey's -e and -v options\n       provide a convenient way to override this default choice.\n\n       When the editor starts up, it will select the `main' keymap.  If that\n       keymap doesn't exist, it will use `.safe' instead.\n\n       In the `.safe' keymap, each single key is bound to self-insert, except\n       for ^J (line feed) and ^M (return) which are bound to accept-line.\n       This is deliberately not pleasant to use; if you are using it, it means\n       you deleted the main keymap, and you should put it back.\n\n   Reading Commands\n       When ZLE is reading a command from the terminal, it may read a sequence\n       that is bound to some command and is also a prefix of a longer bound\n       string.\tIn this case ZLE will wait a certain time to see if more\n       characters are typed, and if not (or they don't match any longer\n       string) it will execute the binding.  This timeout is defined by the\n       KEYTIMEOUT parameter; its default is 0.4 sec.  There is no timeout if\n       the prefix string is not itself bound to a command.\n\n       The key timeout is also applied when ZLE is reading the bytes from a\n       multibyte character string when it is in the appropriate mode.  (This\n       requires that the shell was compiled with multibyte mode enabled;\n       typically also the locale has characters with the UTF-8 encoding,\n       although any multibyte encoding known to the operating system is\n       supported.)  If the second or a subsequent byte is not read within the\n       timeout period, the shell acts as if ? were typed and resets the input\n       state.\n\n       As well as ZLE commands, key sequences can be bound to other strings,\n       by using `bindkey -s'.  When such a sequence is read, the replacement\n       string is pushed back as input, and the command reading process starts\n       again using these fake keystrokes.  This input can itself invoke\n       further replacement strings, but in order to detect loops the process\n       will be stopped if there are twenty such replacements without a real\n       command being read.\n\n       A key sequence typed by the user can be turned into a command name for\n       use in user-defined widgets with the read-command widget, described in\n       the subsection `Miscellaneous' of the section `Standard Widgets' below.\n\n   Local Keymaps\n       While for normal editing a single keymap is used exclusively, in many\n       modes a local keymap allows for some keys to be customised. For\n       example, in an incremental search mode, a binding in the isearch keymap\n       will override a binding in the main keymap but all keys that are not\n       overridden can still be used.\n\n       If a key sequence is defined in a local keymap, it will hide a key\n       sequence in the global keymap that is a prefix of that sequence. An\n       example of this occurs with the binding of iw in viopp as this hides\n       the binding of i in vicmd. However, a longer sequence in the global\n       keymap that shares the same prefix can still apply so for example the\n       binding of ^Xa in the global keymap will be unaffected by the binding\n       of ^Xb in the local keymap.\n\nZLE BUILTINS\n       The ZLE module contains three related builtin commands. The bindkey\n       command manipulates keymaps and key bindings; the vared command invokes\n       ZLE on the value of a shell parameter; and the zle command manipulates\n       editing widgets and allows command line access to ZLE commands from\n       within shell functions.\n\n       bindkey [ options ] -l [ -L ] [ keymap ... ]\n       bindkey [ options ] -d\n       bindkey [ options ] -D keymap ...\n       bindkey [ options ] -A old-keymap new-keymap\n       bindkey [ options ] -N new-keymap [ old-keymap ]\n       bindkey [ options ] -m\n       bindkey [ options ] -r in-string ...\n       bindkey [ options ] -s in-string out-string ...\n       bindkey [ options ] in-string command ...\n       bindkey [ options ] [ in-string ]\n\t      bindkey's options can be divided into three categories: keymap\n\t      selection for the current command, operation selection, and\n\t      others.  The keymap selection options are:\n\n\t      -e     Selects keymap `emacs' for any operations by the current\n\t\t     command, and also links `emacs' to `main' so that it is\n\t\t     selected by default the next time the editor starts.\n\n\t      -v     Selects keymap `viins' for any operations by the current\n\t\t     command, and also links `viins' to `main' so that it is\n\t\t     selected by default the next time the editor starts.\n\n\t      -a     Selects keymap `vicmd' for any operations by the current\n\t\t     command.\n\n\t      -M keymap\n\t\t     The keymap specifies a keymap name that is selected for\n\t\t     any operations by the current command.\n\n\t      If a keymap selection is required and none of the options above\n\t      are used, the `main' keymap is used.  Some operations do not\n\t      permit a keymap to be selected, namely:\n\n\t      -l     List all existing keymap names; if any arguments are\n\t\t     given, list just those keymaps.\n\n\t\t     If the -L option is also used, list in the form of\n\t\t     bindkey commands to create or link the keymaps.  `bindkey\n\t\t     -lL main' shows which keymap is linked to `main', if any,\n\t\t     and hence if the standard emacs or vi emulation is in\n\t\t     effect.  This option does not show the .safe keymap\n\t\t     because it cannot be created in that fashion; however,\n\t\t     neither is `bindkey -lL .safe' reported as an error, it\n\t\t     simply outputs nothing.\n\n\t      -d     Delete all existing keymaps and reset to the default\n\t\t     state.\n\n\t      -D keymap ...\n\t\t     Delete the named keymaps.\n\n\t      -A old-keymap new-keymap\n\t\t     Make the new-keymap name an alias for old-keymap, so that\n\t\t     both names refer to the same keymap.  The names have\n\t\t     equal standing; if either is deleted, the other remains.\n\t\t     If there is already a keymap with the new-keymap name, it\n\t\t     is deleted.\n\n\t      -N new-keymap [ old-keymap ]\n\t\t     Create a new keymap, named new-keymap.  If a keymap\n\t\t     already has that name, it is deleted.  If an old-keymap\n\t\t     name is given, the new keymap is initialized to be a\n\t\t     duplicate of it, otherwise the new keymap will be empty.\n\n\t      To use a newly created keymap, it should be linked to main.\n\t      Hence the sequence of commands to create and use a new keymap\n\t      `mymap' initialized from the emacs keymap (which remains\n\t      unchanged) is:\n\n\t\t     bindkey -N mymap emacs\n\t\t     bindkey -A mymap main\n\n\t      Note that while `bindkey -A newmap main' will work when newmap\n\t      is emacs or viins, it will not work for vicmd, as switching from\n\t      vi insert to command mode becomes impossible.\n\n\t      The following operations act on the `main' keymap if no keymap\n\t      selection option was given:\n\n\t      -m     Add the built-in set of meta-key bindings to the selected\n\t\t     keymap.  Only keys that are unbound or bound to\n\t\t     self-insert are affected.\n\n\t      -r in-string ...\n\t\t     Unbind the specified in-strings in the selected keymap.\n\t\t     This is exactly equivalent to binding the strings to\n\t\t     undefined-key.\n\n\t\t     When -R is also used, interpret the in-strings as ranges.\n\n\t\t     When -p is also used, the in-strings specify prefixes.\n\t\t     Any binding that has the given in-string as a prefix, not\n\t\t     including the binding for the in-string itself, if any,\n\t\t     will be removed.  For example,\n\n\t\t\t    bindkey -rpM viins '^['\n\n\t\t     will remove all bindings in the vi-insert keymap\n\t\t     beginning with an escape character (probably cursor\n\t\t     keys), but leave the binding for the escape character\n\t\t     itself (probably vi-cmd-mode).  This is incompatible with\n\t\t     the option -R.\n\n\t      -s in-string out-string ...\n\t\t     Bind each in-string to each out-string.  When in-string\n\t\t     is typed, out-string will be pushed back and treated as\n\t\t     input to the line editor.\tWhen -R is also used,\n\t\t     interpret the in-strings as ranges.\n\n\t\t     Note that both in-string and out-string are subject to\n\t\t     the same form of interpretation, as described below.\n\n\t      in-string command ...\n\t\t     Bind each in-string to each command.  When -R is used,\n\t\t     interpret the in-strings as ranges.\n\n\t      [ in-string ]\n\t\t     List key bindings.  If an in-string is specified, the\n\t\t     binding of that string in the selected keymap is\n\t\t     displayed.  Otherwise, all key bindings in the selected\n\t\t     keymap are displayed.  (As a special case, if the -e or\n\t\t     -v option is used alone, the keymap is not displayed -\n\t\t     the implicit linking of keymaps is the only thing that\n\t\t     happens.)\n\n\t\t     When the option -p is used, the in-string must be\n\t\t     present.  The listing shows all bindings which have the\n\t\t     given key sequence as a prefix, not including any\n\t\t     bindings for the key sequence itself.\n\n\t\t     When the -L option is used, the list is in the form of\n\t\t     bindkey commands to create the key bindings.\n\n\t      When the -R option is used as noted above, a valid range\n\t      consists of two characters, with an optional `-' between them.\n\t      All characters between the two specified, inclusive, are bound\n\t      as specified.\n\n\t      For either in-string or out-string, the following escape\n\t      sequences are recognised:\n\n\t      \\a     bell character\n\t      \\b     backspace\n\t      \\e, \\E escape\n\t      \\f     form feed\n\t      \\n     linefeed (newline)\n\t      \\r     carriage return\n\t      \\t     horizontal tab\n\t      \\v     vertical tab\n\t      \\NNN   character code in octal\n\t      \\xNN   character code in hexadecimal\n\t      \\uNNNN unicode character code in hexadecimal\n\t      \\UNNNNNNNN\n\t\t     unicode character code in hexadecimal\n\t      \\M[-]X character with meta bit set\n\t      \\C[-]X control character\n\t      ^X     control character\n\n\t      In all other cases, `\\' escapes the following character.\tDelete\n\t      is written as `^?'.  Note that `\\M^?' and `^\\M?' are not the\n\t      same, and that (unlike emacs), the bindings `\\M-X' and `\\eX' are\n\t      entirely distinct, although they are initialized to the same\n\t      bindings by `bindkey -m'."
  manpageQuestion1: What is the primary purpose of the zshzle command?
  manpageQuestion2: How can you configure zshzle to use the Vi keymap for command line editing?
  manpageQuestion3: Can you explain how to bind a custom key sequence to a specific command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvared [ -Aacghe ] [ -p prompt ] [ -r rprompt ]\n\t     [ -M main-keymap ] [ -m vicmd-keymap ]\n\t     [ -i init-widget ] [ -f finish-widget ]\n\t     [ -t tty ] name\n\t      The value of the parameter name is loaded into the edit buffer,\n\t      and the line editor is invoked.  When the editor exits, name is\n\t      set to the string value returned by the editor.  When the -c\n\t      flag is given, the parameter is created if it doesn't already\n\t      exist.  The -a flag may be given with -c to create an array\n\t      parameter, or the -A flag to create an associative array.  If\n\t      the type of an existing parameter does not match the type to be\n\t      created, the parameter is unset and recreated.  The -g flag may\n\t      be given to suppress warnings from the WARN_CREATE_GLOBAL and\n\t      WARN_NESTED_VAR options.\n\n\t      If an array or array slice is being edited, separator characters\n\t      as defined in $IFS will be shown quoted with a backslash, as\n\t      will backslashes themselves.  Conversely, when the edited text\n\t      is split into an array, a backslash quotes an immediately\n\t      following separator character or backslash; no other special\n\t      handling of backslashes, or any handling of quotes, is\n\t      performed."
  manpageQuestion1: What is the primary purpose of the vared command in the Zsh shell?
  manpageQuestion2: How can you use vared to create an associative array parameter named 'myassoc' that prompts the user for input?
  manpageQuestion3: Can you provide an example of using vared to edit a string parameter 'myvar' and suppress warnings about global variables?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nIndividual elements of existing array or associative array\n\t      parameters may be edited by using subscript syntax on name.  New\n\t      elements are created automatically, even without -c.\n\n\t      If the -p flag is given, the following string will be taken as\n\t      the prompt to display at the left.  If the -r flag is given, the\n\t      following string gives the prompt to display at the right.  If\n\t      the -h flag is specified, the history can be accessed from ZLE.\n\t      If the -e flag is given, typing ^D (Control-D) on an empty line\n\t      causes vared to exit immediately with a non-zero return value.\n\n\t      The -M option gives a keymap to link to the main keymap during\n\t      editing, and the -m option gives a keymap to link to the vicmd\n\t      keymap during editing.  For vi-style editing, this allows a pair\n\t      of keymaps to override viins and vicmd.  For emacs-style\n\t      editing, only -M is normally needed but the -m option may still\n\t      be used.\tOn exit, the previous keymaps will be restored."
  manpageQuestion1: What is the primary purpose of the zshzle tool?
  manpageQuestion2: How can you configure zshzle to display a custom prompt on the left and right sides during editing?
  manpageQuestion3: What options are available to customize the keymaps used by zshzle during editing?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nVared calls the usual `zle-line-init' and `zle-line-finish'\n\t      hooks before and after it takes control. Using the -i and -f\n\t      options, it is possible to replace these with other custom\n\t      widgets.\n\n\t      If `-t tty' is given, tty is the name of a terminal device to be\n\t      used instead of the default /dev/tty.  If tty does not refer to\n\t      a terminal an error is reported.\n\n       zle\n       zle -l [ -L | -a ] [ string ... ]\n       zle -D widget ...\n       zle -A old-widget new-widget\n       zle -N widget [ function ]\n       zle -f flag [ flag... ]\n       zle -C widget completion-widget function\n       zle -R [ -c ] [ display-string ] [ string ... ]\n       zle -M string\n       zle -U string\n       zle -K keymap\n       zle -F [ -L | -w ] [ fd [ handler ] ]\n       zle -I\n       zle -T [ tc function | -r tc | -L ]\n       zle widget [ -n num ] [ -f flag ] [ -Nw ] [ -K keymap ] args ...\n\t      The zle builtin performs a number of different actions\n\t      concerning ZLE.\n\n\t      With no options and no arguments, only the return status will be\n\t      set.  It is zero if ZLE is currently active and widgets could be\n\t      invoked using this builtin command and non-zero otherwise.  Note\n\t      that even if non-zero status is returned, zle may still be\n\t      active as part of the completion system; this does not allow\n\t      direct calls to ZLE widgets."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to customize the line editing behavior in a shell session?
  manpageQuestion3: Can you provide an example of using zshzle to redirect input from a specific terminal device?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nOtherwise, which operation it performs depends on its options:\n\n\t      -l [ -L | -a ] [ string ]\n\t\t     List all existing user-defined widgets.  If the -L option\n\t\t     is used, list in the form of zle commands to create the\n\t\t     widgets.\n\n\t\t     When combined with the -a option, all widget names are\n\t\t     listed, including the builtin ones. In this case the -L\n\t\t     option is ignored.\n\n\t\t     If at least one string is given, and -a is present or -L\n\t\t     is not used, nothing will be printed.  The return status\n\t\t     will be zero if all strings are names of existing widgets\n\t\t     and non-zero if at least one string is not a name of a\n\t\t     defined widget.  If -a is also present, all widget names\n\t\t     are used for the comparison including builtin widgets,\n\t\t     else only user-defined widgets are used.\n\n\t\t     If at least one string is present and the -L option is\n\t\t     used, user-defined widgets matching any string are listed\n\t\t     in the form of zle commands to create the widgets."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you list all user-defined widgets in zshzle, including built-in ones?
  manpageQuestion3: Can you provide an example of using zshzle to list all widgets that match the string 'history'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\n-D widget ...\n\t\t     Delete the named widgets.\n\n\t      -A old-widget new-widget\n\t\t     Make the new-widget name an alias for old-widget, so that\n\t\t     both names refer to the same widget.  The names have\n\t\t     equal standing; if either is deleted, the other remains.\n\t\t     If there is already a widget with the new-widget name, it\n\t\t     is deleted.\n\n\t      -N widget [ function ]\n\t\t     Create a user-defined widget.  If there is already a\n\t\t     widget with the specified name, it is overwritten.  When\n\t\t     the new widget is invoked from within the editor, the\n\t\t     specified shell function is called.  If no function name\n\t\t     is specified, it defaults to the same name as the widget.\n\t\t     For further information, see the section `Widgets' below.\n\n\t      -f flag [ flag... ]\n\t\t     Set various flags on the running widget.  Possible values\n\t\t     for flag are:\n\n\t\t     yank for indicating that the widget has yanked text into\n\t\t     the buffer.  If the widget is wrapping an existing\n\t\t     internal widget, no further action is necessary, but if\n\t\t     it has inserted the text manually, then it should also\n\t\t     take care to set YANK_START and YANK_END correctly.\n\t\t     yankbefore does the same but is used when the yanked text\n\t\t     appears after the cursor."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use zshzle to create a user-defined widget named 'mywidget' that invokes the shell function 'myfunction'?
  manpageQuestion3: Can you provide an example of using zshzle to alias the existing widget 'oldwidget' to a new name 'newwidget'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nkill for indicating that text has been killed into the\n\t\t     cutbuffer.  When repeatedly invoking a kill widget, text\n\t\t     is appended to the cutbuffer instead of replacing it, but\n\t\t     when wrapping such widgets, it is necessary to call `zle\n\t\t     -f kill' to retain this effect.\n\n\t\t     vichange for indicating that the widget represents a vi\n\t\t     change that can be repeated as a whole with\n\t\t     `vi-repeat-change'. The flag should be set early in the\n\t\t     function before inspecting the value of NUMERIC or\n\t\t     invoking other widgets. This has no effect for a widget\n\t\t     invoked from insert mode. If insert mode is active when\n\t\t     the widget finishes, the change extends until next\n\t\t     returning to command mode.\n\n\t      -C widget completion-widget function\n\t\t     Create a user-defined completion widget named widget. The\n\t\t     completion widget will behave like the built-in\n\t\t     completion-widget whose name is given as\n\t\t     completion-widget. To generate the completions, the shell\n\t\t     function function will be called.\tFor further\n\t\t     information, see zshcompwid(1)."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use zshzle to create a custom completion widget named 'mycomplete' that calls a shell function called 'mycompletionfunction'?
  manpageQuestion3: Can you provide an example of using zshzle to set a widget as a vi-change mode that can be repeated with `vi-repeat-change`?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\n-R [ -c ] [ display-string ] [ string ... ]\n\t\t     Redisplay the command line.  If a display-string is given\n\t\t     and not empty, this is shown in the status line\n\t\t     (immediately below the line being edited).\n\n\t\t     If the optional strings are given they are listed below\n\t\t     the prompt in the same way as completion lists are\n\t\t     printed. If no strings are given but the -c option is\n\t\t     used such a list is cleared.\n\n\t\t     Note that immediately after returning from running\n\t\t     widgets, the command line will be redisplayed and the\n\t\t     strings displayed will be erased.\tTherefore, this option\n\t\t     is only useful for widgets that do not exit immediately\n\t\t     after using it.\n\n\t\t     This command can safely be called outside user defined\n\t\t     widgets; if zle is active, the display will be refreshed,\n\t\t     while if zle is not active, the command has no effect.\n\t\t     In this case there will usually be no other arguments.\n\n\t\t     The status is zero if zle was active, else one."
  manpageQuestion1: What is the primary purpose of the zshzle command?
  manpageQuestion2: How can I use zshzle to display a custom message in the status line after executing a command?
  manpageQuestion3: Can you provide an example of using zshzle to show a list of completion options below the prompt?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\n-M string\n\t\t     As with the -R option, the string will be displayed below\n\t\t     the command line; unlike the -R option, the string will\n\t\t     not be put into the status line but will instead be\n\t\t     printed normally below the prompt.  This means that the\n\t\t     string will still be displayed after the widget returns\n\t\t     (until it is overwritten by subsequent commands).\n\n\t      -U string\n\t\t     This pushes the characters in the string onto the input\n\t\t     stack of ZLE.  After the widget currently executed\n\t\t     finishes ZLE will behave as if the characters in the\n\t\t     string were typed by the user.\n\n\t\t     As ZLE uses a stack, if this option is used repeatedly\n\t\t     the last string pushed onto the stack will be processed\n\t\t     first.  However, the characters in each string will be\n\t\t     processed in the order in which they appear in the\n\t\t     string.\n\n\t      -K keymap\n\t\t     Selects the keymap named keymap.  An error message will\n\t\t     be displayed if there is no such keymap."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use the -M option with zshzle to display a custom message below the command line?
  manpageQuestion3: Can you explain how to use the -U option with zshzle to push a string onto the input stack for later processing?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nThis keymap selection affects the interpretation of\n\t\t     following keystrokes within this invocation of ZLE.  Any\n\t\t     following invocation (e.g., the next command line) will\n\t\t     start as usual with the `main' keymap selected.\n\n\t      -F [ -L | -w ] [ fd [ handler ] ]\n\t\t     Only available if your system supports one of the `poll'\n\t\t     or `select' system calls; most modern systems do.\n\n\t\t     Installs handler (the name of a shell function) to handle\n\t\t     input from file descriptor fd.  Installing a handler for\n\t\t     an fd which is already handled causes the existing\n\t\t     handler to be replaced.  Any number of handlers for any\n\t\t     number of readable file descriptors may be installed.\n\t\t     Note that zle makes no attempt to check whether this fd\n\t\t     is actually readable when installing the handler.\tThe\n\t\t     user must make their own arrangements for handling the\n\t\t     file descriptor when zle is not active.\n\n\t\t     When zle is attempting to read data, it will examine both\n\t\t     the terminal and the list of handled fd's.  If data\n\t\t     becomes available on a handled fd, zle calls handler with\n\t\t     the fd which is ready for reading as the first argument.\n\t\t     Under normal circumstances this is the only argument, but\n\t\t     if an error was detected, a second argument provides\n\t\t     details: `hup' for a disconnect, `nval' for a closed or\n\t\t     otherwise invalid descriptor, or `err' for any other\n\t\t     condition.  Systems that support only the `select' system\n\t\t     call always use `err'."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you configure zshzle to handle input from a specific file descriptor using a custom shell function?
  manpageQuestion3: What is the difference between using -F with -L and -F with -w in the zshzle command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nIf the option -w is also given, the handler is instead a\n\t\t     line editor widget, typically a shell function made into\n\t\t     a widget using `zle -N'.  In that case handler can use\n\t\t     all the facilities of zle to update the current editing\n\t\t     line.  Note, however, that as handling fd takes place at\n\t\t     a low level changes to the display will not automatically\n\t\t     appear; the widget should call `zle -R' to force\n\t\t     redisplay.  As of this writing, widget handlers only\n\t\t     support a single argument and thus are never passed a\n\t\t     string for error state, so widgets must be prepared to\n\t\t     test the descriptor themselves.\n\n\t\t     If either type of handler produces output to the\n\t\t     terminal, it should call `zle -I' before doing so (see\n\t\t     below).  Handlers should not attempt to read from the\n\t\t     terminal.\n\n\t\t     If no handler is given, but an fd is present, any handler\n\t\t     for that fd is removed.  If there is none, an error\n\t\t     message is printed and status 1 is returned.\n\n\t\t     If no arguments are given, or the -L option is supplied,\n\t\t     a list of handlers is printed in a form which can be\n\t\t     stored for later execution.\n\n\t\t     An fd (but not a handler) may optionally be given with\n\t\t     the -L option; in this case, the function will list the\n\t\t     handler if any, else silently return status 1.\n\n\t\t     Note that this feature should be used with care.\n\t\t     Activity on one of the fd's which is not properly handled\n\t\t     can cause the terminal to become unusable.  Removing an\n\t\t     fd handler from within a signal trap may cause\n\t\t     unpredictable behavior.\n\n\t\t     Here is a simple example of using this feature.  A\n\t\t     connection to a remote TCP port is created using the ztcp\n\t\t     command; see the description of the zsh/net/tcp module in\n\t\t     zshmodules(1).  Then a handler is installed which simply\n\t\t     prints out any data which arrives on this connection.\n\t\t     Note that `select' will indicate that the file descriptor\n\t\t     needs handling if the remote side has closed the\n\t\t     connection; we handle that by testing for a failed read.\n\n\t\t\t    if ztcp pwspc 2811; then\n\t\t\t      tcpfd=$REPLY\n\t\t\t      handler() {\n\t\t\t\tzle -I\n\t\t\t\tlocal line\n\t\t\t\tif ! read -r line <&$1; then\n\t\t\t\t  # select marks this fd if we reach EOF,\n\t\t\t\t  # so handle this specially.\n\t\t\t\t  print \"[Read on fd $1 failed, removing.]\" >&2\n\t\t\t\t  zle -F $1\n\t\t\t\t  return 1\n\t\t\t\tfi\n\t\t\t\tprint -r - $line\n\t\t\t      }\n\t\t\t      zle -F $tcpfd handler\n\t\t\t    fi\n\n\t      -I     Unusually, this option is most useful outside ordinary\n\t\t     widget functions, though it may be used within if normal\n\t\t     output to the terminal is required.  It invalidates the\n\t\t     current zle display in preparation for output; typically\n\t\t     this will be from a trap function.  It has no effect if\n\t\t     zle is not active.  When a trap exits, the shell checks\n\t\t     to see if the display needs restoring, hence the\n\t\t     following will print output in such a way as not to\n\t\t     disturb the line being edited:\n\n\t\t\t    TRAPUSR1() {\n\t\t\t      # Invalidate zle display\n\t\t\t      [[ -o zle ]] && zle -I\n\t\t\t      # Show output\n\t\t\t      print Hello\n\t\t\t    }\n\n\t\t     In general, the trap function may need to test whether\n\t\t     zle is active before using this method (as shown in the\n\t\t     example), since the zsh/zle module may not even be\n\t\t     loaded; if it is not, the command can be skipped.\n\n\t\t     It is possible to call `zle -I' several times before\n\t\t     control is returned to the editor; the display will only\n\t\t     be invalidated the first time to minimise disruption.\n\n\t\t     Note that there are normally better ways of manipulating\n\t\t     the display from within zle widgets; see, for example,\n\t\t     `zle -R' above.\n\n\t\t     The returned status is zero if zle was invalidated, even\n\t\t     though this may have been by a previous call to `zle -I'\n\t\t     or by a system notification.  To test if a zle widget may\n\t\t     be called at this point, execute zle with no arguments\n\t\t     and examine the return status.\n\n\t      -T     This is used to add, list or remove internal\n\t\t     transformations on the processing performed by the line\n\t\t     editor.  It is typically used only for debugging or\n\t\t     testing and is therefore of little interest to the\n\t\t     general user.\n\n\t\t     `zle -T transformation func' specifies that the given\n\t\t     transformation (see below) is effected by shell function\n\t\t     func.\n\n\t\t     `zle -Tr transformation' removes the given transformation\n\t\t     if it was present (it is not an error if none was).\n\n\t\t     `zle -TL' can be used to list all transformations\n\t\t     currently in operation.\n\n\t\t     Currently the only transformation is tc.  This is used\n\t\t     instead of outputting termcap codes to the terminal.\n\t\t     When the transformation is in operation the shell\n\t\t     function is passed the termcap code that would be output\n\t\t     as its first argument; if the operation required a\n\t\t     numeric argument, that is passed as a second argument.\n\t\t     The function should set the shell variable REPLY to the\n\t\t     transformed termcap code.\tTypically this is used to\n\t\t     produce some simply formatted version of the code and\n\t\t     optional argument for debugging or testing.  Note that\n\t\t     this transformation is not applied to other non-printing\n\t\t     characters such as carriage returns and newlines.\n\n\t      widget [ -n num ] [ -f flag ] [ -Nw ] [ -K keymap ] args ...\n\t\t     Invoke the specified widget.  This can only be done when\n\t\t     ZLE is active; normally this will be within a\n\t\t     user-defined widget.\n\n\t\t     With the options -n and -N, the current numeric argument\n\t\t     will be saved and then restored after the call to widget;\n\t\t     `-n num' sets the numeric argument temporarily to num,\n\t\t     while `-N' sets it to the default, i.e. as if there were\n\t\t     none.\n\n\t\t     With the option -K, keymap will be used as the current\n\t\t     keymap during the execution of the widget.  The previous\n\t\t     keymap will be restored when the widget exits.\n\n\t\t     Normally, calling a widget in this way does not set the\n\t\t     special parameter WIDGET and related parameters, so that\n\t\t     the environment appears as if the top-level widget called\n\t\t     by the user were still active.  With the option -w,\n\t\t     WIDGET and related parameters are set to reflect the\n\t\t     widget being executed by the zle call.\n\n\t\t     Normally, when widget returns the special parameter\n\t\t     LASTWIDGET will point to it.  This can be inhibited by\n\t\t     passing the option -f nolast.\n\n\t\t     Any further arguments will be passed to the widget; note\n\t\t     that as standard argument handling is performed, any\n\t\t     general argument list should be preceded by --.  If it is\n\t\t     a shell function, these are passed down as positional\n\t\t     parameters; for builtin widgets it is up to the widget in\n\t\t     question what it does with them.  Currently arguments are\n\t\t     only handled by the incremental-search commands, the\n\t\t     history-search-forward and -backward and the\n\t\t     corresponding functions prefixed by vi-, and by\n\t\t     universal-argument.  No error is flagged if the command\n\t\t     does not use the arguments, or only uses some of them.\n\n\t\t     The return status reflects the success or failure of the\n\t\t     operation carried out by the widget, or if it is a\n\t\t     user-defined widget the return status of the shell\n\t\t     function.\n\n\t\t     A non-zero return status causes the shell to beep when\n\t\t     the widget exits, unless the BEEP options was unset or\n\t\t     the widget was called via the zle command.  Thus if a\n\t\t     user defined widget requires an immediate beep, it should\n\t\t     call the beep widget directly.\n\nZLE WIDGETS\n       All actions in the editor are performed by `widgets'.  A widget's job\n       is simply to perform some small action.\tThe ZLE commands that key\n       sequences in keymaps are bound to are in fact widgets.  Widgets can be\n       user-defined or built in.\n\n       The standard widgets built into ZLE are listed in the section `Standard\n       Widgets' below.\tOther built-in widgets can be defined by other modules\n       (see zshmodules(1)).  Each built-in widget has two names: its normal\n       canonical name, and the same name preceded by a `.'.  The `.' name is\n       special: it can't be rebound to a different widget.  This makes the\n       widget available even when its usual name has been redefined.\n\n       User-defined widgets are defined using `zle -N', and implemented as\n       shell functions.  When the widget is executed, the corresponding shell\n       function is executed, and can perform editing (or other) actions.  It\n       is recommended that user-defined widgets should not have names starting\n       with `.'.\n\nUSER-DEFINED WIDGETS\n       User-defined widgets, being implemented as shell functions, can execute\n       any normal shell command.  They can also run other widgets (whether\n       built-in or user-defined) using the zle builtin command. The standard\n       input of the function is redirected from /dev/null to prevent external\n       commands from unintentionally blocking ZLE by reading from the\n       terminal, but read -k or read -q can be used to read characters.\n       Finally, they can examine and edit the ZLE buffer being edited by\n       reading and setting the special parameters described below.\n\n       These special parameters are always available in widget functions, but\n       are not in any way special outside ZLE.\tIf they have some normal value\n       outside ZLE, that value is temporarily inaccessible, but will return\n       when the widget function exits.\tThese special parameters in fact have\n       local scope, like parameters created in a function using local.\n\n       Inside completion widgets and traps called while ZLE is active, these\n       parameters are available read-only.\n\n       Note that the parameters appear as local to any ZLE widget in which\n       they appear.  Hence if it is desired to override them this needs to be\n       done within a nested function:\n\n\t      widget-function() {\n\t\t# $WIDGET here refers to the special variable\n\t\t# that is local inside widget-function\n\t\t() {\n\t\t   # This anonymous nested function allows WIDGET\n\t\t   # to be used as a local variable.  The -h\n\t\t   # removes the special status of the variable.\n\t\t   local -h WIDGET\n\t\t}\n\t      }\n\n       BUFFER (scalar)\n\t      The entire contents of the edit buffer.  If it is written to,\n\t      the cursor remains at the same offset, unless that would put it\n\t      outside the buffer.\n\n       BUFFERLINES (integer)\n\t      The number of screen lines needed for the edit buffer currently\n\t      displayed on screen (i.e. without any changes to the preceding\n\t      parameters done after the last redisplay); read-only.\n\n       CONTEXT (scalar)\n\t      The context in which zle was called to read a line; read-only.\n\t      One of the values:\n\n\t      start  The start of a command line (at prompt PS1).\n\n\t      cont   A continuation to a command line (at prompt PS2).\n\n\t      select In a select loop (at prompt PS3).\n\n\t      vared  Editing a variable in vared.\n\n       CURSOR (integer)\n\t      The offset of the cursor, within the edit buffer.  This is in\n\t      the range 0 to $#BUFFER, and is by definition equal to\n\t      $#LBUFFER.  Attempts to move the cursor outside the buffer will\n\t      result in the cursor being moved to the appropriate end of the\n\t      buffer.\n\n       CUTBUFFER (scalar)\n\t      The last item cut using one of the `kill-' commands; the string\n\t      which the next yank would insert in the line.  Later entries in\n\t      the kill ring are in the array killring.\tNote that the command\n\t      `zle copy-region-as-kill string' can be used to set the text of\n\t      the cut buffer from a shell function and cycle the kill ring in\n\t      the same way as interactively killing text.\n\n       HISTNO (integer)\n\t      The current history number.  Setting this has the same effect as\n\t      moving up or down in the history to the corresponding history\n\t      line.  An attempt to set it is ignored if the line is not stored\n\t      in the history.  Note this is not the same as the parameter\n\t      HISTCMD, which always gives the number of the history line being\n\t      added to the main shell's history.  HISTNO refers to the line\n\t      being retrieved within zle.\n\n       ISEARCHMATCH_ACTIVE (integer)\n       ISEARCHMATCH_START (integer)\n       ISEARCHMATCH_END (integer)\n\t      ISEARCHMATCH_ACTIVE indicates whether a part of the BUFFER is\n\t      currently matched by an incremental search pattern.\n\t      ISEARCHMATCH_START and ISEARCHMATCH_END give the location of the\n\t      matched part and are in the same units as CURSOR. They are only\n\t      valid for reading when ISEARCHMATCH_ACTIVE is non-zero.\n\n\t      All parameters are read-only.\n\n       KEYMAP (scalar)\n\t      The name of the currently selected keymap; read-only.\n\n       KEYS (scalar)\n\t      The keys typed to invoke this widget, as a literal string;\n\t      read-only.\n\n       KEYS_QUEUED_COUNT (integer)\n\t      The number of bytes pushed back to the input queue and therefore\n\t      available for reading immediately before any I/O is done;\n\t      read-only.  See also PENDING; the two values are distinct.\n\n       killring (array)\n\t      The array of previously killed items, with the most recently\n\t      killed first.  This gives the items that would be retrieved by a\n\t      yank-pop in the same order.  Note, however, that the most\n\t      recently killed item is in $CUTBUFFER; $killring shows the array\n\t      of previous entries.\n\n\t      The default size for the kill ring is eight, however the length\n\t      may be changed by normal array operations.  Any empty string in\n\t      the kill ring is ignored by the yank-pop command, hence the size\n\t      of the array effectively sets the maximum length of the kill\n\t      ring, while the number of non-zero strings gives the current\n\t      length, both as seen by the user at the command line.\n\n       LASTABORTEDSEARCH (scalar)\n\t      The last search string used by an interactive search that was\n\t      aborted by the user (status 3 returned by the search widget).\n\n       LASTSEARCH (scalar)\n\t      The last search string used by an interactive search; read-only.\n\t      This is set even if the search failed (status 0, 1 or 2 returned\n\t      by the search widget), but not if it was aborted by the user.\n\n       LASTWIDGET (scalar)\n\t      The name of the last widget that was executed; read-only.\n\n       LBUFFER (scalar)\n\t      The part of the buffer that lies to the left of the cursor\n\t      position.  If it is assigned to, only that part of the buffer is\n\t      replaced, and the cursor remains between the new $LBUFFER and\n\t      the old $RBUFFER.\n\n       MARK (integer)\n\t      Like CURSOR, but for the mark. With vi-mode operators that wait\n\t      for a movement command to select a region of text, setting MARK\n\t      allows the selection to extend in both directions from the\n\t      initial cursor position.\n\n       NUMERIC (integer)\n\t      The numeric argument. If no numeric argument was given, this\n\t      parameter is unset. When this is set inside a widget function,\n\t      builtin widgets called with the zle builtin command will use the\n\t      value assigned. If it is unset inside a widget function, builtin\n\t      widgets called behave as if no numeric argument was given.\n\n       PENDING (integer)\n\t      The number of bytes pending for input, i.e. the number of bytes\n\t      which have already been typed and can immediately be read. On\n\t      systems where the shell is not able to get this information,\n\t      this parameter will always have a value of zero.\tRead-only.\n\t      See also KEYS_QUEUED_COUNT; the two values are distinct.\n\n       PREBUFFER (scalar)\n\t      In a multi-line input at the secondary prompt, this read-only\n\t      parameter contains the contents of the lines before the one the\n\t      cursor is currently in.\n\n       PREDISPLAY (scalar)\n\t      Text to be displayed before the start of the editable text\n\t      buffer.  This does not have to be a complete line; to display a\n\t      complete line, a newline must be appended explicitly.  The text\n\t      is reset on each new invocation (but not recursive invocation)\n\t      of zle.\n\n       POSTDISPLAY (scalar)\n\t      Text to be displayed after the end of the editable text buffer.\n\t      This does not have to be a complete line; to display a complete\n\t      line, a newline must be prepended explicitly.  The text is reset\n\t      on each new invocation (but not recursive invocation) of zle.\n\n       RBUFFER (scalar)\n\t      The part of the buffer that lies to the right of the cursor\n\t      position.  If it is assigned to, only that part of the buffer is\n\t      replaced, and the cursor remains between the old $LBUFFER and\n\t      the new $RBUFFER.\n\n       REGION_ACTIVE (integer)\n\t      Indicates if the region is currently active.  It can be assigned\n\t      0 or 1 to deactivate and activate the region respectively. A\n\t      value of 2 activates the region in line-wise mode with the\n\t      highlighted text extending for whole lines only; see Character\n\t      Highlighting below.\n\n       region_highlight (array)\n\t      Each element of this array may be set to a string that describes\n\t      highlighting for an arbitrary region of the command line that\n\t      will take effect the next time the command line is redisplayed.\n\t      Highlighting of the non-editable parts of the command line in\n\t      PREDISPLAY and POSTDISPLAY are possible, but note that the P\n\t      flag is needed for character indexing to include PREDISPLAY.\n\n\t      Each string consists of the following whitespace-separated\n\t      parts:\n\n\t      •      Optionally, a `P' to signify that the start and end\n\t\t     offset that follow include any string set by the\n\t\t     PREDISPLAY special parameter; this is needed if the\n\t\t     predisplay string itself is to be highlighted.\n\t\t     Whitespace between the `P' and the start offset is\n\t\t     optional.\n\n\t      •      A start offset in the same units as CURSOR.\n\n\t      •      An end offset in the same units as CURSOR.\n\n\t      •      A highlight specification in the same format as used for\n\t\t     contexts in the parameter zle_highlight, see the section\n\t\t     `Character Highlighting' below; for example, standout or\n\t\t     fg=red,bold.\n\n\t      •      Optionally, a string of the form `memo=token'.  The token\n\t\t     consists of everything between the `=' and the next\n\t\t     whitespace, comma, NUL, or the end of the string.\tThe\n\t\t     token is preserved verbatim but not parsed in any way.\n\n\t\t     Plugins may use this to identify array elements they have\n\t\t     added: for example, a plugin might set token to its (the\n\t\t     plugin's) name and then use `region_highlight=(\n\t\t     ${region_highlight:#*memo=token} )' in order to remove\n\t\t     array elements it have added.\n\n\t\t     (This example uses the `${name:#pattern}' array-grepping\n\t\t     syntax described in the section `Parameter Expansion' in\n\t\t     zshexpn(1).)\n\n\t      For example,\n\n\t\t     region_highlight=(\"P0 20 bold memo=foobar\")\n\n\t      specifies that the first twenty characters of the text including\n\t      any predisplay string should be highlighted in bold.\n\n\t      Note that the effect of region_highlight is not saved and\n\t      disappears as soon as the line is accepted.\n\n\t      Note that zsh 5.8 and older do not support the `memo=token'\n\t      field and may misparse the third (highlight specification) field\n\t      when a memo is given."
  manpageQuestion1: What is the primary purpose of the 4ccconv command?
  manpageQuestion2: How can I convert a 4-character code to its hexadecimal representation using 4ccconv?
  manpageQuestion3: What is the correct way to display a 4-character code as an unsigned integer with 4ccconv?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nThe final highlighting on the command line depends on both\n\t      region_highlight and zle_highlight; see the section CHARACTER\n\t      HIGHLIGHTING below for details.\n\n       registers (associative array)\n\t      The contents of each of the vi register buffers. These are\n\t      typically set using vi-set-buffer followed by a delete, change\n\t      or yank command.\n\n       SUFFIX_ACTIVE (integer)\n       SUFFIX_START (integer)\n       SUFFIX_END (integer)\n\t      SUFFIX_ACTIVE indicates whether an auto-removable completion\n\t      suffix is currently active. SUFFIX_START and SUFFIX_END give the\n\t      location of the suffix and are in the same units as CURSOR. They\n\t      are only valid for reading when SUFFIX_ACTIVE is non-zero.\n\n\t      All parameters are read-only.\n\n       UNDO_CHANGE_NO (integer)\n\t      A number representing the state of the undo history.  The only\n\t      use of this is passing as an argument to the undo widget in\n\t      order to undo back to the recorded point.  Read-only."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use the SUFFIX_ACTIVE and SUFFIX_START/SUFFIX_END parameters in zshzle to track an auto-removable completion suffix on the command line?
  manpageQuestion3: What is the role of the UNDO_CHANGE_NO parameter in zshzle, and how is it used with the undo widget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nUNDO_LIMIT_NO (integer)\n\t      A number corresponding to an existing change in the undo\n\t      history; compare UNDO_CHANGE_NO.\tIf this is set to a value\n\t      greater than zero, the undo command will not allow the line to\n\t      be undone beyond the given change number.  It is still possible\n\t      to use `zle undo change' in a widget to undo beyond that point;\n\t      in that case, it will not be possible to undo at all until\n\t      UNDO_LIMIT_NO is reduced.  Set to 0 to disable the limit.\n\n\t      A typical use of this variable in a widget function is as\n\t      follows (note the additional function scope is required):\n\n\t\t     () {\n\t\t       local UNDO_LIMIT_NO=$UNDO_CHANGE_NO\n\t\t       # Perform some form of recursive edit.\n\t\t     }\n\n       WIDGET (scalar)\n\t      The name of the widget currently being executed; read-only.\n\n       WIDGETFUNC (scalar)\n\t      The name of the shell function that implements a widget defined\n\t      with either zle -N or zle -C.  In the former case, this is the\n\t      second argument to the zle -N command that defined the widget,\n\t      or the first argument if there was no second argument.  In the\n\t      latter case this is the third argument to the zle -C command\n\t      that defined the widget.\tRead-only."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you set an undo limit in zshzle to prevent undoing beyond a specific change number?
  manpageQuestion3: What is the function of the WIDGETFUNC variable in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nWIDGETSTYLE (scalar)\n\t      Describes the implementation behind the completion widget\n\t      currently being executed; the second argument that followed zle\n\t      -C when the widget was defined.  This is the name of a builtin\n\t      completion widget.  For widgets defined with zle -N this is set\n\t      to the empty string.  Read-only.\n\n       YANK_ACTIVE (integer)\n       YANK_START (integer)\n       YANK_END (integer)\n\t      YANK_ACTIVE indicates whether text has just been yanked (pasted)\n\t      into the buffer.\tYANK_START and YANK_END give the location of\n\t      the pasted text and are in the same units as CURSOR.  They are\n\t      only valid for reading when YANK_ACTIVE is non-zero.  They can\n\t      also be assigned by widgets that insert text in a yank-like\n\t      fashion, for example wrappers of bracketed-paste.  See also zle\n\t      -f.\n\n\t      YANK_ACTIVE is read-only.\n\n       ZLE_RECURSIVE (integer)\n\t      Usually zero, but incremented inside any instance of\n\t      recursive-edit.  Hence indicates the current recursion level."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can the YANK_ACTIVE variable be used in zshzle to track pasted text?
  manpageQuestion3: What does the ZLE_RECURSIVE variable indicate in the context of zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nZLE_RECURSIVE is read-only.\n\n       ZLE_STATE (scalar)\n\t      Contains a set of space-separated words that describe the\n\t      current zle state.\n\n\t      Currently, the states shown are the insert mode as set by the\n\t      overwrite-mode or vi-replace widgets and whether history\n\t      commands will visit imported entries as controlled by the\n\t      set-local-history widget.  The string contains `insert' if\n\t      characters to be inserted on the command line move existing\n\t      characters to the right or `overwrite' if characters to be\n\t      inserted overwrite existing characters. It contains\n\t      `localhistory' if only local history commands will be visited or\n\t      `globalhistory' if imported history commands will also be\n\t      visited.\n\n\t      The substrings are sorted in alphabetical order so that if you\n\t      want to test for two specific substrings in a future-proof way,\n\t      you can do match by doing:\n\n\t\t     if [[ $ZLE_STATE == *globalhistory*insert* ]]; then ...; fi\n\n   Special Widgets\n       There are a few user-defined widgets which are special to the shell.\n       If they do not exist, no special action is taken.  The environment\n       provided is identical to that for any other editing widget."
  manpageQuestion1: What is the primary purpose of the ZLE_RECURSIVE variable in the zshzle resource?
  manpageQuestion2: How can you check if the current ZLE_STATE includes both 'globalhistory' and 'insert' states in a shell script?
  manpageQuestion3: What is the function of the special user-defined widgets in the zshzle resource?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nzle-isearch-exit\n\t      Executed at the end of incremental search at the point where the\n\t      isearch prompt is removed from the display.  See\n\t      zle-isearch-update for an example.\n\n       zle-isearch-update\n\t      Executed within incremental search when the display is about to\n\t      be redrawn.  Additional output below the incremental search\n\t      prompt can be generated by using `zle -M' within the widget.\n\t      For example,\n\n\t\t     zle-isearch-update() { zle -M \"Line $HISTNO\"; }\n\t\t     zle -N zle-isearch-update\n\n\t      Note the line output by `zle -M' is not deleted on exit from\n\t      incremental search.  This can be done from a zle-isearch-exit\n\t      widget:\n\n\t\t     zle-isearch-exit() { zle -M \"\"; }\n\t\t     zle -N zle-isearch-exit\n\n       zle-line-pre-redraw\n\t      Executed whenever the input line is about to be redrawn,\n\t      providing an opportunity to update the region_highlight array.\n\n       zle-line-init\n\t      Executed every time the line editor is started to read a new\n\t      line of input.  The following example puts the line editor into\n\t      vi command mode when it starts up."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you customize the incremental search prompt in Zsh to display the current line number?
  manpageQuestion3: Can you explain how to set up the zle-line-init widget to enable vi command mode when starting a new line in Zsh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nzle-line-init() { zle -K vicmd; }\n\t\t     zle -N zle-line-init\n\n\t      (The command inside the function sets the keymap directly; it is\n\t      equivalent to zle vi-cmd-mode.)\n\n       zle-line-finish\n\t      This is similar to zle-line-init but is executed every time the\n\t      line editor has finished reading a line of input.\n\n       zle-history-line-set\n\t      Executed when the history line changes.\n\n       zle-keymap-select\n\t      Executed every time the keymap changes, i.e. the special\n\t      parameter KEYMAP is set to a different value, while the line\n\t      editor is active.  Initialising the keymap when the line editor\n\t      starts does not cause the widget to be called.\n\n\t      The value $KEYMAP within the function reflects the new keymap.\n\t      The old keymap is passed as the sole argument.\n\n\t      This can be used for detecting switches between the vi command\n\t      (vicmd) and insert (usually main) keymaps.\n\nSTANDARD WIDGETS\n       The following is a list of all the standard widgets, and their default\n       bindings in emacs mode, vi command mode and vi insert mode (the\n       `emacs', `vicmd' and `viins' keymaps, respectively)."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you configure zshzle to switch between vi command mode and insert mode when starting a new line?
  manpageQuestion3: What is the function of the zle-keymap-select widget in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nNote that cursor keys are bound to movement keys in all three keymaps;\n       the shell assumes that the cursor keys send the key sequences reported\n       by the terminal-handling library (termcap or terminfo).\tThe key\n       sequences shown in the list are those based on the VT100, common on\n       many modern terminals, but in fact these are not necessarily bound.  In\n       the case of the viins keymap, the initial escape character of the\n       sequences serves also to return to the vicmd keymap: whether this\n       happens is determined by the KEYTIMEOUT parameter, see zshparam(1).\n\n   Movement\n       vi-backward-blank-word (unbound) (B) (unbound)\n\t      Move backward one word, where a word is defined as a series of\n\t      non-blank characters.\n\n       vi-backward-blank-word-end (unbound) (gE) (unbound)\n\t      Move to the end of the previous word, where a word is defined as\n\t      a series of non-blank characters.\n\n       backward-char (^B ESC-[D) (unbound) (unbound)\n\t      Move backward one character."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to navigate backward through the text in a shell prompt?
  manpageQuestion3: Can you explain how to configure zshzle to handle cursor key sequences in a terminal?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-backward-char (unbound) (^H h ^?) (ESC-[D)\n\t      Move backward one character, without changing lines.\n\n       backward-word (ESC-B ESC-b) (unbound) (unbound)\n\t      Move to the beginning of the previous word.\n\n       emacs-backward-word\n\t      Move to the beginning of the previous word.\n\n       vi-backward-word (unbound) (b) (unbound)\n\t      Move to the beginning of the previous word, vi-style.\n\n       vi-backward-word-end (unbound) (ge) (unbound)\n\t      Move to the end of the previous word, vi-style.\n\n       beginning-of-line (^A) (unbound) (unbound)\n\t      Move to the beginning of the line.  If already at the beginning\n\t      of the line, move to the beginning of the previous line, if any.\n\n       vi-beginning-of-line\n\t      Move to the beginning of the line, without changing lines.\n\n       down-line (unbound) (unbound) (unbound)\n\t      Move down a line in the buffer.\n\n       end-of-line (^E) (unbound) (unbound)\n\t      Move to the end of the line.  If already at the end of the line,\n\t      move to the end of the next line, if any."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you move backward one character in the current line without changing lines using zshzle?
  manpageQuestion3: What command or key binding can be used to move to the beginning of the previous word in a vi-style manner within zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-end-of-line (unbound) ($) (unbound)\n\t      Move to the end of the line.  If an argument is given to this\n\t      command, the cursor will be moved to the end of the line\n\t      (argument - 1) lines down.\n\n       vi-forward-blank-word (unbound) (W) (unbound)\n\t      Move forward one word, where a word is defined as a series of\n\t      non-blank characters.\n\n       vi-forward-blank-word-end (unbound) (E) (unbound)\n\t      Move to the end of the current word, or, if at the end of the\n\t      current word, to the end of the next word, where a word is\n\t      defined as a series of non-blank characters.\n\n       forward-char (^F ESC-[C) (unbound) (unbound)\n\t      Move forward one character.\n\n       vi-forward-char (unbound) (space l) (ESC-[C)\n\t      Move forward one character.\n\n       vi-find-next-char (^X^F) (f) (unbound)\n\t      Read a character from the keyboard, and move to the next\n\t      occurrence of it in the line.\n\n       vi-find-next-char-skip (unbound) (t) (unbound)\n\t      Read a character from the keyboard, and move to the position\n\t      just before the next occurrence of it in the line."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use vi-forward-blank-word-end to move to the end of the current word or the next word?
  manpageQuestion3: Can you provide an example of using vi-find-next-char to find and move to the next occurrence of a specific character in a line?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-find-prev-char (unbound) (F) (unbound)\n\t      Read a character from the keyboard, and move to the previous\n\t      occurrence of it in the line.\n\n       vi-find-prev-char-skip (unbound) (T) (unbound)\n\t      Read a character from the keyboard, and move to the position\n\t      just after the previous occurrence of it in the line.\n\n       vi-first-non-blank (unbound) (^) (unbound)\n\t      Move to the first non-blank character in the line.\n\n       vi-forward-word (unbound) (w) (unbound)\n\t      Move forward one word, vi-style.\n\n       forward-word (ESC-F ESC-f) (unbound) (unbound)\n\t      Move to the beginning of the next word.  The editor's idea of a\n\t      word is specified with the WORDCHARS parameter.\n\n       emacs-forward-word\n\t      Move to the end of the next word.\n\n       vi-forward-word-end (unbound) (e) (unbound)\n\t      Move to the end of the next word.\n\n       vi-goto-column (ESC-|) (|) (unbound)\n\t      Move to the column specified by the numeric argument.\n\n       vi-goto-mark (unbound) (`) (unbound)\n\t      Move to the specified mark."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use vi-forward-word to move to the beginning of the next word in zshzle?
  manpageQuestion3: What is the function of vi-goto-column in zshzle and how is it used?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-goto-mark-line (unbound) (') (unbound)\n\t      Move to beginning of the line containing the specified mark.\n\n       vi-repeat-find (unbound) (;) (unbound)\n\t      Repeat the last vi-find command.\n\n       vi-rev-repeat-find (unbound) (,) (unbound)\n\t      Repeat the last vi-find command in the opposite direction.\n\n       up-line (unbound) (unbound) (unbound)\n\t      Move up a line in the buffer.\n\n   History Control\n       beginning-of-buffer-or-history (ESC-<) (gg) (unbound)\n\t      Move to the beginning of the buffer, or if already there, move\n\t      to the first event in the history list.\n\n       beginning-of-line-hist\n\t      Move to the beginning of the line.  If already at the beginning\n\t      of the buffer, move to the previous history line.\n\n       beginning-of-history\n\t      Move to the first event in the history list.\n\n       down-line-or-history (^N ESC-[B) (j) (ESC-[B)\n\t      Move down a line in the buffer, or if already at the bottom\n\t      line, move to the next event in the history list."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to move down a line in the buffer or navigate through the history list?
  manpageQuestion3: Can you explain how to use zshzle to repeat the last vi-find command in the opposite direction?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-down-line-or-history (unbound) (+) (unbound)\n\t      Move down a line in the buffer, or if already at the bottom\n\t      line, move to the next event in the history list.  Then move to\n\t      the first non-blank character on the line.\n\n       down-line-or-search\n\t      Move down a line in the buffer, or if already at the bottom\n\t      line, search forward in the history for a line beginning with\n\t      the first word in the buffer.\n\n\t      If called from a function by the zle command with arguments, the\n\t      first argument is taken as the string for which to search,\n\t      rather than the first word in the buffer.\n\n       down-history (unbound) (^N) (unbound)\n\t      Move to the next event in the history list.\n\n       history-beginning-search-backward\n\t      Search backward in the history for a line beginning with the\n\t      current line up to the cursor.  This leaves the cursor in its\n\t      original position.\n\n       end-of-buffer-or-history (ESC->) (unbound) (unbound)\n\t      Move to the end of the buffer, or if already there, move to the\n\t      last event in the history list."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to navigate through the history list in a bash shell?
  manpageQuestion3: Can you explain how to use the 'history-beginning-search-backward' command in zshzle for backward history search?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nend-of-line-hist\n\t      Move to the end of the line.  If already at the end of the\n\t      buffer, move to the next history line.\n\n       end-of-history\n\t      Move to the last event in the history list.\n\n       vi-fetch-history (unbound) (G) (unbound)\n\t      Fetch the history line specified by the numeric argument.  This\n\t      defaults to the current history line (i.e. the one that isn't\n\t      history yet).\n\n       history-incremental-search-backward (^R ^Xr) (unbound) (unbound)\n\t      Search backward incrementally for a specified string.  The\n\t      search is case-insensitive if the search string does not have\n\t      uppercase letters and no numeric argument was given.  The string\n\t      may begin with `^' to anchor the search to the beginning of the\n\t      line.  When called from a user-defined function returns the\n\t      following statuses: 0, if the search succeeded; 1, if the search\n\t      failed; 2, if the search term was a bad pattern; 3, if the\n\t      search was aborted by the send-break command."
  manpageQuestion1: What is the primary purpose of the zshzle utility?
  manpageQuestion2: How can you navigate to the last event in the history list using zshzle?
  manpageQuestion3: What command can be used to search backward incrementally for a specific string in the history using zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nA restricted set of editing functions is available in the\n\t      mini-buffer.  Keys are looked up in the special isearch keymap,\n\t      and if not found there in the main keymap (note that by default\n\t      the isearch keymap is empty).  An interrupt signal, as defined\n\t      by the stty setting, will stop the search and go back to the\n\t      original line.  An undefined key will have the same effect.\n\t      Note that the following always perform the same task within\n\t      incremental searches and cannot be replaced by user defined\n\t      widgets, nor can the set of functions be extended.  The\n\t      supported functions are:\n\n\t      accept-and-hold\n\t      accept-and-infer-next-history\n\t      accept-line\n\t      accept-line-and-down-history\n\t\t     Perform the usual function after exiting incremental\n\t\t     search.  The command line displayed is executed.\n\n\t      backward-delete-char\n\t      vi-backward-delete-char\n\t\t     Back up one place in the search history.  If the search\n\t\t     has been repeated this does not immediately erase a\n\t\t     character in the minibuffer."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to perform an incremental search and then accept the current line as a command?
  manpageQuestion3: Can you provide an example of using zshzle to delete the previous character in the command line during incremental search?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\naccept-search\n\t\t     Exit incremental search, retaining the command line but\n\t\t     performing no further action.  Note that this function is\n\t\t     not bound by default and has no effect outside\n\t\t     incremental search.\n\n\t      backward-delete-word\n\t      backward-kill-word\n\t      vi-backward-kill-word\n\t\t     Back up one character in the minibuffer; if multiple\n\t\t     searches have been performed since the character was\n\t\t     inserted the search history is rewound to the point just\n\t\t     before the character was entered.\tHence this has the\n\t\t     effect of repeating backward-delete-char.\n\n\t      clear-screen\n\t\t     Clear the screen, remaining in incremental search mode.\n\n\t      history-incremental-search-backward\n\t\t     Find the next occurrence of the contents of the\n\t\t     mini-buffer. If the mini-buffer is empty, the most recent\n\t\t     previously used search string is reinstated.\n\n\t      history-incremental-search-forward\n\t\t     Invert the sense of the search.\n\n\t      magic-space\n\t\t     Inserts a non-magical space."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you exit incremental search mode in zshzle while retaining the command line?
  manpageQuestion3: What is the function of the history-incremental-search-backward command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nquoted-insert\n\t      vi-quoted-insert\n\t\t     Quote the character to insert into the minibuffer.\n\n\t      redisplay\n\t\t     Redisplay the command line, remaining in incremental\n\t\t     search mode.\n\n\t      vi-cmd-mode\n\t\t     Select the `vicmd' keymap; the `main' keymap (insert\n\t\t     mode) will be selected initially.\n\n\t\t     In addition, the modifications that were made while in vi\n\t\t     insert mode are merged to form a single undo event.\n\n\t      vi-repeat-search\n\t      vi-rev-repeat-search\n\t\t     Repeat the search.  The direction of the search is\n\t\t     indicated in the mini-buffer.\n\n\t      Any character that is not bound to one of the above functions,\n\t      or self-insert or self-insert-unmeta, will cause the mode to be\n\t      exited.  The character is then looked up and executed in the\n\t      keymap in effect at that point.\n\n\t      When called from a widget function by the zle command, the\n\t      incremental search commands can take a string argument.  This\n\t      will be treated as a string of keys, as for arguments to the\n\t      bindkey command, and used as initial input for the command.  Any\n\t      characters in the string which are unused by the incremental\n\t      search will be silently ignored.\tFor example,"
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use zshzle to enable vi-command mode in the ZLE (Z shell Line Editor) for a more efficient editing experience?
  manpageQuestion3: Can you provide an example of using zshzle to repeat a previous search in the ZLE incremental search mode?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nzle history-incremental-search-backward forceps\n\n\t      will search backwards for forceps, leaving the minibuffer\n\t      containing the string `forceps'.\n\n       history-incremental-search-forward (^S ^Xs) (unbound) (unbound)\n\t      Search forward incrementally for a specified string.  The search\n\t      is case-insensitive if the search string does not have uppercase\n\t      letters and no numeric argument was given.  The string may begin\n\t      with `^' to anchor the search to the beginning of the line.  The\n\t      functions available in the mini-buffer are the same as for\n\t      history-incremental-search-backward.\n\n       history-incremental-pattern-search-backward\n       history-incremental-pattern-search-forward\n\t      These widgets behave similarly to the corresponding widgets with\n\t      no -pattern, but the search string typed by the user is treated\n\t      as a pattern, respecting the current settings of the various\n\t      options affecting pattern matching.  See FILENAME GENERATION in\n\t      zshexpn(1) for a description of patterns.  If no numeric\n\t      argument was given lowercase letters in the search string may\n\t      match uppercase letters in the history.  The string may begin\n\t      with `^' to anchor the search to the beginning of the line."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you perform an incremental backward search for the string `forceps` in Zsh history using zle?
  manpageQuestion3: Can you explain how to use the history-incremental-pattern-search-backward widget with a case-insensitive search for `example` in Zsh history?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nThe prompt changes to indicate an invalid pattern; this may\n\t      simply indicate the pattern is not yet complete.\n\n\t      Note that only non-overlapping matches are reported, so an\n\t      expression with wildcards may return fewer matches on a line\n\t      than are visible by inspection.\n\n       history-search-backward (ESC-P ESC-p) (unbound) (unbound)\n\t      Search backward in the history for a line beginning with the\n\t      first word in the buffer.\n\n\t      If called from a function by the zle command with arguments, the\n\t      first argument is taken as the string for which to search,\n\t      rather than the first word in the buffer.\n\n       vi-history-search-backward (unbound) (/) (unbound)\n\t      Search backward in the history for a specified string.  The\n\t      string may begin with `^' to anchor the search to the beginning\n\t      of the line.\n\n\t      A restricted set of editing functions is available in the\n\t      mini-buffer.  An interrupt signal, as defined by the stty\n\t      setting,\twill stop the search.  The functions available in the\n\t      mini-buffer are: accept-line, backward-delete-char,\n\t      vi-backward-delete-char, backward-kill-word,\n\t      vi-backward-kill-word, clear-screen, redisplay, quoted-insert\n\t      and vi-quoted-insert."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use vi-history-search-backward to search for a line in the history that starts with the string 'example'?
  manpageQuestion3: What are the available functions within the mini-buffer when using zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-cmd-mode is treated the same as accept-line, and magic-space\n\t      is treated as a space.  Any other character that is not bound to\n\t      self-insert or self-insert-unmeta will beep and be ignored. If\n\t      the function is called from vi command mode, the bindings of the\n\t      current insert mode will be used.\n\n\t      If called from a function by the zle command with arguments, the\n\t      first argument is taken as the string for which to search,\n\t      rather than the first word in the buffer.\n\n       history-search-forward (ESC-N ESC-n) (unbound) (unbound)\n\t      Search forward in the history for a line beginning with the\n\t      first word in the buffer.\n\n\t      If called from a function by the zle command with arguments, the\n\t      first argument is taken as the string for which to search,\n\t      rather than the first word in the buffer.\n\n       vi-history-search-forward (unbound) (?) (unbound)\n\t      Search forward in the history for a specified string.  The\n\t      string may begin with `^' to anchor the search to the beginning\n\t      of the line. The functions available in the mini-buffer are the\n\t      same as for vi-history-search-backward.  Argument handling is\n\t      also the same as for that command."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to search forward in the history for a line beginning with the first word in the buffer?
  manpageQuestion3: What is the functionality of the vi-history-search-forward command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\ninfer-next-history (^X^N) (unbound) (unbound)\n\t      Search in the history list for a line matching the current one\n\t      and fetch the event following it.\n\n       insert-last-word (ESC-_ ESC-.) (unbound) (unbound)\n\t      Insert the last word from the previous history event at the\n\t      cursor position.\tIf a positive numeric argument is given,\n\t      insert that word from the end of the previous history event.  If\n\t      the argument is zero or negative insert that word from the left\n\t      (zero inserts the previous command word).  Repeating this\n\t      command replaces the word just inserted with the last word from\n\t      the history event prior to the one just used; numeric arguments\n\t      can be used in the same way to pick a word from that event.\n\n\t      When called from a shell function invoked from a user-defined\n\t      widget, the command can take one to three arguments.  The first\n\t      argument specifies a history offset which applies to successive\n\t      calls to this widget: if it is -1, the default behaviour is\n\t      used, while if it is 1, successive calls will move forwards\n\t      through the history.  The value 0 can be used to indicate that\n\t      the history line examined by the previous execution of the\n\t      command will be reexamined.  Note that negative numbers should\n\t      be preceded by a `--' argument to avoid confusing them with\n\t      options."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to insert the last word of the previous command into the current line?
  manpageQuestion3: Can you provide an example of using zshzle with a numeric argument to insert a specific word from the previous history event?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nIf two arguments are given, the second specifies the word on the\n\t      command line in normal array index notation (as a more natural\n\t      alternative to the numeric argument).  Hence 1 is the first\n\t      word, and -1 (the default) is the last word.\n\n\t      If a third argument is given, its value is ignored, but it is\n\t      used to signify that the history offset is relative to the\n\t      current history line, rather than the one remembered after the\n\t      previous invocations of insert-last-word.\n\n\t      For example, the default behaviour of the command corresponds to\n\n\t\t     zle insert-last-word -- -1 -1\n\n\t      while the command\n\n\t\t     zle insert-last-word -- -1 1 -\n\n\t      always copies the first word of the line in the history\n\t      immediately before the line being edited.  This has the side\n\t      effect that later invocations of the widget will be relative to\n\t      that line.\n\n       vi-repeat-search (unbound) (n) (unbound)\n\t      Repeat the last vi history search.\n\n       vi-rev-repeat-search (unbound) (N) (unbound)\n\t      Repeat the last vi history search, but in reverse."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to insert the last word of the current line into the command history?
  manpageQuestion3: Can you provide an example of using zshzle to repeat the last vi history search in reverse?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nup-line-or-history (^P ESC-[A) (k) (ESC-[A)\n\t      Move up a line in the buffer, or if already at the top line,\n\t      move to the previous event in the history list.\n\n       vi-up-line-or-history (unbound) (-) (unbound)\n\t      Move up a line in the buffer, or if already at the top line,\n\t      move to the previous event in the history list.  Then move to\n\t      the first non-blank character on the line.\n\n       up-line-or-search\n\t      Move up a line in the buffer, or if already at the top line,\n\t      search backward in the history for a line beginning with the\n\t      first word in the buffer.\n\n\t      If called from a function by the zle command with arguments, the\n\t      first argument is taken as the string for which to search,\n\t      rather than the first word in the buffer.\n\n       up-history (unbound) (^P) (unbound)\n\t      Move to the previous event in the history list.\n\n       history-beginning-search-forward\n\t      Search forward in the history for a line beginning with the\n\t      current line up to the cursor.  This leaves the cursor in its\n\t      original position."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you move up a line in the command history using zshzle?
  manpageQuestion3: Can you explain how to search forward in the history for a line that starts with the current line using zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nset-local-history\n\t      By default, history movement commands visit the imported lines\n\t      as well as the local lines. This widget lets you toggle this on\n\t      and off, or set it with the numeric argument. Zero for both\n\t      local and imported lines and nonzero for only local lines.\n\n   Modifying Text\n       vi-add-eol (unbound) (A) (unbound)\n\t      Move to the end of the line and enter insert mode.\n\n       vi-add-next (unbound) (a) (unbound)\n\t      Enter insert mode after the current cursor position, without\n\t      changing lines.\n\n       backward-delete-char (^H ^?) (unbound) (unbound)\n\t      Delete the character behind the cursor.\n\n       vi-backward-delete-char (unbound) (X) (^H)\n\t      Delete the character behind the cursor, without changing lines.\n\t      If in insert mode, this won't delete past the point where insert\n\t      mode was last entered.\n\n       backward-delete-word\n\t      Delete the word behind the cursor.\n\n       backward-kill-line\n\t      Kill from the beginning of the line to the cursor position."
  manpageQuestion1: What is the primary purpose of the zshzle widget?
  manpageQuestion2: How would you modify text in an interactive shell session using zshzle?
  manpageQuestion3: Can you explain how to configure the behavior of history movement commands in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nbackward-kill-word (^W ESC-^H ESC-^?) (unbound) (unbound)\n\t      Kill the word behind the cursor.\n\n       vi-backward-kill-word (unbound) (unbound) (^W)\n\t      Kill the word behind the cursor, without going past the point\n\t      where insert mode was last entered.\n\n       capitalize-word (ESC-C ESC-c) (unbound) (unbound)\n\t      Capitalize the current word and move past it.\n\n       vi-change (unbound) (c) (unbound)\n\t      Read a movement command from the keyboard, and kill from the\n\t      cursor position to the endpoint of the movement.\tThen enter\n\t      insert mode.  If the command is vi-change, change the current\n\t      line.\n\n\t      For compatibility with vi, if the command is vi-forward-word or\n\t      vi-forward-blank-word, the whitespace after the word is not\n\t      included. If you prefer the more consistent behaviour with the\n\t      whitespace included use the following key binding:\n\n\t\t     bindkey -a -s cw dwi\n\n       vi-change-eol (unbound) (C) (unbound)\n\t      Kill to the end of the line and enter insert mode."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use vi-change-eol in zshzle to enter insert mode at the end of the current line?
  manpageQuestion3: What key binding can be used to achieve similar functionality to vi-forward-word in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-change-whole-line (unbound) (S) (unbound)\n\t      Kill the current line and enter insert mode.\n\n       copy-region-as-kill (ESC-W ESC-w) (unbound) (unbound)\n\t      Copy the area from the cursor to the mark to the kill buffer.\n\n\t      If called from a ZLE widget function in the form `zle\n\t      copy-region-as-kill string' then string will be taken as the\n\t      text to copy to the kill buffer.\tThe cursor, the mark and the\n\t      text on the command line are not used in this case.\n\n       copy-prev-word (ESC-^_) (unbound) (unbound)\n\t      Duplicate the word to the left of the cursor.\n\n       copy-prev-shell-word\n\t      Like copy-prev-word, but the word is found by using shell\n\t      parsing, whereas copy-prev-word looks for blanks. This makes a\n\t      difference when the word is quoted and contains spaces.\n\n       vi-delete (unbound) (d) (unbound)\n\t      Read a movement command from the keyboard, and kill from the\n\t      cursor position to the endpoint of the movement.\tIf the command\n\t      is vi-delete, kill the current line."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to copy the previous shell word (including words with spaces) to the kill buffer?
  manpageQuestion3: What command can be used in zshzle to delete the current line and enter insert mode?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\ndelete-char\n\t      Delete the character under the cursor.\n\n       vi-delete-char (unbound) (x) (unbound)\n\t      Delete the character under the cursor, without going past the\n\t      end of the line.\n\n       delete-word\n\t      Delete the current word.\n\n       down-case-word (ESC-L ESC-l) (unbound) (unbound)\n\t      Convert the current word to all lowercase and move past it.\n\n       vi-down-case (unbound) (gu) (unbound)\n\t      Read a movement command from the keyboard, and convert all\n\t      characters from the cursor position to the endpoint of the\n\t      movement to lowercase.  If the movement command is vi-down-case,\n\t      swap the case of all characters on the current line.\n\n       kill-word (ESC-D ESC-d) (unbound) (unbound)\n\t      Kill the current word.\n\n       gosmacs-transpose-chars\n\t      Exchange the two characters behind the cursor.\n\n       vi-indent (unbound) (>) (unbound)\n\t      Indent a number of lines.\n\n       vi-insert (unbound) (i) (unbound)\n\t      Enter insert mode.\n\n       vi-insert-bol (unbound) (I) (unbound)\n\t      Move to the first non-blank character on the line and enter\n\t      insert mode."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you delete the current word in zshzle?
  manpageQuestion3: What command can be used to exchange the two characters behind the cursor in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-join (^X^J) (J) (unbound)\n\t      Join the current line with the next one.\n\n       kill-line (^K) (unbound) (unbound)\n\t      Kill from the cursor to the end of the line.  If already on the\n\t      end of the line, kill the newline character.\n\n       vi-kill-line (unbound) (unbound) (^U)\n\t      Kill from the cursor back to wherever insert mode was last\n\t      entered.\n\n       vi-kill-eol (unbound) (D) (unbound)\n\t      Kill from the cursor to the end of the line.\n\n       kill-region\n\t      Kill from the cursor to the mark.\n\n       kill-buffer (^X^K) (unbound) (unbound)\n\t      Kill the entire buffer.\n\n       kill-whole-line (^U) (unbound) (unbound)\n\t      Kill the current line.\n\n       vi-match-bracket (^X^B) (%) (unbound)\n\t      Move to the bracket character (one of {}, () or []) that matches\n\t      the one under the cursor.  If the cursor is not on a bracket\n\t      character, move forward without going past the end of the line\n\t      to find one, and then go to the matching bracket.\n\n       vi-open-line-above (unbound) (O) (unbound)\n\t      Open a line above the cursor and enter insert mode."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to join the current line with the next one in a Vim-like editing mode?
  manpageQuestion3: What is the function of the 'vi-kill-line' command in zshzle and how would you invoke it?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-open-line-below (unbound) (o) (unbound)\n\t      Open a line below the cursor and enter insert mode.\n\n       vi-oper-swap-case (unbound) (g~) (unbound)\n\t      Read a movement command from the keyboard, and swap the case of\n\t      all characters from the cursor position to the endpoint of the\n\t      movement.  If the movement command is vi-oper-swap-case, swap\n\t      the case of all characters on the current line.\n\n       overwrite-mode (^X^O) (unbound) (unbound)\n\t      Toggle between overwrite mode and insert mode.\n\n       vi-put-before (unbound) (P) (unbound)\n\t      Insert the contents of the kill buffer before the cursor.  If\n\t      the kill buffer contains a sequence of lines (as opposed to\n\t      characters), paste it above the current line.\n\n       vi-put-after (unbound) (p) (unbound)\n\t      Insert the contents of the kill buffer after the cursor.\tIf the\n\t      kill buffer contains a sequence of lines (as opposed to\n\t      characters), paste it below the current line.\n\n       put-replace-selection (unbound) (unbound) (unbound)\n\t      Replace the contents of the current region or selection with the\n\t      contents of the kill buffer. If the kill buffer contains a\n\t      sequence of lines (as opposed to characters), the current line\n\t      will be split by the pasted lines."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use vi-put-after to insert the contents of the kill buffer after the cursor?
  manpageQuestion3: Can you explain how to replace the current region with the contents of the kill buffer using put-replace-selection?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nquoted-insert (^V) (unbound) (unbound)\n\t      Insert the next character typed into the buffer literally.  An\n\t      interrupt character will not be inserted.\n\n       vi-quoted-insert (unbound) (unbound) (^Q ^V)\n\t      Display a `^' at the cursor position, and insert the next\n\t      character typed into the buffer literally.  An interrupt\n\t      character will not be inserted.\n\n       quote-line (ESC-') (unbound) (unbound)\n\t      Quote the current line; that is, put a `'' character at the\n\t      beginning and the end, and convert all `'' characters to `'\\'''.\n\n       quote-region (ESC-\") (unbound) (unbound)\n\t      Quote the region from the cursor to the mark.\n\n       vi-replace (unbound) (R) (unbound)\n\t      Enter overwrite mode.\n\n       vi-repeat-change (unbound) (.) (unbound)\n\t      Repeat the last vi mode text modification.  If a count was used\n\t      with the modification, it is remembered.\tIf a count is given to\n\t      this command, it overrides the remembered count, and is\n\t      remembered for future uses of this command.  The cut buffer\n\t      specification is similarly remembered."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you insert the next character into the buffer literally without interpreting it as a meta-character in zshzle?
  manpageQuestion3: What is the function of the quote-line command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-replace-chars (unbound) (r) (unbound)\n\t      Replace the character under the cursor with a character read\n\t      from the keyboard.\n\n       self-insert (printable characters) (unbound) (printable characters and\n       some control characters)\n\t      Insert a character into the buffer at the cursor position.\n\n       self-insert-unmeta (ESC-^I ESC-^J ESC-^M) (unbound) (unbound)\n\t      Insert a character into the buffer after stripping the meta bit\n\t      and converting ^M to ^J.\n\n       vi-substitute (unbound) (s) (unbound)\n\t      Substitute the next character(s).\n\n       vi-swap-case (unbound) (~) (unbound)\n\t      Swap the case of the character under the cursor and move past\n\t      it.\n\n       transpose-chars (^T) (unbound) (unbound)\n\t      Exchange the two characters to the left of the cursor if at end\n\t      of line, else exchange the character under the cursor with the\n\t      character to the left.\n\n       transpose-words (ESC-T ESC-t) (unbound) (unbound)\n\t      Exchange the current word with the one before it."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use zshzle to replace the character under the cursor with a new character from the keyboard?
  manpageQuestion3: Can you provide an example of using zshzle to swap the case of a character in the current line?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nWith a positive numeric argument N, the word around the cursor,\n\t      or following it if the cursor is between words, is transposed\n\t      with the preceding N words.  The cursor is put at the end of the\n\t      resulting group of words.\n\n\t      With a negative numeric argument -N, the effect is the same as\n\t      using a positive argument N except that the original cursor\n\t      position is retained, regardless of how the words are\n\t      rearranged.\n\n       vi-unindent (unbound) (<) (unbound)\n\t      Unindent a number of lines.\n\n       vi-up-case (unbound) (gU) (unbound)\n\t      Read a movement command from the keyboard, and convert all\n\t      characters from the cursor position to the endpoint of the\n\t      movement to lowercase.  If the movement command is vi-up-case,\n\t      swap the case of all characters on the current line.\n\n       up-case-word (ESC-U ESC-u) (unbound) (unbound)\n\t      Convert the current word to all caps and move past it.\n\n       yank (^Y) (unbound) (unbound)\n\t      Insert the contents of the kill buffer at the cursor position."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to transpose the word around the cursor with the preceding 3 words?
  manpageQuestion3: Can you provide an example of using zshzle to convert the current word to all caps and move past it?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nyank-pop (ESC-y) (unbound) (unbound)\n\t      Remove the text just yanked, rotate the kill-ring (the history\n\t      of previously killed text) and yank the new top.\tOnly works\n\t      following yank, vi-put-before, vi-put-after or yank-pop.\n\n       vi-yank (unbound) (y) (unbound)\n\t      Read a movement command from the keyboard, and copy the region\n\t      from the cursor position to the endpoint of the movement into\n\t      the kill buffer.\tIf the command is vi-yank, copy the current\n\t      line.\n\n       vi-yank-whole-line (unbound) (Y) (unbound)\n\t      Copy the current line into the kill buffer.\n\n       vi-yank-eol\n\t      Copy the region from the cursor position to the end of the line\n\t      into the kill buffer.  Arguably, this is what Y should do in vi,\n\t      but it isn't what it actually does.\n\n   Arguments\n       digit-argument (ESC-0..ESC-9) (1-9) (unbound)\n\t      Start a new numeric argument, or add to the current one.\tSee\n\t      also vi-digit-or-beginning-of-line.  This only works if bound to\n\t      a key sequence ending in a decimal digit."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use vi-yank to copy the current line into the kill buffer in zshzle?
  manpageQuestion3: What is the function of the vi-yank-whole-line command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nInside a widget function, a call to this function treats the\n\t      last key of the key sequence which called the widget as the\n\t      digit.\n\n       neg-argument (ESC--) (unbound) (unbound)\n\t      Changes the sign of the following argument.\n\n       universal-argument\n\t      Multiply the argument of the next command by 4.  Alternatively,\n\t      if this command is followed by an integer (positive or\n\t      negative), use that as the argument for the next command.  Thus\n\t      digits cannot be repeated using this command.  For example, if\n\t      this command occurs twice, followed immediately by forward-char,\n\t      move forward sixteen spaces; if instead it is followed by -2,\n\t      then forward-char, move backward two spaces.\n\n\t      Inside a widget function, if passed an argument, i.e. `zle\n\t      universal-argument num', the numeric argument will be set to\n\t      num; this is equivalent to `NUMERIC=num'.\n\n       argument-base\n\t      Use the existing numeric argument as a numeric base, which must\n\t      be in the range 2 to 36 inclusive.  Subsequent use of\n\t      digit-argument and universal-argument will input a new numeric\n\t      argument in the given base.  The usual hexadecimal convention is\n\t      used: the letter a or A corresponds to 10, and so on.  Arguments\n\t      in bases requiring digits from 10 upwards are more conveniently\n\t      input with universal-argument, since ESC-a etc. are not usually\n\t      bound to digit-argument."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use the zshzle universal-argument to modify the argument of the next command?
  manpageQuestion3: Can you explain how to set a numeric argument in a specific base using the zshzle argument-base command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nThe function can be used with a command argument inside a\n\t      user-defined widget.  The following code sets the base to 16 and\n\t      lets the user input a hexadecimal argument until a key out of\n\t      the digit range is typed:\n\n\t\t     zle argument-base 16\n\t\t     zle universal-argument\n\n   Completion\n       accept-and-menu-complete\n\t      In a menu completion, insert the current completion into the\n\t      buffer, and advance to the next possible completion.\n\n       complete-word\n\t      Attempt completion on the current word.\n\n       delete-char-or-list (^D) (unbound) (unbound)\n\t      Delete the character under the cursor.  If the cursor is at the\n\t      end of the line, list possible completions for the current word.\n\n       expand-cmd-path\n\t      Expand the current command to its full pathname.\n\n       expand-or-complete (TAB) (unbound) (TAB)\n\t      Attempt shell expansion on the current word.  If that fails,\n\t      attempt completion.\n\n       expand-or-complete-prefix\n\t      Attempt shell expansion on the current word up to cursor."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you configure zshzle to accept hexadecimal input until an invalid character is entered?
  manpageQuestion3: What is the function of the 'expand-or-complete' command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nexpand-history (ESC-space ESC-!) (unbound) (unbound)\n\t      Perform history expansion on the edit buffer.\n\n       expand-word (^X*) (unbound) (unbound)\n\t      Attempt shell expansion on the current word.\n\n       list-choices (ESC-^D) (^D =) (^D)\n\t      List possible completions for the current word.\n\n       list-expand (^Xg ^XG) (^G) (^G)\n\t      List the expansion of the current word.\n\n       magic-space\n\t      Perform history expansion and insert a space into the buffer.\n\t      This is intended to be bound to space.\n\n       menu-complete\n\t      Like complete-word, except that menu completion is used.\tSee\n\t      the MENU_COMPLETE option.\n\n       menu-expand-or-complete\n\t      Like expand-or-complete, except that menu completion is used.\n\n       reverse-menu-complete\n\t      Perform menu completion, like menu-complete, except that if a\n\t      menu completion is already in progress, move to the previous\n\t      completion rather than the next.\n\n       end-of-list\n\t      When a previous completion displayed a list below the prompt,\n\t      this widget can be used to move the prompt below the list."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use menu-complete in zshzle to complete a command with a list of possible options?
  manpageQuestion3: What is the function of the magic-space widget in zshzle and how is it typically used?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nMiscellaneous\n       accept-and-hold (ESC-A ESC-a) (unbound) (unbound)\n\t      Push the contents of the buffer on the buffer stack and execute\n\t      it.\n\n       accept-and-infer-next-history\n\t      Execute the contents of the buffer.  Then search the history\n\t      list for a line matching the current one and push the event\n\t      following onto the buffer stack.\n\n       accept-line (^J ^M) (^J ^M) (^J ^M)\n\t      Finish editing the buffer.  Normally this causes the buffer to\n\t      be executed as a shell command.\n\n       accept-line-and-down-history (^O) (unbound) (unbound)\n\t      Execute the current line, and push the next history event on the\n\t      buffer stack.\n\n       auto-suffix-remove\n\t      If the previous action added a suffix (space, slash, etc.) to\n\t      the word on the command line, remove it.\tOtherwise do nothing.\n\t      Removing the suffix ends any active menu completion or menu\n\t      selection.\n\n\t      This widget is intended to be called from user-defined widgets\n\t      to enforce a desired suffix-removal behavior."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to execute a buffer and push the next history event onto the buffer stack?
  manpageQuestion3: Can you explain how to remove a suffix from the current command line in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nauto-suffix-retain\n\t      If the previous action added a suffix (space, slash, etc.) to\n\t      the word on the command line, force it to be preserved.\n\t      Otherwise do nothing.  Retaining the suffix ends any active menu\n\t      completion or menu selection.\n\n\t      This widget is intended to be called from user-defined widgets\n\t      to enforce a desired suffix-preservation behavior.\n\n       beep   Beep, unless the BEEP option is unset.\n\n       bracketed-paste (^[[200~) (^[[200~) (^[[200~)\n\t      This widget is invoked when text is pasted to the terminal\n\t      emulator. It is not intended to be bound to actual keys but\n\t      instead to the special sequence generated by the terminal\n\t      emulator when text is pasted.\n\n\t      When invoked interactively, the pasted text is inserted to the\n\t      buffer and placed in the cutbuffer.  If a numeric argument is\n\t      given, shell quoting will be applied to the pasted text before\n\t      it is inserted.\n\n\t      When a named buffer is specified with vi-set-buffer (\"x), the\n\t      pasted text is stored in that named buffer but not inserted."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you configure zshzle to retain a suffix added by the previous action when processing command line input?
  manpageQuestion3: What is the function of the bracketed-paste widget in zshzle and how is it typically used?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nWhen called from a widget function as `bracketed-paste name`,\n\t      the pasted text is assigned to the variable name and no other\n\t      processing is done.\n\n\t      See also the zle_bracketed_paste parameter.\n\n       vi-cmd-mode (^X^V) (unbound) (^[)\n\t      Enter command mode; that is, select the `vicmd' keymap.  Yes,\n\t      this is bound by default in emacs mode.\n\n       vi-caps-lock-panic\n\t      Hang until any lowercase key is pressed.\tThis is for vi users\n\t      without the mental capacity to keep track of their caps lock key\n\t      (like the author).\n\n       clear-screen (^L ESC-^L) (^L) (^L)\n\t      Clear the screen and redraw the prompt.\n\n       deactivate-region\n\t      Make the current region inactive. This disables vim-style visual\n\t      selection mode if it is active.\n\n       describe-key-briefly\n\t      Reads a key sequence, then prints the function bound to that\n\t      sequence.\n\n       exchange-point-and-mark (^X^X) (unbound) (unbound)\n\t      Exchange the cursor position (point) with the position of the\n\t      mark.  Unless a negative numeric argument is given, the region\n\t      between point and mark is activated so that it can be\n\t      highlighted.  If a zero numeric argument is given, the region is\n\t      activated but point and mark are not swapped."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you activate the vi command mode in zshzle?
  manpageQuestion3: What is the function of the 'clear-screen' command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nexecute-named-cmd (ESC-x) (:) (unbound)\n\t      Read the name of an editor command and execute it.  Aliasing\n\t      this widget with `zle -A' or replacing it with `zle -N' has no\n\t      effect when interpreting key bindings, but `zle\n\t      execute-named-cmd' will invoke such an alias or replacement.\n\n\t      A restricted set of editing functions is available in the\n\t      mini-buffer.  Keys are looked up in the special command keymap,\n\t      and if not found there in the main keymap.  An interrupt signal,\n\t      as defined by the stty setting, will abort the function.\tNote\n\t      that the following always perform the same task within the\n\t      executed-named-cmd environment and cannot be replaced by user\n\t      defined widgets, nor can the set of functions be extended.  The\n\t      allowed functions are: backward-delete-char,\n\t      vi-backward-delete-char, clear-screen, redisplay, quoted-insert,\n\t      vi-quoted-insert, backward-kill-word, vi-backward-kill-word,\n\t      kill-whole-line, vi-kill-line, backward-kill-line, list-choices,\n\t      delete-char-or-list, complete-word, accept-line,\n\t      expand-or-complete and expand-or-complete-prefix."
  manpageQuestion1: What is the primary purpose of the `execute-named-cmd` function in zshzle?
  manpageQuestion2: How can you use `execute-named-cmd` to perform a backward delete of the previous character in the zle mini-buffer?
  manpageQuestion3: Can you provide an example of using `execute-named-cmd` to execute the `complete-word` function within the zshzle environment?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nkill-region kills the last word, and vi-cmd-mode is treated the\n\t      same as accept-line.  The space and tab characters, if not bound\n\t      to one of these functions, will complete the name and then list\n\t      the possibilities if the AUTO_LIST option is set.  Any other\n\t      character that is not bound to self-insert or self-insert-unmeta\n\t      will beep and be ignored.  The bindings of the current insert\n\t      mode will be used.\n\n\t      Currently this command may not be redefined or called by name.\n\n       execute-last-named-cmd (ESC-z) (unbound) (unbound)\n\t      Redo the last function executed with execute-named-cmd.\n\n\t      Like execute-named-cmd, this command may not be redefined, but\n\t      it may be called by name.\n\n       get-line (ESC-G ESC-g) (unbound) (unbound)\n\t      Pop the top line off the buffer stack and insert it at the\n\t      cursor position.\n\n       pound-insert (unbound) (#) (unbound)\n\t      If there is no # character at the beginning of the buffer, add\n\t      one to the beginning of each line.  If there is one, remove a #\n\t      from each line that has one.  In either case, accept the current\n\t      line.  The INTERACTIVE_COMMENTS option must be set for this to\n\t      have any usefulness."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use the pound-insert command in zshzle to modify lines in a buffer?
  manpageQuestion3: Can you provide an example of using the get-line command in zshzle to insert a line from the buffer stack?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-pound-insert\n\t      If there is no # character at the beginning of the current line,\n\t      add one.\tIf there is one, remove it.  The INTERACTIVE_COMMENTS\n\t      option must be set for this to have any usefulness.\n\n       push-input\n\t      Push the entire current multiline construct onto the buffer\n\t      stack and return to the top-level (PS1) prompt.  If the current\n\t      parser construct is only a single line, this is exactly like\n\t      push-line.  Next time the editor starts up or is popped with\n\t      get-line, the construct will be popped off the top of the buffer\n\t      stack and loaded into the editing buffer.\n\n       push-line (^Q ESC-Q ESC-q) (unbound) (unbound)\n\t      Push the current buffer onto the buffer stack and clear the\n\t      buffer.  Next time the editor starts up, the buffer will be\n\t      popped off the top of the buffer stack and loaded into the\n\t      editing buffer.\n\n       push-line-or-edit\n\t      At the top-level (PS1) prompt, equivalent to push-line.  At a\n\t      secondary (PS2) prompt, move the entire current multiline\n\t      construct into the editor buffer.  The latter is equivalent to\n\t      push-input followed by get-line."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you push the current multiline construct into the buffer stack and then retrieve it later using zshzle commands?
  manpageQuestion3: What is the difference between the 'push-line' and 'push-line-or-edit' commands in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nread-command\n\t      Only useful from a user-defined widget.  A keystroke is read\n\t      just as in normal operation, but instead of the command being\n\t      executed the name of the command that would be executed is\n\t      stored in the shell parameter REPLY.  This can be used as the\n\t      argument of a future zle command.  If the key sequence is not\n\t      bound, status 1 is returned; typically, however, REPLY is set to\n\t      undefined-key to indicate a useless key sequence.\n\n       recursive-edit\n\t      Only useful from a user-defined widget.  At this point in the\n\t      function, the editor regains control until one of the standard\n\t      widgets which would normally cause zle to exit (typically an\n\t      accept-line caused by hitting the return key) is executed.\n\t      Instead, control returns to the user-defined widget.  The status\n\t      returned is non-zero if the return was caused by an error, but\n\t      the function still continues executing and hence may tidy up.\n\t      This makes it safe for the user-defined widget to alter the\n\t      command line or key bindings temporarily."
  manpageQuestion1: What is the primary purpose of the `zshzle` resource?
  manpageQuestion2: How can you use the `read-command` widget in zshzle to capture the command that would be executed next?
  manpageQuestion3: What is the functionality of the `recursive-edit` widget in zshzle and how does it interact with user-defined widgets?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nThe following widget, caps-lock, serves as an example.\n\n\t\t     self-insert-ucase() {\n\t\t       LBUFFER+=${(U)KEYS[-1]}\n\t\t     }\n\n\t\t     integer stat\n\n\t\t     zle -N self-insert self-insert-ucase\n\t\t     zle -A caps-lock save-caps-lock\n\t\t     zle -A accept-line caps-lock\n\n\t\t     zle recursive-edit\n\t\t     stat=$?\n\n\t\t     zle -A .self-insert self-insert\n\t\t     zle -A save-caps-lock caps-lock\n\t\t     zle -D save-caps-lock\n\n\t\t     (( stat )) && zle send-break\n\n\t\t     return $stat\n\n\t      This causes typed letters to be inserted capitalised until\n\t      either accept-line (i.e. typically the return key) is typed or\n\t      the caps-lock widget is invoked again; the later is handled by\n\t      saving the old definition of caps-lock as save-caps-lock and\n\t      then rebinding it to invoke accept-line.\tNote that an error\n\t      from the recursive edit is detected as a non-zero return status\n\t      and propagated by using the send-break widget.\n\n       redisplay (unbound) (^R) (^R)\n\t      Redisplays the edit buffer."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you configure zshzle to make typed letters uppercase until the return key is pressed?
  manpageQuestion3: What does the zshzle resource do when the redisplay command is invoked?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nreset-prompt (unbound) (unbound) (unbound)\n\t      Force the prompts on both the left and right of the screen to be\n\t      re-expanded, then redisplay the edit buffer.  This reflects\n\t      changes both to the prompt variables themselves and changes in\n\t      the expansion of the values (for example, changes in time or\n\t      directory, or changes to the value of variables referred to by\n\t      the prompt).\n\n\t      Otherwise, the prompt is only expanded each time zle starts, and\n\t      when the display has been interrupted by output from another\n\t      part of the shell (such as a job notification) which causes the\n\t      command line to be reprinted.\n\n\t      reset-prompt doesn't alter the special parameter LASTWIDGET.\n\n       send-break (^G ESC-^G) (unbound) (unbound)\n\t      Abort the current editor function, e.g. execute-named-command,\n\t      or the editor itself, e.g. if you are in vared. Otherwise abort\n\t      the parsing of the current line; in this case the aborted line\n\t      is available in the shell variable ZLE_LINE_ABORTED.  If the\n\t      editor is aborted from within vared, the variable\n\t      ZLE_VARED_ABORTED is set."
  manpageQuestion1: What is the primary purpose of the reset-prompt command in zshzle?
  manpageQuestion2: How can you use the send-break command to abort an editor function in zshzle?
  manpageQuestion3: What is the effect of using reset-prompt in the context of zshzle's prompt expansion?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nrun-help (ESC-H ESC-h) (unbound) (unbound)\n\t      Push the buffer onto the buffer stack, and execute the command\n\t      `run-help cmd', where cmd is the current command.  run-help is\n\t      normally aliased to man.\n\n       vi-set-buffer (unbound) (\") (unbound)\n\t      Specify a buffer to be used in the following command.  There are\n\t      37 buffers that can be specified: the 26 `named' buffers \"a to\n\t      \"z, the `yank' buffer \"0, the nine `queued' buffers \"1 to \"9 and\n\t      the `black hole' buffer \"_.  The named buffers can also be\n\t      specified as \"A to \"Z.\n\n\t      When a buffer is specified for a cut, change or yank command,\n\t      the text concerned replaces the previous contents of the\n\t      specified buffer. If a named buffer is specified using a\n\t      capital, the newly cut text is appended to the buffer instead of\n\t      overwriting it. When using the \"_ buffer, nothing happens. This\n\t      can be useful for deleting text without affecting any buffers.\n\n\t      If no buffer is specified for a cut or change command, \"1 is\n\t      used, and the contents of \"1 to \"8 are each shifted along one\n\t      buffer; the contents of \"9 is lost. If no buffer is specified\n\t      for a yank command, \"0 is used. Finally, a paste command without\n\t      a specified buffer will paste the text from the most recent\n\t      command regardless of any buffer that might have been used with\n\t      that command."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use vi-set-buffer to append text to a named buffer, such as buffer 'A'?
  manpageQuestion3: What is the default behavior when a cut or change command is executed without specifying a buffer?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nWhen called from a widget function by the zle command, the\n\t      buffer can optionally be specified with an argument. For\n\t      example,\n\n\t\t     zle vi-set-buffer A\n\n       vi-set-mark (unbound) (m) (unbound)\n\t      Set the specified mark at the cursor position.\n\n       set-mark-command (^@) (unbound) (unbound)\n\t      Set the mark at the cursor position.  If called with a negative\n\t      numeric argument, do not set the mark but deactivate the region\n\t      so that it is no longer highlighted (it is still usable for\n\t      other purposes).\tOtherwise the region is marked as active.\n\n       spell-word (ESC-$ ESC-S ESC-s) (unbound) (unbound)\n\t      Attempt spelling correction on the current word.\n\n       split-undo\n\t      Breaks the undo sequence at the current change.  This is useful\n\t      in vi mode as changes made in insert mode are coalesced on\n\t      entering command mode.  Similarly, undo will normally revert as\n\t      one all the changes made by a user-defined widget.\n\n       undefined-key\n\t      This command is executed when a key sequence that is not bound\n\t      to any command is typed.\tBy default it beeps."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use the vi-set-buffer command in zshzle to set a custom buffer for a widget function?
  manpageQuestion3: Can you provide an example of using the set-mark-command in zshzle to manage text regions in a shell environment?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nundo (^_ ^Xu ^X^U) (u) (unbound)\n\t      Incrementally undo the last text modification.  When called from\n\t      a user-defined widget, takes an optional argument indicating a\n\t      previous state of the undo history as returned by the\n\t      UNDO_CHANGE_NO variable; modifications are undone until that\n\t      state is reached, subject to any limit imposed by the\n\t      UNDO_LIMIT_NO variable.\n\n\t      Note that when invoked from vi command mode, the full prior\n\t      change made in insert mode is reverted, the changes having been\n\t      merged when command mode was selected.\n\n       redo (unbound) (^R) (unbound)\n\t      Incrementally redo undone text modifications.\n\n       vi-undo-change (unbound) (unbound) (unbound)\n\t      Undo the last text modification.\tIf repeated, redo the\n\t      modification.\n\n       visual-mode (unbound) (v) (unbound)\n\t      Toggle vim-style visual selection mode. If line-wise visual mode\n\t      is currently enabled then it is changed to being character-wise.\n\t      If used following an operator, it forces the subsequent movement\n\t      command to be treated as a character-wise movement."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use the vi-undo-change command in zshzle to undo the last text modification?
  manpageQuestion3: Can you provide an example of how to toggle visual selection mode in zshzle for character-wise selection?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvisual-line-mode (unbound) (V) (unbound)\n\t      Toggle vim-style line-wise visual selection mode. If\n\t      character-wise visual mode is currently enabled then it is\n\t      changed to being line-wise. If used following an operator, it\n\t      forces the subsequent movement command to be treated as a\n\t      line-wise movement.\n\n       what-cursor-position (^X=) (ga) (unbound)\n\t      Print the character under the cursor, its code as an octal,\n\t      decimal and hexadecimal number, the current cursor position\n\t      within the buffer and the column of the cursor in the current\n\t      line.\n\n       where-is\n\t      Read the name of an editor command and print the listing of key\n\t      sequences that invoke the specified command.  A restricted set\n\t      of editing functions is available in the mini-buffer.  Keys are\n\t      looked up in the special command keymap, and if not found there\n\t      in the main keymap.\n\n       which-command (ESC-?) (unbound) (unbound)\n\t      Push the buffer onto the buffer stack, and execute the command\n\t      `which-command cmd'. where cmd is the current command.\n\t      which-command is normally aliased to whence."
  manpageQuestion1: What is the primary purpose of the zshzle utility?
  manpageQuestion2: How would you use the `what-cursor-position` command to display information about the current cursor in a zshzle session?
  manpageQuestion3: Can you provide an example of using the `which-command` command to find key sequences associated with a specific editor command in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nvi-digit-or-beginning-of-line (unbound) (0) (unbound)\n\t      If the last command executed was a digit as part of an argument,\n\t      continue the argument.  Otherwise, execute vi-beginning-of-line.\n\n   Text Objects\n       Text objects are commands that can be used to select a block of text\n       according to some criteria. They are a feature of the vim text editor\n       and so are primarily intended for use with vi operators or from visual\n       selection mode. However, they can also be used from vi-insert or emacs\n       mode. Key bindings listed below apply to the viopp and visual keymaps.\n\n       select-a-blank-word (aW)\n\t      Select a word including adjacent blanks, where a word is defined\n\t      as a series of non-blank characters. With a numeric argument,\n\t      multiple words will be selected.\n\n       select-a-shell-word (aa)\n\t      Select the current command argument applying the normal rules\n\t      for quoting.\n\n       select-a-word (aw)\n\t      Select a word including adjacent blanks, using the normal\n\t      vi-style word definition. With a numeric argument, multiple\n\t      words will be selected."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use zshzle to select a word in vi-insert mode according to the default vi-style definition?
  manpageQuestion3: Can you provide an example of using zshzle to select a shell word with a numeric argument?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nselect-in-blank-word (iW)\n\t      Select a word, where a word is defined as a series of non-blank\n\t      characters. With a numeric argument, multiple words will be\n\t      selected.\n\n       select-in-shell-word (ia)\n\t      Select the current command argument applying the normal rules\n\t      for quoting. If the argument begins and ends with matching quote\n\t      characters, these are not included in the selection.\n\n       select-in-word (iw)\n\t      Select a word, using the normal vi-style word definition. With a\n\t      numeric argument, multiple words will be selected.\n\nCHARACTER HIGHLIGHTING\n       The line editor has the ability to highlight characters or regions of\n       the line that have a particular significance.  This is controlled by\n       the array parameter zle_highlight, if it has been set by the user.\n\n       If the parameter contains the single entry none all highlighting is\n       turned off.  Note the parameter is still expected to be an array.\n\n       Otherwise each entry of the array should consist of a word indicating a\n       context for highlighting, then a colon, then a comma-separated list of\n       the types of highlighting to apply in that context."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you use select-in-blank-word to select multiple words in the zshzle line editor?
  manpageQuestion3: What is the function of the zle_highlight parameter in the context of character highlighting?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nThe contexts available for highlighting are the following:\n\n       default\n\t      Any text within the command line not affected by any other\n\t      highlighting.  Text outside the editable area of the command\n\t      line is not affected.\n\n       isearch\n\t      When one of the incremental history search widgets is active,\n\t      the area of the command line matched by the search string or\n\t      pattern.\n\n       region The currently selected text. In emacs terminology, this is\n\t      referred to as the region and is bounded by the cursor (point)\n\t      and the mark. The region is only highlighted if it is active,\n\t      which is the case after the mark is modified with\n\t      set-mark-command or exchange-point-and-mark.  Note that whether\n\t      or not the region is active has no effect on its use within\n\t      emacs style widgets, it simply determines whether it is\n\t      highlighted. In vi mode, the region corresponds to selected text\n\t      in visual mode.\n\n       special\n\t      Individual characters that have no direct printable\n\t      representation but are shown in a special manner by the line\n\t      editor.  These characters are described below."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you highlight the currently selected text in zshzle?
  manpageQuestion3: What is the function of the 'special' context in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nsuffix This context is used in completion for characters that are\n\t      marked as suffixes that will be removed if the completion ends\n\t      at that point, the most obvious example being a slash (/) after\n\t      a directory name.  Note that suffix removal is configurable; the\n\t      circumstances under which the suffix will be removed may differ\n\t      for different completions.\n\n       paste  Following a command to paste text, the characters that were\n\t      inserted.\n\n       When region_highlight is set, the contexts that describe a region --\n       isearch, region, suffix, and paste -- are applied first, then\n       region_highlight is applied, then the remaining zle_highlight contexts\n       are applied.  If a particular character is affected by multiple\n       specifications, the last specification wins.\n\n       zle_highlight may contain additional fields for controlling how\n       terminal sequences to change colours are output.  Each of the following\n       is followed by a colon and a string in the same form as for key\n       bindings.  This will not be necessary for the vast majority of\n       terminals as the defaults shown in parentheses are widely used."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you configure zshzle to handle suffixes when completing file names?
  manpageQuestion3: Can you explain how the zle_highlight contexts are applied in order when configuring zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nfg_start_code (\\e[3)\n\t      The start of the escape sequence for the foreground colour.\n\t      This is followed by one to three ASCII digits representing the\n\t      colour.  Only used for palette colors, i.e. not 24-bit colors\n\t      specified via a color triplet.\n\n       fg_default_code (9)\n\t      The number to use instead of the colour to reset the default\n\t      foreground colour.\n\n       fg_end_code (m)\n\t      The end of the escape sequence for the foreground colour.\n\n       bg_start_code (\\e[4)\n\t      The start of the escape sequence for the background colour.  See\n\t      fg_start_code above.\n\n       bg_default_code (9)\n\t      The number to use instead of the colour to reset the default\n\t      background colour.\n\n       bg_end_code (m)\n\t      The end of the escape sequence for the background colour.\n\n       The available types of highlighting are the following.  Note that not\n       all types of highlighting are available on all terminals:\n\n       none   No highlighting is applied to the given context.\tIt is not\n\t      useful for this to appear with other types of highlighting; it\n\t      is used to override a default."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you use zshzle to set the foreground color to a palette color represented by the ASCII digits '3'?
  manpageQuestion3: Can you provide an example of using zshzle to reset the default background color to its default state?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nfg=colour\n\t      The foreground colour should be set to colour, a decimal\n\t      integer, the name of one of the eight most widely-supported\n\t      colours or as a `#' followed by an RGB triplet in hexadecimal\n\t      format.\n\n\t      Not all terminals support this and, of those that do, not all\n\t      provide facilities to test the support, hence the user should\n\t      decide based on the terminal type.  Most terminals support the\n\t      colours black, red, green, yellow, blue, magenta, cyan and\n\t      white, which can be set by name.\tIn addition. default may be\n\t      used to set the terminal's default foreground colour.\n\t      Abbreviations are allowed; b or bl selects black.  Some\n\t      terminals may generate additional colours if the bold attribute\n\t      is also present.\n\n\t      On recent terminals and on systems with an up-to-date terminal\n\t      database the number of colours supported may be tested by the\n\t      command `echotc Co'; if this succeeds, it indicates a limit on\n\t      the number of colours which will be enforced by the line editor.\n\t      The number of colours is in any case limited to 256 (i.e. the\n\t      range 0 to 255)."
  manpageQuestion1: What is the primary purpose of the zshzle tool?
  manpageQuestion2: How can you set the foreground color of the zshzle line editor to a specific hexadecimal RGB value?
  manpageQuestion3: Can you provide an example of using zshzle to set the foreground color to a named color like 'cyan'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nSome modern terminal emulators have support for 24-bit true\n\t      colour (16 million colours). In this case, the hex triplet\n\t      format can be used. This consists of a `#' followed by either a\n\t      three or six digit hexadecimal number describing the red, green\n\t      and blue components of the colour. Hex triplets can also be used\n\t      with 88 and 256 colour terminals via the zsh/nearcolor module\n\t      (see zshmodules(1)).\n\n\t      Colour is also known as color.\n\n       bg=colour\n\t      The background colour should be set to colour.  This works\n\t      similarly to the foreground colour, except the background is not\n\t      usually affected by the bold attribute.\n\n       bold   The characters in the given context are shown in a bold font.\n\t      Not all terminals distinguish bold fonts.\n\n       standout\n\t      The characters in the given context are shown in the terminal's\n\t      standout mode.  The actual effect is specific to the terminal;\n\t      on many terminals it is inverse video.  On some such terminals,\n\t      where the cursor does not blink it appears with standout mode\n\t      negated, making it less than clear where the cursor actually is.\n\t      On such terminals one of the other effects may be preferable for\n\t      highlighting the region and matched search string."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: 'How can you set the background color of a zshzle prompt to a hexadecimal triplet like #FF5733?'
  manpageQuestion3: What is the function of the 'standout' option in zshzle, and how can it be applied to highlight text?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nunderline\n\t      The characters in the given context are shown underlined.  Some\n\t      terminals show the foreground in a different colour instead; in\n\t      this case whitespace will not be highlighted.\n\n       The characters described above as `special' are as follows.  The\n       formatting described here is used irrespective of whether the\n       characters are highlighted:\n\n       ASCII control characters\n\t      Control characters in the ASCII range are shown as `^' followed\n\t      by the base character.\n\n       Unprintable multibyte characters\n\t      This item applies to control characters not in the ASCII range,\n\t      plus other characters as follows.  If the MULTIBYTE option is in\n\t      effect, multibyte characters not in the ASCII character set that\n\t      are reported as having zero width are treated as combining\n\t      characters when the option COMBINING_CHARS is on.  If the option\n\t      is off, or if a character appears where a combining character is\n\t      not valid, the character is treated as unprintable."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How can you configure zshzle to display ASCII control characters as `^' followed by the base character?
  manpageQuestion3: What is the effect of enabling the COMBINING_CHARS option when dealing with unprintable multibyte characters in zshzle?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nUnprintable multibyte characters are shown as a hexadecimal\n\t      number between angle brackets.  The number is the code point of\n\t      the character in the wide character set; this may or may not be\n\t      Unicode, depending on the operating system.\n\n       Invalid multibyte characters\n\t      If the MULTIBYTE option is in effect, any sequence of one or\n\t      more bytes that does not form a valid character in the current\n\t      character set is treated as a series of bytes each shown as a\n\t      special character.  This case can be distinguished from other\n\t      unprintable characters as the bytes are represented as two\n\t      hexadecimal digits between angle brackets, as distinct from the\n\t      four or eight digits that are used for unprintable characters\n\t      that are nonetheless valid in the current character set.\n\n\t      Not all systems support this: for it to work, the system's\n\t      representation of wide characters must be code values from the\n\t      Universal Character Set, as defined by IS0 10646 (also known as\n\t      Unicode)."
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How would you configure zshzle to display invalid multibyte characters as hexadecimal byte sequences?
  manpageQuestion3: Can you explain how zshzle handles unprintable characters that are valid in the current character set?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshzle`.\n\n\n\nManpage text:\n\nWrapped double-width characters\n\t      When a double-width character appears in the final column of a\n\t      line, it is instead shown on the next line. The empty space left\n\t      in the original position is highlighted as a special character.\n\n       If zle_highlight is not set or no value applies to a particular\n       context, the defaults applied are equivalent to\n\n\t      zle_highlight=(region:standout special:standout\n\t      suffix:bold isearch:underline paste:standout)\n\n       i.e. both the region and special characters are shown in standout mode.\n\n       Within widgets, arbitrary regions may be highlighted by setting the\n       special array parameter region_highlight; see above.\n\nzsh 5.9 \t\t\t May 14, 2022\t\t\t     ZSHZLE(1)"
  manpageQuestion1: What is the primary purpose of the zshzle resource?
  manpageQuestion2: How does zshzle handle wrapped double-width characters in a line?
  manpageQuestion3: What are the default highlighting settings for zshzle when zle_highlight is not set?

