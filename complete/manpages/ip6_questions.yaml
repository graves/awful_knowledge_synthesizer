- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIP6(4)\t\t\t     Device Drivers Manual\t\t\tIP6(4)\n\nNAME\n     ip6 – Internet Protocol version 6 (IPv6) network layer\n\nSYNOPSIS\n     #include <sys/socket.h>\n     #include <netinet/in.h>\n\n     int\n     socket(AF_INET6, SOCK_RAW, proto);\n\nDESCRIPTION\n     The IPv6 network layer is used by the IPv6 protocol family for\n     transporting data.  IPv6 packets contain an IPv6 header that is not\n     provided as part of the payload contents when passed to an application.\n     IPv6 header options affect the behavior of this protocol and may be used\n     by high-level protocols (such as the tcp(4) and udp(4) protocols) as well\n     as directly by “raw sockets”, which process IPv6 messages at a lower-\n     level and may be useful for developing new protocols and special-purpose\n     applications.\n\n   Header\n     All IPv6 packets begin with an IPv6 header.  When data received by the\n     kernel are passed to the application, this header is not included in\n     buffer, even when raw sockets are being used.  Likewise, when data are\n     sent to the kernel for transmit from the application, the buffer is not\n     examined for an IPv6 header: the kernel always constructs the header.  To\n     directly access IPv6 headers from received packets and specify them as\n     part of the buffer passed to the kernel, link-level access (bpf(4), for\n     example) must instead be utilized."
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How would you create a raw socket using the ip6 resource to send IPv6 packets?
  manpageQuestion3: What is the role of the IPv6 header in the context of raw sockets and how does it differ from standard socket operations?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nThe header has the following definition:\n\n\t   struct ip6_hdr {\n\t\tunion {\n\t\t     struct ip6_hdrctl {\n\t\t\t  u_int32_t ip6_un1_flow;  /* 20 bits of flow ID */\n\t\t\t  u_int16_t ip6_un1_plen;  /* payload length */\n\t\t\t  u_int8_t  ip6_un1_nxt;   /* next header */\n\t\t\t  u_int8_t  ip6_un1_hlim;  /* hop limit */\n\t\t     } ip6_un1;\n\t\t     u_int8_t ip6_un2_vfc;   /* version and class */\n\t\t} ip6_ctlun;\n\t\tstruct in6_addr ip6_src;   /* source address */\n\t\tstruct in6_addr ip6_dst;   /* destination address */\n\t   } __packed;\n\n\t   #define ip6_vfc\t   ip6_ctlun.ip6_un2_vfc\n\t   #define ip6_flow\t   ip6_ctlun.ip6_un1.ip6_un1_flow\n\t   #define ip6_plen\t   ip6_ctlun.ip6_un1.ip6_un1_plen\n\t   #define ip6_nxt\t   ip6_ctlun.ip6_un1.ip6_un1_nxt\n\t   #define ip6_hlim\t   ip6_ctlun.ip6_un1.ip6_un1_hlim\n\t   #define ip6_hops\t   ip6_ctlun.ip6_un1.ip6_un1_hlim\n\n     All fields are in network-byte order.  Any options specified (see Options\n     below) must also be specified in network-byte order.\n\n     ip6_flow specifies the flow ID.  ip6_plen specifies the payload length.\n     ip6_nxt specifies the type of the next header.  ip6_hlim specifies the\n     hop limit."
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How would you use the ip6 resource to access the flow ID field of an IPv6 header?
  manpageQuestion3: Can you explain how to retrieve the payload length from an IPv6 header using the ip6 resource?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nThe top 4 bits of ip6_vfc specify the class and the bottom 4 bits specify\n     the version.\n\n     ip6_src and ip6_dst specify the source and destination addresses.\n\n     The IPv6 header may be followed by any number of extension headers that\n     start with the following generic definition:\n\n\t   struct ip6_ext {\n\t\tu_int8_t ip6e_nxt;\n\t\tu_int8_t ip6e_len;\n\t   } __packed;\n\n   Options\n     IPv6 allows header options on packets to manipulate the behavior of the\n     protocol.\tThese options and other control requests are accessed with the\n     getsockopt(2) and setsockopt(2) system calls at level IPPROTO_IPV6 and by\n     using ancillary data in recvmsg(2) and sendmsg(2).  They can be used to\n     access most of the fields in the IPv6 header and extension headers.\n\n     The following socket options are supported:\n\n     IPV6_UNICAST_HOPS int *\n\t     Get or set the default hop limit header field for outgoing\n\t     unicast datagrams sent on this socket.  A value of -1 resets to\n\t     the default value."
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How can you set the default hop limit for outgoing unicast datagrams using ip6?
  manpageQuestion3: What is the role of the ip6_ext structure in IPv6 headers?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIPV6_MULTICAST_IF u_int *\n\t     Get or set the interface from which multicast packets will be\n\t     sent.  For hosts with multiple interfaces, each multicast\n\t     transmission is sent from the primary network interface.  The\n\t     interface is specified as its index as provided by\n\t     if_nametoindex(3).  A value of zero specifies the default\n\t     interface.\n\n     IPV6_MULTICAST_HOPS int *\n\t     Get or set the default hop limit header field for outgoing\n\t     multicast datagrams sent on this socket.  This option controls\n\t     the scope of multicast datagram transmissions.\n\n\t     Datagrams with a hop limit of 1 are not forwarded beyond the\n\t     local network.  Multicast datagrams with a hop limit of zero will\n\t     not be transmitted on any network but may be delivered locally if\n\t     the sending host belongs to the destination group and if\n\t     multicast loopback (see below) has not been disabled on the\n\t     sending socket.  Multicast datagrams with a hop limit greater\n\t     than 1 may be forwarded to the other networks if a multicast\n\t     router (such as mrouted(8)) is attached to the local network."
  manpageQuestion1: What is the primary purpose of the ip6 resource in macOS?
  manpageQuestion2: How would you set the hop limit for multicast datagrams to 3 using ip6?
  manpageQuestion3: Can you explain how to specify the interface index for multicast packet transmission with ip6?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIPV6_MULTICAST_LOOP u_int *\n\t     Get or set the status of whether multicast datagrams will be\n\t     looped back for local delivery when a multicast datagram is sent\n\t     to a group to which the sending host belongs.\n\n\t     This option improves performance for applications that may have\n\t     no more than one instance on a single host (such as a router\n\t     daemon) by eliminating the overhead of receiving their own\n\t     transmissions.  It should generally not be used by applications\n\t     for which there may be more than one instance on a single host\n\t     (such as a conferencing program) or for which the sender does not\n\t     belong to the destination group (such as a time-querying\n\t     program).\n\n\t     A multicast datagram sent with an initial hop limit greater than\n\t     1 may be delivered to the sending host on a different interface\n\t     from that on which it was sent if the host belongs to the\n\t     destination group on that other interface.  The multicast\n\t     loopback control option has no effect on such delivery."
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How would you configure a multicast loopback setting using the ip6 resource?
  manpageQuestion3: What is the recommended use case for disabling the multicast loopback option in ip6?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIPV6_JOIN_GROUP struct ipv6_mreq *\n\t     Join a multicast group.  A host must become a member of a\n\t     multicast group before it can receive datagrams sent to the\n\t     group.\n\n\t     struct ipv6_mreq {\n\t\t     struct in6_addr ipv6mr_multiaddr;\n\t\t     unsigned int    ipv6mr_interface;\n\t     };\n\n\t     ipv6mr_interface may be set to zeroes to choose the default\n\t     multicast interface or to the index of a particular multicast-\n\t     capable interface if the host is multihomed.  Membership is\n\t     associated with a single interface; programs running on\n\t     multihomed hosts may need to join the same group on more than one\n\t     interface.\n\n\t     If the multicast address is unspecified (i.e., all zeroes),\n\t     messages from all multicast addresses will be accepted by this\n\t     group.  Note that setting to this value requires superuser\n\t     privileges.\n\n     IPV6_LEAVE_GROUP struct ipv6_mreq *\n\t     Drop membership from the associated multicast group.  Memberships\n\t     are automatically dropped when the socket is closed or when the\n\t     process exits."
  manpageQuestion1: What is the primary purpose of the ip6 resource in macOS?
  manpageQuestion2: How would you use the ip6 resource to join a multicast group on the default interface?
  manpageQuestion3: Can you provide an example of using ip6 to leave a multicast group on a specific interface?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIPV6_PORTRANGE int *\n\t     Get or set the allocation policy of ephemeral ports for when the\n\t     kernel automatically binds a local address to this socket.  The\n\t     following values are available:\n\n\t     IPV6_PORTRANGE_DEFAULT  Use the regular range of non-reserved\n\t\t\t\t     ports (varies, see sysctl(8)).\n\t     IPV6_PORTRANGE_HIGH     Use a high range (varies, see sysctl(8)).\n\t     IPV6_PORTRANGE_LOW      Use a low, reserved range (600-1023).\n\n     IPV6_PKTINFO int *\n\t     Get or set whether additional information about subsequent\n\t     packets will be provided as ancillary data along with the payload\n\t     in subsequent recvmsg(2) calls.  The information is stored in the\n\t     following structure in the ancillary data returned:\n\n\t     struct in6_pktinfo {\n\t\t     struct in6_addr ipi6_addr;    /* src/dst IPv6 address */\n\t\t     unsigned int    ipi6_ifindex; /* send/recv if index */\n\t     };\n\n     IPV6_HOPLIMIT int *\n\t     Get or set whether the hop limit header field from subsequent\n\t     packets will be provided as ancillary data along with the payload\n\t     in subsequent recvmsg(2) calls.  The value is stored as an int in\n\t     the ancillary data returned."
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How would you use the ip6 resource to set the ephemeral port range to the high range?
  manpageQuestion3: Can you provide an example of using the ip6 resource to retrieve information about IPv6 packet information?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIPV6_HOPOPTS int *\n\t     Get or set whether the hop-by-hop options from subsequent packets\n\t     will be provided as ancillary data along with the payload in\n\t     subsequent recvmsg(2) calls.  The option is stored in the\n\t     following structure in the ancillary data returned:\n\n\t     struct ip6_hbh {\n\t\t     u_int8_t ip6h_nxt;      /* next header */\n\t\t     u_int8_t ip6h_len;      /* length in units of 8 octets */\n\t     /* followed by options */\n\t     } __packed;\n\n\t     The inet6_option_space() routine and family of routines may be\n\t     used to manipulate this data.\n\n\t     This option requires superuser privileges.\n\n     IPV6_DSTOPTS int *\n\t     Get or set whether the destination options from subsequent\n\t     packets will be provided as ancillary data along with the payload\n\t     in subsequent recvmsg(2) calls.  The option is stored in the\n\t     following structure in the ancillary data returned:\n\n\t     struct ip6_dest {\n\t\t     u_int8_t ip6d_nxt;      /* next header */\n\t\t     u_int8_t ip6d_len;      /* length in units of 8 octets */\n\t     /* followed by options */\n\t     } __packed;"
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How would you use the ip6 resource to configure hop-by-hop options for IPv6 packets?
  manpageQuestion3: Can you provide an example of using the ip6 resource to set destination options for IPv6 packets?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nThe inet6_option_space() routine and family of routines may be\n\t     used to manipulate this data.\n\n\t     This option requires superuser privileges.\n\n     IPV6_TCLASS int *\n\t     Get or set the value of the traffic class field used for outgoing\n\t     datagrams on this socket. The value must be between -1 and 255.\n\t     A value of -1 resets to the default value.\n\n     IPV6_RECVTCLASS int *\n\t     Get or set the status of whether the traffic class header field\n\t     will be provided as ancillary data along with the payload in\n\t     subsequent recvmsg(2) calls. The header field is stored as a\n\t     single value of type int.\n\n     IPV6_RTHDR int *\n\t     Get or set whether the routing header from subsequent packets\n\t     will be provided as ancillary data along with the payload in\n\t     subsequent recvmsg(2) calls.  The header is stored in the\n\t     following structure in the ancillary data returned:\n\n\t     struct ip6_rthdr {\n\t\t     u_int8_t ip6r_nxt;      /* next header */\n\t\t     u_int8_t ip6r_len;      /* length in units of 8 octets */\n\t\t     u_int8_t ip6r_type;     /* routing type */\n\t\t     u_int8_t ip6r_segleft;  /* segments left */\n\t     /* followed by routing-type-specific data */\n\t     } __packed;"
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How would you use the IPV6_TCLASS option to set the traffic class field for outgoing datagrams on a socket?
  manpageQuestion3: Can you provide an example of using the IPV6_RTHDR option to retrieve routing header information from received packets?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nThe inet6_option_space() routine and family of routines may be\n\t     used to manipulate this data.\n\n\t     This option requires superuser privileges.\n\n     IPV6_PKTOPTIONS struct cmsghdr *\n\t     Get or set all header options and extension headers at one time\n\t     on the last packet sent or received on the socket.  All options\n\t     must fit within the size of an mbuf (see mbuf(9)).  Options are\n\t     specified as a series of cmsghdr structures followed by\n\t     corresponding values.  cmsg_level is set to IPPROTO_IPV6,\n\t     cmsg_type to one of the other values in this list, and trailing\n\t     data to the option value.\tWhen setting options, if the length\n\t     optlen to setsockopt(2) is zero, all header options will be reset\n\t     to their default values.  Otherwise, the length should specify\n\t     the size the series of control messages consumes.\n\n\t     Instead of using sendmsg(2) to specify option values, the\n\t     ancillary data used in these calls that correspond to the desired\n\t     header options may be directly specified as the control message\n\t     in the series of control messages provided as the argument to\n\t     setsockopt(2)."
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How would you use the ip6 resource to set header options on a socket?
  manpageQuestion3: Can you provide an example of using the ip6 resource to reset all header options on a socket?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIPV6_CHECKSUM int *\n\t     Get or set the byte offset into a packet where the 16-bit\n\t     checksum is located.  When set, this byte offset is where\n\t     incoming packets will be expected to have checksums of their data\n\t     stored and where outgoing packets will have checksums of their\n\t     data computed and stored by the kernel.  A value of -1 specifies\n\t     that no checksums will be checked on incoming packets and that no\n\t     checksums will be computed or stored on outgoing packets.\tThe\n\t     offset of the checksum for ICMPv6 sockets cannot be relocated or\n\t     turned off.\n\n     IPV6_V6ONLY int *\n\t     Get or set whether only IPv6 connections can be made to this\n\t     socket.  For wildcard sockets, this can restrict connections to\n\t     IPv6 only.\n\n     IPV6_USE_MIN_MTU int *\n\t     Get or set whether the minimal IPv6 maximum transmission unit\n\t     (MTU) size will be used to avoid fragmentation from occurring for\n\t     subsequent outgoing datagrams.\n\n     The IPV6_PKTINFO, IPV6_HOPLIMIT, IPV6_HOPOPTS, IPV6_DSTOPTS, and\n     IPV6_RTHDR options will return ancillary data along with payload contents\n     in subsequent recvmsg(2) calls with cmsg_level set to IPPROTO_IPV6 and\n     cmsg_type set to respective option name value (e.g., IPV6_HOPTLIMIT).\n     These options may also be used directly as ancillary cmsg_type values in\n     sendmsg(2) to set options on the packet being transmitted by the call.\n     The cmsg_level value must be IPPROTO_IPV6.  For these options, the\n     ancillary data object value format is the same as the value returned as\n     explained for each when received with recvmsg(2)."
  manpageQuestion1: What is the primary purpose of the ip6 resource in macOS?
  manpageQuestion2: How can you configure a socket to only accept IPv6 connections using the ip6 resource?
  manpageQuestion3: What is the function of the IPV6_USE_MIN_MTU option in the ip6 resource?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.



    Manpage text:

    Note that using sendmsg(2) to specify options on particular packets works
         only on UDP and raw sockets.  To manipulate header options for packets on
         TCP sockets, only the socket options may be used.

         In some cases, there are multiple APIs defined for manipulating an IPv6
         header field.  A good example is the outgoing interface for multicast
         datagrams, which can be set by the IPV6_MULTICAST_IF socket option,
         through the IPV6_PKTINFO option, and through the sin6_scope_id field of
         the socket address passed to the sendto(2) system call.

         Resolving these conflicts is implementation dependent.  This
         implementation determines the value in the following way: options
         specified by using ancillary data (i.e., sendmsg(2)) are considered
         first, options specified by using IPV6_PKTOPTIONS to set “sticky” options
         are considered second, options specified by using the individual, basic,
         and direct socket options (e.g., IPV6_UNICAST_HOPS) are considered third,
         and options specified in the socket address supplied to sendto(2) are the
         last choice.
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How can you set the outgoing interface for multicast datagrams using ip6?
  manpageQuestion3: What is the order of precedence for different methods of setting IPv6 header options?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.



    Manpage text:

    Multicasting
         IPv6 multicasting is supported only on AF_INET6 sockets of type
         SOCK_DGRAM and SOCK_RAW, and only on networks where the interface driver
         supports multicasting.  Socket options (see above) that manipulate
         membership of multicast groups and other multicast options include
         IPV6_MULTICAST_IF, IPV6_MULTICAST_HOPS, IPV6_MULTICAST_LOOP,
         IPV6_LEAVE_GROUP, and IPV6_JOIN_GROUP.

       Raw Sockets
         Raw IPv6 sockets are connectionless and are normally used with the
         sendto(2) and recvfrom(2) calls, although the connect(2) call may be used
         to fix the destination address for future outgoing packets so that
         send(2) may instead be used and the bind(2) call may be used to fix the
         source address for future outgoing packets instead of having the kernel
         choose a source address.

         By using connect(2) or bind(2), raw socket input is constrained to only
         packets with their source address matching the socket destination address
         if connect(2) was used and to packets with their destination address
         matching the socket source address if bind(2) was used.
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How can raw IPv6 sockets be used to send and receive packets?
  manpageQuestion3: What are the key socket options related to IPv6 multicasting?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nIf the proto argument to socket(2) is zero, the default protocol\n     (IPPROTO_RAW) is used for outgoing packets.  For incoming packets,\n     protocols recognized by kernel are not passed to the application socket\n     (e.g., tcp(4) and udp(4)) except for some ICMPv6 messages.  The ICMPv6\n     messages not passed to raw sockets include echo, timestamp, and address\n     mask requests.  If proto is non-zero, only packets with this protocol\n     will be passed to the socket.\n\n     IPv6 fragments are also not passed to application sockets until they have\n     been reassembled.\tIf reception of all packets is desired, link-level\n     access (such as bpf(4)) must be used instead.\n\n     Outgoing packets automatically have an IPv6 header prepended to them\n     (based on the destination address and the protocol number the socket was\n     created with).  Incoming packets are received by an application without\n     the IPv6 header or any extension headers.\n\n     Outgoing packets will be fragmented automatically by the kernel if they\n     are too large.  Incoming packets will be reassembled before being sent to\n     the raw socket, so packet fragments or fragment headers will never be\n     seen on a raw socket."
  manpageQuestion1: What is the primary purpose of the `ip6` resource?
  manpageQuestion2: How does the `ip6` resource handle incoming and outgoing packets differently?
  manpageQuestion3: What is the behavior of `ip6` when receiving fragmented packets?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nEXAMPLES\n     The following determines the hop limit on the next packet received:\n\n     struct iovec iov[2];\n     u_char buf[BUFSIZ];\n     struct cmsghdr *cm;\n     struct msghdr m;\n     int found, optval;\n     u_char data[2048];\n\n     /* Create socket. */\n\n     (void)memset(&m, 0, sizeof(m));\n     (void)memset(&iov, 0, sizeof(iov));\n\n     iov[0].iov_base = data;\t     /* buffer for packet payload */\n     iov[0].iov_len = sizeof(data);  /* expected packet length */\n\n     m.msg_name = &from;\t     /* sockaddr_in6 of peer */\n     m.msg_namelen = sizeof(from);\n     m.msg_iov = iov;\n     m.msg_iovlen = 1;\n     m.msg_control = (caddr_t)buf;   /* buffer for control messages */\n     m.msg_controllen = sizeof(buf);\n\n     /*\n      * Enable the hop limit value from received packets to be\n      * returned along with the payload.\n      */\n     optval = 1;\n     if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPLIMIT, &optval,\n\t sizeof(optval)) == -1)\n\t     err(1, \"setsockopt\");\n\n     found = 0;\n     while (!found) {\n\t     if (recvmsg(s, &m, 0) == -1)\n\t\t     err(1, \"recvmsg\");\n\t     for (cm = CMSG_FIRSTHDR(&m); cm != NULL;\n\t\t  cm = CMSG_NXTHDR(&m, cm)) {\n\t\t     if (cm->cmsg_level == IPPROTO_IPV6 &&\n\t\t\t cm->cmsg_type == IPV6_HOPLIMIT &&\n\t\t\t cm->cmsg_len == CMSG_LEN(sizeof(int))) {\n\t\t\t     found = 1;\n\t\t\t     (void)printf(\"hop limit: %d\\n\",\n\t\t\t\t *(int *)CMSG_DATA(cm));\n\t\t\t     break;\n\t\t     }\n\t     }\n     }"
  manpageQuestion1: What is the primary purpose of the `ip6` resource?
  manpageQuestion2: How can you retrieve the hop limit value from a received IPv6 packet using `ip6`?
  manpageQuestion3: What is the function of the `setsockopt` call in the provided example for `ip6`?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nDIAGNOSTICS\n     A socket operation may fail with one of the following errors returned:\n\n     [EISCONN]\t      when trying to establish a connection on a socket which\n\t\t      already has one or when trying to send a datagram with\n\t\t      the destination address specified and the socket is\n\t\t      already connected.\n\n     [ENOTCONN]       when trying to send a datagram, but no destination\n\t\t      address is specified, and the socket hasn't been\n\t\t      connected.\n\n     [ENOBUFS]\t      when the system runs out of memory for an internal data\n\t\t      structure.\n\n     [EADDRNOTAVAIL]  when an attempt is made to create a socket with a\n\t\t      network address for which no network interface exists.\n\n     [EACCES]\t      when an attempt is made to create a raw IPv6 socket by a\n\t\t      non-privileged process.\n\n     The following errors specific to IPv6 may occur when setting or getting\n     header options:\n\n     [EINVAL]\t      An unknown socket option name was given.\n\n     [EINVAL]\t      An ancillary data object was improperly formed."
  manpageQuestion1: What is the primary purpose of the 'ip6' resource?
  manpageQuestion2: What error code is returned when attempting to send a datagram on an already connected IPv6 socket?
  manpageQuestion3: What error code is raised when a non-privileged process tries to create a raw IPv6 socket?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ip6`.\n\n\n\nManpage text:\n\nSEE ALSO\n     getsockopt(2), recv(2), send(2), setsockopt(2), socket(2),\n     if_nametoindex(3), bpf(4), icmp6(4), inet6(4), netintro(4), tcp(4),\n     udp(4)\n\n     W. Stevens and M. Thomas, Advanced Sockets API for IPv6, RFC 2292,\n     February 1998.\n\n     S. Deering and R. Hinden, Internet Protocol, Version 6 (IPv6)\n     Specification, RFC 2460, December 1998.\n\n     R. Gilligan, S. Thomson, J. Bound, and W. Stevens, Basic Socket Interface\n     Extensions for IPv6, RFC 2553, March 1999.\n\n     W. Stevens, B. Fenner, and A. Rudoff, UNIX Network Programming, third\n     edition.\n\nSTANDARDS\n     Most of the socket options are defined in RFC 2292 or RFC 2553.  The\n     IPV6_V6ONLY socket option is defined in RFC 3542.\tThe IPV6_PORTRANGE\n     socket option and the conflict resolution rule are not defined in the\n     RFCs and should be considered implementation dependent.\n\nmacOS 15.3\t\t       December 29, 2004\t\t    macOS 15.3"
  manpageQuestion1: What is the primary purpose of the ip6 resource?
  manpageQuestion2: How can you use the ip6 resource to configure IPv6 settings on a macOS system?
  manpageQuestion3: What are the key standards and RFCs that define the socket options for IPv6 in macOS?

