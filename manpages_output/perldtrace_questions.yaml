- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldtrace`.\n\n\n\nManpage text:\n\nPERLDTRACE(1)\t       Perl Programmers Reference Guide \t PERLDTRACE(1)\n\n\nNAME\n       perldtrace - Perl's support for DTrace\n\nSYNOPSIS\n\t# dtrace -Zn 'perl::sub-entry, perl::sub-return { trace(copyinstr(arg0)) }'\n\tdtrace: description 'perl::sub-entry, perl::sub-return ' matched 10 probes\n\n\t# perl -E 'sub outer { inner(@_) } sub inner { say shift } outer(\"hello\")'\n\thello\n\n\t(dtrace output)\n\tCPU\tID\t\t      FUNCTION:NAME\n\t  0  75915\t Perl_pp_entersub:sub-entry   BEGIN\n\t  0  75915\t Perl_pp_entersub:sub-entry   import\n\t  0  75922\tPerl_pp_leavesub:sub-return   import\n\t  0  75922\tPerl_pp_leavesub:sub-return   BEGIN\n\t  0  75915\t Perl_pp_entersub:sub-entry   outer\n\t  0  75915\t Perl_pp_entersub:sub-entry   inner\n\t  0  75922\tPerl_pp_leavesub:sub-return   inner\n\t  0  75922\tPerl_pp_leavesub:sub-return   outer\n\nDESCRIPTION\n       DTrace is a framework for comprehensive system- and application-level\n       tracing. Perl is a DTrace provider, meaning it exposes several probes\n       for instrumentation. You can use these in conjunction with kernel-level\n       probes, as well as probes from other providers such as MySQL, in order\n       to diagnose software defects, or even just your application's\n       bottlenecks.\n\n       Perl must be compiled with the \"-Dusedtrace\" option in order to make\n       use of the provided probes. While DTrace aims to have no overhead when\n       its instrumentation is not active, Perl's support itself cannot uphold\n       that guarantee, so it is built without DTrace probes under most\n       systems. One notable exception is that Mac OS X ships a /usr/bin/perl\n       with DTrace support enabled.\n\nHISTORY\n       5.10.1\n\t   Perl's initial DTrace support was added, providing \"sub-entry\" and\n\t   \"sub-return\" probes.\n\n       5.14.0\n\t   The \"sub-entry\" and \"sub-return\" probes gain a fourth argument: the\n\t   package name of the function.\n\n       5.16.0\n\t   The \"phase-change\" probe was added.\n\n       5.18.0\n\t   The \"op-entry\", \"loading-file\", and \"loaded-file\" probes were\n\t   added.\n\nPROBES\n       sub-entry(SUBNAME, FILE, LINE, PACKAGE)\n\t   Traces the entry of any subroutine. Note that all of the variables\n\t   refer to the subroutine that is being invoked; there is currently\n\t   no way to get ahold of any information about the subroutine's\n\t   caller from a DTrace action.\n\n\t    :*perl*::sub-entry {\n\t\tprintf(\"%s::%s entered at %s line %d\\n\",\n\t\t      copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg2);\n\t    }\n\n       sub-return(SUBNAME, FILE, LINE, PACKAGE)\n\t   Traces the exit of any subroutine. Note that all of the variables\n\t   refer to the subroutine that is returning; there is currently no\n\t   way to get ahold of any information about the subroutine's caller\n\t   from a DTrace action.\n\n\t    :*perl*::sub-return {\n\t\tprintf(\"%s::%s returned at %s line %d\\n\",\n\t\t      copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg2);\n\t    }\n\n       phase-change(NEWPHASE, OLDPHASE)\n\t   Traces changes to Perl's interpreter state. You can internalize\n\t   this as tracing changes to Perl's \"${^GLOBAL_PHASE}\" variable,\n\t   especially since the values for \"NEWPHASE\" and \"OLDPHASE\" are the\n\t   strings that \"${^GLOBAL_PHASE}\" reports.\n\n\t    :*perl*::phase-change {\n\t\tprintf(\"Phase changed from %s to %s\\n\",\n\t\t    copyinstr(arg1), copyinstr(arg0));\n\t    }\n\n       op-entry(OPNAME)\n\t   Traces the execution of each opcode in the Perl runloop. This probe\n\t   is fired before the opcode is executed. When the Perl debugger is\n\t   enabled, the DTrace probe is fired after the debugger hooks (but\n\t   still before the opcode itself is executed).\n\n\t    :*perl*::op-entry {\n\t\tprintf(\"About to execute opcode %s\\n\", copyinstr(arg0));\n\t    }\n\n       loading-file(FILENAME)\n\t   Fires when Perl is about to load an individual file, whether from\n\t   \"use\", \"require\", or \"do\". This probe fires before the file is read\n\t   from disk. The filename argument is converted to local filesystem\n\t   paths instead of providing \"Module::Name\"-style names.\n\n\t    :*perl*:loading-file {\n\t\tprintf(\"About to load %s\\n\", copyinstr(arg0));\n\t    }\n\n       loaded-file(FILENAME)\n\t   Fires when Perl has successfully loaded an individual file, whether\n\t   from \"use\", \"require\", or \"do\". This probe fires after the file is\n\t   read from disk and its contents evaluated. The filename argument is\n\t   converted to local filesystem paths instead of providing\n\t   \"Module::Name\"-style names.\n\n\t    :*perl*:loaded-file {\n\t\tprintf(\"Successfully loaded %s\\n\", copyinstr(arg0));\n\t    }\n\nEXAMPLES\n       Most frequently called functions\n\t    # dtrace -qZn 'sub-entry { @[strjoin(strjoin(copyinstr(arg3),\"::\"),copyinstr(arg0))] = count() } END {trunc(@, 10)}'\n\n\t    Class::MOP::Attribute::slots\t\t\t\t    400\n\t    Try::Tiny::catch\t\t\t\t\t\t    411\n\t    Try::Tiny::try\t\t\t\t\t\t    411\n\t    Class::MOP::Instance::inline_slot_access\t\t\t    451\n\t    Class::MOP::Class::Immutable::Trait:::around\t\t    472\n\t    Class::MOP::Mixin::AttributeCore::has_initializer\t\t    496\n\t    Class::MOP::Method::Wrapped::__ANON__\t\t\t    544\n\t    Class::MOP::Package::_package_stash \t\t\t    737\n\t    Class::MOP::Class::initialize\t\t\t\t   1128\n\t    Class::MOP::get_metaclass_by_name\t\t\t\t   1204\n\n       Trace function calls\n\t    # dtrace -qFZn 'sub-entry, sub-return { trace(copyinstr(arg0)) }'\n\n\t    0  -> Perl_pp_entersub\t\t\t  BEGIN\n\t    0  <- Perl_pp_leavesub\t\t\t  BEGIN\n\t    0  -> Perl_pp_entersub\t\t\t  BEGIN\n\t    0\t -> Perl_pp_entersub\t\t\t  import\n\t    0\t <- Perl_pp_leavesub\t\t\t  import\n\t    0  <- Perl_pp_leavesub\t\t\t  BEGIN\n\t    0  -> Perl_pp_entersub\t\t\t  BEGIN\n\t    0\t -> Perl_pp_entersub\t\t\t  dress\n\t    0\t <- Perl_pp_leavesub\t\t\t  dress\n\t    0\t -> Perl_pp_entersub\t\t\t  dirty\n\t    0\t <- Perl_pp_leavesub\t\t\t  dirty\n\t    0\t -> Perl_pp_entersub\t\t\t  whiten\n\t    0\t <- Perl_pp_leavesub\t\t\t  whiten\n\t    0  <- Perl_dounwind \t\t\t  BEGIN\n\n       Function calls during interpreter cleanup\n\t    # dtrace -Zn 'phase-change /copyinstr(arg0) == \"END\"/ { self->ending = 1 } sub-entry /self->ending/ { trace(copyinstr(arg0)) }'\n\n\t    CPU     ID\t\t\t  FUNCTION:NAME\n\t      1  77214\t     Perl_pp_entersub:sub-entry   END\n\t      1  77214\t     Perl_pp_entersub:sub-entry   END\n\t      1  77214\t     Perl_pp_entersub:sub-entry   cleanup\n\t      1  77214\t     Perl_pp_entersub:sub-entry   _force_writable\n\t      1  77214\t     Perl_pp_entersub:sub-entry   _force_writable\n\n       System calls at compile time\n\t    # dtrace -qZn 'phase-change /copyinstr(arg0) == \"START\"/ { self->interesting = 1 } phase-change /copyinstr(arg0) == \"RUN\"/ { self->interesting = 0 } syscall::: /self->interesting/ { @[probefunc] = count() } END { trunc(@, 3) }'\n\n\t    lseek\t\t\t\t\t\t\t    310\n\t    read\t\t\t\t\t\t\t    374\n\t    stat64\t\t\t\t\t\t\t   1056\n\n       Perl functions that execute the most opcodes\n\t    # dtrace -qZn 'sub-entry { self->fqn = strjoin(copyinstr(arg3), strjoin(\"::\", copyinstr(arg0))) } op-entry /self->fqn != \"\"/ { @[self->fqn] = count() } END { trunc(@, 3) }'\n\n\t    warnings::unimport\t\t\t\t\t\t   4589\n\t    Exporter::Heavy::_rebuild_cache\t\t\t\t   5039\n\t    Exporter::import\t\t\t\t\t\t  14578\n\nREFERENCES\n       DTrace Dynamic Tracing Guide\n\t   <http://dtrace.org/guide/preface.html>\n\n       DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X and FreeBSD\n\t   <https://www.amazon.com/DTrace-Dynamic-Tracing-Solaris-FreeBSD/dp/0132091518/>\n\nSEE ALSO\n       Devel::DTrace::Provider\n\t   This CPAN module lets you create application-level DTrace probes\n\t   written in Perl.\n\nAUTHORS\n       Shawn M Moore \"sartak@gmail.com\"\n\nperl v5.34.1\t\t\t  2022-02-19\t\t\t PERLDTRACE(1)"
  manpageQuestion1: What is the primary purpose of the perldtrace tool?
  manpageQuestion2: How can you use DTrace to trace the entry and return of subroutines in Perl?
  manpageQuestion3: Can you provide an example of using DTrace to monitor system calls made during Perl's compile phase?

