- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nPERLRE(1)\t       Perl Programmers Reference Guide \t     PERLRE(1)"
  manpageQuestion1: What is the primary purpose of the perlre utility?
  manpageQuestion2: How can you use perlre to match a regular expression against a string?
  manpageQuestion3: Can you provide an example of using perlre to extract all occurrences of a specific pattern from a text file?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    NAME
           perlre - Perl regular expressions

    DESCRIPTION
           This page describes the syntax of regular expressions in Perl.

           If you haven't used regular expressions before, a tutorial introduction
           is available in perlretut.  If you know just a little about them, a
           quick-start introduction is available in perlrequick.

           Except for "The Basics" section, this page assumes you are familiar
           with regular expression basics, like what is a "pattern", what does it
           look like, and how it is basically used.  For a reference on how they
           are used, plus various examples of the same, see discussions of "m//",
           "s///", "qr//" and "??" in "Regexp Quote-Like Operators" in perlop.

           New in v5.22, "use re 'strict'" applies stricter rules than otherwise
           when compiling regular expression patterns.  It can find things that,
           while legal, may not be what you intended.

       The Basics
           Regular expressions are strings with the very particular syntax and
           meaning described in this document and auxiliary documents referred to
           by this one.  The strings are called "patterns".  Patterns are used to
           determine if some other string, called the "target", has (or doesn't
           have) the characteristics specified by the pattern.  We call this
           "matching" the target string against the pattern.  Usually the match is
           done by having the target be the first operand, and the pattern be the
           second operand, of one of the two binary operators "=~" and "!~",
           listed in "Binding Operators" in perlop; and the pattern will have been
           converted from an ordinary string by one of the operators in "Regexp
           Quote-Like Operators" in perlop, like so:
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use perlre to match a string that starts with 'http' and ends with '.com'?
  manpageQuestion3: Can you provide an example of using perlre to find all occurrences of the word 'example' in a given text?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n$foo =~ m/abc/\n\n       This evaluates to true if and only if the string in the variable $foo\n       contains somewhere in it, the sequence of characters \"a\", \"b\", then\n       \"c\".  (The \"=~ m\", or match operator, is described in\n       \"m/PATTERN/msixpodualngc\" in perlop.)\n\n       Patterns that aren't already stored in some variable must be\n       delimitted, at both ends, by delimitter characters.  These are often,\n       as in the example above, forward slashes, and the typical way a pattern\n       is written in documentation is with those slashes.  In most cases, the\n       delimitter is the same character, fore and aft, but there are a few\n       cases where a character looks like it has a mirror-image mate, where\n       the opening version is the beginning delimiter, and the closing one is\n       the ending delimiter, like\n\n\t$foo =~ m<abc>\n\n       Most times, the pattern is evaluated in double-quotish context, but it\n       is possible to choose delimiters to force single-quotish, like"
  manpageQuestion1: What is the primary purpose of the perlre utility?
  manpageQuestion2: How would you use perlre to check if a string contains the substring 'abc'?
  manpageQuestion3: Can you provide an example of using perlre with different delimiter characters to match a pattern in a string?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n$foo =~ m'abc'\n\n       If the pattern contains its delimiter within it, that delimiter must be\n       escaped.  Prefixing it with a backslash (e.g., \"/foo\\/bar/\") serves\n       this purpose.\n\n       Any single character in a pattern matches that same character in the\n       target string, unless the character is a metacharacter with a special\n       meaning described in this document.  A sequence of non-metacharacters\n       matches the same sequence in the target string, as we saw above with\n       \"m/abc/\".\n\n       Only a few characters (all of them being ASCII punctuation characters)\n       are metacharacters.  The most commonly used one is a dot \".\", which\n       normally matches almost any character (including a dot itself).\n\n       You can cause characters that normally function as metacharacters to be\n       interpreted literally by prefixing them with a \"\\\", just like the\n       pattern's delimiter must be escaped if it also occurs within the\n       pattern.  Thus, \"\\.\" matches just a literal dot, \".\" instead of its\n       normal meaning.\tThis means that the backslash is also a metacharacter,\n       so \"\\\\\" matches a single \"\\\".  And a sequence that contains an escaped\n       metacharacter matches the same sequence (but without the escape) in the\n       target string.  So, the pattern \"/blur\\\\fl/\" would match any target\n       string that contains the sequence \"blur\\fl\"."
  manpageQuestion1: What is the primary purpose of the perlre utility?
  manpageQuestion2: How would you use perlre to match a string containing the literal dot character, such as 'a.b'?
  manpageQuestion3: Can you provide an example of using perlre to match a string that includes a backslash followed by a dot, like 'a\.'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThe metacharacter \"|\" is used to match one thing or another.  Thus\n\n\t$foo =~ m/this|that/\n\n       is TRUE if and only if $foo contains either the sequence \"this\" or the\n       sequence \"that\".  Like all metacharacters, prefixing the \"|\" with a\n       backslash makes it match the plain punctuation character; in its case,\n       the VERTICAL LINE.\n\n\t$foo =~ m/this\\|that/\n\n       is TRUE if and only if $foo contains the sequence \"this|that\".\n\n       You aren't limited to just a single \"|\".\n\n\t$foo =~ m/fee|fie|foe|fum/\n\n       is TRUE if and only if $foo contains any of those 4 sequences from the\n       children's story \"Jack and the Beanstalk\".\n\n       As you can see, the \"|\" binds less tightly than a sequence of ordinary\n       characters.  We can override this by using the grouping metacharacters,\n       the parentheses \"(\" and \")\".\n\n\t$foo =~ m/th(is|at) thing/\n\n       is TRUE if and only if $foo contains either the sequence \"this thing\"\n       or the sequence \"that thing\".  The portions of the string that match\n       the portions of the pattern enclosed in parentheses are normally made\n       available separately for use later in the pattern, substitution, or\n       program.  This is called \"capturing\", and it can get complicated.  See\n       \"Capture groups\"."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a string that contains either 'apple' or 'banana'?
  manpageQuestion3: Can you provide an example of using perlre to match a string that contains either 'cat' or 'dog', with the option to capture the matched group?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    The first alternative includes everything from the last pattern
           delimiter ("(", "(?:" (described later), etc. or the beginning of the
           pattern) up to the first "|", and the last alternative contains
           everything from the last "|" to the next closing pattern delimiter.
           That's why it's common practice to include alternatives in parentheses:
           to minimize confusion about where they start and end.

           Alternatives are tried from left to right, so the first alternative
           found for which the entire expression matches, is the one that is
           chosen. This means that alternatives are not necessarily greedy. For
           example: when matching "foo|foot" against "barefoot", only the "foo"
           part will match, as that is the first alternative tried, and it
           successfully matches the target string. (This might not seem important,
           but it is important when you are capturing matched text using
           parentheses.)

           Besides taking away the special meaning of a metacharacter, a prefixed
           backslash changes some letter and digit characters away from matching
           just themselves to instead have special meaning.  These are called
           "escape sequences", and all such are described in perlrebackslash.  A
           backslash sequence (of a letter or digit) that doesn't currently have
           special meaning to Perl will raise a warning if warnings are enabled,
           as those are reserved for potential future use.
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use perlre to match a string that starts with 'foo' and ends with 'bar', allowing for any characters in between?
  manpageQuestion3: What is the effect of using a backslash before a metacharacter in perlre?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nOne such sequence is \"\\b\", which matches a boundary of some sort.\n       \"\\b{wb}\" and a few others give specialized types of boundaries.\t(They\n       are all described in detail starting at \"\\b{}, \\b, \\B{}, \\B\" in\n       perlrebackslash.)  Note that these don't match characters, but the\n       zero-width spaces between characters.  They are an example of a zero-\n       width assertion.  Consider again,\n\n\t$foo =~ m/fee|fie|foe|fum/\n\n       It evaluates to TRUE if, besides those 4 words, any of the sequences\n       \"feed\", \"field\", \"Defoe\", \"fume\", and many others are in $foo.  By\n       judicious use of \"\\b\" (or better (because it is designed to handle\n       natural language) \"\\b{wb}\"), we can make sure that only the Giant's\n       words are matched:\n\n\t$foo =~ m/\\b(fee|fie|foe|fum)\\b/\n\t$foo =~ m/\\b{wb}(fee|fie|foe|fum)\\b{wb}/\n\n       The final example shows that the characters \"{\" and \"}\" are\n       metacharacters.\n\n       Another use for escape sequences is to specify characters that cannot\n       (or which you prefer not to) be written literally.  These are described\n       in detail in \"Character Escapes\" in perlrebackslash, but the next three\n       paragraphs briefly describe some of them."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match only whole words 'fee', 'fie', 'foe', and 'fum' in a string?
  manpageQuestion3: Can you provide an example of using perlre to represent the characters '{' and '}' as literal characters in a regular expression?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    Various control characters can be written in C language style: "\n"
           matches a newline, "\t" a tab, "\r" a carriage return, "\f" a form
           feed, etc.

           More generally, "\nnn", where nnn is a string of three octal digits,
           matches the character whose native code point is nnn.  You can easily
           run into trouble if you don't have exactly three digits.  So always use
           three, or since Perl 5.14, you can use "\o{...}" to specify any number
           of octal digits.

           Similarly, "\xnn", where nn are hexadecimal digits, matches the
           character whose native ordinal is nn.  Again, not using exactly two
           digits is a recipe for disaster, but you can use "\x{...}" to specify
           any number of hex digits.

           Besides being a metacharacter, the "." is an example of a "character
           class", something that can match any single character of a given set of
           them.  In its case, the set is just about all possible characters.
           Perl predefines several character classes besides the "."; there is a
           separate reference page about just these, perlrecharclass.
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you represent a newline character in Perl using octal notation?
  manpageQuestion3: What is the correct way to match a hexadecimal value in Perl using the perlre resource?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    You can define your own custom character classes, by putting into your
           pattern in the appropriate place(s), a list of all the characters you
           want in the set.  You do this by enclosing the list within "[]" bracket
           characters.  These are called "bracketed character classes" when we are
           being precise, but often the word "bracketed" is dropped.  (Dropping it
           usually doesn't cause confusion.)  This means that the "[" character is
           another metacharacter.  It doesn't match anything just by itself; it is
           used only to tell Perl that what follows it is a bracketed character
           class.  If you want to match a literal left square bracket, you must
           escape it, like "\[".  The matching "]" is also a metacharacter; again
           it doesn't match anything by itself, but just marks the end of your
           custom class to Perl.  It is an example of a "sometimes metacharacter".
           It isn't a metacharacter if there is no corresponding "[", and matches
           its literal self:
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How would you create a regular expression pattern in Perl to match any single character that is a vowel (a, e, i, o, u) using bracketed character classes?
  manpageQuestion3: Can you explain how to match a literal left square bracket character in a regular expression using perlre?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nprint \"]\" =~ /]/;  # prints 1\n\n       The list of characters within the character class gives the set of\n       characters matched by the class.  \"[abc]\" matches a single \"a\" or \"b\"\n       or \"c\".\tBut if the first character after the \"[\" is \"^\", the class\n       instead matches any character not in the list.  Within a list, the \"-\"\n       character specifies a range of characters, so that \"a-z\" represents all\n       characters between \"a\" and \"z\", inclusive.  If you want either \"-\" or\n       \"]\" itself to be a member of a class, put it at the start of the list\n       (possibly after a \"^\"), or escape it with a backslash.  \"-\" is also\n       taken literally when it is at the end of the list, just before the\n       closing \"]\".  (The following all specify the same class of three\n       characters: \"[-az]\", \"[az-]\", and \"[a\\-z]\".  All are different from\n       \"[a-z]\", which specifies a class containing twenty-six characters, even\n       on EBCDIC-based character sets.)\n\n       There is lots more to bracketed character classes; full details are in\n       \"Bracketed Character Classes\" in perlrecharclass."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you create a regular expression that matches any character except 'a', 'b', or 'c' using a character class?
  manpageQuestion3: Can you provide an example of how to create a regular expression that matches a hyphen (-) or a closing bracket (]) as literal characters within a character class?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nMetacharacters\n\n       \"The Basics\" introduced some of the metacharacters.  This section gives\n       them all.  Most of them have the same meaning as in the egrep command.\n\n       Only the \"\\\" is always a metacharacter.\tThe others are metacharacters\n       just sometimes.\tThe following tables lists all of them, summarizes\n       their use, and gives the contexts where they are metacharacters.\n       Outside those contexts or if prefixed by a \"\\\", they match their\n       corresponding punctuation character.  In some cases, their meaning\n       varies depending on various pattern modifiers that alter the default\n       behaviors.  See \"Modifiers\".\n\n\t\t   PURPOSE\t\t\t\t    WHERE\n\t\\   Escape the next character\t\t\t Always, except when\n\t\t\t\t\t\t\t escaped by another \\\n\t^   Match the beginning of the string\t\t Not in []\n\t      (or line, if /m is used)\n\t^   Complement the [] class\t\t\t At the beginning of []\n\t.   Match any single character except newline\t Not in []\n\t      (under /s, includes newline)\n\t$   Match the end of the string \t\t Not in [], but can\n\t      (or before newline at the end of the\t mean interpolate a\n\t      string; or before any newline if /m is\t scalar\n\t      used)\n\t|   Alternation \t\t\t\t Not in []\n\t()  Grouping\t\t\t\t\t Not in []\n\t[   Start Bracketed Character class\t\t Not in []\n\t]   End Bracketed Character class\t\t Only in [], and\n\t\t\t\t\t\t\t   not first\n\t*   Matches the preceding element 0 or more\t Not in []\n\t      times\n\t+   Matches the preceding element 1 or more\t Not in []\n\t      times\n\t?   Matches the preceding element 0 or 1\t Not in []\n\t      times\n\t{   Starts a sequence that gives number(s)\t Not in []\n\t      of times the preceding element can be\n\t      matched\n\t{   when following certain escape sequences\n\t      starts a modifier to the meaning of the\n\t      sequence\n\t}   End sequence started by {\n\t-   Indicates a range\t\t\t\t Only in [] interior\n\t#   Beginning of comment, extends to line end\t Only with /x modifier"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a string that starts with 'http' followed by any characters except newline and ends with '.com'?
  manpageQuestion3: Can you provide an example of using perlre to extract all email addresses from a text file named 'emails.txt'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nNotice that most of the metacharacters lose their special meaning when\n       they occur in a bracketed character class, except \"^\" has a different\n       meaning when it is at the beginning of such a class.  And \"-\" and \"]\"\n       are metacharacters only at restricted positions within bracketed\n       character classes; while \"}\" is a metacharacter only when closing a\n       special construct started by \"{\".\n\n       In double-quotish context, as is usually the case,  you need to be\n       careful about \"$\" and the non-metacharacter \"@\".  Those could\n       interpolate variables, which may or may not be what you intended.\n\n       These rules were designed for compactness of expression, rather than\n       legibility and maintainability.\tThe \"/x and /xx\" pattern modifiers\n       allow you to insert white space to improve readability.\tAnd use of\n       \"re 'strict'\" adds extra checking to catch some typos that might\n       silently compile into something unintended.\n\n       By default, the \"^\" character is guaranteed to match only the beginning\n       of the string, the \"$\" character only the end (or before the newline at\n       the end), and Perl does certain optimizations with the assumption that\n       the string contains only one line.  Embedded newlines will not be\n       matched by \"^\" or \"$\".  You may, however, wish to treat a string as a\n       multi-line buffer, such that the \"^\" will match after any newline\n       within the string (except if the newline is the last character in the\n       string), and \"$\" will match before any newline.\tAt the cost of a\n       little more overhead, you can do this by using the \"/m\" modifier on the\n       pattern match operator.\t(Older programs did this by setting $*, but\n       this option was removed in perl 5.10.)"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you modify a regular expression in Perl to treat the string as a multi-line buffer so that ^ matches at the beginning of each line and $ matches before each newline?
  manpageQuestion3: What are the key considerations when using metacharacters in a bracketed character class in Perl regular expressions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nTo simplify multi-line substitutions, the \".\" character never matches a\n       newline unless you use the \"/s\" modifier, which in effect tells Perl to\n       pretend the string is a single line--even if it isn't.\n\n   Modifiers\n       Overview\n\n       The default behavior for matching can be changed, using various\n       modifiers.  Modifiers that relate to the interpretation of the pattern\n       are listed just below.  Modifiers that alter the way a pattern is used\n       by Perl are detailed in \"Regexp Quote-Like Operators\" in perlop and\n       \"Gory details of parsing quoted constructs\" in perlop.  Modifiers can\n       be added dynamically; see \"Extended Patterns\" below.\n\n       \"m\" Treat the string being matched against as multiple lines.  That is,\n\t   change \"^\" and \"$\" from matching the start of the string's first\n\t   line and the end of its last line to matching the start and end of\n\t   each line within the string.\n\n       \"s\" Treat the string as single line.  That is, change \".\" to match any\n\t   character whatsoever, even a newline, which normally it would not\n\t   match."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you modify Perl's behavior to make the '.' character match newline characters in a multi-line string?
  manpageQuestion3: What modifier should be used to make the '^' and '$' meta characters match the start and end of each line within a multi-line string?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nUsed together, as \"/ms\", they let the \".\" match any character\n\t   whatsoever, while still allowing \"^\" and \"$\" to match,\n\t   respectively, just after and just before newlines within the\n\t   string.\n\n       \"i\" Do case-insensitive pattern matching.  For example, \"A\" will match\n\t   \"a\" under \"/i\".\n\n\t   If locale matching rules are in effect, the case map is taken from\n\t   the current locale for code points less than 255, and from Unicode\n\t   rules for larger code points.  However, matches that would cross\n\t   the Unicode rules/non-Unicode rules boundary (ords 255/256) will\n\t   not succeed, unless the locale is a UTF-8 one.  See perllocale.\n\n\t   There are a number of Unicode characters that match a sequence of\n\t   multiple characters under \"/i\".  For example, \"LATIN SMALL LIGATURE\n\t   FI\" should match the sequence \"fi\".\tPerl is not currently able to\n\t   do this when the multiple characters are in the pattern and are\n\t   split between groupings, or when one or more are quantified.  Thus\n\n\t    \"\\N{LATIN SMALL LIGATURE FI}\" =~ /fi/i;\t     # Matches\n\t    \"\\N{LATIN SMALL LIGATURE FI}\" =~ /[fi][fi]/i;    # Doesn't match!\n\t    \"\\N{LATIN SMALL LIGATURE FI}\" =~ /fi*/i;\t     # Doesn't match!"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you modify a regular expression in Perl to perform case-insensitive matching on the string 'example'?
  manpageQuestion3: Can you provide an example of using Perl's regex with the 'i' flag to match a Unicode character sequence like 'LATIN SMALL LIGATURE FI'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n# The below doesn't match, and it isn't clear what $1 and $2 would\n\t    # be even if it did!!\n\t    \"\\N{LATIN SMALL LIGATURE FI}\" =~ /(f)(i)/i;      # Doesn't match!\n\n\t   Perl doesn't match multiple characters in a bracketed character\n\t   class unless the character that maps to them is explicitly\n\t   mentioned, and it doesn't match them at all if the character class\n\t   is inverted, which otherwise could be highly confusing.  See\n\t   \"Bracketed Character Classes\" in perlrecharclass, and \"Negation\" in\n\t   perlrecharclass.\n\n       \"x\" and \"xx\"\n\t   Extend your pattern's legibility by permitting whitespace and\n\t   comments.  Details in \"/x and  /xx\"\n\n       \"p\" Preserve the string matched such that \"${^PREMATCH}\", \"${^MATCH}\",\n\t   and \"${^POSTMATCH}\" are available for use after matching.\n\n\t   In Perl 5.20 and higher this is ignored. Due to a new copy-on-write\n\t   mechanism, \"${^PREMATCH}\", \"${^MATCH}\", and \"${^POSTMATCH}\" will be\n\t   available after the match regardless of the modifier.\n\n       \"a\", \"d\", \"l\", and \"u\"\n\t   These modifiers, all new in 5.14, affect which character-set rules\n\t   (Unicode, etc.) are used, as described below in \"Character set\n\t   modifiers\"."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use the 'x' modifier in Perl regular expressions to improve pattern legibility?
  manpageQuestion3: What do the 'a', 'd', 'l', and 'u' modifiers in Perl regular expressions do?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n\"n\" Prevent the grouping metacharacters \"()\" from capturing. This\n\t   modifier, new in 5.22, will stop $1, $2, etc... from being filled\n\t   in.\n\n\t     \"hello\" =~ /(hi|hello)/;\t# $1 is \"hello\"\n\t     \"hello\" =~ /(hi|hello)/n;\t# $1 is undef\n\n\t   This is equivalent to putting \"?:\" at the beginning of every\n\t   capturing group:\n\n\t     \"hello\" =~ /(?:hi|hello)/; # $1 is undef\n\n\t   \"/n\" can be negated on a per-group basis. Alternatively, named\n\t   captures may still be used.\n\n\t     \"hello\" =~ /(?-n:(hi|hello))/n;   # $1 is \"hello\"\n\t     \"hello\" =~ /(?<greet>hi|hello)/n; # $1 is \"hello\", $+{greet} is\n\t\t\t\t\t       # \"hello\"\n\n       Other Modifiers\n\t   There are a number of flags that can be found at the end of regular\n\t   expression constructs that are not generic regular expression\n\t   flags, but apply to the operation being performed, like matching or\n\t   substitution (\"m//\" or \"s///\" respectively).\n\n\t   Flags described further in \"Using regular expressions in Perl\" in\n\t   perlretut are:\n\n\t     c\t- keep the current position during repeated matching\n\t     g\t- globally match the pattern repeatedly in the string"
  manpageQuestion1: What is the primary purpose of the 'n' modifier in Perl regular expressions?
  manpageQuestion2: How would you use the 'n' modifier to prevent capturing in a regular expression that matches 'hello'?
  manpageQuestion3: Can you provide an example of using the 'n' modifier with a named capture group in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nSubstitution-specific modifiers described in\n\t   \"s/PATTERN/REPLACEMENT/msixpodualngcer\" in perlop are:\n\n\t     e\t- evaluate the right-hand side as an expression\n\t     ee - evaluate the right side as a string then eval the result\n\t     o\t- pretend to optimize your code, but actually introduce bugs\n\t     r\t- perform non-destructive substitution and return the new value\n\n       Regular expression modifiers are usually written in documentation as\n       e.g., \"the \"/x\" modifier\", even though the delimiter in question might\n       not really be a slash.  The modifiers \"/imnsxadlup\" may also be\n       embedded within the regular expression itself using the \"(?...)\"\n       construct, see \"Extended Patterns\" below.\n\n       Details on some modifiers\n\n       Some of the modifiers require more explanation than given in the\n       \"Overview\" above.\n\n       \"/x\" and  \"/xx\"\n\n       A single \"/x\" tells the regular expression parser to ignore most\n       whitespace that is neither backslashed nor within a bracketed character\n       class.  You can use this to break up your regular expression into more\n       readable parts.\tAlso, the \"#\" character is treated as a metacharacter\n       introducing a comment that runs up to the pattern's closing delimiter,\n       or to the end of the current line if the pattern extends onto the next\n       line.  Hence, this is very much like an ordinary Perl code comment.\n       (You can include the closing delimiter within the comment only if you\n       precede it with a backslash, so be careful!)"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use the /x modifier in a regular expression to improve readability?
  manpageQuestion3: Can you explain how the 'e' modifier works in a substitution operation?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    Use of "/x" means that if you want real whitespace or "#" characters in
           the pattern (outside a bracketed character class, which is unaffected
           by "/x"), then you'll either have to escape them (using backslashes or
           "\Q...\E") or encode them using octal, hex, or "\N{}" or "\p{name=...}"
           escapes.  It is ineffective to try to continue a comment onto the next
           line by escaping the "\n" with a backslash or "\Q".

           You can use "(?#text)" to create a comment that ends earlier than the
           end of the current line, but "text" also can't contain the closing
           delimiter unless escaped with a backslash.

           A common pitfall is to forget that "#" characters begin a comment under
           "/x" and are not matched literally.  Just keep that in mind when trying
           to puzzle out why a particular "/x" pattern isn't working as expected.

           Starting in Perl v5.26, if the modifier has a second "x" within it, it
           does everything that a single "/x" does, but additionally non-
           backslashed SPACE and TAB characters within bracketed character classes
           are also generally ignored, and hence can be added to make the classes
           more readable.
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use the /x modifier in Perl regular expressions to make the pattern more readable while preserving the original meaning?
  manpageQuestion3: What is a common mistake when using the /x modifier in Perl regular expressions and how can it be avoided?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n/ [d-e g-i 3-7]/xx\n\t   /[ ! @ \" # $ % ^ & * () = ? <> ' ]/xx\n\n       may be easier to grasp than the squashed equivalents\n\n\t   /[d-eg-i3-7]/\n\t   /[!@\"#$%^&*()=?<>']/\n\n       Taken together, these features go a long way towards making Perl's\n       regular expressions more readable.  Here's an example:\n\n\t   # Delete (most) C comments.\n\t   $program =~ s {\n\t       /\\*     # Match the opening delimiter.\n\t       .*?     # Match a minimal number of characters.\n\t       \\*/     # Match the closing delimiter.\n\t   } []gsx;\n\n       Note that anything inside a \"\\Q...\\E\" stays unaffected by \"/x\".\tAnd\n       note that \"/x\" doesn't affect space interpretation within a single\n       multi-character construct.  For example \"(?:...)\" can't have a space\n       between the \"(\", \"?\", and \":\".  Within any delimiters for such a\n       construct, allowed spaces are not affected by \"/x\", and depend on the\n       construct.  For example, all constructs using curly braces as\n       delimiters, such as \"\\x{...}\" can have blanks within but adjacent to\n       the braces, but not elsewhere, and no non-blank space characters.  An\n       exception are Unicode properties which follow Unicode rules, for which\n       see \"Properties accessible through \\p{} and \\P{}\" in perluniprops."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use the /x flag in Perl regular expressions to make them more readable, and what is an example of its application?
  manpageQuestion3: Can you explain how the /x flag interacts with constructs like (?:...) and \\x{...} in Perl regular expressions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThe set of characters that are deemed whitespace are those that Unicode\n       calls \"Pattern White Space\", namely:\n\n\tU+0009 CHARACTER TABULATION\n\tU+000A LINE FEED\n\tU+000B LINE TABULATION\n\tU+000C FORM FEED\n\tU+000D CARRIAGE RETURN\n\tU+0020 SPACE\n\tU+0085 NEXT LINE\n\tU+200E LEFT-TO-RIGHT MARK\n\tU+200F RIGHT-TO-LEFT MARK\n\tU+2028 LINE SEPARATOR\n\tU+2029 PARAGRAPH SEPARATOR\n\n       Character set modifiers\n\n       \"/d\", \"/u\", \"/a\", and \"/l\", available starting in 5.14, are called the\n       character set modifiers; they affect the character set rules used for\n       the regular expression.\n\n       The \"/d\", \"/u\", and \"/l\" modifiers are not likely to be of much use to\n       you, and so you need not worry about them very much.  They exist for\n       Perl's internal use, so that complex regular expression data structures\n       can be automatically serialized and later exactly reconstituted,\n       including all their nuances.  But, since Perl can't keep a secret, and\n       there may be rare instances where they are useful, they are documented\n       here."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a string that contains any of the Unicode pattern whitespace characters?
  manpageQuestion3: Can you provide an example of using perlre with the '/d' character set modifier to modify the behavior of a regular expression?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThe \"/a\" modifier, on the other hand, may be useful.  Its purpose is to\n       allow code that is to work mostly on ASCII data to not have to concern\n       itself with Unicode.\n\n       Briefly, \"/l\" sets the character set to that of whatever Locale is in\n       effect at the time of the execution of the pattern match.\n\n       \"/u\" sets the character set to Unicode.\n\n       \"/a\" also sets the character set to Unicode, BUT adds several\n       restrictions for ASCII-safe matching.\n\n       \"/d\" is the old, problematic, pre-5.14 Default character set behavior.\n       Its only use is to force that old behavior.\n\n       At any given time, exactly one of these modifiers is in effect.\tTheir\n       existence allows Perl to keep the originally compiled behavior of a\n       regular expression, regardless of what rules are in effect when it is\n       actually executed.  And if it is interpolated into a larger regex, the\n       original's rules continue to apply to it, and don't affect the other\n       parts."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How would you use the /u modifier in perlre to ensure that a regular expression matches Unicode characters?
  manpageQuestion3: Can you explain how the /a modifier in perlre affects the behavior of a regular expression when matching ASCII-safe data?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThe \"/l\" and \"/u\" modifiers are automatically selected for regular\n       expressions compiled within the scope of various pragmas, and we\n       recommend that in general, you use those pragmas instead of specifying\n       these modifiers explicitly.  For one thing, the modifiers affect only\n       pattern matching, and do not extend to even any replacement done,\n       whereas using the pragmas gives consistent results for all appropriate\n       operations within their scopes.\tFor example,\n\n\ts/foo/\\Ubar/il\n\n       will match \"foo\" using the locale's rules for case-insensitive\n       matching, but the \"/l\" does not affect how the \"\\U\" operates.  Most\n       likely you want both of them to use locale rules.  To do this, instead\n       compile the regular expression within the scope of \"use locale\".  This\n       both implicitly adds the \"/l\", and applies locale rules to the \"\\U\".\n       The lesson is to \"use locale\", and not \"/l\" explicitly.\n\n       Similarly, it would be better to use \"use feature 'unicode_strings'\"\n       instead of,"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you ensure that both case-insensitive matching and Unicode string handling are applied in a regular expression?
  manpageQuestion3: What is the recommended approach for using locale-specific case-insensitive matching in Perl regular expressions?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    s/foo/\Lbar/iu

           to get Unicode rules, as the "\L" in the former (but not necessarily
           the latter) would also use Unicode rules.

           More detail on each of the modifiers follows.  Most likely you don't
           need to know this detail for "/l", "/u", and "/d", and can skip ahead
           to /a.

           /l

           means to use the current locale's rules (see perllocale) when pattern
           matching.  For example, "\w" will match the "word" characters of that
           locale, and "/i" case-insensitive matching will match according to the
           locale's case folding rules.  The locale used will be the one in effect
           at the time of execution of the pattern match.  This may not be the
           same as the compilation-time locale, and can differ from one match to
           another if there is an intervening call of the setlocale() function.

           Prior to v5.20, Perl did not support multi-byte locales.  Starting
           then, UTF-8 locales are supported.  No other multi byte locales are
           ever likely to be supported.  However, in all locales, one can have
           code points above 255 and these will always be treated as Unicode no
           matter what locale is in effect.
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a pattern with locale-specific rules and case-insensitive matching?
  manpageQuestion3: Can you provide an example of using perlre to apply Unicode rules for case folding in a regular expression?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    Under Unicode rules, there are a few case-insensitive matches that
           cross the 255/256 boundary.  Except for UTF-8 locales in Perls v5.20
           and later, these are disallowed under "/l".  For example, 0xFF (on
           ASCII platforms) does not caselessly match the character at 0x178,
           "LATIN CAPITAL LETTER Y WITH DIAERESIS", because 0xFF may not be "LATIN
           SMALL LETTER Y WITH DIAERESIS" in the current locale, and Perl has no
           way of knowing if that character even exists in the locale, much less
           what code point it is.

           In a UTF-8 locale in v5.20 and later, the only visible difference
           between locale and non-locale in regular expressions should be tainting
           (see perlsec).

           This modifier may be specified to be the default by "use locale", but
           see "Which character set modifier is in effect?".

           /u

           means to use Unicode rules when pattern matching.  On ASCII platforms,
           this means that the code points between 128 and 255 take on their
           Latin-1 (ISO-8859-1) meanings (which are the same as Unicode's).
           (Otherwise Perl considers their meanings to be undefined.)  Thus, under
           this modifier, the ASCII platform effectively becomes a Unicode
           platform; and hence, for example, "\w" will match any of the more than
           100_000 word characters in Unicode.
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How would you use the /u modifier in perlre to enable Unicode rules for pattern matching on an ASCII platform?
  manpageQuestion3: Can you provide an example of using the /u modifier in perlre to match Unicode characters in a regular expression?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nUnlike most locales, which are specific to a language and country pair,\n       Unicode classifies all the characters that are letters somewhere in the\n       world as \"\\w\".  For example, your locale might not think that \"LATIN\n       SMALL LETTER ETH\" is a letter (unless you happen to speak Icelandic),\n       but Unicode does.  Similarly, all the characters that are decimal\n       digits somewhere in the world will match \"\\d\"; this is hundreds, not\n       10, possible matches.  And some of those digits look like some of the\n       10 ASCII digits, but mean a different number, so a human could easily\n       think a number is a different quantity than it really is.  For example,\n       \"BENGALI DIGIT FOUR\" (U+09EA) looks very much like an \"ASCII DIGIT\n       EIGHT\" (U+0038), and \"LEPCHA DIGIT SIX\" (U+1C46) looks very much like\n       an \"ASCII DIGIT FIVE\" (U+0035).\tAnd, \"\\d+\", may match strings of\n       digits that are a mixture from different writing systems, creating a\n       security issue.\tA fraudulent website, for example, could display the\n       price of something using U+1C46, and it would appear to the user that\n       something cost 500 units, but it really costs 600.  A browser that\n       enforced script runs (\"Script Runs\") would prevent that fraudulent\n       display.  \"num()\" in Unicode::UCD can also be used to sort this out.\n       Or the \"/a\" modifier can be used to force \"\\d\" to match just the ASCII\n       0 through 9."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you modify the behavior of \\
  manpageQuestion3: What is an example of how Unicode's \\

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nAlso, under this modifier, case-insensitive matching works on the full\n       set of Unicode characters.  The \"KELVIN SIGN\", for example matches the\n       letters \"k\" and \"K\"; and \"LATIN SMALL LIGATURE FF\" matches the sequence\n       \"ff\", which, if you're not prepared, might make it look like a\n       hexadecimal constant, presenting another potential security issue.  See\n       <https://unicode.org/reports/tr36> for a detailed discussion of Unicode\n       security issues.\n\n       This modifier may be specified to be the default by \"use feature\n       'unicode_strings\", \"use locale ':not_characters'\", or \"use 5.012\" (or\n       higher), but see \"Which character set modifier is in effect?\".\n\n       /d\n\n       This modifier means to use the \"Default\" native rules of the platform\n       except when there is cause to use Unicode rules instead, as follows:\n\n       1.  the target string is encoded in UTF-8; or\n\n       2.  the pattern is encoded in UTF-8; or\n\n       3.  the pattern explicitly mentions a code point that is above 255 (say\n\t   by \"\\x{100}\"); or\n\n       4.  the pattern uses a Unicode name (\"\\N{...}\");  or\n\n       5.  the pattern uses a Unicode property (\"\\p{...}\" or \"\\P{...}\"); or\n\n       6.  the pattern uses a Unicode break (\"\\b{...}\" or \"\\B{...}\"); or\n\n       7.  the pattern uses \"(?[ ])\"\n\n       8.  the pattern uses \"(*script_run: ...)\"\n\n       Another mnemonic for this modifier is \"Depends\", as the rules actually\n       used depend on various things, and as a result you can get unexpected\n       results.  See \"The \"Unicode Bug\"\" in perlunicode.  The Unicode Bug has\n       become rather infamous, leading to yet other (without swearing) names\n       for this modifier, \"Dicey\" and \"Dodgy\".\n\n       Unless the pattern or string are encoded in UTF-8, only ASCII\n       characters can match positively.\n\n       Here are some examples of how that works on an ASCII platform:\n\n\t$str =\t\"\\xDF\";      # $str is not in UTF-8 format.\n\t$str =~ /^\\w/;\t     # No match, as $str isn't in UTF-8 format.\n\t$str .= \"\\x{0e0b}\";  # Now $str is in UTF-8 format.\n\t$str =~ /^\\w/;\t     # Match! $str is now in UTF-8 format.\n\tchop $str;\n\t$str =~ /^\\w/;\t     # Still a match! $str remains in UTF-8 format.\n\n       This modifier is automatically selected by default when none of the\n       others are, so yet another name for it is \"Default\".\n\n       Because of the unexpected behaviors associated with this modifier, you\n       probably should only explicitly use it to maintain weird backward\n       compatibilities.\n\n       /a (and /aa)\n\n       This modifier stands for ASCII-restrict (or ASCII-safe).  This modifier\n       may be doubled-up to increase its effect.\n\n       When it appears singly, it causes the sequences \"\\d\", \"\\s\", \"\\w\", and\n       the Posix character classes to match only in the ASCII range.  They\n       thus revert to their pre-5.6, pre-Unicode meanings.  Under \"/a\",  \"\\d\"\n       always means precisely the digits \"0\" to \"9\"; \"\\s\" means the five\n       characters \"[ \\f\\n\\r\\t]\", and starting in Perl v5.18, the vertical tab;\n       \"\\w\" means the 63 characters \"[A-Za-z0-9_]\"; and likewise, all the\n       Posix classes such as \"[[:print:]]\" match only the appropriate ASCII-\n       range characters.\n\n       This modifier is useful for people who only incidentally use Unicode,\n       and who do not wish to be burdened with its complexities and security\n       concerns.\n\n       With \"/a\", one can write \"\\d\" with confidence that it will only match\n       ASCII characters, and should the need arise to match beyond ASCII, you\n       can instead use \"\\p{Digit}\" (or \"\\p{Word}\" for \"\\w\").  There are\n       similar \"\\p{...}\" constructs that can match beyond ASCII both white\n       space (see \"Whitespace\" in perlrecharclass), and Posix classes (see\n       \"POSIX Character Classes\" in perlrecharclass).  Thus, this modifier\n       doesn't mean you can't use Unicode, it means that to get Unicode\n       matching you must explicitly use a construct (\"\\p{}\", \"\\P{}\") that\n       signals Unicode.\n\n       As you would expect, this modifier causes, for example, \"\\D\" to mean\n       the same thing as \"[^0-9]\"; in fact, all non-ASCII characters match\n       \"\\D\", \"\\S\", and \"\\W\".  \"\\b\" still means to match at the boundary\n       between \"\\w\" and \"\\W\", using the \"/a\" definitions of them (similarly\n       for \"\\B\").\n\n       Otherwise, \"/a\" behaves like the \"/u\" modifier, in that case-\n       insensitive matching uses Unicode rules; for example, \"k\" will match\n       the Unicode \"\\N{KELVIN SIGN}\" under \"/i\" matching, and code points in\n       the Latin1 range, above ASCII will have Unicode rules when it comes to\n       case-insensitive matching.\n\n       To forbid ASCII/non-ASCII matches (like \"k\" with \"\\N{KELVIN SIGN}\"),\n       specify the \"a\" twice, for example \"/aai\" or \"/aia\".  (The first\n       occurrence of \"a\" restricts the \"\\d\", etc., and the second occurrence\n       adds the \"/i\" restrictions.)  But, note that code points outside the\n       ASCII range will use Unicode rules for \"/i\" matching, so the modifier\n       doesn't really restrict things to just ASCII; it just forbids the\n       intermixing of ASCII and non-ASCII.\n\n       To summarize, this modifier provides protection for applications that\n       don't wish to be exposed to all of Unicode.  Specifying it twice gives\n       added protection.\n\n       This modifier may be specified to be the default by \"use re '/a'\" or\n       \"use re '/aa'\".\tIf you do so, you may actually have occasion to use\n       the \"/u\" modifier explicitly if there are a few regular expressions\n       where you do want full Unicode rules (but even here, it's best if\n       everything were under feature \"unicode_strings\", along with the \"use re\n       '/aa'\").  Also see \"Which character set modifier is in effect?\".\n\n       Which character set modifier is in effect?\n\n       Which of these modifiers is in effect at any given point in a regular\n       expression depends on a fairly complex set of interactions.  These have\n       been designed so that in general you don't have to worry about it, but\n       this section gives the gory details.  As explained below in \"Extended\n       Patterns\" it is possible to explicitly specify modifiers that apply\n       only to portions of a regular expression.  The innermost always has\n       priority over any outer ones, and one applying to the whole expression\n       has priority over any of the default settings that are described in the\n       remainder of this section.\n\n       The \"use re '/foo'\" pragma can be used to set default modifiers\n       (including these) for regular expressions compiled within its scope.\n       This pragma has precedence over the other pragmas listed below that\n       also change the defaults.\n\n       Otherwise, \"use locale\" sets the default modifier to \"/l\"; and \"use\n       feature 'unicode_strings\", or \"use 5.012\" (or higher) set the default\n       to \"/u\" when not in the same scope as either \"use locale\" or \"use\n       bytes\".\t(\"use locale ':not_characters'\" also sets the default to \"/u\",\n       overriding any plain \"use locale\".)  Unlike the mechanisms mentioned\n       above, these affect operations besides regular expressions pattern\n       matching, and so give more consistent results with other operators,\n       including using \"\\U\", \"\\l\", etc. in substitution replacements.\n\n       If none of the above apply, for backwards compatibility reasons, the\n       \"/d\" modifier is the one in effect by default.  As this can lead to\n       unexpected results, it is best to specify which other rule set should\n       be used.\n\n       Character set modifier behavior prior to Perl 5.14\n\n       Prior to 5.14, there were no explicit modifiers, but \"/l\" was implied\n       for regexes compiled within the scope of \"use locale\", and \"/d\" was\n       implied otherwise.  However, interpolating a regex into a larger regex\n       would ignore the original compilation in favor of whatever was in\n       effect at the time of the second compilation.  There were a number of\n       inconsistencies (bugs) with the \"/d\" modifier, where Unicode rules\n       would be used when inappropriate, and vice versa.  \"\\p{}\" did not imply\n       Unicode rules, and neither did all occurrences of \"\\N{}\", until 5.12.\n\n   Regular Expressions\n       Quantifiers\n\n       Quantifiers are used when a particular portion of a pattern needs to\n       match a certain number (or numbers) of times.  If there isn't a\n       quantifier the number of times to match is exactly one.\tThe following\n       standard quantifiers are recognized:\n\n\t   *\t       Match 0 or more times\n\t   +\t       Match 1 or more times\n\t   ?\t       Match 1 or 0 times\n\t   {n}\t       Match exactly n times\n\t   {n,}        Match at least n times\n\t   {,n}        Match at most n times\n\t   {n,m}       Match at least n but not more than m times\n\n       (If a non-escaped curly bracket occurs in a context other than one of\n       the quantifiers listed above, where it does not form part of a\n       backslashed sequence like \"\\x{...}\", it is either a fatal syntax error,\n       or treated as a regular character, generally with a deprecation warning\n       raised.\tTo escape it, you can precede it with a backslash (\"\\{\") or\n       enclose it within square brackets  (\"[{]\").  This change will allow for\n       future syntax extensions (like making the lower bound of a quantifier\n       optional), and better error checking of quantifiers).\n\n       The \"*\" quantifier is equivalent to \"{0,}\", the \"+\" quantifier to\n       \"{1,}\", and the \"?\" quantifier to \"{0,1}\".  n and m are limited to non-\n       negative integral values less than a preset limit defined when perl is\n       built.  This is usually 65534 on the most common platforms.  The actual\n       limit can be seen in the error message generated by code such as this:\n\n\t   $_ **= $_ , / {$_} / for 2 .. 42;\n\n       By default, a quantified subpattern is \"greedy\", that is, it will match\n       as many times as possible (given a particular starting location) while\n       still allowing the rest of the pattern to match.  If you want it to\n       match the minimum number of times possible, follow the quantifier with\n       a \"?\".  Note that the meanings don't change, just the \"greediness\":\n\n\t   *?\t     Match 0 or more times, not greedily\n\t   +?\t     Match 1 or more times, not greedily\n\t   ??\t     Match 0 or 1 time, not greedily\n\t   {n}?      Match exactly n times, not greedily (redundant)\n\t   {n,}?     Match at least n times, not greedily\n\t   {,n}?     Match at most n times, not greedily\n\t   {n,m}?    Match at least n but not more than m times, not greedily\n\n       Normally when a quantified subpattern does not allow the rest of the\n       overall pattern to match, Perl will backtrack. However, this behaviour\n       is sometimes undesirable. Thus Perl provides the \"possessive\"\n       quantifier form as well.\n\n\t*+     Match 0 or more times and give nothing back\n\t++     Match 1 or more times and give nothing back\n\t?+     Match 0 or 1 time and give nothing back\n\t{n}+   Match exactly n times and give nothing back (redundant)\n\t{n,}+  Match at least n times and give nothing back\n\t{,n}+  Match at most n times and give nothing back\n\t{n,m}+ Match at least n but not more than m times and give nothing back\n\n       For instance,\n\n\t  'aaaa' =~ /a++a/\n\n       will never match, as the \"a++\" will gobble up all the \"a\"'s in the\n       string and won't leave any for the remaining part of the pattern. This\n       feature can be extremely useful to give perl hints about where it\n       shouldn't backtrack. For instance, the typical \"match a double-quoted\n       string\" problem can be most efficiently performed when written as:\n\n\t  /\"(?:[^\"\\\\]++|\\\\.)*+\"/\n\n       as we know that if the final quote does not match, backtracking will\n       not help. See the independent subexpression \"(?>pattern)\" for more\n       details; possessive quantifiers are just syntactic sugar for that\n       construct. For instance the above example could also be written as\n       follows:\n\n\t  /\"(?>(?:(?>[^\"\\\\]+)|\\\\.)*)\"/\n\n       Note that the possessive quantifier modifier can not be combined with\n       the non-greedy modifier. This is because it would make no sense.\n       Consider the follow equivalency table:\n\n\t   Illegal\t   Legal\n\t   ------------    ------\n\t   X??+ \t   X{0}\n\t   X+?+ \t   X{1}\n\t   X{min,max}?+    X{min}\n\n       Escape sequences\n\n       Because patterns are processed as double-quoted strings, the following\n       also work:\n\n\t\\t\t    tab \t\t  (HT, TAB)\n\t\\n\t    newline\t\t  (LF, NL)\n\t\\r\t    return\t\t  (CR)\n\t\\f\t    form feed\t\t  (FF)\n\t\\a\t    alarm (bell)\t  (BEL)\n\t\\e\t    escape (think troff)  (ESC)\n\t\\cK\t    control char\t  (example: VT)\n\t\\x{}, \\x00  character whose ordinal is the given hexadecimal number\n\t\\N{name}    named Unicode character or character sequence\n\t\\N{U+263D}  Unicode character\t  (example: FIRST QUARTER MOON)\n\t\\o{}, \\000  character whose ordinal is the given octal number\n\t\\l\t    lowercase next char (think vi)\n\t\\u\t    uppercase next char (think vi)\n\t\\L\t    lowercase until \\E (think vi)\n\t\\U\t    uppercase until \\E (think vi)\n\t\\Q\t    quote (disable) pattern metacharacters until \\E\n\t\\E\t    end either case modification or quoted section, think vi\n\n       Details are in \"Quote and Quote-like Operators\" in perlop.\n\n       Character Classes and other Special Escapes\n\n       In addition, Perl defines the following:\n\n\tSequence   Note    Description\n\t [...]\t   [1]\tMatch a character according to the rules of the\n\t\t\t  bracketed character class defined by the \"...\".\n\t\t\t  Example: [a-z] matches \"a\" or \"b\" or \"c\" ... or \"z\"\n\t [[:...:]] [2]\tMatch a character according to the rules of the POSIX\n\t\t\t  character class \"...\" within the outer bracketed\n\t\t\t  character class.  Example: [[:upper:]] matches any\n\t\t\t  uppercase character.\n\t (?[...])  [8]\tExtended bracketed character class\n\t \\w\t   [3]\tMatch a \"word\" character (alphanumeric plus \"_\", plus\n\t\t\t  other connector punctuation chars plus Unicode\n\t\t\t  marks)\n\t \\W\t   [3]\tMatch a non-\"word\" character\n\t \\s\t   [3]\tMatch a whitespace character\n\t \\S\t   [3]\tMatch a non-whitespace character\n\t \\d\t   [3]\tMatch a decimal digit character\n\t \\D\t   [3]\tMatch a non-digit character\n\t \\pP\t   [3]\tMatch P, named property.  Use \\p{Prop} for longer names\n\t \\PP\t   [3]\tMatch non-P\n\t \\X\t   [4]\tMatch Unicode \"eXtended grapheme cluster\"\n\t \\1\t   [5]\tBackreference to a specific capture group or buffer.\n\t\t\t  '1' may actually be any positive integer.\n\t \\g1\t   [5]\tBackreference to a specific or previous group,\n\t \\g{-1}    [5]\tThe number may be negative indicating a relative\n\t\t\t  previous group and may optionally be wrapped in\n\t\t\t  curly brackets for safer parsing.\n\t \\g{name}  [5]\tNamed backreference\n\t \\k<name>  [5]\tNamed backreference\n\t \\k'name'  [5]\tNamed backreference\n\t \\k{name}  [5]\tNamed backreference\n\t \\K\t   [6]\tKeep the stuff left of the \\K, don't include it in $&\n\t \\N\t   [7]\tAny character but \\n.  Not affected by /s modifier\n\t \\v\t   [3]\tVertical whitespace\n\t \\V\t   [3]\tNot vertical whitespace\n\t \\h\t   [3]\tHorizontal whitespace\n\t \\H\t   [3]\tNot horizontal whitespace\n\t \\R\t   [4]\tLinebreak\n\n       [1] See \"Bracketed Character Classes\" in perlrecharclass for details.\n\n       [2] See \"POSIX Character Classes\" in perlrecharclass for details.\n\n       [3] See \"Unicode Character Properties\" in perlunicode for details\n\n       [4] See \"Misc\" in perlrebackslash for details.\n\n       [5] See \"Capture groups\" below for details.\n\n       [6] See \"Extended Patterns\" below for details.\n\n       [7] Note that \"\\N\" has two meanings.  When of the form \"\\N{NAME}\", it\n\t   matches the character or character sequence whose name is NAME; and\n\t   similarly when of the form \"\\N{U+hex}\", it matches the character\n\t   whose Unicode code point is hex.  Otherwise it matches any\n\t   character but \"\\n\".\n\n       [8] See \"Extended Bracketed Character Classes\" in perlrecharclass for\n\t   details.\n\n       Assertions\n\n       Besides \"^\" and \"$\", Perl defines the following zero-width assertions:\n\n\t\\b{}   Match at Unicode boundary of specified type\n\t\\B{}   Match where corresponding \\b{} doesn't match\n\t\\b     Match a \\w\\W or \\W\\w boundary\n\t\\B     Match except at a \\w\\W or \\W\\w boundary\n\t\\A     Match only at beginning of string\n\t\\Z     Match only at end of string, or before newline at the end\n\t\\z     Match only at end of string\n\t\\G     Match only at pos() (e.g. at the end-of-match position\n\t       of prior m//g)\n\n       A Unicode boundary (\"\\b{}\"), available starting in v5.22, is a spot\n       between two characters, or before the first character in the string, or\n       after the final character in the string where certain criteria defined\n       by Unicode are met.  See \"\\b{}, \\b, \\B{}, \\B\" in perlrebackslash for\n       details.\n\n       A word boundary (\"\\b\") is a spot between two characters that has a \"\\w\"\n       on one side of it and a \"\\W\" on the other side of it (in either order),\n       counting the imaginary characters off the beginning and end of the\n       string as matching a \"\\W\".  (Within character classes \"\\b\" represents\n       backspace rather than a word boundary, just as it normally does in any\n       double-quoted string.)  The \"\\A\" and \"\\Z\" are just like \"^\" and \"$\",\n       except that they won't match multiple times when the \"/m\" modifier is\n       used, while \"^\" and \"$\" will match at every internal line boundary.  To\n       match the actual end of the string and not ignore an optional trailing\n       newline, use \"\\z\".\n\n       The \"\\G\" assertion can be used to chain global matches (using \"m//g\"),\n       as described in \"Regexp Quote-Like Operators\" in perlop.  It is also\n       useful when writing \"lex\"-like scanners, when you have several patterns\n       that you want to match against consequent substrings of your string;\n       see the previous reference.  The actual location where \"\\G\" will match\n       can also be influenced by using \"pos()\" as an lvalue: see \"pos\" in\n       perlfunc. Note that the rule for zero-length matches (see \"Repeated\n       Patterns Matching a Zero-length Substring\") is modified somewhat, in\n       that contents to the left of \"\\G\" are not counted when determining the\n       length of the match. Thus the following will not match forever:\n\n\t    my $string = 'ABC';\n\t    pos($string) = 1;\n\t    while ($string =~ /(.\\G)/g) {\n\t\tprint $1;\n\t    }\n\n       It will print 'A' and then terminate, as it considers the match to be\n       zero-width, and thus will not match at the same position twice in a\n       row.\n\n       It is worth noting that \"\\G\" improperly used can result in an infinite\n       loop. Take care when using patterns that include \"\\G\" in an\n       alternation.\n\n       Note also that \"s///\" will refuse to overwrite part of a substitution\n       that has already been replaced; so for example this will stop after the\n       first iteration, rather than iterating its way backwards through the\n       string:\n\n\t   $_ = \"123456789\";\n\t   pos = 6;\n\t   s/.(?=.\\G)/X/g;\n\t   print;      # prints 1234X6789, not XXXXX6789\n\n       Capture groups\n\n       The grouping construct \"( ... )\" creates capture groups (also referred\n       to as capture buffers). To refer to the current contents of a group\n       later on, within the same pattern, use \"\\g1\" (or \"\\g{1}\") for the\n       first, \"\\g2\" (or \"\\g{2}\") for the second, and so on.  This is called a\n       backreference."
  manpageQuestion1: What is the primary purpose of the 4ccconv command?
  manpageQuestion2: How can I use 4ccconv to convert a decimal number to its hexadecimal 4cc representation?
  manpageQuestion3: What is the correct command to convert a hexadecimal 4cc code to an unsigned integer?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThere is no limit to the number of captured substrings that you may\n       use.  Groups are numbered with the leftmost open parenthesis being\n       number 1, etc.  If a group did not match, the associated backreference\n       won't match either. (This can happen if the group is optional, or in a\n       different branch of an alternation.)  You can omit the \"g\", and write\n       \"\\1\", etc, but there are some issues with this form, described below.\n\n       You can also refer to capture groups relatively, by using a negative\n       number, so that \"\\g-1\" and \"\\g{-1}\" both refer to the immediately\n       preceding capture group, and \"\\g-2\" and \"\\g{-2}\" both refer to the\n       group before it.  For example:\n\n\t       /\n\t\t(Y)\t       # group 1\n\t\t(\t       # group 2\n\t\t   (X)\t       # group 3\n\t\t   \\g{-1}      # backref to group 3\n\t\t   \\g{-3}      # backref to group 1\n\t\t)\n\t       /x\n\n       would match the same as \"/(Y) ( (X) \\g3 \\g1 )/x\".  This allows you to\n       interpolate regexes into larger regexes and not have to worry about the\n       capture groups being renumbered."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you refer to a capture group in Perl using relative numbering?
  manpageQuestion3: What is the effect of omitting the 'g' in a backreference like \

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nYou can dispense with numbers altogether and create named capture\n       groups.\tThe notation is \"(?<name>...)\" to declare and \"\\g{name}\" to\n       reference.  (To be compatible with .Net regular expressions, \"\\g{name}\"\n       may also be written as \"\\k{name}\", \"\\k<name>\" or \"\\k'name'\".)  name\n       must not begin with a number, nor contain hyphens.  When different\n       groups within the same pattern have the same name, any reference to\n       that name assumes the leftmost defined group.  Named groups count in\n       absolute and relative numbering, and so can also be referred to by\n       those numbers.  (It's possible to do things with named capture groups\n       that would otherwise require \"(??{})\".)\n\n       Capture group contents are dynamically scoped and available to you\n       outside the pattern until the end of the enclosing block or until the\n       next successful match, whichever comes first.  (See \"Compound\n       Statements\" in perlsyn.)  You can refer to them by absolute number\n       (using \"$1\" instead of \"\\g1\", etc); or by name via the \"%+\" hash, using\n       \"$+{name}\"."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to create a regular expression with named capture groups for extracting specific information from text?
  manpageQuestion3: Can you provide an example of using perlre to refer to the contents of a named capture group outside of the matching pattern?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nBraces are required in referring to named capture groups, but are\n       optional for absolute or relative numbered ones.  Braces are safer when\n       creating a regex by concatenating smaller strings.  For example if you\n       have \"qr/$a$b/\", and $a contained \"\\g1\", and $b contained \"37\", you\n       would get \"/\\g137/\" which is probably not what you intended.\n\n       If you use braces, you may also optionally add any number of blank\n       (space or tab) characters within but adjacent to the braces, like\n       \"\\g{ -1 }\", or \"\\k{ name }\".\n\n       The \"\\g\" and \"\\k\" notations were introduced in Perl 5.10.0.  Prior to\n       that there were no named nor relative numbered capture groups.\n       Absolute numbered groups were referred to using \"\\1\", \"\\2\", etc., and\n       this notation is still accepted (and likely always will be).  But it\n       leads to some ambiguities if there are more than 9 capture groups, as\n       \"\\10\" could mean either the tenth capture group, or the character whose\n       ordinal in octal is 010 (a backspace in ASCII).\tPerl resolves this\n       ambiguity by interpreting \"\\10\" as a backreference only if at least 10\n       left parentheses have opened before it.\tLikewise \"\\11\" is a\n       backreference only if at least 11 left parentheses have opened before\n       it.  And so on.\t\"\\1\" through \"\\9\" are always interpreted as\n       backreferences.\tThere are several examples below that illustrate these\n       perils.\tYou can avoid the ambiguity by always using \"\\g{}\" or \"\\g\" if\n       you mean capturing groups; and for octal constants always using \"\\o{}\",\n       or for \"\\077\" and below, using 3 digits padded with leading zeros,\n       since a leading zero implies an octal constant."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you refer to named capture groups in a regular expression using perlre?
  manpageQuestion3: What is the recommended way to avoid ambiguity when referencing capture groups in perlre?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThe \"\\digit\" notation also works in certain circumstances outside the\n       pattern.  See \"Warning on \\1 Instead of $1\" below for details.\n\n       Examples:\n\n\t   s/^([^ ]*) *([^ ]*)/$2 $1/;\t   # swap first two words\n\n\t   /(.)\\g1/\t\t\t   # find first doubled char\n\t\tand print \"'$1' is the first doubled character\\n\";\n\n\t   /(?<char>.)\\k<char>/ \t   # ... a different way\n\t\tand print \"'$+{char}' is the first doubled character\\n\";\n\n\t   /(?'char'.)\\g1/\t\t   # ... mix and match\n\t\tand print \"'$1' is the first doubled character\\n\";\n\n\t   if (/Time: (..):(..):(..)/) {   # parse out values\n\t       $hours = $1;\n\t       $minutes = $2;\n\t       $seconds = $3;\n\t   }\n\n\t   /(.)(.)(.)(.)(.)(.)(.)(.)(.)\\g10/   # \\g10 is a backreference\n\t   /(.)(.)(.)(.)(.)(.)(.)(.)(.)\\10/    # \\10 is octal\n\t   /((.)(.)(.)(.)(.)(.)(.)(.)(.))\\10/  # \\10 is a backreference\n\t   /((.)(.)(.)(.)(.)(.)(.)(.)(.))\\010/ # \\010 is octal\n\n\t   $a = '(.)\\1';\t# Creates problems when concatenated.\n\t   $b = '(.)\\g{1}';\t# Avoids the problems.\n\t   \"aa\" =~ /${a}/;\t# True\n\t   \"aa\" =~ /${b}/;\t# True\n\t   \"aa0\" =~ /${a}0/;\t# False!\n\t   \"aa0\" =~ /${b}0/;\t# True\n\t   \"aa\\x08\" =~ /${a}0/;  # True!\n\t   \"aa\\x08\" =~ /${b}0/;  # False"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to extract and swap the first two words of a string like 'Hello World'?
  manpageQuestion3: 'Can you provide an example of using perlre to parse a time string like ''Time: 12:34:56'' into separate hour, minute, and second variables?'

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nSeveral special variables also refer back to portions of the previous\n       match.  $+ returns whatever the last bracket match matched.  $& returns\n       the entire matched string.  (At one point $0 did also, but now it\n       returns the name of the program.)  \"$`\" returns everything before the\n       matched string.\t\"$'\" returns everything after the matched string. And\n       $^N contains whatever was matched by the most-recently closed group\n       (submatch). $^N can be used in extended patterns (see below), for\n       example to assign a submatch to a variable.\n\n       These special variables, like the \"%+\" hash and the numbered match\n       variables ($1, $2, $3, etc.) are dynamically scoped until the end of\n       the enclosing block or until the next successful match, whichever comes\n       first.  (See \"Compound Statements\" in perlsyn.)\n\n       NOTE: Failed matches in Perl do not reset the match variables, which\n       makes it easier to write code that tests for a series of more specific\n       cases and remembers the best match."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you retrieve the entire matched string using Perl's special variables?
  manpageQuestion3: Can you explain how to capture and use submatches in Perl using the $^N variable?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    WARNING: If your code is to run on Perl 5.16 or earlier, beware that
           once Perl sees that you need one of $&, "$`", or "$'" anywhere in the
           program, it has to provide them for every pattern match.  This may
           substantially slow your program.

           Perl uses the same mechanism to produce $1, $2, etc, so you also pay a
           price for each pattern that contains capturing parentheses.  (To avoid
           this cost while retaining the grouping behaviour, use the extended
           regular expression "(?: ... )" instead.)  But if you never use $&, "$`"
           or "$'", then patterns without capturing parentheses will not be
           penalized.  So avoid $&, "$'", and "$`" if you can, but if you can't
           (and some algorithms really appreciate them), once you've used them
           once, use them at will, because you've already paid the price.

           Perl 5.16 introduced a slightly more efficient mechanism that notes
           separately whether each of "$`", $&, and "$'" have been seen, and thus
           may only need to copy part of the string.  Perl 5.20 introduced a much
           more efficient copy-on-write mechanism which eliminates any slowdown.
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you optimize Perl code to avoid performance penalties associated with using $&, $`, or $'?
  manpageQuestion3: What changes were introduced in Perl 5.16 and Perl 5.20 to improve the efficiency of pattern matching operations?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    As another workaround for this problem, Perl 5.10.0 introduced
           "${^PREMATCH}", "${^MATCH}" and "${^POSTMATCH}", which are equivalent
           to "$`", $& and "$'", except that they are only guaranteed to be
           defined after a successful match that was executed with the "/p"
           (preserve) modifier.  The use of these variables incurs no global
           performance penalty, unlike their punctuation character equivalents,
           however at the trade-off that you have to tell perl when you want to
           use them.  As of Perl 5.20, these three variables are equivalent to
           "$`", $& and "$'", and "/p" is ignored.

       Quoting metacharacters
           Backslashed metacharacters in Perl are alphanumeric, such as "\b",
           "\w", "\n".  Unlike some other regular expression languages, there are
           no backslashed symbols that aren't alphanumeric.  So anything that
           looks like "\\", "\(", "\)", "\[", "\]", "\{", or "\}" is always
           interpreted as a literal character, not a metacharacter.  This was once
           used in a common idiom to disable or quote the special meanings of
           regular expression metacharacters in a string that you want to use for
           a pattern. Simply quote all non-"word" characters:
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you quote special regular expression metacharacters in a string using Perl?
  manpageQuestion3: What is the function of the ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} variables in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n$pattern =~ s/(\\W)/\\\\$1/g;\n\n       (If \"use locale\" is set, then this depends on the current locale.)\n       Today it is more common to use the \"quotemeta()\" function or the \"\\Q\"\n       metaquoting escape sequence to disable all metacharacters' special\n       meanings like this:\n\n\t   /$unquoted\\Q$quoted\\E$unquoted/\n\n       Beware that if you put literal backslashes (those not inside\n       interpolated variables) between \"\\Q\" and \"\\E\", double-quotish backslash\n       interpolation may lead to confusing results.  If you need to use\n       literal backslashes within \"\\Q...\\E\", consult \"Gory details of parsing\n       quoted constructs\" in perlop.\n\n       \"quotemeta()\" and \"\\Q\" are fully described in \"quotemeta\" in perlfunc.\n\n   Extended Patterns\n       Perl also defines a consistent extension syntax for features not found\n       in standard tools like awk and lex.  The syntax for most of these is a\n       pair of parentheses with a question mark as the first thing within the\n       parentheses.  The character after the question mark indicates the\n       extension."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a regular expression that escapes all non-word characters in a string?
  manpageQuestion3: Can you provide an example of using perlre to apply an extended pattern syntax for a specific feature not found in standard tools like awk or lex?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nA question mark was chosen for this and for the minimal-matching\n       construct because 1) question marks are rare in older regular\n       expressions, and 2) whenever you see one, you should stop and\n       \"question\" exactly what is going on.  That's psychology....\n\n       \"(?#text)\"\n\t   A comment.  The text is ignored.  Note that Perl closes the comment\n\t   as soon as it sees a \")\", so there is no way to put a literal \")\"\n\t   in the comment.  The pattern's closing delimiter must be escaped by\n\t   a backslash if it appears in the comment.\n\n\t   See \"/x\" for another way to have comments in patterns.\n\n\t   Note that a comment can go just about anywhere, except in the\n\t   middle of an escape sequence.   Examples:\n\n\t    qr/foo(?#comment)bar/'  # Matches 'foobar'\n\n\t    # The pattern below matches 'abcd', 'abccd', or 'abcccd'\n\t    qr/abc(?#comment between literal and its quantifier){1,3}d/\n\n\t    # The pattern below generates a syntax error, because the '\\p' must\n\t    # be followed immediately by a '{'.\n\t    qr/\\p(?#comment between \\p and its property name){Any}/"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to add a comment within a regular expression pattern?
  manpageQuestion3: Can you provide an example of using perlre to include a comment in a regular expression that matches strings with varying repetitions of 'cc' followed by 'd'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n# The pattern below generates a syntax error, because the initial\n\t    # '\\(' is a literal opening parenthesis, and so there is nothing\n\t    # for the  closing ')' to match\n\t    qr/\\(?#the backslash means this isn't a comment)p{Any}/\n\n\t    # Comments can be used to fold long patterns into multiple lines\n\t    qr/First part of a long regex(?#\n\t      )remaining part/\n\n       \"(?adlupimnsx-imnsx)\"\n       \"(?^alupimnsx)\"\n\t   Zero or more embedded pattern-match modifiers, to be turned on (or\n\t   turned off if preceded by \"-\") for the remainder of the pattern or\n\t   the remainder of the enclosing pattern group (if any).\n\n\t   This is particularly useful for dynamically-generated patterns,\n\t   such as those read in from a configuration file, taken from an\n\t   argument, or specified in a table somewhere.  Consider the case\n\t   where some patterns want to be case-sensitive and some do not:  The\n\t   case-insensitive ones merely need to include \"(?i)\" at the front of\n\t   the pattern.  For example:\n\n\t       $pattern = \"foobar\";\n\t       if ( /$pattern/i ) { }"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to create a regular expression that matches case-insensitively any string containing the word 'foobar'?
  manpageQuestion3: Can you provide an example of using perlre to apply multiple pattern-match modifiers, such as case-insensitive and multiline, to a regular expression?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n# more flexible:\n\n\t       $pattern = \"(?i)foobar\";\n\t       if ( /$pattern/ ) { }\n\n\t   These modifiers are restored at the end of the enclosing group. For\n\t   example,\n\n\t       ( (?i) blah ) \\s+ \\g1\n\n\t   will match \"blah\" in any case, some spaces, and an exact (including\n\t   the case!)  repetition of the previous word, assuming the \"/x\"\n\t   modifier, and no \"/i\" modifier outside this group.\n\n\t   These modifiers do not carry over into named subpatterns called in\n\t   the enclosing group. In other words, a pattern such as\n\t   \"((?i)(?&NAME))\" does not change the case-sensitivity of the NAME\n\t   pattern.\n\n\t   A modifier is overridden by later occurrences of this construct in\n\t   the same scope containing the same modifier, so that\n\n\t       /((?im)foo(?-m)bar)/\n\n\t   matches all of \"foobar\" case insensitively, but uses \"/m\" rules for\n\t   only the \"foo\" portion.  The \"a\" flag overrides \"aa\" as well;\n\t   likewise \"aa\" overrides \"a\".  The same goes for \"x\" and \"xx\".\n\t   Hence, in\n\n\t       /(?-x)foo/xx"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use modifiers within a group in perlre to control case sensitivity and multiline matching for specific subpatterns?
  manpageQuestion3: Can you provide an example of using perlre to demonstrate how modifiers can override each other within the same scope?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nboth \"/x\" and \"/xx\" are turned off during matching \"foo\".  And in\n\n\t       /(?x)foo/x\n\n\t   \"/x\" but NOT \"/xx\" is turned on for matching \"foo\".\t(One might\n\t   mistakenly think that since the inner \"(?x)\" is already in the\n\t   scope of \"/x\", that the result would effectively be the sum of\n\t   them, yielding \"/xx\".  It doesn't work that way.)  Similarly, doing\n\t   something like \"(?xx-x)foo\" turns off all \"x\" behavior for matching\n\t   \"foo\", it is not that you subtract 1 \"x\" from 2 to get 1 \"x\"\n\t   remaining.\n\n\t   Any of these modifiers can be set to apply globally to all regular\n\t   expressions compiled within the scope of a \"use re\".  See \"'/flags'\n\t   mode\" in re.\n\n\t   Starting in Perl 5.14, a \"^\" (caret or circumflex accent)\n\t   immediately after the \"?\" is a shorthand equivalent to \"d-imnsx\".\n\t   Flags (except \"d\") may follow the caret to override it.  But a\n\t   minus sign is not legal with it.\n\n\t   Note that the \"a\", \"d\", \"l\", \"p\", and \"u\" modifiers are special in\n\t   that they can only be enabled, not disabled, and the \"a\", \"d\", \"l\",\n\t   and \"u\" modifiers are mutually exclusive: specifying one de-\n\t   specifies the others, and a maximum of one (or two \"a\"'s) may\n\t   appear in the construct.  Thus, for example, \"(?-p)\" will warn when\n\t   compiled under \"use warnings\"; \"(?-d:...)\" and \"(?dl:...)\" are\n\t   fatal errors."
  manpageQuestion1: What is the primary purpose of the perlre utility?
  manpageQuestion2: How can you disable the 'x' modifier for a specific regex pattern in Perl?
  manpageQuestion3: What is the effect of placing a caret (^) immediately after '?' in Perl regular expressions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nNote also that the \"p\" modifier is special in that its presence\n\t   anywhere in a pattern has a global effect.\n\n\t   Having zero modifiers makes this a no-op (so why did you specify\n\t   it, unless it's generated code), and starting in v5.30, warns under\n\t   \"use re 'strict'\".\n\n       \"(?:pattern)\"\n       \"(?adluimnsx-imnsx:pattern)\"\n       \"(?^aluimnsx:pattern)\"\n\t   This is for clustering, not capturing; it groups subexpressions\n\t   like \"()\", but doesn't make backreferences as \"()\" does.  So\n\n\t       @fields = split(/\\b(?:a|b|c)\\b/)\n\n\t   matches the same field delimiters as\n\n\t       @fields = split(/\\b(a|b|c)\\b/)\n\n\t   but doesn't spit out the delimiters themselves as extra fields\n\t   (even though that's the behaviour of \"split\" in perlfunc when its\n\t   pattern contains capturing groups).\tIt's also cheaper not to\n\t   capture characters if you don't need to.\n\n\t   Any letters between \"?\" and \":\" act as flags modifiers as with\n\t   \"(?adluimnsx-imnsx)\".  For example,\n\n\t       /(?s-i:more.*than).*million/i"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use the 'p' modifier in perlre to influence the behavior of a regular expression pattern?
  manpageQuestion3: Can you provide an example of using the non-capturing group syntax in perlre to split a string without capturing the delimiter?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nis equivalent to the more verbose\n\n\t       /(?:(?s-i)more.*than).*million/i\n\n\t   Note that any \"()\" constructs enclosed within this one will still\n\t   capture unless the \"/n\" modifier is in effect.\n\n\t   Like the \"(?adlupimnsx-imnsx)\" construct, \"aa\" and \"a\" override\n\t   each other, as do \"xx\" and \"x\".  They are not additive.  So, doing\n\t   something like \"(?xx-x:foo)\" turns off all \"x\" behavior for\n\t   matching \"foo\".\n\n\t   Starting in Perl 5.14, a \"^\" (caret or circumflex accent)\n\t   immediately after the \"?\" is a shorthand equivalent to \"d-imnsx\".\n\t   Any positive flags (except \"d\") may follow the caret, so\n\n\t       (?^x:foo)\n\n\t   is equivalent to\n\n\t       (?x-imns:foo)\n\n\t   The caret tells Perl that this cluster doesn't inherit the flags of\n\t   any surrounding pattern, but uses the system defaults (\"d-imnsx\"),\n\t   modified by any flags specified.\n\n\t   The caret allows for simpler stringification of compiled regular\n\t   expressions.  These look like\n\n\t       (?^:pattern)\n\n\t   with any non-default flags appearing between the caret and the\n\t   colon.  A test that looks at such stringification thus doesn't need\n\t   to have the system default flags hard-coded in it, just the caret.\n\t   If new flags are added to Perl, the meaning of the caret's\n\t   expansion will change to include the default for those flags, so\n\t   the test will still work, unchanged."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use the caret (^) modifier in Perl regular expressions to simplify stringification of compiled patterns?
  manpageQuestion3: What is the effect of using "(?^x:foo)" in a Perl regular expression compared to "(?x-imns:foo)"?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nSpecifying a negative flag after the caret is an error, as the flag\n\t   is redundant.\n\n\t   Mnemonic for \"(?^...)\":  A fresh beginning since the usual use of a\n\t   caret is to match at the beginning.\n\n       \"(?|pattern)\"\n\t   This is the \"branch reset\" pattern, which has the special property\n\t   that the capture groups are numbered from the same starting point\n\t   in each alternation branch. It is available starting from perl\n\t   5.10.0.\n\n\t   Capture groups are numbered from left to right, but inside this\n\t   construct the numbering is restarted for each branch.\n\n\t   The numbering within each branch will be as normal, and any groups\n\t   following this construct will be numbered as though the construct\n\t   contained only one branch, that being the one with the most capture\n\t   groups in it.\n\n\t   This construct is useful when you want to capture one of a number\n\t   of alternative matches.\n\n\t   Consider the following pattern.  The numbers underneath show in\n\t   which group the captured content will be stored."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a pattern where different branches of an alternation share the same capture group numbering?
  manpageQuestion3: Can you provide an example of using perlre to create a regular expression that captures the first group from either of two alternative patterns, ensuring they share the same group numbering?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n# before  ---------------branch-reset----------- after\n\t       / ( a )\t(?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x\n\t       # 1\t      2 \t2  3\t    2\t  3\t4\n\n\t   Be careful when using the branch reset pattern in combination with\n\t   named captures. Named captures are implemented as being aliases to\n\t   numbered groups holding the captures, and that interferes with the\n\t   implementation of the branch reset pattern. If you are using named\n\t   captures in a branch reset pattern, it's best to use the same\n\t   names, in the same order, in each of the alternations:\n\n\t      /(?|  (?<a> x ) (?<b> y )\n\t\t |  (?<a> z ) (?<b> w )) /x\n\n\t   Not doing so may lead to surprises:\n\n\t     \"12\" =~ /(?| (?<a> \\d+ ) | (?<b> \\D+))/x;\n\t     say $+{a};    # Prints '12'\n\t     say $+{b};    # *Also* prints '12'.\n\n\t   The problem here is that both the group named \"a\" and the group\n\t   named \"b\" are aliases for the group belonging to $1.\n\n       Lookaround Assertions\n\t   Lookaround assertions are zero-width patterns which match a\n\t   specific pattern without including it in $&. Positive assertions\n\t   match when their subpattern matches, negative assertions match when\n\t   their subpattern fails. Lookbehind matches text up to the current\n\t   match position, lookahead matches text following the current match\n\t   position."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use perlre to create a regular expression that matches either 'apple' or 'banana' using branch reset patterns?
  manpageQuestion3: Can you explain how to use lookaround assertions in perlre to ensure that a word is preceded by an underscore and followed by a colon?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n\"(?=pattern)\"\n\t   \"(*pla:pattern)\"\n\t   \"(*positive_lookahead:pattern)\"\n\t       A zero-width positive lookahead assertion.  For example,\n\t       \"/\\w+(?=\\t)/\" matches a word followed by a tab, without\n\t       including the tab in $&.\n\n\t   \"(?!pattern)\"\n\t   \"(*nla:pattern)\"\n\t   \"(*negative_lookahead:pattern)\"\n\t       A zero-width negative lookahead assertion.  For example\n\t       \"/foo(?!bar)/\" matches any occurrence of \"foo\" that isn't\n\t       followed by \"bar\".  Note however that lookahead and lookbehind\n\t       are NOT the same thing.\tYou cannot use this for lookbehind.\n\n\t       If you are looking for a \"bar\" that isn't preceded by a \"foo\",\n\t       \"/(?!foo)bar/\" will not do what you want.  That's because the\n\t       \"(?!foo)\" is just saying that the next thing cannot be\n\t       \"foo\"--and it's not, it's a \"bar\", so \"foobar\" will match.  Use\n\t       lookbehind instead (see below).\n\n\t   \"(?<=pattern)\"\n\t   \"\\K\"\n\t   \"(*plb:pattern)\"\n\t   \"(*positive_lookbehind:pattern)\"\n\t       A zero-width positive lookbehind assertion.  For example,\n\t       \"/(?<=\\t)\\w+/\" matches a word that follows a tab, without\n\t       including the tab in $&."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to create a regular expression that matches any occurrence of the word 'apple' that is not immediately followed by the letters 'banana'?
  manpageQuestion3: Can you provide an example of using perlre to match a word that is preceded by a tab character, without including the tab in the matched text?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nPrior to Perl 5.30, it worked only for fixed-width lookbehind,\n\t       but starting in that release, it can handle variable lengths\n\t       from 1 to 255 characters as an experimental feature.  The\n\t       feature is enabled automatically if you use a variable length\n\t       lookbehind assertion, but will raise a warning at pattern\n\t       compilation time, unless turned off, in the \"experimental::vlb\"\n\t       category.  This is to warn you that the exact behavior is\n\t       subject to change should feedback from actual use in the field\n\t       indicate to do so; or even complete removal if the problems\n\t       found are not practically surmountable.\tYou can achieve close\n\t       to pre-5.30 behavior by fatalizing warnings in this category.\n\n\t       There is a special form of this construct, called \"\\K\"\n\t       (available since Perl 5.10.0), which causes the regex engine to\n\t       \"keep\" everything it had matched prior to the \"\\K\" and not\n\t       include it in $&. This effectively provides non-experimental\n\t       variable-length lookbehind of any length."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use variable-length lookbehind assertions in Perl 5.30 or later?
  manpageQuestion3: What is the function of the \K escape in Perl regular expressions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nAnd, there is a technique that can be used to handle variable\n\t       length lookbehinds on earlier releases, and longer than 255\n\t       characters.  It is described in\n\t       <http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html>.\n\n\t       Note that under \"/i\", a few single characters match two or\n\t       three other characters.\tThis makes them variable length, and\n\t       the 255 length applies to the maximum number of characters in\n\t       the match.  For example \"qr/\\N{LATIN SMALL LETTER SHARP S}/i\"\n\t       matches the sequence \"ss\".  Your lookbehind assertion could\n\t       contain 127 Sharp S characters under \"/i\", but adding a 128th\n\t       would generate a compilation error, as that could match 256 \"s\"\n\t       characters in a row.\n\n\t       The use of \"\\K\" inside of another lookaround assertion is\n\t       allowed, but the behaviour is currently not well defined.\n\n\t       For various reasons \"\\K\" may be significantly more efficient\n\t       than the equivalent \"(?<=...)\" construct, and it is especially\n\t       useful in situations where you want to efficiently remove\n\t       something following something else in a string. For instance"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a variable-length lookbehind assertion that allows up to 255 characters?
  manpageQuestion3: Can you provide an example of using perlre to efficiently remove a substring following a specific pattern in a string?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\ns/(foo)bar/$1/g;\n\n\t       can be rewritten as the much more efficient\n\n\t\t s/foo\\Kbar//g;\n\n\t       Use of the non-greedy modifier \"?\" may not give you the\n\t       expected results if it is within a capturing group within the\n\t       construct.\n\n\t   \"(?<!pattern)\"\n\t   \"(*nlb:pattern)\"\n\t   \"(*negative_lookbehind:pattern)\"\n\t       A zero-width negative lookbehind assertion.  For example\n\t       \"/(?<!bar)foo/\" matches any occurrence of \"foo\" that does not\n\t       follow \"bar\".\n\n\t       Prior to Perl 5.30, it worked only for fixed-width lookbehind,\n\t       but starting in that release, it can handle variable lengths\n\t       from 1 to 255 characters as an experimental feature.  The\n\t       feature is enabled automatically if you use a variable length\n\t       lookbehind assertion, but will raise a warning at pattern\n\t       compilation time, unless turned off, in the \"experimental::vlb\"\n\t       category.  This is to warn you that the exact behavior is\n\t       subject to change should feedback from actual use in the field\n\t       indicate to do so; or even complete removal if the problems\n\t       found are not practically surmountable.\tYou can achieve close\n\t       to pre-5.30 behavior by fatalizing warnings in this category."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you efficiently replace all occurrences of 'foo' followed by 'bar' with just 'foo' using perlre?
  manpageQuestion3: What is the difference between a standard negative lookbehind assertion and the experimental variable-length negative lookbehind in perlre?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThere is a technique that can be used to handle variable length\n\t       lookbehinds on earlier releases, and longer than 255\n\t       characters.  It is described in\n\t       <http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html>.\n\n\t       Note that under \"/i\", a few single characters match two or\n\t       three other characters.\tThis makes them variable length, and\n\t       the 255 length applies to the maximum number of characters in\n\t       the match.  For example \"qr/\\N{LATIN SMALL LETTER SHARP S}/i\"\n\t       matches the sequence \"ss\".  Your lookbehind assertion could\n\t       contain 127 Sharp S characters under \"/i\", but adding a 128th\n\t       would generate a compilation error, as that could match 256 \"s\"\n\t       characters in a row.\n\n\t       Use of the non-greedy modifier \"?\" may not give you the\n\t       expected results if it is within a capturing group within the\n\t       construct.\n\n       \"(?<NAME>pattern)\"\n       \"(?'NAME'pattern)\"\n\t   A named capture group. Identical in every respect to normal\n\t   capturing parentheses \"()\" but for the additional fact that the\n\t   group can be referred to by name in various regular expression\n\t   constructs (like \"\\g{NAME}\") and can be accessed by name after a\n\t   successful match via \"%+\" or \"%-\". See perlvar for more details on\n\t   the \"%+\" and \"%-\" hashes."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use perlre to create a named capture group that matches the word 'example' and stores it in a variable called 'match_result'?
  manpageQuestion3: What is the maximum length for a variable-length lookbehind assertion in perlre and what are the implications of exceeding this limit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIf multiple distinct capture groups have the same name, then\n\t   $+{NAME} will refer to the leftmost defined group in the match.\n\n\t   The forms \"(?'NAME'pattern)\" and \"(?<NAME>pattern)\" are equivalent.\n\n\t   NOTE: While the notation of this construct is the same as the\n\t   similar function in .NET regexes, the behavior is not. In Perl the\n\t   groups are numbered sequentially regardless of being named or not.\n\t   Thus in the pattern\n\n\t     /(x)(?<foo>y)(z)/\n\n\t   $+{foo} will be the same as $2, and $3 will contain 'z' instead of\n\t   the opposite which is what a .NET regex hacker might expect.\n\n\t   Currently NAME is restricted to simple identifiers only.  In other\n\t   words, it must match \"/^[_A-Za-z][_A-Za-z0-9]*\\z/\" or its Unicode\n\t   extension (see utf8), though it isn't extended by the locale (see\n\t   perllocale).\n\n\t   NOTE: In order to make things easier for programmers with\n\t   experience with the Python or PCRE regex engines, the pattern\n\t   \"(?P<NAME>pattern)\" may be used instead of \"(?<NAME>pattern)\";\n\t   however this form does not support the use of single quotes as a\n\t   delimiter for the name."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use perlre to capture and refer to named capture groups in a regular expression?
  manpageQuestion3: What is the difference between using named capture groups in Perl regex and .NET regex?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n\"\\k<NAME>\"\n       \"\\k'NAME'\"\n       \"\\k{NAME}\"\n\t   Named backreference. Similar to numeric backreferences, except that\n\t   the group is designated by name and not number. If multiple groups\n\t   have the same name then it refers to the leftmost defined group in\n\t   the current match.\n\n\t   It is an error to refer to a name not defined by a \"(?<NAME>)\"\n\t   earlier in the pattern.\n\n\t   All three forms are equivalent, although with \"\\k{ NAME }\", you may\n\t   optionally have blanks within but adjacent to the braces, as shown.\n\n\t   NOTE: In order to make things easier for programmers with\n\t   experience with the Python or PCRE regex engines, the pattern\n\t   \"(?P=NAME)\" may be used instead of \"\\k<NAME>\".\n\n       \"(?{ code })\"\n\t   WARNING: Using this feature safely requires that you understand its\n\t   limitations.  Code executed that has side effects may not perform\n\t   identically from version to version due to the effect of future\n\t   optimisations in the regex engine.  For more information on this,\n\t   see \"Embedded Code Execution Frequency\"."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use named backreferences in Perl regular expressions to refer to a previously defined group by its name?
  manpageQuestion3: What is the difference between using "\k<NAME>" and "(?P=NAME)" in Perl regular expressions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThis zero-width assertion executes any embedded Perl code.  It\n\t   always succeeds, and its return value is set as $^R.\n\n\t   In literal patterns, the code is parsed at the same time as the\n\t   surrounding code. While within the pattern, control is passed\n\t   temporarily back to the perl parser, until the logically-balancing\n\t   closing brace is encountered. This is similar to the way that an\n\t   array index expression in a literal string is handled, for example\n\n\t       \"abc$array[ 1 + f('[') + g()]def\"\n\n\t   In particular, braces do not need to be balanced:\n\n\t       s/abc(?{ f('{'); })/def/\n\n\t   Even in a pattern that is interpolated and compiled at run-time,\n\t   literal code blocks will be compiled once, at perl compile time;\n\t   the following prints \"ABCD\":\n\n\t       print \"D\";\n\t       my $qr = qr/(?{ BEGIN { print \"A\" } })/;\n\t       my $foo = \"foo\";\n\t       /$foo$qr(?{ BEGIN { print \"B\" } })/;\n\t       BEGIN { print \"C\" }\n\n\t   In patterns where the text of the code is derived from run-time\n\t   information rather than appearing literally in a source code\n\t   /pattern/, the code is compiled at the same time that the pattern\n\t   is compiled, and for reasons of security, \"use re 'eval'\" must be\n\t   in scope. This is to stop user-supplied patterns containing code\n\t   snippets from being executable."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to execute a block of Perl code within a regular expression pattern?
  manpageQuestion3: Can you provide an example of using perlre to compile a regular expression that executes a Perl code block during pattern matching?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIn situations where you need to enable this with \"use re 'eval'\",\n\t   you should also have taint checking enabled.  Better yet, use the\n\t   carefully constrained evaluation within a Safe compartment.\tSee\n\t   perlsec for details about both these mechanisms.\n\n\t   From the viewpoint of parsing, lexical variable scope and closures,\n\n\t       /AAA(?{ BBB })CCC/\n\n\t   behaves approximately like\n\n\t       /AAA/ && do { BBB } && /CCC/\n\n\t   Similarly,\n\n\t       qr/AAA(?{ BBB })CCC/\n\n\t   behaves approximately like\n\n\t       sub { /AAA/ && do { BBB } && /CCC/ }\n\n\t   In particular:\n\n\t       { my $i = 1; $r = qr/(?{ print $i })/ }\n\t       my $i = 2;\n\t       /$r/; # prints \"1\"\n\n\t   Inside a \"(?{...})\" block, $_ refers to the string the regular\n\t   expression is matching against. You can also use \"pos()\" to know\n\t   what is the current position of matching within this string.\n\n\t   The code block introduces a new scope from the perspective of\n\t   lexical variable declarations, but not from the perspective of\n\t   \"local\" and similar localizing behaviours. So later code blocks\n\t   within the same pattern will still see the values which were\n\t   localized in earlier blocks.  These accumulated localizations are\n\t   undone either at the end of a successful match, or if the assertion\n\t   is backtracked (compare \"Backtracking\"). For example,"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use perlre to execute code during the matching of a regular expression?
  manpageQuestion3: Can you provide an example of using perlre to perform actions within a regular expression pattern?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n$_ = 'a' x 8;\n\t     m<\n\t\t(?{ $cnt = 0 }) \t      # Initialize $cnt.\n\t\t(\n\t\t  a\n\t\t  (?{\n\t\t      local $cnt = $cnt + 1;  # Update $cnt,\n\t\t\t\t\t      # backtracking-safe.\n\t\t  })\n\t\t)*\n\t\taaaa\n\t\t(?{ $res = $cnt })\t      # On success copy to\n\t\t\t\t\t      # non-localized location.\n\t      >x;\n\n\t   will initially increment $cnt up to 8; then during backtracking,\n\t   its value will be unwound back to 4, which is the value assigned to\n\t   $res.  At the end of the regex execution, $cnt will be wound back\n\t   to its initial value of 0.\n\n\t   This assertion may be used as the condition in a\n\n\t       (?(condition)yes-pattern|no-pattern)\n\n\t   switch.  If not used in this way, the result of evaluation of code\n\t   is put into the special variable $^R.  This happens immediately, so\n\t   $^R can be used from other \"(?{ code })\" assertions inside the same\n\t   regular expression.\n\n\t   The assignment to $^R above is properly localized, so the old value\n\t   of $^R is restored if the assertion is backtracked; compare\n\t   \"Backtracking\"."
  manpageQuestion1: What is the primary purpose of the `perlre` resource?
  manpageQuestion2: How can you use `perlre` to capture the number of times a certain pattern is matched within a regular expression?
  manpageQuestion3: Can you explain how the `perlre` resource handles variable scoping and backtracking during regular expression matching?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nNote that the special variable $^N  is particularly useful with\n\t   code blocks to capture the results of submatches in variables\n\t   without having to keep track of the number of nested parentheses.\n\t   For example:\n\n\t     $_ = \"The brown fox jumps over the lazy dog\";\n\t     /the (\\S+)(?{ $color = $^N }) (\\S+)(?{ $animal = $^N })/i;\n\t     print \"color = $color, animal = $animal\\n\";\n\n       \"(??{ code })\"\n\t   WARNING: Using this feature safely requires that you understand its\n\t   limitations.  Code executed that has side effects may not perform\n\t   identically from version to version due to the effect of future\n\t   optimisations in the regex engine.  For more information on this,\n\t   see \"Embedded Code Execution Frequency\".\n\n\t   This is a \"postponed\" regular subexpression.  It behaves in exactly\n\t   the same way as a \"(?{ code })\" code block as described above,\n\t   except that its return value, rather than being assigned to $^R, is\n\t   treated as a pattern, compiled if it's a string (or used as-is if\n\t   its a qr// object), then matched as if it were inserted instead of\n\t   this construct."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use embedded code execution in a regular expression to capture submatch results into variables?
  manpageQuestion3: What is the difference between using a code block with parentheses and a postponed subexpression in perlre?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nDuring the matching of this sub-pattern, it has its own set of\n\t   captures which are valid during the sub-match, but are discarded\n\t   once control returns to the main pattern. For example, the\n\t   following matches, with the inner pattern capturing \"B\" and\n\t   matching \"BB\", while the outer pattern captures \"A\";\n\n\t       my $inner = '(.)\\1';\n\t       \"ABBA\" =~ /^(.)(??{ $inner })\\1/;\n\t       print $1; # prints \"A\";\n\n\t   Note that this means that  there is no way for the inner pattern to\n\t   refer to a capture group defined outside.  (The code block itself\n\t   can use $1, etc., to refer to the enclosing pattern's capture\n\t   groups.)  Thus, although\n\n\t       ('a' x 100)=~/(??{'(.)' x 100})/\n\n\t   will match, it will not set $1 on exit.\n\n\t   The following pattern matches a parenthesized group:\n\n\t    $re = qr{\n\t\t       \\(\n\t\t       (?:\n\t\t\t  (?> [^()]+ )\t# Non-parens without backtracking\n\t\t\t|\n\t\t\t  (??{ $re })\t# Group with matching parens\n\t\t       )*\n\t\t       \\)\n\t\t    }x;\n\n\t   See also \"(?PARNO)\" for a different, more efficient way to\n\t   accomplish the same task."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use perlre to match a nested pattern that captures content within an inner group and references it in the outer group?
  manpageQuestion3: What is the role of the '??' operator in perlre when dealing with recursive pattern matching?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nExecuting a postponed regular expression too many times without\n\t   consuming any input string will also result in a fatal error.  The\n\t   depth at which that happens is compiled into perl, so it can be\n\t   changed with a custom build.\n\n       \"(?PARNO)\" \"(?-PARNO)\" \"(?+PARNO)\" \"(?R)\" \"(?0)\"\n\t   Recursive subpattern. Treat the contents of a given capture buffer\n\t   in the current pattern as an independent subpattern and attempt to\n\t   match it at the current position in the string. Information about\n\t   capture state from the caller for things like backreferences is\n\t   available to the subpattern, but capture buffers set by the\n\t   subpattern are not visible to the caller.\n\n\t   Similar to \"(??{ code })\" except that it does not involve executing\n\t   any code or potentially compiling a returned pattern string;\n\t   instead it treats the part of the current pattern contained within\n\t   a specified capture group as an independent pattern that must match\n\t   at the current position. Also different is the treatment of capture\n\t   buffers, unlike \"(??{ code })\" recursive patterns have access to\n\t   their caller's match state, so one can use backreferences safely."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use recursive subpatterns in perlre to match a substring that repeats the content of a previously captured group?
  manpageQuestion3: Can you explain how to use the '(?R)' syntax in perlre for recursive pattern matching?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nPARNO is a sequence of digits (not starting with 0) whose value\n\t   reflects the paren-number of the capture group to recurse to.\n\t   \"(?R)\" recurses to the beginning of the whole pattern. \"(?0)\" is an\n\t   alternate syntax for \"(?R)\". If PARNO is preceded by a plus or\n\t   minus sign then it is assumed to be relative, with negative numbers\n\t   indicating preceding capture groups and positive ones following.\n\t   Thus \"(?-1)\" refers to the most recently declared group, and\n\t   \"(?+1)\" indicates the next group to be declared.  Note that the\n\t   counting for relative recursion differs from that of relative\n\t   backreferences, in that with recursion unclosed groups are\n\t   included.\n\n\t   The following pattern matches a function \"foo()\" which may contain\n\t   balanced parentheses as the argument.\n\n\t     $re = qr{ (\t\t   # paren group 1 (full function)\n\t\t\t foo\n\t\t\t (\t\t   # paren group 2 (parens)\n\t\t\t   \\(\n\t\t\t     (\t\t   # paren group 3 (contents of parens)\n\t\t\t     (?:\n\t\t\t      (?> [^()]+ ) # Non-parens without backtracking\n\t\t\t     |\n\t\t\t      (?2)\t   # Recurse to start of paren group 2\n\t\t\t     )*\n\t\t\t     )\n\t\t\t   \\)\n\t\t\t )\n\t\t       )\n\t\t     }x;"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How would you use the PARNO feature in perlre to recursively match a function call with nested parentheses?
  manpageQuestion3: Can you provide an example of using perlre's PARNO with relative recursion to refer to a previously declared capture group?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIf the pattern was used as follows\n\n\t       'foo(bar(baz)+baz(bop))'=~/$re/\n\t\t   and print \"\\$1 = $1\\n\",\n\t\t\t     \"\\$2 = $2\\n\",\n\t\t\t     \"\\$3 = $3\\n\";\n\n\t   the output produced should be the following:\n\n\t       $1 = foo(bar(baz)+baz(bop))\n\t       $2 = (bar(baz)+baz(bop))\n\t       $3 = bar(baz)+baz(bop)\n\n\t   If there is no corresponding capture group defined, then it is a\n\t   fatal error.  Recursing deeply without consuming any input string\n\t   will also result in a fatal error.  The depth at which that happens\n\t   is compiled into perl, so it can be changed with a custom build.\n\n\t   The following shows how using negative indexing can make it easier\n\t   to embed recursive patterns inside of a \"qr//\" construct for later\n\t   use:\n\n\t       my $parens = qr/(\\((?:[^()]++|(?-1))*+\\))/;\n\t       if (/foo $parens \\s+ \\+ \\s+ bar $parens/x) {\n\t\t  # do something here...\n\t       }\n\n\t   Note that this pattern does not behave the same way as the\n\t   equivalent PCRE or Python construct of the same form. In Perl you\n\t   can backtrack into a recursed group, in PCRE and Python the\n\t   recursed into group is treated as atomic. Also, modifiers are\n\t   resolved at compile time, so constructs like \"(?i:(?1))\" or\n\t   \"(?:(?i)(?1))\" do not affect how the sub-pattern will be processed."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use Perl's recursive regular expressions to capture nested parentheses in a string?
  manpageQuestion3: Can you provide an example of using negative indexing with qr// to create a reusable regex pattern for matching nested parentheses?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n\"(?&NAME)\"\n\t   Recurse to a named subpattern. Identical to \"(?PARNO)\" except that\n\t   the parenthesis to recurse to is determined by name. If multiple\n\t   parentheses have the same name, then it recurses to the leftmost.\n\n\t   It is an error to refer to a name that is not declared somewhere in\n\t   the pattern.\n\n\t   NOTE: In order to make things easier for programmers with\n\t   experience with the Python or PCRE regex engines the pattern\n\t   \"(?P>NAME)\" may be used instead of \"(?&NAME)\".\n\n       \"(?(condition)yes-pattern|no-pattern)\"\n       \"(?(condition)yes-pattern)\"\n\t   Conditional expression. Matches yes-pattern if condition yields a\n\t   true value, matches no-pattern otherwise. A missing pattern always\n\t   matches.\n\n\t   \"(condition)\" should be one of:\n\n\t   an integer in parentheses\n\t       (which is valid if the corresponding pair of parentheses\n\t       matched);\n\n\t   a lookahead/lookbehind/evaluate zero-width assertion;\n\t   a name in angle brackets or single quotes\n\t       (which is valid if a group with the given name matched);"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to implement a regular expression that matches a string if it contains the word 'example' only after a backslash?
  manpageQuestion3: Can you provide an example of using perlre to create a conditional pattern that matches a number only if it is followed by the word 'end'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nthe special symbol \"(R)\"\n\t       (true when evaluated inside of recursion or eval).\n\t       Additionally the \"R\" may be followed by a number, (which will\n\t       be true when evaluated when recursing inside of the appropriate\n\t       group), or by \"&NAME\", in which case it will be true only when\n\t       evaluated during recursion in the named group.\n\n\t   Here's a summary of the possible predicates:\n\n\t   \"(1)\" \"(2)\" ...\n\t       Checks if the numbered capturing group has matched something.\n\t       Full syntax: \"(?(1)then|else)\"\n\n\t   \"(<NAME>)\" \"('NAME')\"\n\t       Checks if a group with the given name has matched something.\n\t       Full syntax: \"(?(<name>)then|else)\"\n\n\t   \"(?=...)\" \"(?!...)\" \"(?<=...)\" \"(?<!...)\"\n\t       Checks whether the pattern matches (or does not match, for the\n\t       \"!\" variants).  Full syntax: \"(?(?=lookahead)then|else)\"\n\n\t   \"(?{ CODE })\"\n\t       Treats the return value of the code block as the condition.\n\t       Full syntax: \"(?(?{ code })then|else)\"\n\n\t   \"(R)\"\n\t       Checks if the expression has been evaluated inside of\n\t       recursion.  Full syntax: \"(?(R)then|else)\""
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to check if a specific capturing group, such as group 3, has matched something in a regular expression?
  manpageQuestion3: Can you provide an example of using perlre to determine if a regular expression is being evaluated within a recursive context?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n\"(R1)\" \"(R2)\" ...\n\t       Checks if the expression has been evaluated while executing\n\t       directly inside of the n-th capture group. This check is the\n\t       regex equivalent of\n\n\t\t if ((caller(0))[3] eq 'subname') { ... }\n\n\t       In other words, it does not check the full recursion stack.\n\n\t       Full syntax: \"(?(R1)then|else)\"\n\n\t   \"(R&NAME)\"\n\t       Similar to \"(R1)\", this predicate checks to see if we're\n\t       executing directly inside of the leftmost group with a given\n\t       name (this is the same logic used by \"(?&NAME)\" to\n\t       disambiguate). It does not check the full stack, but only the\n\t       name of the innermost active recursion.\tFull syntax:\n\t       \"(?(R&name)then|else)\"\n\n\t   \"(DEFINE)\"\n\t       In this case, the yes-pattern is never directly executed, and\n\t       no no-pattern is allowed. Similar in spirit to \"(?{0})\" but\n\t       more efficient.\tSee below for details.\tFull syntax:\n\t       \"(?(DEFINE)definitions...)\"\n\n\t   For example:\n\n\t       m{ ( \\( )?\n\t\t  [^()]+\n\t\t  (?(1) \\) )\n\t\t}x"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use the (R1) predicate in perlre to check if a regular expression is currently executing within the first capture group?
  manpageQuestion3: Can you provide an example of using the (DEFINE) feature in perlre to define a regular expression pattern that only evaluates the yes-pattern if certain conditions are met?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nmatches a chunk of non-parentheses, possibly included in\n\t   parentheses themselves.\n\n\t   A special form is the \"(DEFINE)\" predicate, which never executes\n\t   its yes-pattern directly, and does not allow a no-pattern. This\n\t   allows one to define subpatterns which will be executed only by the\n\t   recursion mechanism.  This way, you can define a set of regular\n\t   expression rules that can be bundled into any pattern you choose.\n\n\t   It is recommended that for this usage you put the DEFINE block at\n\t   the end of the pattern, and that you name any subpatterns defined\n\t   within it.\n\n\t   Also, it's worth noting that patterns defined this way probably\n\t   will not be as efficient, as the optimizer is not very clever about\n\t   handling them.\n\n\t   An example of how this might be used is as follows:\n\n\t     /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))\n\t      (?(DEFINE)\n\t\t(?<NAME_PAT>....)\n\t\t(?<ADDRESS_PAT>....)\n\t      )/x\n\n\t   Note that capture groups matched inside of recursion are not\n\t   accessible after the recursion returns, so the extra layer of\n\t   capturing groups is necessary. Thus $+{NAME_PAT} would not be\n\t   defined even though $+{NAME} would be."
  manpageQuestion1: What is the primary purpose of the `perlre` resource?
  manpageQuestion2: How can you define a recursive subpattern in `perlre` using the DEFINE predicate?
  manpageQuestion3: Can you provide an example of using `perlre` to match a pattern that includes recursively defined subpatterns?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nFinally, keep in mind that subpatterns created inside a DEFINE\n\t   block count towards the absolute and relative number of captures,\n\t   so this:\n\n\t       my @captures = \"a\" =~ /(.)\t\t   # First capture\n\t\t\t\t      (?(DEFINE)\n\t\t\t\t\t  (?<EXAMPLE> 1 )  # Second capture\n\t\t\t\t      )/x;\n\t       say scalar @captures;\n\n\t   Will output 2, not 1. This is particularly important if you intend\n\t   to compile the definitions with the \"qr//\" operator, and later\n\t   interpolate them in another pattern.\n\n       \"(?>pattern)\"\n       \"(*atomic:pattern)\"\n\t   An \"independent\" subexpression, one which matches the substring\n\t   that a standalone pattern would match if anchored at the given\n\t   position, and it matches nothing other than this substring.\tThis\n\t   construct is useful for optimizations of what would otherwise be\n\t   \"eternal\" matches, because it will not backtrack (see\n\t   \"Backtracking\").  It may also be useful in places where the \"grab\n\t   all you can, and do not give anything back\" semantic is desirable.\n\n\t   For example: \"^(?>a*)ab\" will never match, since \"(?>a*)\" (anchored\n\t   at the beginning of string, as above) will match all characters \"a\"\n\t   at the beginning of string, leaving no \"a\" for \"ab\" to match.  In\n\t   contrast, \"a*ab\" will match the same as \"a+b\", since the match of\n\t   the subgroup \"a*\" is influenced by the following group \"ab\" (see\n\t   \"Backtracking\").  In particular, \"a*\" inside \"a*ab\" will match\n\t   fewer characters than a standalone \"a*\", since this makes the tail\n\t   match.\n\n\t   \"(?>pattern)\" does not disable backtracking altogether once it has\n\t   matched. It is still possible to backtrack past the construct, but\n\t   not into it. So \"((?>a*)|(?>b*))ar\" will still match \"bar\".\n\n\t   An effect similar to \"(?>pattern)\" may be achieved by writing\n\t   \"(?=(pattern))\\g{-1}\".  This matches the same substring as a\n\t   standalone \"a+\", and the following \"\\g{-1}\" eats the matched\n\t   string; it therefore makes a zero-length assertion into an analogue\n\t   of \"(?>...)\".  (The difference between these two constructs is that\n\t   the second one uses a capturing group, thus shifting ordinals of\n\t   backreferences in the rest of a regular expression.)\n\n\t   Consider this pattern:\n\n\t       m{ \\(\n\t\t     (\n\t\t       [^()]+\t\t# x+\n\t\t     |\n\t\t       \\( [^()]* \\)\n\t\t     )+\n\t\t  \\)\n\t\t}x\n\n\t   That will efficiently match a nonempty group with matching\n\t   parentheses two levels deep or less.  However, if there is no such\n\t   group, it will take virtually forever on a long string.  That's\n\t   because there are so many different ways to split a long string\n\t   into several substrings.  This is what \"(.+)+\" is doing, and\n\t   \"(.+)+\" is similar to a subpattern of the above pattern.  Consider\n\t   how the pattern above detects no-match on \"((()aaaaaaaaaaaaaaaaaa\"\n\t   in several seconds, but that each extra letter doubles this time.\n\t   This exponential performance will make it appear that your program\n\t   has hung.  However, a tiny change to this pattern\n\n\t       m{ \\(\n\t\t     (\n\t\t       (?> [^()]+ )\t   # change x+ above to (?> x+ )\n\t\t     |\n\t\t       \\( [^()]* \\)\n\t\t     )+\n\t\t  \\)\n\t\t}x\n\n\t   which uses \"(?>...)\" matches exactly when the one above does\n\t   (verifying this yourself would be a productive exercise), but\n\t   finishes in a fourth the time when used on a similar string with\n\t   1000000 \"a\"s.  Be aware, however, that, when this construct is\n\t   followed by a quantifier, it currently triggers a warning message\n\t   under the \"use warnings\" pragma or -w switch saying it \"matches\n\t   null string many times in regex\".\n\n\t   On simple groups, such as the pattern \"(?> [^()]+ )\", a comparable\n\t   effect may be achieved by negative lookahead, as in \"[^()]+ (?!\n\t   [^()] )\".  This was only 4 times slower on a string with 1000000\n\t   \"a\"s.\n\n\t   The \"grab all you can, and do not give anything back\" semantic is\n\t   desirable in many situations where on the first sight a simple\n\t   \"()*\" looks like the correct solution.  Suppose we parse text with\n\t   comments being delimited by \"#\" followed by some optional\n\t   (horizontal) whitespace.  Contrary to its appearance, \"#[ \\t]*\" is\n\t   not the correct subexpression to match the comment delimiter,\n\t   because it may \"give up\" some whitespace if the remainder of the\n\t   pattern can be made to match that way.  The correct answer is\n\t   either one of these:\n\n\t       (?>#[ \\t]*)\n\t       #[ \\t]*(?![ \\t])\n\n\t   For example, to grab non-empty comments into $1, one should use\n\t   either one of these:\n\n\t       / (?> \\# [ \\t]* ) (\t  .+ ) /x;\n\t       /     \\# [ \\t]*\t ( [^ \\t] .* ) /x;\n\n\t   Which one you pick depends on which of these expressions better\n\t   reflects the above specification of comments.\n\n\t   In some literature this construct is called \"atomic matching\" or\n\t   \"possessive matching\".\n\n\t   Possessive quantifiers are equivalent to putting the item they are\n\t   applied to inside of one of these constructs. The following\n\t   equivalences apply:\n\n\t       Quantifier Form\t   Bracketing Form\n\t       ---------------\t   ---------------\n\t       PAT*+\t\t   (?>PAT*)\n\t       PAT++\t\t   (?>PAT+)\n\t       PAT?+\t\t   (?>PAT?)\n\t       PAT{min,max}+\t   (?>PAT{min,max})\n\n\t   Nested \"(?>...)\" constructs are not no-ops, even if at first glance\n\t   they might seem to be.  This is because the nested \"(?>...)\" can\n\t   restrict internal backtracking that otherwise might occur.  For\n\t   example,\n\n\t    \"abc\" =~ /(?>a[bc]*c)/\n\n\t   matches, but\n\n\t    \"abc\" =~ /(?>a(?>[bc]*)c)/\n\n\t   does not.\n\n       \"(?[ ])\"\n\t   See \"Extended Bracketed Character Classes\" in perlrecharclass.\n\n\t   Note that this feature is currently experimental; using it yields a\n\t   warning in the \"experimental::regex_sets\" category.\n\n   Backtracking\n       NOTE: This section presents an abstract approximation of regular\n       expression behavior.  For a more rigorous (and complicated) view of the\n       rules involved in selecting a match among possible alternatives, see\n       \"Combining RE Pieces\".\n\n       A fundamental feature of regular expression matching involves the\n       notion called backtracking, which is currently used (when needed) by\n       all regular non-possessive expression quantifiers, namely \"*\", \"*?\",\n       \"+\", \"+?\", \"{n,m}\", and \"{n,m}?\".  Backtracking is often optimized\n       internally, but the general principle outlined here is valid.\n\n       For a regular expression to match, the entire regular expression must\n       match, not just part of it.  So if the beginning of a pattern\n       containing a quantifier succeeds in a way that causes later parts in\n       the pattern to fail, the matching engine backs up and recalculates the\n       beginning part--that's why it's called backtracking.\n\n       Here is an example of backtracking:  Let's say you want to find the\n       word following \"foo\" in the string \"Food is on the foo table.\":\n\n\t   $_ = \"Food is on the foo table.\";\n\t   if ( /\\b(foo)\\s+(\\w+)/i ) {\n\t       print \"$2 follows $1.\\n\";\n\t   }\n\n       When the match runs, the first part of the regular expression\n       (\"\\b(foo)\") finds a possible match right at the beginning of the\n       string, and loads up $1 with \"Foo\".  However, as soon as the matching\n       engine sees that there's no whitespace following the \"Foo\" that it had\n       saved in $1, it realizes its mistake and starts over again one\n       character after where it had the tentative match.  This time it goes\n       all the way until the next occurrence of \"foo\". The complete regular\n       expression matches this time, and you get the expected output of \"table\n       follows foo.\"\n\n       Sometimes minimal matching can help a lot.  Imagine you'd like to match\n       everything between \"foo\" and \"bar\".  Initially, you write something\n       like this:\n\n\t   $_ =  \"The food is under the bar in the barn.\";\n\t   if ( /foo(.*)bar/ ) {\n\t       print \"got <$1>\\n\";\n\t   }\n\n       Which perhaps unexpectedly yields:\n\n\t got <d is under the bar in the >\n\n       That's because \".*\" was greedy, so you get everything between the first\n       \"foo\" and the last \"bar\".  Here it's more effective to use minimal\n       matching to make sure you get the text between a \"foo\" and the first\n       \"bar\" thereafter.\n\n\t   if ( /foo(.*?)bar/ ) { print \"got <$1>\\n\" }\n\t got <d is under the >\n\n       Here's another example. Let's say you'd like to match a number at the\n       end of a string, and you also want to keep the preceding part of the\n       match.  So you write this:\n\n\t   $_ = \"I have 2 numbers: 53147\";\n\t   if ( /(.*)(\\d*)/ ) { \t\t\t       # Wrong!\n\t       print \"Beginning is <$1>, number is <$2>.\\n\";\n\t   }\n\n       That won't work at all, because \".*\" was greedy and gobbled up the\n       whole string. As \"\\d*\" can match on an empty string the complete\n       regular expression matched successfully.\n\n\t   Beginning is <I have 2 numbers: 53147>, number is <>.\n\n       Here are some variants, most of which don't work:\n\n\t   $_ = \"I have 2 numbers: 53147\";\n\t   @pats = qw{\n\t       (.*)(\\d*)\n\t       (.*)(\\d+)\n\t       (.*?)(\\d*)\n\t       (.*?)(\\d+)\n\t       (.*)(\\d+)$\n\t       (.*?)(\\d+)$\n\t       (.*)\\b(\\d+)$\n\t       (.*\\D)(\\d+)$\n\t   };\n\n\t   for $pat (@pats) {\n\t       printf \"%-12s \", $pat;\n\t       if ( /$pat/ ) {\n\t\t   print \"<$1> <$2>\\n\";\n\t       } else {\n\t\t   print \"FAIL\\n\";\n\t       }\n\t   }\n\n       That will print out:\n\n\t   (.*)(\\d*)\t<I have 2 numbers: 53147> <>\n\t   (.*)(\\d+)\t<I have 2 numbers: 5314> <7>\n\t   (.*?)(\\d*)\t<> <>\n\t   (.*?)(\\d+)\t<I have > <2>\n\t   (.*)(\\d+)$\t<I have 2 numbers: 5314> <7>\n\t   (.*?)(\\d+)$\t<I have 2 numbers: > <53147>\n\t   (.*)\\b(\\d+)$ <I have 2 numbers: > <53147>\n\t   (.*\\D)(\\d+)$ <I have 2 numbers: > <53147>\n\n       As you see, this can be a bit tricky.  It's important to realize that a\n       regular expression is merely a set of assertions that gives a\n       definition of success.  There may be 0, 1, or several different ways\n       that the definition might succeed against a particular string.  And if\n       there are multiple ways it might succeed, you need to understand\n       backtracking to know which variety of success you will achieve.\n\n       When using lookahead assertions and negations, this can all get even\n       trickier.  Imagine you'd like to find a sequence of non-digits not\n       followed by \"123\".  You might try to write that as\n\n\t   $_ = \"ABC123\";\n\t   if ( /^\\D*(?!123)/ ) {\t\t # Wrong!\n\t       print \"Yup, no 123 in $_\\n\";\n\t   }\n\n       But that isn't going to match; at least, not the way you're hoping.  It\n       claims that there is no 123 in the string.  Here's a clearer picture of\n       why that pattern matches, contrary to popular expectations:\n\n\t   $x = 'ABC123';\n\t   $y = 'ABC445';\n\n\t   print \"1: got $1\\n\" if $x =~ /^(ABC)(?!123)/;\n\t   print \"2: got $1\\n\" if $y =~ /^(ABC)(?!123)/;\n\n\t   print \"3: got $1\\n\" if $x =~ /^(\\D*)(?!123)/;\n\t   print \"4: got $1\\n\" if $y =~ /^(\\D*)(?!123)/;\n\n       This prints\n\n\t   2: got ABC\n\t   3: got AB\n\t   4: got ABC\n\n       You might have expected test 3 to fail because it seems to a more\n       general purpose version of test 1.  The important difference between\n       them is that test 3 contains a quantifier (\"\\D*\") and so can use\n       backtracking, whereas test 1 will not.  What's happening is that you've\n       asked \"Is it true that at the start of $x, following 0 or more non-\n       digits, you have something that's not 123?\"  If the pattern matcher had\n       let \"\\D*\" expand to \"ABC\", this would have caused the whole pattern to\n       fail.\n\n       The search engine will initially match \"\\D*\" with \"ABC\".  Then it will\n       try to match \"(?!123)\" with \"123\", which fails.\tBut because a\n       quantifier (\"\\D*\") has been used in the regular expression, the search\n       engine can backtrack and retry the match differently in the hope of\n       matching the complete regular expression.\n\n       The pattern really, really wants to succeed, so it uses the standard\n       pattern back-off-and-retry and lets \"\\D*\" expand to just \"AB\" this\n       time.  Now there's indeed something following \"AB\" that is not \"123\".\n       It's \"C123\", which suffices.\n\n       We can deal with this by using both an assertion and a negation.  We'll\n       say that the first part in $1 must be followed both by a digit and by\n       something that's not \"123\".  Remember that the lookaheads are zero-\n       width expressions--they only look, but don't consume any of the string\n       in their match.\tSo rewriting this way produces what you'd expect; that\n       is, case 5 will fail, but case 6 succeeds:\n\n\t   print \"5: got $1\\n\" if $x =~ /^(\\D*)(?=\\d)(?!123)/;\n\t   print \"6: got $1\\n\" if $y =~ /^(\\D*)(?=\\d)(?!123)/;\n\n\t   6: got ABC\n\n       In other words, the two zero-width assertions next to each other work\n       as though they're ANDed together, just as you'd use any built-in\n       assertions:  \"/^$/\" matches only if you're at the beginning of the line\n       AND the end of the line simultaneously.\tThe deeper underlying truth is\n       that juxtaposition in regular expressions always means AND, except when\n       you write an explicit OR using the vertical bar.  \"/ab/\" means match\n       \"a\" AND (then) match \"b\", although the attempted matches are made at\n       different positions because \"a\" is not a zero-width assertion, but a\n       one-width assertion.\n\n       WARNING: Particularly complicated regular expressions can take\n       exponential time to solve because of the immense number of possible\n       ways they can use backtracking to try for a match.  For example,\n       without internal optimizations done by the regular expression engine,\n       this will take a painfully long time to run:\n\n\t   'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/\n\n       And if you used \"*\"'s in the internal groups instead of limiting them\n       to 0 through 5 matches, then it would take forever--or until you ran\n       out of stack space.  Moreover, these internal optimizations are not\n       always applicable.  For example, if you put \"{0,5}\" instead of \"*\" on\n       the external group, no current optimization is applicable, and the\n       match takes a long time to finish.\n\n       A powerful tool for optimizing such beasts is what is known as an\n       \"independent group\", which does not backtrack (see \"(?>pattern)\").\n       Note also that zero-length lookahead/lookbehind assertions will not\n       backtrack to make the tail match, since they are in \"logical\" context:\n       only whether they match is considered relevant.\tFor an example where\n       side-effects of lookahead might have influenced the following match,\n       see \"(?>pattern)\".\n\n   Script Runs\n       A script run is basically a sequence of characters, all from the same\n       Unicode script (see \"Scripts\" in perlunicode), such as Latin or Greek.\n       In most places a single word would never be written in multiple\n       scripts, unless it is a spoofing attack.  An infamous example, is\n\n\tpaypal.com\n\n       Those letters could all be Latin (as in the example just above), or\n       they could be all Cyrillic (except for the dot), or they could be a\n       mixture of the two.  In the case of an internet address the \".com\"\n       would be in Latin, And any Cyrillic ones would cause it to be a\n       mixture, not a script run.  Someone clicking on such a link would not\n       be directed to the real Paypal website, but an attacker would craft a\n       look-alike one to attempt to gather sensitive information from the\n       person.\n\n       Starting in Perl 5.28, it is now easy to detect strings that aren't\n       script runs.  Simply enclose just about any pattern like either of\n       these:\n\n\t(*script_run:pattern)\n\t(*sr:pattern)\n\n       What happens is that after pattern succeeds in matching, it is\n       subjected to the additional criterion that every character in it must\n       be from the same script (see exceptions below).\tIf this isn't true,\n       backtracking occurs until something all in the same script is found\n       that matches, or all possibilities are exhausted.  This can cause a lot\n       of backtracking, but generally, only malicious input will result in\n       this, though the slow down could cause a denial of service attack.  If\n       your needs permit, it is best to make the pattern atomic to cut down on\n       the amount of backtracking.  This is so likely to be what you want,\n       that instead of writing this:\n\n\t(*script_run:(?>pattern))\n\n       you can write either of these:\n\n\t(*atomic_script_run:pattern)\n\t(*asr:pattern)\n\n       (See \"(?>pattern)\".)\n\n       In Taiwan, Japan, and Korea, it is common for text to have a mixture of\n       characters from their native scripts and base Chinese.  Perl follows\n       Unicode's UTS 39 (<https://unicode.org/reports/tr39/>) Unicode Security\n       Mechanisms in allowing such mixtures.  For example, the Japanese\n       scripts Katakana and Hiragana are commonly mixed together in practice,\n       along with some Chinese characters, and hence are treated as being in a\n       single script run by Perl.\n\n       The rules used for matching decimal digits are slightly stricter.  Many\n       scripts have their own sets of digits equivalent to the Western 0\n       through 9 ones.\tA few, such as Arabic, have more than one set.\tFor a\n       string to be considered a script run, all digits in it must come from\n       the same set of ten, as determined by the first digit encountered.  As\n       an example,\n\n\tqr/(*script_run: \\d+ \\b )/x\n\n       guarantees that the digits matched will all be from the same set of 10.\n       You won't get a look-alike digit from a different script that has a\n       different value than what it appears to be.\n\n       Unicode has three pseudo scripts that are handled specially.\n\n       \"Unknown\" is applied to code points whose meaning has yet to be\n       determined.  Perl currently will match as a script run, any single\n       character string consisting of one of these code points.  But any\n       string longer than one code point containing one of these will not be\n       considered a script run.\n\n       \"Inherited\" is applied to characters that modify another, such as an\n       accent of some type.  These are considered to be in the script of the\n       master character, and so never cause a script run to not match.\n\n       The other one is \"Common\".  This consists of mostly punctuation, emoji,\n       and characters used in mathematics and music, the ASCII digits 0\n       through 9, and full-width forms of these digits.  These characters can\n       appear intermixed in text in many of the world's scripts.  These also\n       don't cause a script run to not match.  But like other scripts, all\n       digits in a run must come from the same set of 10.\n\n       This construct is non-capturing.  You can add parentheses to pattern to\n       capture, if desired.  You will have to do this if you plan to use\n       \"(*ACCEPT) (*ACCEPT:arg)\" and not have it bypass the script run\n       checking.\n\n       The \"Script_Extensions\" property as modified by UTS 39\n       (<https://unicode.org/reports/tr39/>) is used as the basis for this\n       feature.\n\n       To summarize,\n\n       •   All length 0 or length 1 sequences are script runs.\n\n       •   A longer sequence is a script run if and only if all of the\n\t   following conditions are met:"
  manpageQuestion1: What is the primary purpose of the 4ccconv command?
  manpageQuestion2: How can I convert a decimal number to a 4cc code using the 4ccconv command?
  manpageQuestion3: What is the correct way to convert a 4cc code back to an unsigned integer using the 4ccconv command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n1.  No code point in the sequence has the \"Script_Extension\"\n\t       property of \"Unknown\".\n\n\t       This currently means that all code points in the sequence have\n\t       been assigned by Unicode to be characters that aren't private\n\t       use nor surrogate code points.\n\n\t   2.  All characters in the sequence come from the Common script\n\t       and/or the Inherited script and/or a single other script.\n\n\t       The script of a character is determined by the\n\t       \"Script_Extensions\" property as modified by UTS 39\n\t       (<https://unicode.org/reports/tr39/>), as described above.\n\n\t   3.  All decimal digits in the sequence come from the same block of\n\t       10 consecutive digits.\n\n   Special Backtracking Control Verbs\n       These special patterns are generally of the form \"(*VERB:arg)\". Unless\n       otherwise stated the arg argument is optional; in some cases, it is\n       mandatory.\n\n       Any pattern containing a special backtracking verb that allows an\n       argument has the special behaviour that when executed it sets the\n       current package's $REGERROR and $REGMARK variables. When doing so the\n       following rules apply:"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use perlre to match a sequence of characters that all belong to the Common script or Inherited script and have decimal digits from the same block of 10 consecutive digits?
  manpageQuestion3: What is the function of special backtracking control verbs in perlre, and how are they typically used in regular expressions?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    On failure, the $REGERROR variable will be set to the arg value of the
           verb pattern, if the verb was involved in the failure of the match. If
           the arg part of the pattern was omitted, then $REGERROR will be set to
           the name of the last "(*MARK:NAME)" pattern executed, or to TRUE if
           there was none. Also, the $REGMARK variable will be set to FALSE.

           On a successful match, the $REGERROR variable will be set to FALSE, and
           the $REGMARK variable will be set to the name of the last
           "(*MARK:NAME)" pattern executed.  See the explanation for the
           "(*MARK:NAME)" verb below for more details.

           NOTE: $REGERROR and $REGMARK are not magic variables like $1 and most
           other regex-related variables. They are not local to a scope, nor
           readonly, but instead are volatile package variables similar to
           $AUTOLOAD.  They are set in the package containing the code that
           executed the regex (rather than the one that compiled it, where those
           differ).  If necessary, you can use "local" to localize changes to
           these variables to a specific scope before executing a regex.
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How does the perlre tool handle error information when a regex match fails?
  manpageQuestion3: What is the significance of the $REGERROR and $REGMARK variables in the context of perlre?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIf a pattern does not contain a special backtracking verb that allows\n       an argument, then $REGERROR and $REGMARK are not touched at all.\n\n       Verbs\n\t  \"(*PRUNE)\" \"(*PRUNE:NAME)\"\n\t      This zero-width pattern prunes the backtracking tree at the\n\t      current point when backtracked into on failure. Consider the\n\t      pattern \"/A (*PRUNE) B/\", where A and B are complex patterns.\n\t      Until the \"(*PRUNE)\" verb is reached, A may backtrack as\n\t      necessary to match. Once it is reached, matching continues in B,\n\t      which may also backtrack as necessary; however, should B not\n\t      match, then no further backtracking will take place, and the\n\t      pattern will fail outright at the current starting position.\n\n\t      The following example counts all the possible matching strings\n\t      in a pattern (without actually matching any of them).\n\n\t\t  'aaab' =~ /a+b?(?{print \"$&\\n\"; $count++})(*FAIL)/;\n\t\t  print \"Count=$count\\n\";\n\n\t      which produces:\n\n\t\t  aaab\n\t\t  aaa\n\t\t  aa\n\t\t  a\n\t\t  aab\n\t\t  aa\n\t\t  a\n\t\t  ab\n\t\t  a\n\t\t  Count=9"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How can you use the (*PRUNE) verb in perlre to optimize backtracking in a regular expression?
  manpageQuestion3: Can you provide an example of using the (*FAIL) verb in perlre to count all possible matches in a pattern?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIf we add a \"(*PRUNE)\" before the count like the following\n\n\t\t  'aaab' =~ /a+b?(*PRUNE)(?{print \"$&\\n\"; $count++})(*FAIL)/;\n\t\t  print \"Count=$count\\n\";\n\n\t      we prevent backtracking and find the count of the longest\n\t      matching string at each matching starting point like so:\n\n\t\t  aaab\n\t\t  aab\n\t\t  ab\n\t\t  Count=3\n\n\t      Any number of \"(*PRUNE)\" assertions may be used in a pattern.\n\n\t      See also \"(?>pattern)\" and possessive quantifiers for other ways\n\t      to control backtracking. In some cases, the use of \"(*PRUNE)\"\n\t      can be replaced with a \"(?>pattern)\" with no functional\n\t      difference; however, \"(*PRUNE)\" can be used to handle cases that\n\t      cannot be expressed using a \"(?>pattern)\" alone.\n\n\t  \"(*SKIP)\" \"(*SKIP:NAME)\"\n\t      This zero-width pattern is similar to \"(*PRUNE)\", except that on\n\t      failure it also signifies that whatever text that was matched\n\t      leading up to the \"(*SKIP)\" pattern being executed cannot be\n\t      part of any match of this pattern. This effectively means that\n\t      the regex engine \"skips\" forward to this position on failure and\n\t      tries to match again, (assuming that there is sufficient room to\n\t      match)."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use (*PRUNE) in a regular expression to count the number of matches in a string?
  manpageQuestion3: Can you provide an example of using (*SKIP) in a regular expression to skip over certain text during matching?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThe name of the \"(*SKIP:NAME)\" pattern has special significance.\n\t      If a \"(*MARK:NAME)\" was encountered while matching, then it is\n\t      that position which is used as the \"skip point\". If no \"(*MARK)\"\n\t      of that name was encountered, then the \"(*SKIP)\" operator has no\n\t      effect. When used without a name the \"skip point\" is where the\n\t      match point was when executing the \"(*SKIP)\" pattern.\n\n\t      Compare the following to the examples in \"(*PRUNE)\"; note the\n\t      string is twice as long:\n\n\t       'aaabaaab' =~ /a+b?(*SKIP)(?{print \"$&\\n\"; $count++})(*FAIL)/;\n\t       print \"Count=$count\\n\";\n\n\t      outputs\n\n\t\t  aaab\n\t\t  aaab\n\t\t  Count=2\n\n\t      Once the 'aaab' at the start of the string has matched, and the\n\t      \"(*SKIP)\" executed, the next starting point will be where the\n\t      cursor was when the \"(*SKIP)\" was executed.\n\n\t  \"(*MARK:NAME)\" \"(*:NAME)\"\n\t      This zero-width pattern can be used to mark the point reached in\n\t      a string when a certain part of the pattern has been\n\t      successfully matched. This mark may be given a name. A later\n\t      \"(*SKIP)\" pattern will then skip forward to that point if\n\t      backtracked into on failure. Any number of \"(*MARK)\" patterns\n\t      are allowed, and the NAME portion may be duplicated."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use (*MARK:NAME) in perlre to mark a specific position in the string for skipping during pattern matching?
  manpageQuestion3: Can you provide an example of using (*SKIP) with a named mark in perlre to skip to a previously marked position during a regex match?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIn addition to interacting with the \"(*SKIP)\" pattern,\n\t      \"(*MARK:NAME)\" can be used to \"label\" a pattern branch, so that\n\t      after matching, the program can determine which branches of the\n\t      pattern were involved in the match.\n\n\t      When a match is successful, the $REGMARK variable will be set to\n\t      the name of the most recently executed \"(*MARK:NAME)\" that was\n\t      involved in the match.\n\n\t      This can be used to determine which branch of a pattern was\n\t      matched without using a separate capture group for each branch,\n\t      which in turn can result in a performance improvement, as perl\n\t      cannot optimize \"/(?:(x)|(y)|(z))/\" as efficiently as something\n\t      like \"/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/\".\n\n\t      When a match has failed, and unless another verb has been\n\t      involved in failing the match and has provided its own name to\n\t      use, the $REGERROR variable will be set to the name of the most\n\t      recently executed \"(*MARK:NAME)\".\n\n\t      See \"(*SKIP)\" for more details."
  manpageQuestion1: What is the primary purpose of the '(*MARK:NAME)' pattern in Perl regular expressions?
  manpageQuestion2: How can '(*MARK:NAME)' be used to identify which branch of a complex pattern was matched successfully?
  manpageQuestion3: What happens to the $REGMARK variable when a regular expression match fails and no other verb provided a name?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nAs a shortcut \"(*MARK:NAME)\" can be written \"(*:NAME)\".\n\n\t  \"(*THEN)\" \"(*THEN:NAME)\"\n\t      This is similar to the \"cut group\" operator \"::\" from Raku.\n\t      Like \"(*PRUNE)\", this verb always matches, and when backtracked\n\t      into on failure, it causes the regex engine to try the next\n\t      alternation in the innermost enclosing group (capturing or\n\t      otherwise) that has alternations.  The two branches of a\n\t      \"(?(condition)yes-pattern|no-pattern)\" do not count as an\n\t      alternation, as far as \"(*THEN)\" is concerned.\n\n\t      Its name comes from the observation that this operation combined\n\t      with the alternation operator (\"|\") can be used to create what\n\t      is essentially a pattern-based if/then/else block:\n\n\t\t( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )\n\n\t      Note that if this operator is used and NOT inside of an\n\t      alternation then it acts exactly like the \"(*PRUNE)\" operator.\n\n\t\t/ A (*PRUNE) B /\n\n\t      is the same as\n\n\t\t/ A (*THEN) B /\n\n\t      but"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use the (*THEN) operator in perlre to create a conditional pattern-based if/then/else block?
  manpageQuestion3: What is the difference between using (*THEN) and (*PRUNE) operators in perlre when not inside an alternation?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n/ ( A (*THEN) B | C ) /\n\n\t      is not the same as\n\n\t\t/ ( A (*PRUNE) B | C ) /\n\n\t      as after matching the A but failing on the B the \"(*THEN)\" verb\n\t      will backtrack and try C; but the \"(*PRUNE)\" verb will simply\n\t      fail.\n\n\t  \"(*COMMIT)\" \"(*COMMIT:arg)\"\n\t      This is the Raku \"commit pattern\" \"<commit>\" or \":::\". It's a\n\t      zero-width pattern similar to \"(*SKIP)\", except that when\n\t      backtracked into on failure it causes the match to fail\n\t      outright. No further attempts to find a valid match by advancing\n\t      the start pointer will occur again.  For example,\n\n\t       'aaabaaab' =~ /a+b?(*COMMIT)(?{print \"$&\\n\"; $count++})(*FAIL)/;\n\t       print \"Count=$count\\n\";\n\n\t      outputs\n\n\t\t  aaab\n\t\t  Count=1\n\n\t      In other words, once the \"(*COMMIT)\" has been entered, and if\n\t      the pattern does not match, the regex engine will not try any\n\t      further matching on the rest of the string.\n\n\t  \"(*FAIL)\" \"(*F)\" \"(*FAIL:arg)\"\n\t      This pattern matches nothing and always fails. It can be used to\n\t      force the engine to backtrack. It is equivalent to \"(?!)\", but\n\t      easier to read. In fact, \"(?!)\" gets optimised into \"(*FAIL)\"\n\t      internally. You can provide an argument so that if the match\n\t      fails because of this \"FAIL\" directive the argument can be\n\t      obtained from $REGERROR."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use (*COMMIT) in a regular expression to enforce that a match must succeed from the current position?
  manpageQuestion3: What is the function of the (*FAIL) operator in Perl regular expressions and when would it be useful to use it?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIt is probably useful only when combined with \"(?{})\" or\n\t      \"(??{})\".\n\n\t  \"(*ACCEPT)\" \"(*ACCEPT:arg)\"\n\t      This pattern matches nothing and causes the end of successful\n\t      matching at the point at which the \"(*ACCEPT)\" pattern was\n\t      encountered, regardless of whether there is actually more to\n\t      match in the string. When inside of a nested pattern, such as\n\t      recursion, or in a subpattern dynamically generated via\n\t      \"(??{})\", only the innermost pattern is ended immediately.\n\n\t      If the \"(*ACCEPT)\" is inside of capturing groups then the groups\n\t      are marked as ended at the point at which the \"(*ACCEPT)\" was\n\t      encountered.  For instance:\n\n\t\t'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;\n\n\t      will match, and $1 will be \"AB\" and $2 will be \"B\", $3 will not\n\t      be set. If another branch in the inner parentheses was matched,\n\t      such as in the string 'ACDE', then the \"D\" and \"E\" would have to\n\t      be matched as well.\n\n\t      You can provide an argument, which will be available in the var\n\t      $REGMARK after the match completes."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can the (*ACCEPT) pattern be used in a regular expression to end matching at a specific point?
  manpageQuestion3: Can you provide an example of using (*ACCEPT) within a capturing group to capture specific parts of a match?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nWarning on \"\\1\" Instead of $1\n       Some people get too used to writing things like:\n\n\t   $pattern =~ s/(\\W)/\\\\\\1/g;\n\n       This is grandfathered (for \\1 to \\9) for the RHS of a substitute to\n       avoid shocking the sed addicts, but it's a dirty habit to get into.\n       That's because in PerlThink, the righthand side of an \"s///\" is a\n       double-quoted string.  \"\\1\" in the usual double-quoted string means a\n       control-A.  The customary Unix meaning of \"\\1\" is kludged in for\n       \"s///\".\tHowever, if you get into the habit of doing that, you get\n       yourself into trouble if you then add an \"/e\" modifier.\n\n\t   s/(\\d+)/ \\1 + 1 /eg; \t   # causes warning under -w\n\n       Or if you try to do\n\n\t   s/(\\d+)/\\1000/;\n\n       You can't disambiguate that by saying \"\\{1}000\", whereas you can fix it\n       with \"${1}000\".\tThe operation of interpolation should not be confused\n       with the operation of matching a backreference.\tCertainly they mean\n       two different things on the left side of the \"s///\"."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you avoid a warning when using backreferences in a substitution operation with perlre?
  manpageQuestion3: What is the correct way to reference a backreference in a substitution operation using perlre?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nRepeated Patterns Matching a Zero-length Substring\n       WARNING: Difficult material (and prose) ahead.  This section needs a\n       rewrite.\n\n       Regular expressions provide a terse and powerful programming language.\n       As with most other power tools, power comes together with the ability\n       to wreak havoc.\n\n       A common abuse of this power stems from the ability to make infinite\n       loops using regular expressions, with something as innocuous as:\n\n\t   'foo' =~ m{ ( o? )* }x;\n\n       The \"o?\" matches at the beginning of \"\"foo\"\", and since the position in\n       the string is not moved by the match, \"o?\" would match again and again\n       because of the \"*\" quantifier.  Another common way to create a similar\n       cycle is with the looping modifier \"/g\":\n\n\t   @matches = ( 'foo' =~ m{ o? }xg );\n\n       or\n\n\t   print \"match: <$&>\\n\" while 'foo' =~ m{ o? }xg;\n\n       or the loop implied by \"split()\".\n\n       However, long experience has shown that many programming tasks may be\n       significantly simplified by using repeated subexpressions that may\n       match zero-length substrings.  Here's a simple example being:"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a pattern that could potentially cause an infinite loop?
  manpageQuestion3: Can you provide an example of using perlre to handle a regular expression that may match zero-length substrings in a controlled way?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n@chars = split //, $string;\t\t # // is not magic in split\n\t   ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /\n\n       Thus Perl allows such constructs, by forcefully breaking the infinite\n       loop.  The rules for this are different for lower-level loops given by\n       the greedy quantifiers \"*+{}\", and for higher-level ones like the \"/g\"\n       modifier or \"split()\" operator.\n\n       The lower-level loops are interrupted (that is, the loop is broken)\n       when Perl detects that a repeated expression matched a zero-length\n       substring.   Thus\n\n\t  m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;\n\n       is made equivalent to\n\n\t  m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;\n\n       For example, this program\n\n\t  #!perl -l\n\t  \"aaaaab\" =~ /\n\t    (?:\n\t       a\t\t # non-zero\n\t       |\t\t # or\n\t      (?{print \"hello\"}) # print hello whenever this\n\t\t\t\t #    branch is tried\n\t      (?=(b))\t\t # zero-width assertion\n\t    )*\t# any number of times\n\t   /x;\n\t  print $&;\n\t  print $1;"
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to match a pattern that alternates between matching 'a' and a zero-length assertion, allowing for multiple repetitions?
  manpageQuestion3: Can you provide an example of using perlre to create a regular expression that matches any string consisting of five or more 'a's followed by the letter 'b'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nprints\n\n\t  hello\n\t  aaaaa\n\t  b\n\n       Notice that \"hello\" is only printed once, as when Perl sees that the\n       sixth iteration of the outermost \"(?:)*\" matches a zero-length string,\n       it stops the \"*\".\n\n       The higher-level loops preserve an additional state between iterations:\n       whether the last match was zero-length.\tTo break the loop, the\n       following match after a zero-length match is prohibited to have a\n       length of zero.\tThis prohibition interacts with backtracking (see\n       \"Backtracking\"), and so the second best match is chosen if the best\n       match is of zero length.\n\n       For example:\n\n\t   $_ = 'bar';\n\t   s/\\w??/<$&>/g;\n\n       results in \"<><b><><a><><r><>\".\tAt each position of the string the\n       best match given by non-greedy \"??\" is the zero-length match, and the\n       second best match is what is matched by \"\\w\".  Thus zero-length matches\n       alternate with one-character-long matches.\n\n       Similarly, for repeated \"m/()/g\" the second-best match is the match at\n       the position one notch further in the string."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to replace all occurrences of a word with two letters in the string 'bar' with their corresponding HTML entities using non-greedy matching?
  manpageQuestion3: Can you provide an example of using perlre to process a string with nested loops that alternate between zero-length and one-character matches?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.



    Manpage text:

    The additional state of being matched with zero-length is associated
           with the matched string, and is reset by each assignment to "pos()".
           Zero-length matches at the end of the previous match are ignored during
           "split".

       Combining RE Pieces
           Each of the elementary pieces of regular expressions which were
           described before (such as "ab" or "\Z") could match at most one
           substring at the given position of the input string.  However, in a
           typical regular expression these elementary pieces are combined into
           more complicated patterns using combining operators "ST", "S|T", "S*"
           etc.  (in these examples "S" and "T" are regular subexpressions).

           Such combinations can include alternatives, leading to a problem of
           choice: if we match a regular expression "a|ab" against "abc", will it
           match substring "a" or "ab"?  One way to describe which substring is
           actually matched is the concept of backtracking (see "Backtracking").
           However, this description is too low-level and makes you think in terms
           of a particular implementation.
  manpageQuestion1: What is the primary purpose of the perlre utility?
  manpageQuestion2: How can you use perlre to match a regular expression that matches either 'apple' or 'applesauce' in a string?
  manpageQuestion3: Can you provide an example of using perlre to find all occurrences of a pattern that matches 'a' followed by exactly two digits in the string 'The answer is 1234567890'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nAnother description starts with notions of \"better\"/\"worse\".  All the\n       substrings which may be matched by the given regular expression can be\n       sorted from the \"best\" match to the \"worst\" match, and it is the \"best\"\n       match which is chosen.  This substitutes the question of \"what is\n       chosen?\"  by the question of \"which matches are better, and which are\n       worse?\".\n\n       Again, for elementary pieces there is no such question, since at most\n       one match at a given position is possible.  This section describes the\n       notion of better/worse for combining operators.\tIn the description\n       below \"S\" and \"T\" are regular subexpressions.\n\n       \"ST\"\n\t   Consider two possible matches, \"AB\" and \"A'B'\", \"A\" and \"A'\" are\n\t   substrings which can be matched by \"S\", \"B\" and \"B'\" are substrings\n\t   which can be matched by \"T\".\n\n\t   If \"A\" is a better match for \"S\" than \"A'\", \"AB\" is a better match\n\t   than \"A'B'\".\n\n\t   If \"A\" and \"A'\" coincide: \"AB\" is a better match than \"AB'\" if \"B\"\n\t   is a better match for \"T\" than \"B'\"."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to find and replace all occurrences of a pattern in a text file?
  manpageQuestion3: Can you provide an example of using perlre to match and sort regular expression alternatives based on the 'better' matching criteria?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n\"S|T\"\n\t   When \"S\" can match, it is a better match than when only \"T\" can\n\t   match.\n\n\t   Ordering of two matches for \"S\" is the same as for \"S\".  Similar\n\t   for two matches for \"T\".\n\n       \"S{REPEAT_COUNT}\"\n\t   Matches as \"SSS...S\" (repeated as many times as necessary).\n\n       \"S{min,max}\"\n\t   Matches as \"S{max}|S{max-1}|...|S{min+1}|S{min}\".\n\n       \"S{min,max}?\"\n\t   Matches as \"S{min}|S{min+1}|...|S{max-1}|S{max}\".\n\n       \"S?\", \"S*\", \"S+\"\n\t   Same as \"S{0,1}\", \"S{0,BIG_NUMBER}\", \"S{1,BIG_NUMBER}\"\n\t   respectively.\n\n       \"S??\", \"S*?\", \"S+?\"\n\t   Same as \"S{0,1}?\", \"S{0,BIG_NUMBER}?\", \"S{1,BIG_NUMBER}?\"\n\t   respectively.\n\n       \"(?>S)\"\n\t   Matches the best match for \"S\" and only that.\n\n       \"(?=S)\", \"(?<=S)\"\n\t   Only the best match for \"S\" is considered.  (This is important only\n\t   if \"S\" has capturing parentheses, and backreferences are used\n\t   somewhere else in the whole regular expression.)\n\n       \"(?!S)\", \"(?<!S)\"\n\t   For this grouping operator there is no need to describe the\n\t   ordering, since only whether or not \"S\" can match is important."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How would you use perlre to match a sequence of one or more occurrences of the pattern 'S'?
  manpageQuestion3: Can you provide an example of using perlre to ensure that a string starts with the best match for the pattern 'S' followed by any characters, but not allowing backtracking?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\n\"(??{ EXPR })\", \"(?PARNO)\"\n\t   The ordering is the same as for the regular expression which is the\n\t   result of EXPR, or the pattern contained by capture group PARNO.\n\n       \"(?(condition)yes-pattern|no-pattern)\"\n\t   Recall that which of yes-pattern or no-pattern actually matches is\n\t   already determined.\tThe ordering of the matches is the same as for\n\t   the chosen subexpression.\n\n       The above recipes describe the ordering of matches at a given position.\n       One more rule is needed to understand how a match is determined for the\n       whole regular expression: a match at an earlier position is always\n       better than a match at a later position.\n\n   Creating Custom RE Engines\n       As of Perl 5.10.0, one can create custom regular expression engines.\n       This is not for the faint of heart, as they have to plug in at the C\n       level.  See perlreapi for more details.\n\n       As an alternative, overloaded constants (see overload) provide a simple\n       way to extend the functionality of the RE engine, by substituting one\n       pattern for another."
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you create a custom regular expression engine in Perl using the information provided?
  manpageQuestion3: Can you explain how the matching order is determined in Perl regular expressions according to the manpage text?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nSuppose that we want to enable a new RE escape-sequence \"\\Y|\" which\n       matches at a boundary between whitespace characters and non-whitespace\n       characters.  Note that \"(?=\\S)(?<!\\S)|(?!\\S)(?<=\\S)\" matches exactly at\n       these positions, so we want to have each \"\\Y|\" in the place of the more\n       complicated version.  We can create a module \"customre\" to do this:\n\n\t   package customre;\n\t   use overload;\n\n\t   sub import {\n\t     shift;\n\t     die \"No argument to customre::import allowed\" if @_;\n\t     overload::constant 'qr' => \\&convert;\n\t   }\n\n\t   sub invalid { die \"/$_[0]/: invalid escape '\\\\$_[1]'\"}\n\n\t   # We must also take care of not escaping the legitimate \\\\Y|\n\t   # sequence, hence the presence of '\\\\' in the conversion rules.\n\t   my %rules = ( '\\\\' => '\\\\\\\\',\n\t\t\t 'Y|' => qr/(?=\\S)(?<!\\S)|(?!\\S)(?<=\\S)/ );\n\t   sub convert {\n\t     my $re = shift;\n\t     $re =~ s{\n\t\t       \\\\ ( \\\\ | Y . )\n\t\t     }\n\t\t     { $rules{$1} or invalid($re,$1) }sgex;\n\t     return $re;\n\t   }\n\n       Now \"use customre\" enables the new escape in constant regular\n       expressions, i.e., those without any runtime variable interpolations.\n       As documented in overload, this conversion will work only over literal\n       parts of regular expressions.  For \"\\Y|$re\\Y|\" the variable part of\n       this regular expression needs to be converted explicitly (but only if\n       the special meaning of \"\\Y|\" should be enabled inside $re):"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can one create a custom regular expression escape sequence in Perl using the overload module?
  manpageQuestion3: Can you provide an example of how to use the customre module to enable a new escape sequence for regular expressions in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nuse customre;\n\t   $re = <>;\n\t   chomp $re;\n\t   $re = customre::convert $re;\n\t   /\\Y|$re\\Y|/;\n\n   Embedded Code Execution Frequency\n       The exact rules for how often \"(??{})\" and \"(?{})\" are executed in a\n       pattern are unspecified.  In the case of a successful match you can\n       assume that they DWIM and will be executed in left to right order the\n       appropriate number of times in the accepting path of the pattern as\n       would any other meta-pattern.  How non-accepting pathways and match\n       failures affect the number of times a pattern is executed is\n       specifically unspecified and may vary depending on what optimizations\n       can be applied to the pattern and is likely to change from version to\n       version.\n\n       For instance in\n\n\t \"aaabcdeeeee\"=~/a(?{print \"a\"})b(?{print \"b\"})cde/;\n\n       the exact number of times \"a\" or \"b\" are printed out is unspecified for\n       failure, but you may assume they will be printed at least once during a\n       successful match, additionally you may assume that if \"b\" is printed,\n       it will be preceded by at least one \"a\"."
  manpageQuestion1: What is the primary purpose of the `customre` module in Perl?
  manpageQuestion2: How would you use the `customre::convert` function to process a regular expression and modify it for custom processing?
  manpageQuestion3: Can you provide an example of using the `customre` module to handle a pattern that includes embedded code execution with conditional printing?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nIn the case of branching constructs like the following:\n\n\t /a(b|(?{ print \"a\" }))c(?{ print \"c\" })/;\n\n       you can assume that the input \"ac\" will output \"ac\", and that \"abc\"\n       will output only \"c\".\n\n       When embedded code is quantified, successful matches will call the code\n       once for each matched iteration of the quantifier.  For example:\n\n\t \"good\" =~ /g(?:o(?{print \"o\"}))*d/;\n\n       will output \"o\" twice.\n\n   PCRE/Python Support\n       As of Perl 5.10.0, Perl supports several Python/PCRE-specific\n       extensions to the regex syntax. While Perl programmers are encouraged\n       to use the Perl-specific syntax, the following are also accepted:\n\n       \"(?P<NAME>pattern)\"\n\t   Define a named capture group. Equivalent to \"(?<NAME>pattern)\".\n\n       \"(?P=NAME)\"\n\t   Backreference to a named capture group. Equivalent to \"\\g{NAME}\".\n\n       \"(?P>NAME)\"\n\t   Subroutine call to a named capture group. Equivalent to \"(?&NAME)\".\n\nBUGS\n       There are a number of issues with regard to case-insensitive matching\n       in Unicode rules.  See \"i\" under \"Modifiers\" above."
  manpageQuestion1: What is the primary purpose of the perlre tool?
  manpageQuestion2: How would you use perlre to define a named capture group and backreference it in a regular expression?
  manpageQuestion3: Can you provide an example of using perlre to execute embedded code within a regular expression that prints output during matching?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlre`.\n\n\n\nManpage text:\n\nThis document varies from difficult to understand to completely and\n       utterly opaque.\tThe wandering prose riddled with jargon is hard to\n       fathom in several places.\n\n       This document needs a rewrite that separates the tutorial content from\n       the reference content.\n\nSEE ALSO\n       The syntax of patterns used in Perl pattern matching evolved from those\n       supplied in the Bell Labs Research Unix 8th Edition (Version 8) regex\n       routines.  (The code is actually derived (distantly) from Henry\n       Spencer's freely redistributable reimplementation of those V8\n       routines.)\n\n       perlrequick.\n\n       perlretut.\n\n       \"Regexp Quote-Like Operators\" in perlop.\n\n       \"Gory details of parsing quoted constructs\" in perlop.\n\n       perlfaq6.\n\n       \"pos\" in perlfunc.\n\n       perllocale.\n\n       perlebcdic.\n\n       Mastering Regular Expressions by Jeffrey Friedl, published by O'Reilly\n       and Associates.\n\nperl v5.34.1\t\t\t  2022-02-19\t\t\t     PERLRE(1)"
  manpageQuestion1: What is the primary purpose of the perlre resource?
  manpageQuestion2: How can you use perlre to understand the syntax of regular expressions in Perl?
  manpageQuestion3: What are some of the key resources recommended by perlre for further learning about Perl regular expressions?

