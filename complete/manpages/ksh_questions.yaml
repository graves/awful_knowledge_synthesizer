- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nKSH(1)\t\t\t    General Commands Manual\t\t\tKSH(1)\n\nNAME\n       ksh, rksh, pfksh - KornShell, a standard/restricted command and\n       programming language\n\nNOTE\n       Currently, rksh and pfksh are not available on Mac OS X / Darwin.\n\nSYNOPSIS\n       ksh [ ±abcefhikmnoprstuvxBCDP ] [ -R file ] [ ±o option ] ... [ - ] [\n       arg ... ]\n       rksh [ ±abcefhikmnoprstuvxBCD ] [ -R file ] [ ±o option ] ...  [ - ] [\n       arg ... ]\n\nDESCRIPTION\n       Ksh is a command and programming language that executes commands read\n       from a terminal or a file.  Rksh is a restricted version of the command\n       interpreter ksh; it is used to set up login names and execution\n       environments whose capabilities are more controlled than those of the\n       standard shell.\tRpfksh is a profile shell version of the command\n       interpreter ksh; it is used to to execute commands with the attributes\n       specified by the user's profiles (see pfexec(1)).  See Invocation below\n       for the meaning of arguments to the shell."
  manpageQuestion1: What is the primary purpose of the ksh command?
  manpageQuestion2: How would you use ksh to execute a script named 'script.sh' with restricted execution environment?
  manpageQuestion3: Can you provide an example of using ksh to run a command with the attributes specified by the user's profiles?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nDefinitions.\n       A metacharacter is one of the following characters:\n\n\t      ;   &   (   )   ⎪   <   >   new-line   space   tab\n\n       A blank is a tab or a space.  An identifier is a sequence of letters,\n       digits, or underscores starting with a letter or underscore.\n       Identifiers are used as components of variable names.  A vname is a\n       sequence of one or more identifiers separated by a . and optionally\n       preceded by a ..  Vnames are used as function and variable names.  A\n       word is a sequence of characters from the character set defined by the\n       current locale, excluding non-quoted metacharacters.\n\n       A command is a sequence of characters in the syntax of the shell\n       language.  The shell reads each command and carries out the desired\n       action either directly or by invoking separate utilities.  A built-in\n       command is a command that is carried out by the shell itself without\n       creating a separate process.  Some commands are built-in purely for\n       convenience and are not documented here.  Built-ins that cause side\n       effects in the shell environment and built-ins that are found before\n       performing a path search (see Execution below) are documented here.\n       For historical reasons, some of these built-ins behave differently than\n       other built-ins and are called special built-ins."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use ksh to execute a command and redirect its output to a file?
  manpageQuestion3: Can you explain how ksh handles variable names and identifiers in its syntax?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nCommands.\n       A simple-command is a list of variable assignments (see Variable\n       Assignments below) or a sequence of blank separated words which may be\n       preceded by a list of variable assignments (see Environment below).\n       The first word specifies the name of the command to be executed.\n       Except as specified below, the remaining words are passed as arguments\n       to the invoked command.\tThe command name is passed as argument 0 (see\n       exec(2)).  The value of a simple-command is its exit status; 0-255 if\n       it terminates normally; 256+signum if it terminates abnormally (the\n       name of the signal corresponding to the exit status can be obtained via\n       the -l option of the kill built-in utility).\n\n       A pipeline is a sequence of one or more commands separated by ⎪.  The\n       standard output of each command but the last is connected by a pipe(2)\n       to the standard input of the next command.  Each command, except\n       possibly the last, is run as a separate process; the shell waits for\n       the last command to terminate.  The exit status of a pipeline is the\n       exit status of the last command unless the pipefail option is enabled.\n       Each pipeline can be preceded by the reserved word !  which causes the\n       exit status of the pipeline to become 0 if the exit status of the last\n       command is non-zero, and 1 if the exit status of the last command is 0."
  manpageQuestion1: What is the primary purpose of the ksh command interpreter?
  manpageQuestion2: How can you use ksh to execute a pipeline that converts the output of a command into lowercase and then counts the number of lines?
  manpageQuestion3: Can you provide an example of using ksh to run a command and capture its output for further processing in the same shell session?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    A list is a sequence of one or more pipelines separated by ;, &, ⎪&,
           &&, or ⎪⎪, and optionally terminated by ;, &, or ⎪&.  Of these five
           symbols, ;, &, and ⎪& have equal precedence, which is lower than that
           of && and ⎪⎪.  The symbols && and ⎪⎪ also have equal precedence.  A
           semicolon (;) causes sequential execution of the preceding pipeline; an
           ampersand (&) causes asynchronous execution of the preceding pipeline
           (i.e., the shell does not wait for that pipeline to finish).  The
           symbol ⎪& causes asynchronous execution of the preceding pipeline with
           a two-way pipe established to the parent shell; the standard input and
           output of the spawned pipeline can be written to and read from by the
           parent shell by applying the redirection operators <& and >& with arg p
           to commands and by using -p option of the built-in commands read and
           print described later.  The symbol && (⎪⎪) causes the list following it
           to be executed only if the preceding pipeline returns a zero (non-zero)
           value.  One or more new-lines may appear in a list instead of a
           semicolon, to delimit a command.  The first item  of the first pipeline
           of a list that is a simple command not beginning with a redirection,
           and not occurring within a while, until, or if list, can be preceded by
           a semicolon.  This semicolon is ignored unless the showme option is
           enabled as described with the set built-in below.
  manpageQuestion1: What is the primary purpose of the ksh shell in this context?
  manpageQuestion2: How can you execute multiple commands sequentially in ksh using a list?
  manpageQuestion3: Can you explain how to use the && operator in ksh to execute a command only if the previous one succeeds?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nA command is either a simple-command or one of the following.  Unless\n       otherwise stated, the value returned by a command is that of the last\n       simple-command executed in the command.\n\n       for vname [ in word ... ] ;do list ;done\n\t      Each time a for command is executed, vname is set to the next\n\t      word taken from the in word list.  If in word ...  is omitted,\n\t      then the for command executes the do list once for each\n\t      positional parameter that is set starting from 1 (see Parameter\n\t      Expansion below).  Execution ends when there are no more words\n\t      in the list.\n\n       for (( [expr1] ; [expr2] ; [expr3] )) ;do list ;done\n\t      The arithmetic expression expr1 is evaluated first (see\n\t      Arithmetic evaluation below).  The arithmetic expression expr2\n\t      is repeatedly evaluated until it evaluates to zero and when non-\n\t      zero, list is executed and the arithmetic expression expr3\n\t      evaluated.  If any expression is omitted, then it behaves as if\n\t      it evaluated to 1."
  manpageQuestion1: What is the primary purpose of the ksh shell command?
  manpageQuestion2: How would you use a for loop in ksh to iterate over a list of filenames and display each one?
  manpageQuestion3: Can you provide an example of using a for (( ... )) loop in ksh to iterate from 1 to 10 and print each number?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nselect vname [ in word ... ] ;do list ;done\n\t      A select command prints on standard error (file descriptor 2)\n\t      the set of words, each preceded by a number.  If in word ...  is\n\t      omitted, then the positional parameters starting from 1 are used\n\t      instead (see Parameter Expansion below).\tThe PS3 prompt is\n\t      printed and a line is read from the standard input.  If this\n\t      line consists of the number of one of the listed words, then the\n\t      value of the variable vname is set to the word corresponding to\n\t      this number.  If this line is empty, the selection list is\n\t      printed again.  Otherwise the value of the variable vname is set\n\t      to null.\tThe contents of the line read from standard input is\n\t      saved in the variable REPLY.  The list is executed for each\n\t      selection until a break or end-of-file is encountered.  If the\n\t      REPLY variable is set to null by the execution of list, then the\n\t      selection list is printed before displaying the PS3 prompt for\n\t      the next selection."
  manpageQuestion1: What is the primary purpose of the ksh shell command 'select'?
  manpageQuestion2: How can you use the 'select' command in ksh to allow a user to choose an option from a list of menu items?
  manpageQuestion3: Can you provide an example of using the 'select' command in ksh to prompt a user for input and assign the selected option to a variable?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\ncase word in [ [(]pattern [ ⎪ pattern ] ... ) list ;; ] ... esac\n\t      A case command executes the list associated with the first\n\t      pattern that matches word.  The form of the patterns is the same\n\t      as that used for file-name generation (see File Name Generation\n\t      below).  The ;; operator causes execution of case to terminate.\n\t      If ;& is used in place of ;; the next subsequent list, if any,\n\t      is executed.\n\n       if list ;then list [ ;elif list ;then list ] ... [ ;else list ] ;fi\n\t      The list following if is executed and, if it returns a zero exit\n\t      status, the list following the first then is executed.\n\t      Otherwise, the list following elif is executed and, if its value\n\t      is zero, the list following the next then is executed.  Failing\n\t      each successive elif list, the else list is executed.  If the if\n\t      list has non-zero exit status and there is no else list, then\n\t      the if command returns a zero exit status.\n\n       while list ;do list ;done\n       until list ;do list ;done\n\t      A while command repeatedly executes the while list and, if the\n\t      exit status of the last command in the list is zero, executes\n\t      the do list; otherwise the loop terminates.  If no commands in\n\t      the do list are executed, then the while command returns a zero\n\t      exit status; until may be used in place of while to negate the\n\t      loop termination test."
  manpageQuestion1: What is the primary purpose of the ksh shell command?
  manpageQuestion2: How would you use a while loop in ksh to print numbers from 1 to 10?
  manpageQuestion3: Can you provide an example of using a case statement in ksh to handle different user input options?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n((expression))\n\t      The expression is evaluated using the rules for arithmetic\n\t      evaluation described below.  If the value of the arithmetic\n\t      expression is non-zero, the exit status is 0, otherwise the exit\n\t      status is 1.\n\n       (list)\n\t      Execute list in a separate environment.  Note, that if two\n\t      adjacent open parentheses are needed for nesting, a space must\n\t      be inserted to avoid evaluation as an arithmetic command as\n\t      described above.\n\n       { list;}\n\t      list is simply executed.\tNote that unlike the metacharacters (\n\t      and ), { and } are reserved words and must occur at the\n\t      beginning of a line or after a ; in order to be recognized.\n\n       [[ expression ]]\n\t      Evaluates expression and returns a zero exit status when\n\t      expression is true.  See Conditional Expressions below, for a\n\t      description of expression.\n\n       function varname { list ;}\n       varname () { list ;}\n\t      Define a function which is referenced by varname.  A function\n\t      whose varname contains a . is called a discipline function and\n\t      the portion of the varname preceding the last . must refer to an\n\t      existing variable.  The body of the function is the list of\n\t      commands between { and }.  A function defined with the function\n\t      varname syntax can also be used as an argument to the . special\n\t      built-in command to get the equivalent behavior as if the\n\t      varname() syntax were used to define it.\t(See Functions below.)"
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use ksh to evaluate an arithmetic expression and check if it is non-zero?
  manpageQuestion3: Can you provide an example of defining a function in ksh and using it as an argument to the . special built-in command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nnamespace identifier { list ;}\n\t      Defines or uses the name space identifier and runs the commands\n\t      in list in this name space.  (See Name Spaces below.)\n\n       & [ name [ arg... ]  ]\n\t      Causes subsequent list commands terminated by & to be placed in\n\t      the background job pool name.  If name is omitted a default\n\t      unnamed pool is used.  Commands in a named background pool may\n\t      be executed remotely.\n\n       time [ pipeline ]\n\t      If pipeline is omitted the user and system time for the current\n\t      shell and completed child processes is printed on standard\n\t      error.  Otherwise, pipeline is executed and the elapsed time as\n\t      well as the user and system time are printed on standard error.\n\t      The TIMEFORMAT variable may be set to a format string that\n\t      specifies how the timing information should be displayed.  See\n\t      Shell Variables below for a description of the TIMEFORMAT\n\t      variable.\n\n       The following reserved words are recognized as reserved only when they\n       are the first word of a command and are not quoted:"
  manpageQuestion1: What is the primary purpose of the ksh shell command?
  manpageQuestion2: How can you use the time command in ksh to measure the execution time of a pipeline and customize the output format?
  manpageQuestion3: Can you explain how to use the namespace identifier feature in ksh to create a new name space and execute commands within it?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nif then else elif fi case esac for while until do done { } function\n       select time [[ ]] !\n\n   Variable Assignments.\n       One or more variable assignments can start a simple command or can be\n       arguments to the typeset, enum, export, or readonly special built-in\n       commands as well as to other declaration commands created as types.\n       The syntax for an assignment is of the form:\n\n       varname=word\n       varname[word]=word\n\t      No space is permitted between varname and the = or between = and\n\t      word.\n\n       varname=(assign_list)\n\t      No space is permitted between varname and the =.\tThe variable\n\t      varname is unset before the assignment.  An assign_list can be\n\t      one of the following:\n\t\t      word ...\n\t\t\t     Indexed array assignment.\n\t\t      [word]=word ...\n\t\t\t     Associative array assignment.  If preceded by\n\t\t\t     typeset -a this will create an indexed array\n\t\t\t     instead.\n\t\t      assignment ...\n\t\t\t     Compound variable assignment.  This creates a\n\t\t\t     compound variable varname with sub-variables of\n\t\t\t     the form varname.name, where name is the name\n\t\t\t     portion of assignment.  The value of varname will\n\t\t\t     contain all the assignment elements.  Additional\n\t\t\t     assignments made to sub-variables of varname will\n\t\t\t     also be displayed as part of the value of\n\t\t\t     varname.  If no assignments are specified,\n\t\t\t     varname will be a compound variable allowing\n\t\t\t     subsequence child elements to be defined.\n\t\t      typeset [options] assignment ...\n\t\t\t     Nested variable assignment.  Multiple assignments\n\t\t\t     can be specified by separating each of them with\n\t\t\t     a ;.  The previous value is unset before the\n\t\t\t     assignment.  Other declaration commands such as\n\t\t\t     readonly, enum, and other declaration commands\n\t\t\t     can be used in place of typeset.\n\t\t      . filename\n\t\t\t     Include the assignment commands contained in\n\t\t\t     filename."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use variable assignments in ksh to create an indexed array with the elements 'apple', 'banana', and 'cherry'?
  manpageQuestion3: Can you provide an example of using compound variable assignment in ksh to define a compound variable with sub-variables 'name' and 'age'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nIn addition, a += can be used in place of the = to signify adding to or\n       appending to the previous value.  When += is applied to an arithmetic\n       type, word is evaluated as an arithmetic expression and added to the\n       current value.  When applied to a string variable, the value defined by\n       word is appended to the value.  For compound assignments, the previous\n       value is not unset and the new values are appended to the current ones\n       provided that the types are compatible.\n\n       The right hand side of a variable assignment undergoes all the\n       expansion listed below except word splitting, brace expansion, and file\n       name generation.  When the left hand side is an assignment is a\n       compound variable and the right hand is the name of a compound\n       variable, the compound variable on the right will be copied or appended\n       to the compound variable on the left.\n\n   Comments.\n       A word beginning with # causes that word and all the following\n       characters up to a new-line to be ignored.\n   Aliasing.\n       The first word of each command is replaced by the text of an alias if\n       an alias for this word has been defined.  An alias name consists of any\n       number of characters excluding metacharacters, quoting characters, file\n       expansion characters, parameter expansion and command substitution\n       characters, the characters / and =.  The replacement string can contain\n       any valid shell script including the metacharacters listed above.  The\n       first word of each command in the replaced text, other than any that\n       are in the process of being replaced, will be tested for aliases.  If\n       the last character of the alias value is a blank then the word\n       following the alias will also be checked for alias substitution.\n       Aliases can be used to redefine built-in commands but cannot be used to\n       redefine the reserved words listed above.  Aliases can be created and\n       listed with the alias command and can be removed with the unalias\n       command.\n       Aliasing is performed when scripts are read, not while they are\n       executed.  Therefore, for an alias to take effect, the alias definition\n       command has to be executed before the command which references the\n       alias is read.\n       The following aliases are compiled into the shell but can be unset or\n       redefined:\n\t\t\t   autoload=′typeset -fu′\n\t\t\t   command=′command  ′\n\t\t\t   compound=′typeset -C′\n\t\t\t   fc=hist\n\t\t\t   float=′typeset -lE′\n\t\t\t   functions=′typeset -f′\n\t\t\t   hash=′alias -t --′\n\t\t\t   history=′hist -l′\n\t\t\t   integer=′typeset -li′\n\t\t\t   nameref=′typeset -n′\n\t\t\t   nohup=′nohup  ′\n\t\t\t   r=′hist -s′\n\t\t\t   redirect=′command exec′\n\t\t\t   source=′command .′\n\t\t\t   stop=′kill -s STOP′\n\t\t\t   suspend=′kill -s STOP $$′\n\t\t\t   times=′{ { time;} 2>&1;}′\n\t\t\t   type=′whence -v′"
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How does the += compound assignment operator work in ksh when used with string variables?
  manpageQuestion3: Can you explain how aliases function in ksh and provide an example of creating and using an alias?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nTilde Substitution.\n       After alias substitution is performed, each word is checked to see if\n       it begins with an unquoted ∼.  For tilde substitution, word also refers\n       to the word portion of parameter expansion (see Parameter Expansion\n       below).\tIf it does, then the word up to a / is checked to see if it\n       matches a user name in the password database (See getpwname(3).)  If a\n       match is found, the ∼ and the matched login name are replaced by the\n       login directory of the matched user.  If no match is found, the\n       original text is left unchanged.  A ∼ by itself, or in front of a /, is\n       replaced by $HOME.  A ∼ followed by a + or - is replaced by the value\n       of $PWD and $OLDPWD respectively.\n\n       In addition, when expanding a variable assignment, tilde substitution\n       is attempted when the value of the assignment begins with a ∼, and when\n       a ∼ appears after a :.  The : also terminates a ∼ login name.\n\n   Command Substitution.\n       The standard output from a command list enclosed in parentheses\n       preceded by a dollar sign ( $(list) ), or in a brace group preceded by\n       a dollar sign ( ${ list;} ), or in a pair of grave accents (``) may be\n       used as part or all of a word; trailing new-lines are removed.  In the\n       second case, the { and } are treated as a reserved words so that { must\n       be followed by a blank and } must appear at the beginning of the line\n       or follow a ;.  In the third (obsolete) form, the string between the\n       quotes is processed for special quoting characters before the command\n       is executed (see Quoting below).  The command substitution $(cat file)\n       can be replaced by the equivalent but faster $(<file).  The command\n       substitution $(n<#) will expand to the current byte offset for file\n       descriptor n.  Except for the second form, the command list is run in a\n       subshell so that no side effects are possible.  For the second form,\n       the final } will be recognized as a reserved word after any token."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use command substitution in ksh to capture the output of the ls -l command and assign it to a variable?
  manpageQuestion3: Can you explain how tilde substitution works in ksh when expanding a variable assignment that starts with a ~?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nArithmetic Substitution.\n       An arithmetic expression enclosed in double parentheses preceded by a\n       dollar sign ( $(()) ) is replaced by the value of the arithmetic\n       expression within the double parentheses.\n\n   Process Substitution.\n       Each command argument of the form <(list) or >(list) will run process\n       list asynchronously connected to some file in /dev/fd if this directory\n       exists, or else a fifo a temporary directory.  The name of this file\n       will become the argument to the command.  If the form with > is\n       selected then writing on this file will provide input for list.\tIf <\n       is used, then the file passed as an argument will contain the output of\n       the list process.  For example,\n\n\t      paste <(cut -f1 file1) <(cut -f3 file2) | tee >(process1)\n\t      >(process2)\n\n       cuts fields 1 and 3 from the files file1 and file2 respectively, pastes\n       the results together, and sends it to the processes process1 and\n       process2, as well as putting it onto the standard output.  Note that\n       the file, which is passed as an argument to the command, is a UNIX\n       pipe(2) so programs that expect to lseek(2) on the file will not work."
  manpageQuestion1: What is the primary purpose of the ksh shell's arithmetic substitution and process substitution features?
  manpageQuestion2: How can you use ksh's process substitution to combine the first field of file1 and the third field of file2, then send the result to both process1 and process2 while also outputting it to standard output?
  manpageQuestion3: Can you provide an example of using ksh's arithmetic substitution to calculate the sum of two numbers, 15 and 27, and output the result?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nProcess substitution of the form <(list) can also be used with the <\n       redirection operator which causes the output of list to be standard\n       input or the input for whatever file descriptor is specified.\n\n   Parameter Expansion.\n       A parameter is a variable, one or more digits, or any of the characters\n       ∗, @, #, ?, -, $, and !.  A variable is denoted by a vname.  To create\n       a variable whose vname contains a ., a variable whose vname consists of\n       everything before the last . must already exist.  A variable has a\n       value and zero or more attributes.  Variables can be assigned values\n       and attributes by using the typeset special built-in command.  The\n       attributes supported by the shell are described later with the typeset\n       special built-in command.  Exported variables pass values and\n       attributes to the environment.\n\n       The shell supports both indexed and associative arrays.\tAn element of\n       an array variable is referenced by a subscript.\tA subscript for an\n       indexed array is denoted by an arithmetic expression (see Arithmetic\n       evaluation below) between a [ and a ].  To assign values to an indexed\n       array, use vname=(value ...) or set -A vname  value ... .  The value of\n       all non-negative subscripts must be in the range of 0 through\n       4,194,303.  A negative subscript is treated as an offset from the\n       maximum current index +1 so that -1 refers to the last element.\n       Indexed arrays can be declared with the -a option to typeset.  Indexed\n       arrays need not be declared.  Any reference to a variable with a valid\n       subscript is legal and an array will be created if necessary."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use parameter expansion in ksh to access the value of a variable named 'myvar'?
  manpageQuestion3: Can you explain how to declare and assign values to an indexed array in ksh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nAn associative array is created with the -A option to typeset.  A\n       subscript for an associative array is denoted by a string enclosed\n       between [ and ].\n\n       Referencing any array without a subscript is equivalent to referencing\n       the array with subscript 0.\n\n       The value of a variable may be assigned by writing:\n\n\t      vname=value [ vname=value ] ...\n\n       or\n\t      vname[subscript]=value [ vname[subscript]=value ] ...\n       Note that no space is allowed before or after the =.\n       Attributes assigned by the typeset special built-in command apply to\n       all elements of the array.  An array element can be a simple variable,\n       a compound variable or an array variable.  An element of an indexed\n       array can be either an indexed array or an associative array.  An\n       element of an associative array can also be either.  To refer to an\n       array element that is part of an array element, concatenate the\n       subscript in brackets.  For example, to refer to the foobar element of\n       an associative array that is defined as the third element of the\n       indexed array, use ${vname[3][foobar]}\n       A nameref is a variable that is a reference to another variable.  A\n       nameref is created with the -n attribute of typeset.  The value of the\n       variable at the time of the typeset command becomes the variable that\n       will be referenced whenever the nameref variable is used.  The name of\n       a nameref cannot contain a ..  When a variable or function name\n       contains a ., and the portion of the name up to the first . matches the\n       name of a nameref, the variable referred to is obtained by replacing\n       the nameref portion with the name of the variable referenced by the\n       nameref.  If a nameref is used as the index of a for loop, a name\n       reference is established for each item in the list.  A nameref provides\n       a convenient way to refer to the variable inside a function whose name\n       is passed as an argument to a function.\tFor example, if the name of a\n       variable is passed as the first argument to a function, the command\n\t      typeset -n var=$1\n       inside the function causes references and assignments to var to be\n       references and assignments to the variable whose name has been passed\n       to the function.\n       If any of the floating point attributes, -E, -F, or -X, or the integer\n       attribute, -i, is set for vname, then the value is subject to\n       arithmetic evaluation as described below.\n       Positional parameters, parameters denoted by a number, may be assigned\n       values with the set special built-in command.  Parameter $0 is set from\n       argument zero when the shell is invoked.\n       The character $ is used to introduce substitutable parameters.\n       ${parameter}\n\t      The shell reads all the characters from ${ to the matching } as\n\t      part of the same word even if it contains braces or\n\t      metacharacters.  The value, if any, of the parameter is\n\t      substituted.  The braces are required when parameter is followed\n\t      by a letter, digit, or underscore that is not to be interpreted\n\t      as part of its name, when the variable name contains a ..  The\n\t      braces are also required when a variable is subscripted unless\n\t      it is part of an Arithmetic Expression or a Conditional\n\t      Expression.  If parameter is one or more digits then it is a\n\t      positional parameter.  A positional parameter of more than one\n\t      digit must be enclosed in braces.  If parameter is ∗ or @, then\n\t      all the positional parameters, starting with $1, are substituted\n\t      (separated by a field separator character).  If an array vname\n\t      with last subscript ∗ @, or for index arrays of the form sub1 ..\n\t      sub2.  is used, then the value for each of the elements between\n\t      sub1 and sub2 inclusive (or all elements for ∗ and @) is\n\t      substituted, separated by the first character of the value of\n\t      IFS.\n       ${#parameter}\n\t      If parameter is ∗ or @, the number of positional parameters is\n\t      substituted.  Otherwise, the length of the value of the\n\t      parameter is substituted.\n       ${#vname[*]}\n       ${#vname[@]}\n\t      The number of elements in the array vname is substituted."
  manpageQuestion1: What is the primary purpose of the ksh shell in this context?
  manpageQuestion2: How would you use ksh to create an associative array and assign a value to a specific subscript?
  manpageQuestion3: Can you provide an example of using namerefs in ksh to pass a variable name as an argument to a function?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n${@vname}\n\t      Expands to the type name (See Type Variables  below) or\n\t      attributes of the variable referred to by vname.\n       ${!vname}\n\t      Expands to the name of the variable referred to by vname.  This\n\t      will be vname except when vname is a name reference.\n       ${!vname[subscript]}\n\t      Expands to name of the subscript unless subscript is *, @.  or\n\t      of the form sub1 ..  sub2.  When subscript is *, the list of\n\t      array subscripts for vname is generated.\tFor a variable that is\n\t      not an array, the value is 0 if the variable is set.  Otherwise\n\t      it is null.  When subscript is @, same as above, except that\n\t      when used in double quotes, each array subscript yields a\n\t      separate argument.  When subscript is of the form sub1 ..  sub2\n\t      it expands to the list of subscripts between sub1 and sub2\n\t      inclusive using the same quoting rules as @.\n       ${!prefix*}\n\t      Expands to the names of the variables whose names begin with\n\t      prefix.\n       ${parameter:-word}\n\t      If parameter is set and is non-null then substitute its value;\n\t      otherwise substitute word.\n       ${parameter:=word}\n\t      If parameter is not set or is null then set it to word; the\n\t      value of the parameter is then substituted.  Positional\n\t      parameters may not be assigned to in this way.\n       ${parameter:?word}\n\t      If parameter is set and is non-null then substitute its value;\n\t      otherwise, print word and exit from the shell (if not\n\t      interactive).  If word is omitted then a standard message is\n\t      printed.\n       ${parameter:+word}\n\t      If parameter is set and is non-null then substitute word;\n\t      otherwise substitute nothing.\n       In the above, word is not evaluated unless it is to be used as the\n       substituted string, so that, in the following example, pwd is executed\n       only if d is not set or is null:\n\t      print ${d:-$(pwd)}\n       If the colon ( : ) is omitted from the above expressions, then the\n       shell only checks whether parameter is set or not.\n       ${parameter:offset:length}\n       ${parameter:offset}\n\t      Expands to the portion of the value of parameter starting at the\n\t      character (counting from 0) determined by expanding offset as an\n\t      arithmetic expression and consisting of the number of characters\n\t      determined by the arithmetic expression defined by length.  In\n\t      the second form, the remainder of the value is used.  If A\n\t      negative offset counts backwards from the end of parameter.\n\t      Note that one or more blanks is required in front of a minus\n\t      sign to prevent the shell from interpreting the operator as :-.\n\t      If parameter is ∗ or @, or is an array name indexed by ∗ or @,\n\t      then offset and length refer to the array index and number of\n\t      elements respectively.  A negative offset is taken relative to\n\t      one greater than the highest subscript for indexed arrays.  The\n\t      order for associate arrays is unspecified.\n       ${parameter#pattern}\n       ${parameter##pattern}\n\t      If the shell pattern matches the beginning of the value of\n\t      parameter, then the value of this expansion is the value of the\n\t      parameter with the matched portion deleted; otherwise the value\n\t      of this parameter is substituted.  In the first form the\n\t      smallest matching pattern is deleted and in the second form the\n\t      largest matching pattern is deleted.  When parameter is @, *, or\n\t      an array variable with subscript @ or *, the substring operation\n\t      is applied to each element in turn."
  manpageQuestion1: What is the primary purpose of the ksh shell's parameter expansion features?
  manpageQuestion2: How can you use ${parameter:-word} to provide a default value for a variable if it is not set or empty?
  manpageQuestion3: Can you demonstrate how to use ${parameter#pattern} to remove the smallest matching pattern from a string?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n${parameter%pattern}\n       ${parameter%%pattern}\n\t      If the shell pattern matches the end of the value of parameter,\n\t      then the value of this expansion is the value of the parameter\n\t      with the matched part deleted; otherwise substitute the value of\n\t      parameter.  In the first form the smallest matching pattern is\n\t      deleted and in the second form the largest matching pattern is\n\t      deleted.\tWhen parameter is @, *, or an array variable with\n\t      subscript @ or *, the substring operation is applied to each\n\t      element in turn.\n\n       ${parameter/pattern/string}\n       ${parameter//pattern/string}\n       ${parameter/#pattern/string}\n       ${parameter/%pattern/string}\n\t      Expands parameter and replaces the longest match of pattern with\n\t      the given string.  Each occurrence of \\n in string is replaced\n\t      by the portion of parameter that matches the n-th sub-pattern.\n\t      In the first form, only the first occurrence of pattern is\n\t      replaced.  In the second form, each match for pattern is\n\t      replaced by the given string.  The third form restricts the\n\t      pattern match to the beginning of the string while the fourth\n\t      form restricts the pattern match to the end of the string.  When\n\t      string is null, the pattern will be deleted and the / in front\n\t      of string may be omitted.  When parameter is @, *, or an array\n\t      variable with subscript @ or *, the substitution operation is\n\t      applied to each element in turn.\tIn this case, the string\n\t      portion of word will be re-evaluated for each element."
  manpageQuestion1: What is the primary purpose of the ksh shell parameter expansion features?
  manpageQuestion2: How would you use parameter expansion in ksh to remove the last three characters from a variable named 'filename'?
  manpageQuestion3: Can you provide an example of using ksh parameter expansion to replace the first occurrence of the substring 'apple' with 'banana' in a variable named 'fruit_list'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThe following parameters are automatically set by the shell:\n\t      #      The number of positional parameters in decimal.\n\t      -      Options supplied to the shell on invocation or by the set\n\t\t     command.\n\t      ?      The decimal value returned by the last executed command.\n\t      $      The process number of this shell.\n\t      _      Initially, the value of _ is an absolute pathname of the\n\t\t     shell or script being executed as passed in the\n\t\t     environment.  Subsequently it is assigned the last\n\t\t     argument of the previous command.\tThis parameter is not\n\t\t     set for commands which are asynchronous.  This parameter\n\t\t     is also used to hold the name of the matching MAIL file\n\t\t     when checking for mail.  While defining a compound\n\t\t     variable or a type, _ is initialized as a reference to\n\t\t     the compound variable or type.  When a discipline\n\t\t     function is invoked, _ is initialized as a reference to\n\t\t     the variable associated with the call to this function.\n\t\t     Finally when _ is used as the name of the first variable\n\t\t     of a type definition, the new type is derived from the\n\t\t     type of the first variable (See Type Variables  below.).\n\t      !      The process id or the pool name and job number of the\n\t\t     last background command invoked or the most recent job\n\t\t     put in the background with the bg built-in command.\n\t\t     Background jobs started in a named pool will be in the\n\t\t     form pool.number where pool is the pool name and number\n\t\t     is the job number within that pool.\n\t      .sh.command\n\t\t     When processing a DEBUG trap, this variable contains the\n\t\t     current command line that is about to run.\n\t      .sh.edchar\n\t\t     This variable contains the value of the keyboard\n\t\t     character (or sequence of characters if the first\n\t\t     character is an ESC, ascii 033) that has been entered\n\t\t     when processing a KEYBD trap (see Key Bindings below).\n\t\t     If the value is changed as part of the trap action, then\n\t\t     the new value replaces the key (or key sequence) that\n\t\t     caused the trap.\n\t      .sh.edcol\n\t\t     The character position of the cursor at the time of the\n\t\t     most recent KEYBD trap.\n\t      .sh.edmode\n\t\t     The value is set to ESC when processing a KEYBD trap\n\t\t     while in vi insert mode.  (See Vi Editing Mode  below.)\n\t\t     Otherwise, .sh.edmode is null when processing a KEYBD\n\t\t     trap.\n\t      .sh.edtext\n\t\t     The characters in the input buffer at the time of the\n\t\t     most recent KEYBD trap.  The value is null when not\n\t\t     processing a KEYBD trap.\n\t      .sh.file\n\t\t     The pathname of the file than contains the current\n\t\t     command.\n\t      .sh.fun\n\t\t     The name of the current function that is being executed.\n\t      .sh.level\n\t\t     Set to the current function depth.  This can be changed\n\t\t     inside a DEBUG trap and will set the context to the\n\t\t     specified level.\n\t      .sh.lineno\n\t\t     Set during a DEBUG trap to the line number for the caller\n\t\t     of each function.\n\t      .sh.match\n\t\t     An indexed array which stores the most recent match and\n\t\t     sub-pattern matches after conditional pattern matches\n\t\t     that match and after variables expansions using the\n\t\t     operators #, %, or /.  The 0-th element stores the\n\t\t     complete match and the i-th.  element stores the i-th\n\t\t     submatch.\tThe .sh.match variable becomes unset when the\n\t\t     variable that has expanded is assigned a new value.\n\t      .sh.math\n\t\t     Used for defining arithmetic functions (see Arithmetic\n\t\t     evaluation below).  and stores the list of user defined\n\t\t     arithmetic functions.\n\t      .sh.name\n\t\t     Set to the name of the variable at the time that a\n\t\t     discipline function is invoked.\n\t      .sh.subscript\n\t\t     Set to the name subscript of the variable at the time\n\t\t     that a discipline function is invoked.\n\t      .sh.subshell\n\t\t     The current depth for subshells and command substitution.\n\t      .sh.value\n\t\t     Set to the value of the variable at the time that the set\n\t\t     or append discipline function is invoked.\tWhen a user\n\t\t     defined arithmetic function is invoked, the value of\n\t\t     .sh.value is saved and .sh.value is set to long double\n\t\t     precision floating point.\t.sh.value is restored when the\n\t\t     function returns.\n\t      .sh.version\n\t\t     Set to a value that identifies the version of this shell.\n\t      KSH_VERSION\n\t\t     A name reference to .sh.version.\n\t      LINENO The current line number within the script or function\n\t\t     being executed.\n\t      OLDPWD The previous working directory set by the cd command.\n\t      OPTARG The value of the last option argument processed by the\n\t\t     getopts built-in command.\n\t      OPTIND The index of the last option argument processed by the\n\t\t     getopts built-in command.\n\t      PPID   The process number of the parent of the shell.\n\t      PWD    The present working directory set by the cd command.\n\t      RANDOM Each time this variable is referenced, a random integer,\n\t\t     uniformly distributed between 0 and 32767, is generated.\n\t\t     The sequence of random numbers can be initialized by\n\t\t     assigning a numeric value to RANDOM.\n\t      REPLY  This variable is set by the select statement and by the\n\t\t     read built-in command when no arguments are supplied.\n\t      SECONDS\n\t\t     Each time this variable is referenced, the number of\n\t\t     seconds since shell invocation is returned.  If this\n\t\t     variable is assigned a value, then the value returned\n\t\t     upon reference will be the value that was assigned plus\n\t\t     the number of seconds since the assignment.\n\t      SHLVL  An integer variable the is incremented each time the\n\t\t     shell is invoked and is exported.\tIf SHLVL is not in the\n\t\t     environment when the shell is invoked, it is set to 1."
  manpageQuestion1: What is the primary purpose of the ksh shell's special variables?
  manpageQuestion2: How can you retrieve the process ID of the current shell using ksh?
  manpageQuestion3: Can you provide an example of using the .sh.file variable to access the current command's file path?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThe following variables are used by the shell:\n\t      CDPATH The search path for the cd command.\n\t      COLUMNS\n\t\t     If this variable is set, the value is used to define the\n\t\t     width of the edit window for the shell edit modes and for\n\t\t     printing select lists.\n\t      EDITOR If the VISUAL variable is not set, the value of this\n\t\t     variable will be checked for the patterns as described\n\t\t     with VISUAL below and the corresponding editing option\n\t\t     (see Special Command set below) will be turned on.\n\t      ENV    If this variable is set, then parameter expansion,\n\t\t     command substitution, and arithmetic substitution are\n\t\t     performed on the value to generate the pathname of the\n\t\t     script that will be executed when the shell is invoked\n\t\t     interactively (see Invocation below).  This file is\n\t\t     typically used for alias and function definitions.  The\n\t\t     default value is $HOME/.kshrc.  On systems that support a\n\t\t     system wide  /etc/ksh.kshrc initialization file, if the\n\t\t     filename generated by the expansion of ENV begins with\n\t\t     /./ or ././ the system wide initialization file will not\n\t\t     be executed.\n\t      FCEDIT Obsolete name for the default editor name for the hist\n\t\t     command.  FCEDIT is not used when HISTEDIT is set.\n\t      FIGNORE\n\t\t     A pattern that defines the set of filenames that will be\n\t\t     ignored when performing filename matching.\n\t      FPATH  The search path for function definitions.\tThe\n\t\t     directories in this path are searched for a file with the\n\t\t     same name as the function or command when a function with\n\t\t     the -u attribute is referenced and when a command is not\n\t\t     found.  If an executable file with the name of that\n\t\t     command is found, then it is read and executed in the\n\t\t     current environment.  Unlike PATH, the current directory\n\t\t     must be represented explicitly by .  rather than by\n\t\t     adjacent : characters or a beginning or ending :.\n\t      HISTCMD\n\t\t     Number of the current command in the history file.\n\t      HISTEDIT\n\t\t     Name for the default editor name for the hist command.\n\t      HISTFILE\n\t\t     If this variable is set when the shell is invoked, then\n\t\t     the value is the pathname of the file that will be used\n\t\t     to store the command history (see Command Re-entry\n\t\t     below).\n\t      HISTSIZE\n\t\t     If this variable is set when the shell is invoked, then\n\t\t     the number of previously entered commands that are\n\t\t     accessible by this shell will be greater than or equal to\n\t\t     this number.  The default is 512.\n\t      HOME   The default argument (home directory) for the cd command.\n\t      IFS    Internal field separators, normally space, tab, and\n\t\t     new-line that are used to separate the results of command\n\t\t     substitution or parameter expansion and to separate\n\t\t     fields with the built-in command read.  The first\n\t\t     character of the IFS variable is used to separate\n\t\t     arguments for the \"$∗\" substitution (see Quoting below).\n\t\t     Each single occurrence of an IFS character in the string\n\t\t     to be split, that is not in the isspace character class,\n\t\t     and any adjacent characters in IFS that are in the\n\t\t     isspace character class, delimit a field.\tOne or more\n\t\t     characters in IFS that belong to the isspace character\n\t\t     class, delimit a field.  In addition, if the same isspace\n\t\t     character appears consecutively inside IFS, this\n\t\t     character is treated as if it were not in the isspace\n\t\t     class, so that if IFS consists of two tab characters,\n\t\t     then two adjacent tab characters delimit a null field.\n\t      JOBMAX This variable defines the maximum number running\n\t\t     background jobs that can run at a time.  When this limit\n\t\t     is reached, the shell will wait for a job to complete\n\t\t     before staring a new job.\n\t      LANG   This variable determines the locale category for any\n\t\t     category not specifically selected with a variable\n\t\t     starting with LC_ or LANG.\n\t      LC_ALL This variable overrides the value of the LANG variable\n\t\t     and any other LC_ variable.\n\t      LC_COLLATE\n\t\t     This variable determines the locale category for\n\t\t     character collation information.\n\t      LC_CTYPE\n\t\t     This variable determines the locale category for\n\t\t     character handling functions.  It determines the\n\t\t     character classes for pattern matching (see File Name\n\t\t     Generation below).\n\t      LC_NUMERIC\n\t\t     This variable determines the locale category for the\n\t\t     decimal point character.\n\t      LINES  If this variable is set, the value is used to determine\n\t\t     the column length for printing select lists.  Select\n\t\t     lists will print vertically until about two-thirds of\n\t\t     LINES lines are filled.\n\t      MAIL   If this variable is set to the name of a mail file and\n\t\t     the MAILPATH variable is not set, then the shell informs\n\t\t     the user of arrival of mail in the specified file.\n\t      MAILCHECK\n\t\t     This variable specifies how often (in seconds) the shell\n\t\t     will check for changes in the modification time of any of\n\t\t     the files specified by the MAILPATH or MAIL variables.\n\t\t     The default value is 600 seconds.\tWhen the time has\n\t\t     elapsed the shell will check before issuing the next\n\t\t     prompt.\n\t      MAILPATH\n\t\t     A colon ( : ) separated list of file names.  If this\n\t\t     variable is set, then the shell informs the user of any\n\t\t     modifications to the specified files that have occurred\n\t\t     within the last MAILCHECK seconds.  Each file name can be\n\t\t     followed by a ?  and a message that will be printed.  The\n\t\t     message will undergo parameter expansion, command\n\t\t     substitution, and arithmetic substitution with the\n\t\t     variable $_ defined as the name of the file that has\n\t\t     changed.  The default message is you have mail in $_.\n\t      PATH   The search path for commands (see Execution below).  The\n\t\t     user may not change PATH if executing under rksh (except\n\t\t     in .profile).\n\t      PS1    The value of this variable is expanded for parameter\n\t\t     expansion, command substitution, and arithmetic\n\t\t     substitution to define the primary prompt string which by\n\t\t     default is ``$''.\tThe character !  in the primary prompt\n\t\t     string is replaced by the command number (see Command\n\t\t     Re-entry below).  Two successive occurrences of !\twill\n\t\t     produce a single !  when the prompt string is printed.\n\t      PS2    Secondary prompt string, by default ``> ''.\n\t      PS3    Selection prompt string used within a select loop, by\n\t\t     default ``#? ''.\n\t      PS4    The value of this variable is expanded for parameter\n\t\t     evaluation, command substitution, and arithmetic\n\t\t     substitution and precedes each line of an execution\n\t\t     trace.  By default, PS4 is ``+ ''.  In addition when PS4\n\t\t     is unset, the execution trace prompt is also ``+ ''.\n\t      SHELL  The pathname of the shell is kept in the environment.  At\n\t\t     invocation, if the basename of this variable is rsh,\n\t\t     rksh, or krsh, then the shell becomes restricted.\tIf it\n\t\t     is pfsh or pfksh, then the shell becomes a profile shell\n\t\t     (see pfexec(1)).\n\t      TIMEFORMAT\n\t\t     The value of this parameter is used as a format string\n\t\t     specifying how the timing information for pipelines\n\t\t     prefixed with the time reserved word should be displayed.\n\t\t     The % character introduces a format sequence that is\n\t\t     expanded to a time value or other information.  The\n\t\t     format sequences and their meanings are as follows.\n\t\t     %%        A literal %.\n\t\t     %[p][l]R  The elapsed time in seconds.\n\t\t     %[p][l]U  The number of CPU seconds spent in user mode.\n\t\t     %[p][l]S  The number of CPU seconds spent in system mode.\n\t\t     %P        The CPU percentage, computed as (U + S) / R."
  manpageQuestion1: What is the primary purpose of the ksh shell variables?
  manpageQuestion2: How would you configure the ksh shell to use a custom editor for filename editing operations?
  manpageQuestion3: Can you provide an example of using the HISTFILE variable to store command history in a specific file?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThe brackets denote optional portions.  The optional p is\n\t\t     a digit specifying the precision, the number of\n\t\t     fractional digits after a decimal point.  A value of 0\n\t\t     causes no decimal point or fraction to be output.\tAt\n\t\t     most three places after the decimal point can be\n\t\t     displayed; values of p greater than 3 are treated as 3.\n\t\t     If p is not specified, the value 3 is used.\n\n\t\t     The optional l specifies a longer format, including hours\n\t\t     if greater than zero, minutes, and seconds of the form\n\t\t     HHhMMmSS.FFs.  The value of p determines whether or not\n\t\t     the fraction is included.\n\n\t\t     All other characters are output without change and a\n\t\t     trailing newline is added.  If unset, the default value,\n\t\t     $'\\nreal\\t%2lR\\nuser\\t%2lU\\nsys%2lS', is used.  If the\n\t\t     value is null, no timing information is displayed.\n\n\t      TMOUT  If set to a value greater than zero, TMOUT will be the\n\t\t     default timeout value for the read built-in command.  The\n\t\t     select compound command terminates after TMOUT seconds\n\t\t     when input is from a terminal.  Otherwise, the shell will\n\t\t     terminate if a line is not entered within the prescribed\n\t\t     number of seconds while reading from a terminal.  (Note\n\t\t     that the shell can be compiled with a maximum bound for\n\t\t     this value which cannot be exceeded.)"
  manpageQuestion1: What is the primary purpose of the ksh shell command?
  manpageQuestion2: How can you format the output of a command to display elapsed time in hours, minutes, and seconds with three decimal places using ksh?
  manpageQuestion3: What is the default behavior of the ksh shell when no timing information is specified?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nVISUAL If the value of this variable matches the pattern\n\t\t     *[Vv][Ii]*, then the vi option (see Special Command set\n\t\t     below) is turned on.  If the value matches the pattern\n\t\t     *gmacs* , the gmacs option is turned on.  If the value\n\t\t     matches the pattern *macs*, then the emacs option will be\n\t\t     turned on.  The value of VISUAL overrides the value of\n\t\t     EDITOR.\n\n       The shell gives default values to PATH, PS1, PS2, PS3, PS4, MAILCHECK,\n       FCEDIT, TMOUT and IFS, while HOME, SHELL, ENV, and MAIL are not set at\n       all by the shell (although HOME is set by login(1)).  On some systems\n       MAIL and SHELL are also set by login(1).\n\n   Field Splitting.\n       After parameter expansion and command substitution, the results of\n       substitutions are scanned for the field separator characters (those\n       found in IFS) and split into distinct fields where such characters are\n       found.  Explicit null fields (\"\" or ′′) are retained.  Implicit null\n       fields (those resulting from parameters that have no values or command\n       substitutions with no output) are removed."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you configure the ksh shell to use the vi editor for interactive sessions?
  manpageQuestion3: What is the effect of setting the VISUAL variable to 'macs' in the ksh shell?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    If the braceexpand (-B) option is set then each of the fields resulting
           from IFS are checked to see if they contain one or more of the brace
           patterns {*,*}, {l1..l2} , {n1..n2} , {n1..n2% fmt} , {n1..n2 ..n3} ,
           or {n1..n2 ..n3%fmt} , where * represents any character, l1,l2 are
           letters and n1,n2,n3 are signed numbers and fmt is a format specified
           as used by printf.  In each case, fields are created by prepending the
           characters before the { and appending the characters after the } to
           each of the strings generated by the characters between the { and }.
           The resulting fields are checked to see if they have any brace
           patterns.

           In the first form, a field is created for each string between { and ,,
           between , and ,, and between , and }.  The string represented by * can
           contain embedded matching { and } without quoting.  Otherwise, each {
           and } with * must be quoted.

           In the seconds form, l1 and l2 must both be either upper case or both
           be lower case characters in the C locale.  In this case a field is
           created for each character from l1 thru l2.
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use brace expansion in ksh to generate a list of filenames matching a pattern like 'file{1..5}.txt', and what is the resulting output?
  manpageQuestion3: Can you explain how to use ksh's brace expansion to create a sequence of numbers from 10 to 20 with a step of 2, and provide an example command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nIn the remaining forms, a field is created for each number starting at\n       n1 and continuing until it reaches n2 incrementing n1 by n3.  The cases\n       where n3 is not specified behave as if n3 where 1 if n1<=n2 and -1\n       otherwise.  If forms which specify %fmt any format flags, widths and\n       precisions can be specified and fmt can end in any of the specifiers\n       cdiouxX.  For example, {a,z}{1..5..3%02d}{b..c}x expands to the 8\n       fields, a01bx, a01cx, a04bx, a04cx, z01bx, z01cx, z04bx and z4cx.\n\n   File Name Generation.\n       Following splitting, each field is scanned for the characters ∗, ?, (,\n       and [ unless the -f option has been set.  If one of these characters\n       appears, then the word is regarded as a pattern.  Each file name\n       component that contains any pattern character is replaced with a\n       lexicographically sorted set of names that matches the pattern from\n       that directory.\tIf no file name is found that matches the pattern,\n       then that component of the filename is left unchanged unless the\n       pattern is prefixed with ∼(N) in which case it is removed as described\n       below.  If FIGNORE is set, then each file name component that matches\n       the pattern defined by the value of FIGNORE is ignored when generating\n       the matching filenames.\tThe names .  and ..  are also ignored.\tIf\n       FIGNORE is not set, the character .  at the start of each file name\n       component will be ignored unless the first character of the pattern\n       corresponding to this component is the character .  itself.  Note, that\n       for other uses of pattern matching the / and .  are not treated\n       specially."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you generate a list of filenames using patterns in ksh?
  manpageQuestion3: What is the effect of setting the FIGNORE variable in ksh when generating filenames?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n∗      Matches any string, including the null string.  When used\n\t\t     for filename expansion, if the globstar option is on, two\n\t\t     adjacent ∗'s by itself will match all files and zero or\n\t\t     more directories and subdirectories.  If followed by a /\n\t\t     then only directories and subdirectories will match.\n\t      ?      Matches any single character.\n\t      [...]  Matches any one of the enclosed characters.  A pair of\n\t\t     characters separated by - matches any character lexically\n\t\t     between the pair, inclusive.  If the first character\n\t\t     following the opening [ is a !  or ^ then any character\n\t\t     not enclosed is matched.  A - can be included in the\n\t\t     character set by putting it as the first or last\n\t\t     character.\n\t\t     Within [ and ], character classes can be specified with\n\t\t     the syntax [:class:] where class is one of the following\n\t\t     classes defined in the ANSI-C standard: (Note that word\n\t\t     is equivalent to alnum plus the character _.)\n\t\t     alnum alpha blank cntrl digit graph lower print punct\n\t\t     space upper word xdigit\n\t\t     Within [ and ], an equivalence class can be specified\n\t\t     with the syntax [=c=] which matches all characters with\n\t\t     the same primary collation weight (as defined by the\n\t\t     current locale) as the character c.  Within [ and ],\n\t\t     [.symbol.] matches the collating symbol symbol.\n       A pattern-list is a list of one or more patterns separated from each\n       other with a & or ⎪.  A & signifies that all patterns must be matched\n       whereas ⎪ requires that only one pattern be matched.  Composite\n       patterns can be formed with one or more of the following sub-patterns:\n\t      ?(pattern-list)\n\t\t     Optionally matches any one of the given patterns.\n\t      *(pattern-list)\n\t\t     Matches zero or more occurrences of the given patterns.\n\t      +(pattern-list)\n\t\t     Matches one or more occurrences of the given patterns.\n\t      {n}(pattern-list)\n\t\t     Matches n occurrences of the given patterns.\n\t      {m,n}(pattern-list)\n\t\t     Matches from m to n occurrences of the given patterns.\n\t\t     If m is omitted, 0 will be used.  If n is omitted at\n\t\t     least m occurrences will be matched.\n\t      @(pattern-list)\n\t\t     Matches exactly one of the given patterns.\n\t      !(pattern-list)\n\t\t     Matches anything except one of the given patterns.\n       By default, each pattern, or sub-pattern will match the longest string\n       possible consistent with generating the longest overall match.  If more\n       than one match is possible, the one starting closest to the beginning\n       of the string will be chosen.   However, for each of the above compound\n       patterns a - can be inserted in front of the ( to cause the shortest\n       match to the specified pattern-list to be used."
  manpageQuestion1: What is the primary purpose of the ksh shell's pattern matching system?
  manpageQuestion2: How can you use ksh pattern matching to match any file name that starts with 'a' and ends with '.txt'?
  manpageQuestion3: Can you provide an example of using ksh's pattern matching to match a string that contains either 'apple' or 'banana', but not both?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nWhen pattern-list is contained within parentheses, the backslash\n       character \\ is treated specially even when inside a character class.\n       All ANSI-C character escapes are recognized and match the specified\n       character.  In addition the following escape sequences are recognized:\n\t      \\d     Matches any character in the digit class.\n\t      \\D     Matches any character not in the digit class.\n\t      \\s     Matches any character in the space class.\n\t      \\S     Matches any character not in the space class.\n\t      \\w     Matches any character in the word class.\n\t      \\W     Matches any character not in the word class.\n\n       A pattern of the form %(pattern-pair(s)) is a sub-pattern that can be\n       used to match nested character expressions.  Each pattern-pair is a two\n       character sequence which cannot contain & or ⎪.\tThe first pattern-pair\n       specifies the starting and ending characters for the match.  Each\n       subsequent pattern-pair represents the beginning and ending characters\n       of a nested group that will be skipped over when counting starting and\n       ending character matches.  The behavior is unspecified when the first\n       character of a pattern-pair is alpha-numeric except for the following:\n\t      D      Causes the ending character to terminate the search for\n\t\t     this pattern without finding a match.\n\t      E      Causes the ending character to be interpreted as an\n\t\t     escape character.\n\t      L      Causes the ending character to be interpreted as a quote\n\t\t     character causing all characters to be ignored when\n\t\t     looking for a match.\n\t      Q      Causes the ending character to be interpreted as a quote\n\t\t     character causing all characters other than any escape\n\t\t     character to be ignored when looking for a match.\n       Thus, %({}Q\"E\\), matches characters starting at { until the matching }\n       is found not counting any { or } that is inside a double quoted string\n       or preceded by the escape character \\.  Without the {} this pattern\n       matches any C language string."
  manpageQuestion1: What is the primary purpose of the ksh shell in macOS?
  manpageQuestion2: How can you use the ksh shell to match characters in a string using the %({}Q)
  manpageQuestion3: What is the function of the escape sequence \d in ksh pattern matching?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nEach sub-pattern in a composite pattern is numbered, starting at 1, by\n       the location of the ( within the pattern.  The sequence \\n, where n is\n       a single digit and \\n comes after the n-th. sub-pattern, matches the\n       same string as the sub-pattern itself.\n\n       Finally a pattern can contain sub-patterns of the form\n       ∼(options:pattern-list), where either options or :pattern-list can be\n       omitted.  Unlike the other compound patterns, these sub-patterns are\n       not counted in the numbered sub-patterns.  :pattern-list must be\n       omitted for options F, G, N , and V below.  If options is present, it\n       can consist of one or more of the following:\n\t      +      Enable the following options.  This is the default.\n\t      -      Disable the following options.\n\t      E      The remainder of the pattern uses extended regular\n\t\t     expression syntax like the egrep(1) command.\n\t      F      The remainder of the pattern uses fgrep(1) expression\n\t\t     syntax.\n\t      G      The remainder of the pattern uses basic regular\n\t\t     expression syntax like the grep(1) command.\n\t      K      The remainder of the pattern uses shell pattern syntax.\n\t\t     This is the default.\n\t      N      This is ignored.  However, when it is the first letter\n\t\t     and is used with file name generation, and no matches\n\t\t     occur, the file pattern expands to the empty string.\n\t      X      The remainder of the pattern uses augmented regular\n\t\t     expression syntax like the xgrep(1) command.\n\t      P      The remainder of the pattern uses perl(1) regular\n\t\t     expression syntax.  Not all perl regular expression\n\t\t     syntax is currently implemented.\n\t      V      The remainder of the pattern uses System V regular\n\t\t     expression syntax.\n\t      i      Treat the match as case insensitive.\n\t      g      File the longest match (greedy).  This is the default.\n\t      l      Left anchor the pattern.  This is the default for K style\n\t\t     patterns.\n\t      r      Right anchor the pattern.\tThis is the default for K\n\t\t     style patterns.\n       If both options and :pattern-list are specified, then the options apply\n       only to\tpattern-list.  Otherwise, these options remain in effect until\n       they are disabled by a subsequent ∼(...) or at the end of the sub-\n       pattern containing ∼(...)."
  manpageQuestion1: What is the primary purpose of the ksh shell in the context of pattern matching?
  manpageQuestion2: How can you use the ksh shell to perform case-insensitive matching with extended regular expressions in a sub-pattern?
  manpageQuestion3: Can you explain how to use the ksh shell's ∼(options:pattern-list) syntax to specify a pattern that uses basic regular expression syntax with optional options?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nQuoting.\n       Each of the metacharacters listed earlier (see Definitions above) has a\n       special meaning to the shell and causes termination of a word unless\n       quoted.\tA character may be quoted (i.e., made to stand for itself) by\n       preceding it with a \\.  The pair \\new-line is removed.  All characters\n       enclosed between a pair of single quote marks (′′) that is not preceded\n       by a $ are quoted.  A single quote cannot appear within the single\n       quotes.\tA single quoted string preceded by an unquoted $ is processed\n       as an ANSI-C string except for the following:\n       \\0     Causes the remainder of the string to be ignored.\n       \\E     Equivalent to the escape character (ascii 033),\n       \\e     Equivalent to the escape character (ascii 033),\n       \\cx    Expands to the character control-x.\n       \\C[.name.]\n\t      Expands to the collating element name.\n\n       Inside double quote marks (\"\"), parameter and command substitution\n       occur and \\ quotes the characters \\, `, \", and $.  A $ in front of a\n       double quoted string will be ignored in the \"C\" or \"POSIX\" locale, and\n       may cause the string to be replaced by a locale specific string\n       otherwise.  The meaning of $∗ and $@ is identical when not quoted or\n       when used as a variable assignment value or as a file name.  However,\n       when used as a command argument, \"$∗\" is equivalent to \"$1d$2d...\",\n       where d is the first character of the IFS variable, whereas \"$@\" is\n       equivalent to \"$1\" \"$2\" ....  Inside grave quote marks (``), \\ quotes\n       the characters \\, `, and $.  If the grave quotes occur within double\n       quotes, then \\ also quotes the character \"."
  manpageQuestion1: What is the primary purpose of the ksh shell's quoting mechanism?
  manpageQuestion2: How can you quote a single quote character (′) within a string in ksh?
  manpageQuestion3: What is the difference between using double quotes and grave quotes in ksh for handling command substitution?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThe special meaning of reserved words or aliases can be removed by\n       quoting any character of the reserved word.  The recognition of\n       function names or built-in command names listed below cannot be altered\n       by quoting them.\n\n   Arithmetic Evaluation.\n       The shell performs arithmetic evaluation for arithmetic substitution,\n       to evaluate an arithmetic command, to evaluate an indexed array\n       subscript, and to evaluate arguments to the built-in commands shift and\n       let.  Evaluations are performed using double precision floating point\n       arithmetic or long double precision floating point for systems that\n       provide this data type.\tFloating point constants follow the ANSI-C\n       programming language floating point conventions.  The floating point\n       constants Nan and Inf can be use to represent \"not a number\" and\n       infinity respectively.  Integer constants follow the ANSI-C programming\n       language integer constant conventions although only single byte\n       character constants are recognized and character casts are not\n       recognized.  In addition constants can be of the form [base#]n where\n       base is a decimal number between two and sixty-four representing the\n       arithmetic base and n is a number in that base.\tThe digits above 9 are\n       represented by the lower case letters, the upper case letters, @, and _\n       respectively.  For bases less than or equal to 36, upper and lower case\n       characters can be used interchangeably."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you perform arithmetic evaluation in ksh to calculate the sum of 10 and 20?
  manpageQuestion3: Can you provide an example of using ksh to evaluate a floating point constant like 3.14e-2?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nAn arithmetic expression uses the same syntax, precedence, and\n       associativity of expression as the C language.  All the C language\n       operators that apply to floating point quantities can be used.  In\n       addition, the operator ** can be used for exponentiation.  It has\n       higher precedence than multiplication and is left associative.  In\n       addition, when the value of an arithmetic variable or sub-expression\n       can be represented as a long integer, all C language integer arithmetic\n       operations can be performed.  Variables can be referenced by name\n       within an arithmetic expression without using the parameter expansion\n       syntax.\tWhen a variable is referenced, its value is evaluated as an\n       arithmetic expression.\n\n       Any of the following math library functions that are in the C math\n       library can be used within an arithmetic expression:\n\n       abs acos acosh asin asinh atan atan2 atanh cbrt ceil copysign cos cosh\n       erf erfc exp exp2 expm1 fabs fpclassify fdim finite floor fma fmax fmin\n       fmod hypot ilogb int isfinite sinf isnan isnormal issubnormal\n       issubordered iszero j0 j1 jn lgamma log log10 log2 logb nearbyint\n       nextafter nexttoward pow remainder rint round scanb signbit sin sinh\n       sqrt tan tanh tgamma trunc y0 y1 yn In addition, arithmetic functions\n       can be define as shell functions with a variant of the function name\n       syntax,"
  manpageQuestion1: What is the primary purpose of the ksh arithmetic expression feature?
  manpageQuestion2: How can you use ksh to perform exponentiation with the ** operator in an arithmetic expression?
  manpageQuestion3: Can you provide an example of using ksh to calculate the absolute value of a number and round it to the nearest integer?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nfunction .sh.math.name ident ... { list ;}\n\t      where name is the function name used in the arithmetic\n\t      expression and each identifier, ident is a name reference to the\n\t      long double precision floating point argument.  The value of\n\t      .sh.value when the function returns is the value of this\n\t      function.  User defined functions can take up to 3 arguments and\n\t      override C math library functions.\n\n       An internal representation of a variable as a double precision floating\n       point can be specified with the -E [n], -F [n], or -X [n] option of the\n       typeset special built-in command.  The -E option causes the expansion\n       of the value to be represented using scientific notation when it is\n       expanded.  The optional option argument n defines the number of\n       significant figures.  The -F option causes the expansion to be\n       represented as a floating decimal number when it is expanded.  The -X\n       option cause the expansion to be represented using the %a format\n       defined by ISO C-99.  The optional option argument n defines the number\n       of places after the decimal (or radix) point in this case."
  manpageQuestion1: What is the primary purpose of the ksh shell in this context?
  manpageQuestion2: How can you specify that a variable should be represented in scientific notation with 5 significant figures using ksh?
  manpageQuestion3: Can you provide an example of using the -X option with ksh to display a variable's value in ISO C-99 format with 3 decimal places?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nAn internal integer representation of a variable can be specified with\n       the -i [n] option of the typeset special built-in command.  The\n       optional option argument n specifies an arithmetic base to be used when\n       expanding the variable.\tIf you do not specify an arithmetic base, base\n       10 will be used.\n\n       Arithmetic evaluation is performed on the value of each assignment to a\n       variable with the -E, -F, -X, or -i attribute.  Assigning a floating\n       point number to a variable whose type is an integer causes the\n       fractional part to be truncated.\n\n   Prompting.\n       When used interactively, the shell prompts with the value of PS1 after\n       expanding it for parameter expansion, command substitution, and\n       arithmetic substitution, before reading a command.  In addition, each\n       single !  in the prompt is replaced by the command number.  A !!  is\n       required to place !  in the prompt.  If at any time a new-line is typed\n       and further input is needed to complete a command, then the secondary\n       prompt (i.e., the value of PS2) is issued.\n\n   Conditional Expressions.\n       A conditional expression is used with the [[ compound command to test\n       attributes of files and to compare strings.  Field splitting and file\n       name generation are not performed on the words between [[ and ]].  Each\n       expression can be constructed from one or more of the following unary\n       or binary expressions:\n       string True, if string is not null.\n       -a file\n\t      Same as -e below.  This is obsolete.\n       -b file\n\t      True, if file exists and is a block special file.\n       -c file\n\t      True, if file exists and is a character special file.\n       -d file\n\t      True, if file exists and is a directory.\n       -e file\n\t      True, if file exists.\n       -f file\n\t      True, if file exists and is an ordinary file.\n       -g file\n\t      True, if file exists and it has its setgid bit set.\n       -k file\n\t      True, if file exists and it has its sticky bit set.\n       -n string\n\t      True, if length of string is non-zero.\n       -o ?option\n\t      True, if option named option is a valid option name.\n       -o option\n\t      True, if option named option is on.\n       -p file\n\t      True, if file exists and is a fifo special file or a pipe.\n       -r file\n\t      True, if file exists and is readable by current process.\n       -s file\n\t      True, if file exists and has size greater than zero.\n       -t fildes\n\t      True, if file descriptor number fildes is open and associated\n\t      with a terminal device.\n       -u file\n\t      True, if file exists and it has its setuid bit set.\n       -v name\n\t      True, if variable name is a valid variable name and is set.\n       -w file\n\t      True, if file exists and is writable by current process.\n       -x file\n\t      True, if file exists and is executable by current process.  If\n\t      file exists and is a directory, then true if the current process\n\t      has permission to search in the directory.\n       -z string\n\t      True, if length of string is zero.\n       -L file\n\t      True, if file exists and is a symbolic link.\n       -h file\n\t      True, if file exists and is a symbolic link.\n       -N file\n\t      True, if file exists and the modification time is greater than\n\t      the last access time.\n       -O file\n\t      True, if file exists and is owned by the effective user id of\n\t      this process.\n       -G file\n\t      True, if file exists and its group matches the effective group\n\t      id of this process.\n       -R name\n\t      True if variable name is a name reference.\n       -S file\n\t      True, if file exists and is a socket.\n       file1 -nt file2\n\t      True, if file1 exists and file2 does not, or file1 is newer than\n\t      file2.\n       file1 -ot file2\n\t      True, if file2 exists and file1 does not, or file1 is older than\n\t      file2.\n       file1 -ef file2\n\t      True, if file1 and file2 exist and refer to the same file.\n       string == pattern\n\t      True, if string matches pattern.\tAny part of pattern can be\n\t      quoted to cause it to be matched as a string.  With a successful\n\t      match to a pattern, the .sh.match array variable will contain\n\t      the match and sub-pattern matches.\n       string = pattern\n\t      Same as == above, but is obsolete.\n       string != pattern\n\t      True, if string does not match pattern.  When the string matches\n\t      the pattern the .sh.match array variable will contain the match\n\t      and sub-pattern matches.\n       string =∼ ere\n\t      True if string matches the pattern ∼(E)ere where ere is an\n\t      extended regular expression.\n       string1 < string2\n\t      True, if string1 comes before string2 based on ASCII value of\n\t      their characters.\n       string1 > string2\n\t      True, if string1 comes after string2 based on ASCII value of\n\t      their characters.\n       The following obsolete arithmetic comparisons are also permitted:\n       exp1 -eq exp2\n\t      True, if exp1 is equal to exp2.\n       exp1 -ne exp2\n\t      True, if exp1 is not equal to exp2.\n       exp1 -lt exp2\n\t      True, if exp1 is less than exp2.\n       exp1 -gt exp2\n\t      True, if exp1 is greater than exp2.\n       exp1 -le exp2\n\t      True, if exp1 is less than or equal to exp2.\n       exp1 -ge exp2\n\t      True, if exp1 is greater than or equal to exp2.\n\n       In each of the above expressions, if file is of the form /dev/fd/n,\n       where n is an integer, then the test is applied to the open file whose\n       descriptor number is n.\n\n       A compound expression can be constructed from these primitives by using\n       any of the following, listed in decreasing order of precedence.\n       (expression)\n\t      True, if expression is true.  Used to group expressions.\n       ! expression\n\t      True if expression is false.\n       expression1 && expression2\n\t      True, if expression1 and expression2 are both true.\n       expression1 ⎪⎪ expression2\n\t      True, if either expression1 or expression2 is true.\n\n   Input/Output.\n       Before a command is executed, its input and output may be redirected\n       using a special notation interpreted by the shell.  The following may\n       appear anywhere in a simple-command or may precede or follow a command\n       and are not passed on to the invoked command.  Command substitution,\n       parameter expansion, and arithmetic substitution occur before word or\n       digit is used except as noted below.  File name generation occurs only\n       if the shell is interactive and the pattern matches a single file.\n       Field splitting is not performed.\n\n       In each of the following redirections, if file is of the form\n       /dev/sctp/host/port, /dev/tcp/host/port, or /dev/udp/host/port, where\n       host is a hostname or host address, and port is a service given by name\n       or an integer port number, then the redirection attempts to make a tcp,\n       sctp or udp connection to the corresponding socket.\n\n       No intervening space is allowed between the characters of redirection\n       operators.\n\n       <word\t     Use file word as standard input (file descriptor 0).\n\n       >word\t     Use file word as standard output (file descriptor 1).  If\n\t\t     the file does not exist then it is created.  If the file\n\t\t     exists, and the noclobber option is on, this causes an\n\t\t     error; otherwise, it is truncated to zero length.\n\n       >|word\t     Same as >, except that it overrides the noclobber option.\n\n       >;word\t     Write output to a temporary file.\tIf the command\n\t\t     completes successfully rename it to word, otherwise,\n\t\t     delete the temporary file.  >;word cannot be used with\n\t\t     the exec(2).  built-in.\n\n       >>word\t     Use file word as standard output.\tIf the file exists,\n\t\t     then output is appended to it (by first seeking to the\n\t\t     end-of-file); otherwise, the file is created.\n\n       <>word\t     Open file word for reading and writing as standard\n\t\t     output.\n\n       <>;word\t     The same as <>word except that if the command completes\n\t\t     successfully, word is truncated to the offset at command\n\t\t     completion.  <>;word cannot be used with the exec(2).\n\t\t     built-in.\n\n       <<[-]word     The shell input is read up to a line that is the same as\n\t\t     word after any quoting has been removed, or to an end-of-\n\t\t     file.  No parameter substitution, command substitution,\n\t\t     arithmetic substitution or file name generation is\n\t\t     performed on word.  The resulting document, called a\n\t\t     here-document, becomes the standard input.  If any\n\t\t     character of word is quoted, then no interpretation is\n\t\t     placed upon the characters of the document; otherwise,\n\t\t     parameter expansion, command substitution, and arithmetic\n\t\t     substitution occur, \\new-line is ignored, and \\ must be\n\t\t     used to quote the characters \\, $, `.  If - is appended\n\t\t     to <<, then all leading tabs are stripped from word and\n\t\t     from the document.  If # is appended to <<, then leading\n\t\t     spaces and tabs will be stripped off the first line of\n\t\t     the document and up to an equivalent indentation will be\n\t\t     stripped from the remaining lines and from word.  A tab\n\t\t     stop is assumed to occur at every 8 columns for the\n\t\t     purposes of determining the indentation.\n\n       <<<word\t     A short form of here document in which word becomes the\n\t\t     contents of the here-document after any parameter\n\t\t     expansion, command substitution, and arithmetic\n\t\t     substitution occur.\n\n       <&digit\t     The standard input is duplicated from file descriptor\n\t\t     digit (see dup(2)).  Similarly for the standard output\n\t\t     using >&digit.\n\n       <&digit-      The file descriptor given by digit is moved to standard\n\t\t     input.  Similarly for the standard output using >&digit-.\n\n       <&-\t     The standard input is closed.  Similarly for the standard\n\t\t     output using >&-.\n\n       <&p\t     The input from the co-process is moved to standard input.\n\n       >&p\t     The output to the co-process is moved to standard output.\n\n       <#((expr))    Evaluate arithmetic expression expr and position file\n\t\t     descriptor 0 to the resulting value bytes from the start\n\t\t     of the file.  The variables CUR and EOF evaluate to the\n\t\t     current offset and end-of-file offset respectively when\n\t\t     evaluating expr.\n\n       >#((offset))  The same as <# except applies to file descriptor 1.\n\n       <#pattern     Seeks forward to the beginning of the next line\n\t\t     containing pattern.\n\n       <##pattern    The same as <# except that the portion of the file that\n\t\t     is skipped is copied to standard output.\n\n       If one of the above is preceded by a digit, with no intervening space,\n       then the file descriptor number referred to is that specified by the\n       digit (instead of the default 0 or 1).  If one of the above, other than\n       >&- and the ># and <# forms, is preceded by {varname} with no\n       intervening space, then a file descriptor number > 10 will be selected\n       by the shell and stored in the variable varname.  If >&- or the any of\n       the ># and <# forms is preceded by {varname} the value of varname\n       defines the file descriptor to close or position.  For example:\n\n\t      ... 2>&1\n\n       means file descriptor 2 is to be opened for writing as a duplicate of\n       file descriptor 1 and\n\n\t      exec {n}<file\n\n       means open file named file for reading and store the file descriptor\n       number in variable n.\n\n       The order in which redirections are specified is significant.  The\n       shell evaluates each redirection in terms of the (file descriptor,\n       file) association at the time of evaluation.  For example:\n\n\t      ... 1>fname 2>&1\n\n       first associates file descriptor 1 with file fname.  It then associates\n       file descriptor 2 with the file associated with file descriptor 1 (i.e.\n       fname).\tIf the order of redirections were reversed, file descriptor 2\n       would be associated with the terminal (assuming file descriptor 1 had\n       been) and then file descriptor 1 would be associated with file fname.\n\n       If a command is followed by & and job control is not active, then the\n       default standard input for the command is the empty file /dev/null.\n       Otherwise, the environment for the execution of a command contains the\n       file descriptors of the invoking shell as modified by input/output\n       specifications.\n\n   Environment.\n       The environment (see environ(7)) is a list of name-value pairs that is\n       passed to an executed program in the same way as a normal argument\n       list.  The names must be identifiers and the values are character\n       strings.  The shell interacts with the environment in several ways.  On\n       invocation, the shell scans the environment and creates a variable for\n       each name found, giving it the corresponding value and attributes and\n       marking it export.  Executed commands inherit the environment.  If the\n       user modifies the values of these variables or creates new ones, using\n       the export or typeset -x commands, they become part of the environment.\n       The environment seen by any executed command is thus composed of any\n       name-value pairs originally inherited by the shell, whose values may be\n       modified by the current shell, plus any additions which must be noted\n       in export or typeset -x commands.\n\n       The environment for any simple-command or function may be augmented by\n       prefixing it with one or more variable assignments.  A variable\n       assignment argument is a word of the form identifier=value.  Thus:\n\n\t      TERM=450 cmd args \t\t and\n\t      (export TERM; TERM=450; cmd args)\n\n       are equivalent (as far as the above execution of cmd is concerned\n       except for special built-in commands listed below - those that are\n       preceded with a dagger).\n\n       If the obsolete -k option is set, all variable assignment arguments are\n       placed in the environment, even if they occur after the command name.\n       The following first prints a=b c and then c:\n\n\t      echo a=b c\n\t      set -k\n\t      echo a=b c\n       This feature is intended for use with scripts written for early\n       versions of the shell and its use in new scripts is strongly\n       discouraged.  It is likely to disappear someday.\n\n   Functions.\n       For historical reasons, there are two ways to define functions, the\n       name() syntax and the function name syntax, described in the Commands\n       section above.  Shell functions are read in and stored internally.\n       Alias names are resolved when the function is read.  Functions are\n       executed like commands with the arguments passed as positional\n       parameters.  (See Execution below.)\n\n       Functions defined by the function name syntax and called by name\n       execute in the same process as the caller and share all files and\n       present working directory with the caller.  Traps caught by the caller\n       are reset to their default action inside the function.  A trap\n       condition that is not caught or ignored by the function causes the\n       function to terminate and the condition to be passed on to the caller.\n       A trap on EXIT set inside a function is executed in the environment of\n       the caller after the function completes.  Ordinarily, variables are\n       shared between the calling program and the function.  However, the\n       typeset special built-in command used within a function defines local\n       variables whose scope includes the current function.  They can be\n       passed to functions that they call in the variable assignment list that\n       precedes the call or as arguments passed as name references.  Errors\n       within functions return control to the caller.\n\n       Functions defined with the name() syntax and functions defined with the\n       function name syntax that are invoked with the . special built-in are\n       executed in the caller's environment and share all variables and traps\n       with the caller.  Errors within these function executions cause the\n       script that contains them to abort.\n\n       The special built-in command return is used to return from function\n       calls.\n\n       Function names can be listed with the -f or +f option of the typeset\n       special built-in command.  The text of functions, when available, will\n       also be listed with -f.\tFunctions can be undefined with the -f option\n       of the unset special built-in command.\n\n       Ordinarily, functions are unset when the shell executes a shell script.\n       Functions that need to be defined across separate invocations of the\n       shell should be placed in a directory and the FPATH variable should\n       contain the name of this directory.  They may also be specified in the\n       ENV file.\n\n   Discipline Functions.\n       Each variable can have zero or more discipline functions associated\n       with it.  The shell initially understands the discipline names get,\n       set, append, and unset but can be added when defining new types.  On\n       most systems others can be added at run time via the C programming\n       interface extension provided by the builtin built-in utility.  If the\n       get discipline is defined for a variable, it is invoked whenever the\n       given variable is referenced.  If the variable .sh.value is assigned a\n       value inside the discipline function, the referenced variable will\n       evaluate to this value instead.\tIf the set discipline is defined for a\n       variable, it is invoked whenever the given variable is assigned a\n       value.  If the append discipline is defined for a variable, it is\n       invoked whenever a value is appended to the given variable.  The\n       variable .sh.value is given the value of the variable before invoking\n       the discipline, and the variable will be assigned the value of\n       .sh.value after the discipline completes.  If .sh.value is unset inside\n       the discipline, then that value is unchanged.  If the unset discipline\n       is defined for a variable, it is invoked whenever the given variable is\n       unset.  The variable will not be unset unless it is unset explicitly\n       from within this discipline function.\n\n       The variable .sh.name contains the name of the variable for which the\n       discipline function is called, .sh.subscript is the subscript of the\n       variable, and .sh.value will contain the value being assigned inside\n       the set discipline function.  The variable _ is a reference to the\n       variable including the subscript if any.  For the set discipline,\n       changing .sh.value will change the value that gets assigned.  Finally,\n       the expansion ${var.name}, when name is the name of a discipline, and\n       there is no variable of this name, is equivalent to the command\n       substitution ${ var.name;}."
  manpageQuestion1: What is the primary purpose of the 4ccconv command?
  manpageQuestion2: How can I convert a 4-character code to its hexadecimal representation using 4ccconv?
  manpageQuestion3: What is the correct way to convert an unsigned integer to a 4cc code with 4ccconv?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    Name Spaces.
           Commands and functions that are executed as part of the list of a
           namespace command that modify variables or create new ones, create a
           new variable whose name is the name of the name space as given by
           identifier preceded by ..  When a variable whose name is name is
           referenced, it is first searched for using .identifier.name.
           Similarly, a function defined by a command in the namespace list is
           created using the name space name  preceded by a ..

           When  the list of a namespace command contains a namespace command, the
           names of variables and functions that are created consist of the
           variable or function name preceded by the list of identifiers each
           preceded by ..

           Outside of a name space, a variable or function created inside a name
           space can be referenced by preceding it with the name space name.

           By default, variables staring with .sh are in the sh name space.
  manpageQuestion1: What is the primary purpose of the `ksh` shell's name space feature?
  manpageQuestion2: How can you create a variable named `myvar` in the `sh` name space using ksh?
  manpageQuestion3: What is the correct syntax to reference a variable created in the `mynamespace` name space from outside of it?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nType Variables.\n       Typed variables provide a way to create data structure and objects.  A\n       type can be defined either by a shared library, by the enum built-in\n       command described below, or by using the new -T option of the typeset\n       built-in command.  With the -T option of typeset, the type name,\n       specified as an option argument to -T, is set with a compound variable\n       assignment that defines the type.  Function definitions can appear\n       inside the compound variable assignment and these become discipline\n       functions for this type and can be invoked or redefined by each\n       instance of the type.  The function name create is treated specially.\n       It is invoked for each instance of the type that is created but is not\n       inherited and cannot be redefined for each instance.\n\n       When a type is defined a special built-in command of that name is\n       added.  These built-ins are declaration commands and follow the same\n       expansion rules as all the special built-in commands defined below that\n       are preceded by ††.  These commands can subsequently be used inside\n       further type definitions.  The man page for these commands can be\n       generated by using the --man option or any of the other -- options\n       described with getopts.\tThe -r, -a, -A, -h, and -S options of typeset\n       are permitted with each of these new built-ins."
  manpageQuestion1: What is the primary purpose of the ksh resource?
  manpageQuestion2: How would you define a new type in ksh using the typeset command with the -T option?
  manpageQuestion3: Can you provide an example of defining a type in ksh that includes a function for creating instances of the type?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    An instance of a type is created by invoking the type name followed by
           one or more instance names.  Each instance of the type is initialized
           with a copy of the sub-variables except for sub-variables that are
           defined with the -S option.  Variables defined with the -S are shared
           by all instances of the type.  Each instance can change the value of
           any sub-variable and can also define new discipline functions of the
           same names as those defined by the type definition as well as any
           standard discipline names.  No additional sub-variables can be defined
           for any instance.

           When defining a type, if the value of a sub-variable is not set and the
           -r attribute is specified, it causes the sub-variable to be a required
           sub-variable.  Whenever an instance of a type is created, all required
           sub-variables must be specified.  These sub-variables become readonly
           in each instance.

           When unset is invoked on a sub-variable within a type, and the -r
           attribute has not been specified for this field, the value is reset to
           the default value associative with the type.  Invoking unset on a type
           instance not contained within another type deletes all sub-variables
           and the variable itself.
  manpageQuestion1: What is the primary purpose of the ksh resource?
  manpageQuestion2: How would you create a new instance of a type in ksh and ensure that a specific sub-variable is required and readonly?
  manpageQuestion3: Can you provide an example of how to unset a sub-variable in a type instance without affecting the default value associated with the type?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nA type definition can be derived from another type definition by\n       defining the first sub-variable name as _ and defining its type as the\n       base type.  Any remaining definitions will be additions and\n       modifications that apply to the new type.  If the new type name is the\n       same is that of the base type, the type will be replaced and the\n       original type will no longer be accessible.\n\n       The typeset command with the -T and no option argument or operands will\n       write all the type definitions to standard output in a form that that\n       can be read in to create all they types.\n\n   Jobs.\n       If the monitor option of the set command is turned on, an interactive\n       shell associates a job with each pipeline.  It keeps a table of current\n       jobs, printed by the jobs command, and assigns them small integer\n       numbers.  When a job is started asynchronously with &, the shell prints\n       a line which looks like:\n\n\t    [1] 1234\n\n       indicating that the job which was started asynchronously was job number\n       1 and had one (top-level) process, whose process id was 1234."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use the typeset command in ksh to define a new type based on an existing one?
  manpageQuestion3: What is the function of the monitor option in the set command when used with an interactive shell?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThis paragraph and the next require features that are not in all\n       versions of UNIX and may not apply.  If you are running a job and wish\n       to do something else you may hit the key ^Z (control-Z) which sends a\n       STOP signal to the current job.\tThe shell will then normally indicate\n       that the job has been `Stopped', and print another prompt.  You can\n       then manipulate the state of this job, putting it in the background\n       with the bg command, or run some other commands and then eventually\n       bring the job back into the foreground with the foreground command fg.\n       A ^Z takes effect immediately and is like an interrupt in that pending\n       output and unread input are discarded when it is typed.\n\n       A job being run in the background will stop if it tries to read from\n       the terminal.  Background jobs are normally allowed to produce output,\n       but this can be disabled by giving the command stty tostop.  If you set\n       this tty option, then background jobs will stop when they try to\n       produce output like they do when they try to read input."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you suspend a running job in ksh and bring it back to the foreground?
  manpageQuestion3: What is the effect of using the stty tostop command in ksh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nA job pool is a collection of jobs started with list & associated with\n       a name.\n\n       There are several ways to refer to jobs in the shell.  A job can be\n       referred to by the process id of any process of the job or by one of\n       the following:\n       %number\n\t      The job with the given number.\n       pool   All the jobs in the job pool named by pool.\n       pool.number\n\t      The job number number in the job pool named by pool.\n       %string\n\t      Any job whose command line begins with string.\n       %?string\n\t      Any job whose command line contains string.\n       %%     Current job.\n       %+     Equivalent to %%.\n       %-     Previous job.  In addition, unless noted otherwise, wherever a\n\t      job can be specified, the name of a background job pool can be\n\t      used to represent all the jobs in that pool.\n\n       The shell learns immediately whenever a process changes state.  It\n       normally informs you whenever a job becomes blocked so that no further\n       progress is possible, but only just before it prints a prompt.  This is\n       done so that it does not otherwise disturb your work.  The notify\n       option of the set command causes the shell to print these job change\n       messages as soon as they occur."
  manpageQuestion1: What is the primary purpose of the ksh shell in managing job pools?
  manpageQuestion2: How can you refer to the second job in a job pool named 'my_pool' using ksh?
  manpageQuestion3: What is the difference between using %string and %?string to refer to jobs in ksh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nWhen the monitor option is on, each background job that completes\n       triggers any trap set for CHLD.\n\n       When you try to leave the shell while jobs are running or stopped, you\n       will be warned that `You have stopped(running) jobs.'  You may use the\n       jobs command to see what they are.  If you immediately try to exit\n       again, the shell will not warn you a second time, and the stopped jobs\n       will be terminated.  When a login shell receives a HUP signal, it sends\n       a HUP signal to each job that has not been disowned with the disown\n       built-in command described below.\n\n   Signals.\n       The INT and QUIT signals for an invoked command are ignored if the\n       command is followed by & and the monitor option is not active.\n       Otherwise, signals have the values inherited by the shell from its\n       parent (but see also the trap built-in command below).\n\n   Execution.\n       Each time a command is read, the above substitutions are carried out.\n       If the command name matches one of the Special Built-in Commands listed\n       below, it is executed within the current shell process.\tNext, the\n       command name is checked to see if it matches a user defined function.\n       If it does, the positional parameters are saved and then reset to the\n       arguments of the function call.\tA function is also executed in the\n       current shell process.  When the function completes or issues a return,\n       the positional parameter list is restored.  For functions defined with\n       the function name syntax, any trap set on EXIT within the function is\n       executed.  The exit value of a function is the value of the last\n       command executed.  If a command name is not a special built-in command\n       or a user defined function, but it is one of the built-in commands\n       listed below, it is executed in the current shell process."
  manpageQuestion1: What is the primary purpose of the `ksh` shell?
  manpageQuestion2: How can you configure the ksh shell to send a HUP signal to all non-disowned jobs when it receives a HUP signal?
  manpageQuestion3: What is the effect of using the monitor option in ksh when background jobs are running?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    The shell variables PATH followed by the variable FPATH defines the
           list of directories to search for the command name.  Alternative
           directory names are separated by a colon (:).  The default path is
           /bin:/usr/bin: (specifying /bin, /usr/bin, and the current directory in
           that order).  The current directory can be specified by two or more
           adjacent colons, or by a colon at the beginning or end of the path
           list.  If the command name contains a /, then the search path is not
           used.  Otherwise, each directory in the list of directories defined by
           PATH and FPATH is checked in order.  If the directory being searched is
           contained in FPATH and contains a file whose name matches the command
           being searched, then this file is loaded into the current shell
           environment as if it were the argument to the . command except that
           only preset aliases are expanded, and a function of the given name is
           executed as described above.
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How does the ksh shell handle command search when the command name contains a slash (/)?
  manpageQuestion3: Can you explain how the ksh shell uses the PATH and FPATH variables to locate executable commands?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nIf this directory is not in FPATH the shell first determines whether\n       there is a built-in version of a command corresponding to a given\n       pathname and if so it is invoked in the current process.  If no built-\n       in is found, the shell checks for a file named .paths in this\n       directory.  If found and there is a line of the form FPATH=path where\n       path names an existing directory then that directory is searched after\n       immediately after the current directory as if it were found in the\n       FPATH variable.\tIf path does not begin with /, it is checked for\n       relative to the directory being searched.\n\n       The .paths file is then checked\tfor a line of the form\n       PLUGIN_LIB=libname [ : libname ] ... .  Each library named by libname\n       will be searched for as if it were an option argument to builtin -f,\n       and if it contains a built-in of the specified name this will be\n       executed instead of a command by this name.  Any built-in loaded from a\n       library found this way will be associated with the directory containing\n       the .paths file so it will only execute if not found in an earlier\n       directory."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you configure the ksh shell to search for shell functions in a custom directory?
  manpageQuestion3: Can you explain how the ksh shell handles the loading of plugins from the .paths file?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nFinally, the directory will be checked for a file of the given name.\n       If the file has execute permission but is not an a.out file, it is\n       assumed to be a file containing shell commands.\tA separate shell is\n       spawned to read it.  All non-exported variables are removed in this\n       case.  If the shell command file doesn't have read permission, or if\n       the setuid and/or setgid bits are set on the file, then the shell\n       executes an agent whose job it is to set up the permissions and execute\n       the shell with the shell command file passed down as an open file.  If\n       the .paths contains a line of the form name=value in the first or\n       second line, then the environment variable name is modified by\n       prepending the directory specified by value to the directory list.  If\n       value is not an absolute directory, then it specifies a directory\n       relative to the directory that the executable was found.  If the\n       environment variable name does not already exist it will be added to\n       the environment list for the specified command.\tA parenthesized\n       command is executed in a sub-shell without removing non-exported\n       variables."
  manpageQuestion1: What is the primary purpose of the ksh command in macOS?
  manpageQuestion2: How can you use ksh to execute a shell script located in a specific directory?
  manpageQuestion3: What is the effect of setting an environment variable in .paths when using ksh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nCommand Re-entry.\n       The text of the last HISTSIZE (default 512) commands entered from a\n       terminal device is saved in a history file.  The file $HOME/.sh_history\n       is used if the HISTFILE variable is not set or if the file it names is\n       not writable.  A shell can access the commands of all interactive\n       shells which use the same named HISTFILE.  The built-in command hist is\n       used to list or edit a portion of this file.  The portion of the file\n       to be edited or listed can be selected by number or by giving the first\n       character or characters of the command.\tA single command or range of\n       commands can be specified.  If you do not specify an editor program as\n       an argument to hist then the value of the variable HISTEDIT is used.\n       If HISTEDIT is unset, the obsolete variable FCEDIT is used.  If FCEDIT\n       is not defined, then /bin/ed is used.  The edited command(s) is printed\n       and re-executed upon leaving the editor unless you quit without\n       writing.  The -s option (and in obsolete versions, the editor name -)\n       is used to skip the editing phase and to re-execute the command.  In\n       this case a substitution parameter of the form old=new can be used to\n       modify the command before execution.  For example, with the preset\n       alias r, which is aliased to ′hist -s′, typing `r bad=good c' will re-\n       execute the most recent command which starts with the letter c,\n       replacing the first occurrence of the string bad with the string good."
  manpageQuestion1: What is the primary purpose of the ksh shell's history management features?
  manpageQuestion2: How can you re-execute the most recent command that starts with 'c' while replacing 'bad' with 'good' using the hist command?
  manpageQuestion3: What is the default editor used by ksh when the HISTEDIT variable is not set?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nIn-line Editing Options.\n       Normally, each command line entered from a terminal device is simply\n       typed followed by a new-line (`RETURN' or `LINE FEED').\tIf either the\n       emacs, gmacs, or vi option is active, the user can edit the command\n       line.  To be in either of these edit modes set the corresponding\n       option.\tAn editing option is automatically selected each time the\n       VISUAL or EDITOR variable is assigned a value ending in either of these\n       option names.\n\n       The editing features require that the user's terminal accept `RETURN'\n       as carriage return without line feed and that a space (` ') must\n       overwrite the current character on the screen.\n\n       Unless the multiline option is on, the editing modes implement a\n       concept where the user is looking through a window at the current line.\n       The window width is the value of COLUMNS if it is defined, otherwise\n       80.  If the window width is too small to display the prompt and leave\n       at least 8 columns to enter input, the prompt is truncated from the\n       left.  If the line is longer than the window width minus two, a mark is\n       displayed at the end of the window to notify the user.  As the cursor\n       moves and reaches the window boundaries the window will be centered\n       about the cursor.  The mark is a > (<, *) if the line extends on the\n       right (left, both) side(s) of the window."
  manpageQuestion1: What is the primary purpose of the ksh shell's in-line editing options?
  manpageQuestion2: How can you configure the ksh shell to use vi as its inline editor for command line editing?
  manpageQuestion3: What are the key features of the in-line editing modes in ksh when multiline editing is disabled?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThe search commands in each edit mode provide access to the history\n       file.  Only strings are matched, not patterns, although a leading ^ in\n       the string restricts the match to begin at the first character in the\n       line.\n\n       Each of the edit modes has an operation to list the files or commands\n       that match a partially entered word.  When applied to the first word on\n       the line, or the first word after a ;, ⎪, &, or (, and the word does\n       not begin with ∼ or contain a /, the list of aliases, functions, and\n       executable commands defined by the PATH variable that could match the\n       partial word is displayed.  Otherwise, the list of files that match the\n       given word is displayed.  If the partially entered word does not\n       contain any file expansion characters, a * is appended before\n       generating these lists.\tAfter displaying the generated list, the input\n       line is redrawn.  These operations are called command name listing and\n       file name listing, respectively.  There are additional operations,\n       referred to as command name completion and file name completion, which\n       compute the list of matching commands or files, but instead of printing\n       the list, replace the current word with a complete or partial match.\n       For file name completion, if the match is unique, a / is appended if\n       the file is a directory and a space is appended if the file is not a\n       directory.  Otherwise, the longest common prefix for all the matching\n       files replaces the word.  For command name completion, only the portion\n       of the file names after the last / are used to find the longest command\n       prefix.\tIf only a single name matches this prefix, then the word is\n       replaced with the command name followed by a space.  When using a tab\n       for completion that does not yield a unique match, a subsequent tab\n       will provide a numbered list of matching alternatives.  A specific\n       selection can be made by entering the selection number followed by a\n       tab."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use command name completion in ksh to complete a partially entered command?
  manpageQuestion3: Can you provide an example of using file name completion in ksh to complete a partially entered filename?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    Key Bindings.
           The KEYBD trap can be used to intercept keys as they are typed and
           change the characters that are actually seen by the shell.  This trap
           is executed after each character (or sequence of characters when the
           first character is ESC) is entered while reading from a terminal.  The
           variable .sh.edchar contains the character or character sequence which
           generated the trap.  Changing the value of .sh.edchar in the trap
           action causes the shell to behave as if the new value were entered from
           the keyboard rather than the original value.

           The variable .sh.edcol is set to the input column number of the cursor
           at the time of the input.  The variable .sh.edmode is set to ESC when
           in vi insert mode (see below) and is null otherwise.  By prepending
           ${.sh.editmode} to a value assigned to .sh.edchar it will cause the
           shell to change to control mode if it is not already in this mode.

           This trap is not invoked for characters entered as arguments to editing
           directives, or while reading input for a character search.
  manpageQuestion1: What is the primary purpose of the ksh shell's KEYBD trap functionality?
  manpageQuestion2: How can you use the KEYBD trap in ksh to modify the input characters before they are processed by the shell?
  manpageQuestion3: Can you explain how to set up a KEYBD trap in ksh to change the input behavior when using vi insert mode?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nEmacs Editing Mode.\n       This mode is entered by enabling either the emacs or gmacs option.  The\n       only difference between these two modes is the way they handle ^T.  To\n       edit, the user moves the cursor to the point needing correction and\n       then inserts or deletes characters or words as needed.  All the editing\n       commands are control characters or escape sequences.  The notation for\n       control characters is caret (^) followed by the character.  For\n       example, ^F is the notation for control F.  This is entered by\n       depressing `f' while holding down the `CTRL' (control) key.  The\n       `SHIFT' key is not depressed.  (The notation ^?\tindicates the DEL\n       (delete) key.)\n\n       The notation for escape sequences is M- followed by a character.  For\n       example, M-f (pronounced Meta f) is entered by depressing ESC (ascii\n       033) followed by `f'.  (M-F would be the notation for ESC followed by\n       `SHIFT' (capital) `F'.)\n\n       All edit commands operate from any place on the line (not just at the\n       beginning).  Neither the `RETURN' nor the `LINE FEED' key is entered\n       after edit commands except when noted."
  manpageQuestion1: What is the primary purpose of the emacs editing mode in ksh?
  manpageQuestion2: How do you insert a space character using the emacs editing mode in ksh?
  manpageQuestion3: What is the correct way to execute an escape sequence for the 'f' command in emacs editing mode?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n^F\t Move cursor forward (right) one character.\n       M-[C\t Move cursor forward (right) one character.\n       M-f\t Move cursor forward one word.\t(The emacs editor's idea of a\n\t\t word is a string of characters consisting of only letters,\n\t\t digits and underscores.)\n       ^B\t Move cursor backward (left) one character.\n       M-[D\t Move cursor backward (left) one character.\n       M-b\t Move cursor backward one word.\n       ^A\t Move cursor to start of line.\n       M-[H\t Move cursor to start of line.\n       ^E\t Move cursor to end of line.\n       M-[Y\t Move cursor to end of line.\n       ^]char\t Move cursor forward to character char on current line.\n       M-^]char  Move cursor backward to character char on current line.\n       ^X^X\t Interchange the cursor and mark.\n       erase\t (User defined erase character as defined by the stty(1)\n\t\t command, usually ^H or #.) Delete previous character.\n       lnext\t (User defined literal next character as defined by the\n\t\t stty(1) command, or ^V if not defined.)  Removes the next\n\t\t character's editing features (if any).\n       ^D\t Delete current character.\n       M-d\t Delete current word.\n       M-^H\t (Meta-backspace) Delete previous word.\n       M-h\t Delete previous word.\n       M-^?\t (Meta-DEL) Delete previous word (if your interrupt character\n\t\t is ^?\t(DEL, the default) then this command will not work).\n       ^T\t Transpose current character with previous character and\n\t\t advance the cursor in emacs mode.  Transpose two previous\n\t\t characters in gmacs mode.\n       ^C\t Capitalize current character.\n       M-c\t Capitalize current word.\n       M-l\t Change the current word to lower case.\n       ^K\t Delete from the cursor to the end of the line.  If preceded\n\t\t by a numerical parameter whose value is less than the current\n\t\t cursor position, then delete from given position up to the\n\t\t cursor.  If preceded by a numerical parameter whose value is\n\t\t greater than the current cursor position, then delete from\n\t\t cursor up to given cursor position.\n       ^W\t Kill from the cursor to the mark.\n       M-p\t Push the region from the cursor to the mark on the stack.\n       kill\t (User defined kill character as defined by the stty command,\n\t\t usually ^G or @.) Kill the entire current line.  If two kill\n\t\t characters are entered in succession, all kill characters\n\t\t from then on cause a line feed (useful when using paper\n\t\t terminals).\n       ^Y\t Restore last item removed from line. (Yank item back to the\n\t\t line.)\n       ^L\t Line feed and print current line.\n       M-^L\t Clear the screen.\n       ^@\t (Null character) Set mark.\n       M-space\t (Meta space) Set mark.\n       ^J\t (New line) Execute the current line.\n       ^M\t (Return) Execute the current line.\n       eof\t End-of-file character, normally ^D, is processed as an End-\n\t\t of-file only if the current line is null.\n       ^P\t Fetch previous command.  Each time ^P is entered the previous\n\t\t command back in time is accessed.  Moves back one line when\n\t\t not on the first line of a multi-line command.\n       M-[A\t If the cursor is at the end of the line, it is equivalent to\n\t\t ^R with string set to the contents of the current line.\n\t\t Otherwise, it is equivalent to ^P.\n       M-<\t Fetch the least recent (oldest) history line.\n       M->\t Fetch the most recent (youngest) history line.\n       ^N\t Fetch next command line.  Each time ^N is entered the next\n\t\t command line forward in time is accessed.\n       M-[B\t Equivalent to ^N.\n       ^Rstring  Reverse search history for a previous command line containing\n\t\t string.  If a parameter of zero is given, the search is\n\t\t forward.  String is terminated by a `RETURN' or `NEW LINE'.\n\t\t If string is preceded by a ^, the matched line must begin\n\t\t with string.  If string is omitted, then the next command\n\t\t line containing the most recent string is accessed.  In this\n\t\t case a parameter of zero reverses the direction of the\n\t\t search.\n       ^O\t Operate - Execute the current line and fetch the next line\n\t\t relative to current line from the history file.\n       M-digits  (Escape) Define numeric parameter, the digits are taken as a\n\t\t parameter to the next command.  The commands that accept a\n\t\t parameter are ^F, ^B, erase, ^C, ^D, ^K, ^R, ^P, ^N, ^], M-.,\n\t\t M-^], M-_, M-=, M-b, M-c, M-d, M-f, M-h, M-l and M-^H.\n       M-letter  Soft-key - Your alias list is searched for an alias by the\n\t\t name _letter and if an alias of this name is defined, its\n\t\t value will be inserted on the input queue.  The letter must\n\t\t not be one of the above meta-functions.\n       M-[letter Soft-key - Your alias list is searched for an alias by the\n\t\t name __letter and if an alias of this name is defined, its\n\t\t value will be inserted on the input queue.  This can be used\n\t\t to program function keys on many terminals.\n       M-.\t The last word of the previous command is inserted on the\n\t\t line.\tIf preceded by a numeric parameter, the value of this\n\t\t parameter determines which word to insert rather than the\n\t\t last word.\n       M-_\t Same as M-..\n       M-*\t Attempt file name generation on the current word.  An\n\t\t asterisk is appended if the word doesn't match any file or\n\t\t contain any special pattern characters.\n       M-ESC\t Command or file name completion as described above.\n       ^I tab\t Attempts command or file name completion as described above.\n\t\t If a partial completion occurs, repeating this will behave as\n\t\t if M-= were entered.  If no match is found or entered after\n\t\t space, a tab is inserted.\n       M-=\t If not preceded by a numeric parameter, it generates the list\n\t\t of matching commands or file names as described above.\n\t\t Otherwise, the word under the cursor is replaced by the item\n\t\t corresponding to the value of the numeric parameter from the\n\t\t most recently generated command or file list.\tIf the cursor\n\t\t is not on a word, it is inserted instead.\n       ^U\t Multiply parameter of next command by 4.\n       \\\t Escape next character.  Editing characters, the user's erase,\n\t\t kill and interrupt (normally ^?) characters may be entered in\n\t\t a command line or in a search string if preceded by a \\.  The\n\t\t \\ removes the next character's editing features (if any).\n       M-^V\t Display version of the shell.\n       M-#\t If the line does not begin with a #, a # is inserted at the\n\t\t beginning of the line and after each new-line, and the line\n\t\t is entered.  This causes a comment to be inserted in the\n\t\t history file.\tIf the line begins with a #, the # is deleted\n\t\t and one # after each new-line is also deleted."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use the ksh shell to move the cursor backward one word and then delete the previous word?
  manpageQuestion3: What command can be used in ksh to execute the current line and fetch the next line from the history file?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    Vi Editing Mode.
           There are two typing modes.  Initially, when you enter a command you
           are in the input mode.  To edit, the user enters control mode by typing
           ESC (033) and moves the cursor to the point needing correction and then
           inserts or deletes characters or words as needed.  Most control
           commands accept an optional repeat count prior to the command.

           When in vi mode on most systems, canonical processing is initially
           enabled and the command will be echoed again if the speed is 1200 baud
           or greater and it contains any control characters or less than one
           second has elapsed since the prompt was printed.  The ESC character
           terminates canonical processing for the remainder of the command and
           the user can then modify the command line.  This scheme has the
           advantages of canonical processing with the type-ahead echoing of raw
           mode.

           If the option viraw is also set, the terminal will always have
           canonical processing disabled.  This mode is implicit for systems that
           do not support two alternate end of line delimiters, and may be helpful
           for certain terminals.
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you enable raw mode in ksh to disable canonical processing?
  manpageQuestion3: What is the difference between input mode and control mode in vi editing within ksh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nInput Edit Commands\n\t      By default the editor is in input mode.\n\t      erase\t(User defined erase character as defined by the stty\n\t\t\tcommand, usually ^H or #.) Delete previous character.\n\t      ^W\tDelete the previous blank separated word.  On some\n\t\t\tsystems the viraw option may be required for this to\n\t\t\twork.\n\t      eof\tAs the first character of the line causes the shell to\n\t\t\tterminate unless the ignoreeof option is set.\n\t\t\tOtherwise this character is ignored.\n\t      lnext\t(User defined literal next character as defined by the\n\t\t\tstty(1) or ^V if not defined.)\tRemoves the next\n\t\t\tcharacter's editing features (if any).\tOn some\n\t\t\tsystems the viraw option may be required for this to\n\t\t\twork.\n\t      \\ \tEscape the next erase or kill character.\n\t      ^I tab\tAttempts command or file name completion as described\n\t\t\tabove and returns to input mode.  If a partial\n\t\t\tcompletion occurs, repeating this will behave as if =\n\t\t\twere entered from control mode.  If no match is found\n\t\t\tor entered after space, a tab is inserted.\n\tMotion Edit Commands\n\t      These commands will move the cursor.\n\t      [count]l\tCursor forward (right) one character.\n\t      [count][C Cursor forward (right) one character.\n\t      [count]w\tCursor forward one alpha-numeric word.\n\t      [count]W\tCursor to the beginning of the next word that follows\n\t\t\ta blank.\n\t      [count]e\tCursor to end of word.\n\t      [count]E\tCursor to end of the current blank delimited word.\n\t      [count]h\tCursor backward (left) one character.\n\t      [count][D Cursor backward (left) one character.\n\t      [count]b\tCursor backward one word.\n\t      [count]B\tCursor to preceding blank separated word.\n\t      [count]⎪\tCursor to column count.\n\t      [count]fc Find the next character c in the current line.\n\t      [count]Fc Find the previous character c in the current line.\n\t      [count]tc Equivalent to f followed by h.\n\t      [count]Tc Equivalent to F followed by l.\n\t      [count];\tRepeats count times, the last single character find\n\t\t\tcommand, f, F, t, or T.\n\t      [count],\tReverses the last single character find command count\n\t\t\ttimes.\n\t      0 \tCursor to start of line.\n\t      ^ \tCursor to start of line.\n\t      [H\tCursor to first non-blank character in line.\n\t      $ \tCursor to end of line.\n\t      [Y\tCursor to end of line.\n\t      % \tMoves to balancing (, ), {, }, [, or ].  If cursor is\n\t\t\tnot on one of the above characters, the remainder of\n\t\t\tthe line is searched for the first occurrence of one\n\t\t\tof the above characters first.\n\tSearch Edit Commands\n\t      These commands access your command history.\n\t      [count]k\tFetch previous command.  Each time k is entered the\n\t\t\tprevious command back in time is accessed.\n\t      [count]-\tEquivalent to k.\n\t      [count][A If cursor is at the end of the line it is equivalent\n\t\t\tto / with string^set to the contents of the current\n\t\t\tline.  Otherwise, it is equivalent to k.\n\t      [count]j\tFetch next command.  Each time j is entered the next\n\t\t\tcommand forward in time is accessed.\n\t      [count]+\tEquivalent to j.\n\t      [count][B Equivalent to j.\n\t      [count]G\tThe command number count is fetched.  The default is\n\t\t\tthe least recent history command.\n\t      /string\tSearch backward through history for a previous command\n\t\t\tcontaining string.  String is terminated by a `RETURN'\n\t\t\tor `NEW LINE'.\tIf string is preceded by a ^, the\n\t\t\tmatched line must begin with string.  If string is\n\t\t\tnull, the previous string will be used.\n\t      ?string\tSame as / except that search will be in the forward\n\t\t\tdirection.\n\t      n \tSearch for next match of the last pattern to / or ?\n\t\t\tcommands.\n\t      N \tSearch for next match of the last pattern to / or ?,\n\t\t\tbut in reverse direction.\n\tText Modification Edit Commands\n\t      These commands will modify the line.\n\t      a \tEnter input mode and enter text after the current\n\t\t\tcharacter.\n\t      A \tAppend text to the end of the line.  Equivalent to $a.\n\t      [count]cmotion\n\t      c[count]motion\n\t\t\tDelete current character through the character that\n\t\t\tmotion would move the cursor to and enter input mode.\n\t\t\tIf motion is c, the entire line will be deleted and\n\t\t\tinput mode entered.\n\t      C \tDelete the current character through the end of line\n\t\t\tand enter input mode.  Equivalent to c$.\n\t      S \tEquivalent to cc.\n\t      [count]s\tReplace characters under the cursor in input mode.\n\t      D \tDelete the current character through the end of line.\n\t\t\tEquivalent to d$.\n\t      [count]dmotion\n\t      d[count]motion\n\t\t\tDelete current character through the character that\n\t\t\tmotion would move to.  If motion is d , the entire\n\t\t\tline will be deleted.\n\t      i \tEnter input mode and insert text before the current\n\t\t\tcharacter.\n\t      I \tInsert text before the beginning of the line.\n\t\t\tEquivalent to 0i.\n\t      [count]P\tPlace the previous text modification before the\n\t\t\tcursor.\n\t      [count]p\tPlace the previous text modification after the cursor.\n\t      R \tEnter input mode and replace characters on the screen\n\t\t\twith characters you type overlay fashion.\n\t      [count]rc Replace the count character(s) starting at the current\n\t\t\tcursor position with c, and advance the cursor.\n\t      [count]x\tDelete current character.\n\t      [count]X\tDelete preceding character.\n\t      [count].\tRepeat the previous text modification command.\n\t      [count]∼\tInvert the case of the count character(s) starting at\n\t\t\tthe current cursor position and advance the cursor.\n\t      [count]_\tCauses the count word of the previous command to be\n\t\t\tappended and input mode entered.  The last word is\n\t\t\tused if count is omitted.\n\t      * \tCauses an * to be appended to the current word and\n\t\t\tfile name generation attempted.  If no match is found,\n\t\t\tit rings the bell.  Otherwise, the word is replaced by\n\t\t\tthe matching pattern and input mode is entered.\n\t      \\ \tCommand or file name completion as described above.\n\tOther Edit Commands\n\t      Miscellaneous commands.\n\t      [count]ymotion\n\t      y[count]motion\n\t\t\tYank current character through character that motion\n\t\t\twould move the cursor to and puts them into the delete\n\t\t\tbuffer.  The text and cursor are unchanged.\n\t      yy\tYanks the entire line.\n\t      Y \tYanks from current position to end of line.\n\t\t\tEquivalent to y$.\n\t      u \tUndo the last text modifying command.\n\t      U \tUndo all the text modifying commands performed on the\n\t\t\tline.\n\t      [count]v\tReturns the command hist -e ${VISUAL:-${EDITOR:-vi}}\n\t\t\tcount in the input buffer.  If count is omitted, then\n\t\t\tthe current line is used.\n\t      ^L\tLine feed and print current line.  Has effect only in\n\t\t\tcontrol mode.\n\t      ^J\t(New line) Execute the current line, regardless of\n\t\t\tmode.\n\t      ^M\t(Return) Execute the current line, regardless of mode.\n\t      # \tIf the first character of the command is a #, then\n\t\t\tthis command deletes this # and each # that follows a\n\t\t\tnewline.  Otherwise, sends the line after inserting a\n\t\t\t# in front of each line in the command.  Useful for\n\t\t\tcausing the current line to be inserted in the history\n\t\t\tas a comment and uncommenting previously commented\n\t\t\tcommands in the history file.\n\t      [count]=\tIf count is not specified, it generates the list of\n\t\t\tmatching commands or file names as described above.\n\t\t\tOtherwise, the word under the the cursor is replaced\n\t\t\tby the count item from the most recently generated\n\t\t\tcommand or file list.  If the cursor is not on a word,\n\t\t\tit is inserted instead.\n\t      @letter\tYour alias list is searched for an alias by the name\n\t\t\t_letter and if an alias of this name is defined, its\n\t\t\tvalue will be inserted on the input queue for\n\t\t\tprocessing.\n\t      ^V\tDisplay version of the shell."
  manpageQuestion1: What is the primary purpose of the ksh shell in the context of command-line editing?
  manpageQuestion2: How can you use ksh to delete the previous word in a line and replace it with the previous command's argument?
  manpageQuestion3: Can you provide an example of how to use ksh's command history search functionality to find and execute a previous command containing the string 'grep'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nBuilt-in Commands.\n       The following simple-commands are executed in the shell process.\n       Input/Output redirection is permitted.  Unless otherwise indicated, the\n       output is written on file descriptor 1 and the exit status, when there\n       is no syntax error, is zero.  Except for :, true, false, echo, newgrp,\n       and login, all built-in commands accept -- to indicate end of options.\n       They also interpret the option --man as a request to display the man\n       page onto standard error and -?\tas a help request which prints a usage\n       message on standard error.  Commands that are preceded by one or two †\n       symbols are special built-in commands and are treated specially in the\n       following ways:\n       1.     Variable assignment lists preceding the command remain in effect\n\t      when the command completes.\n       2.     I/O redirections are processed after variable assignments.\n       3.     Errors cause a script that contains them to abort.\n       4.     They are not valid function names.\n       5.     Words following a command preceded by †† that are in the format\n\t      of a variable assignment are expanded with the same rules as a\n\t      variable assignment.  This means that tilde substitution is\n\t      performed after the = sign and field splitting and file name\n\t      generation are not performed.  These are called declaration\n\t      built-ins."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use the ksh shell to display a help message for the echo command?
  manpageQuestion3: What is the effect of using the †† syntax in ksh shell scripting?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n† : [ arg ... ]\n\t      The command only expands parameters.\n\n       † . name [ arg ... ]\n\t      If name is a function defined with the function name reserved\n\t      word syntax, the function is executed in the current environment\n\t      (as if it had been defined with the name() syntax.)  Otherwise\n\t      if name refers to a file, the file is read in its entirety and\n\t      the commands are executed in the current shell environment.  The\n\t      search path specified by PATH is used to find the directory\n\t      containing the file.  If any arguments arg are given, they\n\t      become the positional parameters while processing the .  command\n\t      and the original positional parameters are restored upon\n\t      completion.  Otherwise the positional parameters are unchanged.\n\t      The exit status is the exit status of the last command executed.\n\n       †† alias [ -ptx ]  [ name[ =value  ] ] ...\n\t      alias with no arguments prints the list of aliases in the form\n\t      name=value on standard output.  The -p option causes the word\n\t      alias to be inserted before each one.  When one or more\n\t      arguments are given, an alias is defined for each name whose\n\t      value is given.  A trailing space in value causes the next word\n\t      to be checked for alias substitution.  The obsolete -t option is\n\t      used to set and list tracked aliases.  The value of a tracked\n\t      alias is the full pathname corresponding to the given name.  The\n\t      value becomes undefined when the value of PATH is reset but the\n\t      alias remains tracked.  Without the -t option, for each name in\n\t      the argument list for which no value is given, the name and\n\t      value of the alias is printed.  The obsolete -x option has no\n\t      effect.  The exit status is non-zero if a name is given, but no\n\t      value, and no alias has been defined for the name."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use the . command in ksh to source a script file named 'my_script.sh'?
  manpageQuestion3: Can you provide an example of using the alias command in ksh to create a custom alias for the 'ls -l' command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nbg [ job... ]\n\t      This command is only on systems that support job control.  Puts\n\t      each specified job into the background.  The current job is put\n\t      in the background if job is not specified.  See Jobs for a\n\t      description of the format of job.\n\n       † break [ n ]\n\t      Exit from the enclosing for, while, until, or select loop, if\n\t      any.  If n is specified, then break n levels.\n\n       builtin [ -ds ] [ -f file ] [ name ... ]\n\t      If name is not specified, and no -f option is specified, the\n\t      built-ins are printed on standard output.  The -s option prints\n\t      only the special built-ins.  Otherwise, each name represents the\n\t      pathname whose basename is the name of the built-in.  The entry\n\t      point function name is determined by prepending b_ to the built-\n\t      in name.\tA built-in specified by a pathname will only be\n\t      executed when that pathname would be found during the path\n\t      search.  Built-ins found in libraries loaded via the .paths file\n\t      will be associate with the pathname of the directory containing\n\t      the .paths file."
  manpageQuestion1: What is the primary purpose of the ksh command-line interpreter?
  manpageQuestion2: How can you put the current job into the background using ksh?
  manpageQuestion3: What is the function of the 'builtin' command in ksh and how can it be used to list all built-in commands?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    The ISO C/C++ prototype is b_mycommand(int argc, char *argv[], void
           *context) for the builtin command mycommand where argv is array an of
           argc elements and context is an optional pointer to a Shell_t structure
           as described in <ast/shell.h>.
           Special built-ins cannot be bound to a pathname or deleted.  The -d
           option deletes each of the given built-ins.  On systems that support
           dynamic loading, the -f option names a shared library containing the
           code for built-ins.  The shared library prefix and/or suffix, which
           depend on the system, can be omitted.  Once a library is loaded, its
           symbols become available for subsequent invocations of builtin.
           Multiple libraries can be specified with separate invocations of the
           builtin command.  Libraries are searched in the reverse order in which
           they are specified.  When a library is loaded, it looks for a function
           in the library whose name is lib_init() and invokes this function with
           an argument of 0.
  manpageQuestion1: What is the primary purpose of the ksh resource?
  manpageQuestion2: How can you use the -f option with the ksh resource to load a shared library containing built-in commands?
  manpageQuestion3: What is the effect of using the -d option with the ksh resource?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\ncd [ -LP ] [ arg ]\n       cd [ -LP ] old new\n\t      This command can be in either of two forms.  In the first form\n\t      it changes the current directory to arg.\tIf arg is - the\n\t      directory is changed to the previous directory.  The shell\n\t      variable HOME is the default arg.  The variable PWD is set to\n\t      the current directory.  The shell variable CDPATH defines the\n\t      search path for the directory containing arg.  Alternative\n\t      directory names are separated by a colon (:).  The default path\n\t      is <null> (specifying the current directory).  Note that the\n\t      current directory is specified by a null path name, which can\n\t      appear immediately after the equal sign or between the colon\n\t      delimiters anywhere else in the path list.  If arg begins with a\n\t      / then the search path is not used.  Otherwise, each directory\n\t      in the path is searched for arg.\n\t      The second form of cd substitutes the string new for the string\n\t      old in the current directory name, PWD, and tries to change to\n\t      this new directory.\n\t      By default, symbolic link names are treated literally when\n\t      finding the directory name.  This is equivalent to the -L\n\t      option.  The -P option causes symbolic links to be resolved when\n\t      determining the directory.  The last instance of -L or -P on the\n\t      command line determines which method is used.\n\t      The cd command may not be executed by rksh.  rksh93."
  manpageQuestion1: What is the primary purpose of the cd command in a shell environment?
  manpageQuestion2: How can you use the cd command to navigate to the home directory and then change to a subdirectory called 'docs'?
  manpageQuestion3: Can you provide an example of using the cd command with the -P option to resolve symbolic links when changing directories?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\ncommand [ -pvxV ] name [ arg ... ]\n\t      Without the -v or -V options, command executes name with the\n\t      arguments given by arg.  The -p option causes a default path to\n\t      be searched rather than the one defined by the value of PATH.\n\t      Functions will not be searched for when finding name.  In\n\t      addition, if name refers to a special built-in, none of the\n\t      special properties associated with the leading daggers will be\n\t      honored.\t(For example, the predefined alias redirect=′command\n\t      exec′ prevents a script from terminating when an invalid\n\t      redirection is given.)  With the -x option, if command execution\n\t      would result in a failure because there are too many arguments,\n\t      errno E2BIG, the shell will invoke command name multiple times\n\t      with a subset of the arguments on each invocation.  Arguments\n\t      that occur prior to the first word that expands to multiple\n\t      arguments and after the last word that expands to multiple\n\t      arguments will be passed on each invocation.  The exit status\n\t      will be the maximum invocation exit status.  With the -v option,\n\t      command is equivalent to the built-in whence command described\n\t      below.  The -V option causes command to act like whence -v."
  manpageQuestion1: What is the primary purpose of the ksh command?
  manpageQuestion2: How can you use the -x option with ksh to handle command execution with a large number of arguments?
  manpageQuestion3: What does the -v option in ksh do, and how can it be used to display information about a command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n† continue [ n ]\n\t      Resume the next iteration of the enclosing for, while, until, or\n\t      select loop.  If n is specified, then resume at the n-th\n\t      enclosing loop.\n\n       disown [ job... ]\n\t      Causes the shell not to send a HUP signal to each given job, or\n\t      all active jobs if job is omitted, when a login shell\n\t      terminates.\n\n       echo [ arg ... ]\n\t      When the first arg does not begin with a -, and none of the\n\t      arguments contain a \\, then echo prints each of its arguments\n\t      separated by a space and terminated by a new-line.  Otherwise,\n\t      the behavior of echo is system dependent and print or printf\n\t      described below should be used.  See echo(1) for usage and\n\t      description.\n\n       †† enum [ -i  ] type[=(value ...) ]\n\t      Creates a declaration command named type that is an integer type\n\t      that allows one of the specified values as enumeration names.\n\t      If =(value_...) is omitted, then type must be an indexed array\n\t      variable with at least two elements and the values are taken\n\t      from this array variable.  If -i is specified the values are\n\t      case insensitive."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use the echo command in ksh to print the string 'Hello, World!' followed by a newline?
  manpageQuestion3: Can you provide an example of using the enum command in ksh to create an enumerated type with case-insensitive values?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n† eval [ arg ... ]\n\t      The arguments are read as input to the shell and the resulting\n\t      command(s) executed.\n\n       † exec [ -c ] [ -a name ] [ arg ... ]\n\t      If arg is given, the command specified by the arguments is\n\t      executed in place of this shell without creating a new process.\n\t      The -c option causes the environment to be cleared before\n\t      applying variable assignments associated with the exec\n\t      invocation.  The -a option causes name rather than the first\n\t      arg, to become argv[0] for the new process.  Input/output\n\t      arguments may appear and affect the current process.  If arg is\n\t      not given, the effect of this command is to modify file\n\t      descriptors as prescribed by the input/output redirection list.\n\t      In this case, any file descriptor numbers greater than 2 that\n\t      are opened with this mechanism are closed when invoking another\n\t      program.\n\n       † exit [ n ]\n\t      Causes the shell to exit with the exit status specified by n.\n\t      The value will be the least significant 8 bits of the specified\n\t      status.  If n is omitted, then the exit status is that of the\n\t      last command executed.  An end-of-file will also cause the shell\n\t      to exit except for a shell which has the ignoreeof option (see\n\t      set below) turned on."
  manpageQuestion1: What is the primary purpose of the ksh shell command resource?
  manpageQuestion2: How can you use the `exec` command in ksh to replace the current shell process with a new program, while preserving file descriptors?
  manpageQuestion3: What is the function of the `exit` command in ksh, and how would you use it to terminate the shell with a specific exit status?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n†† export [ -p ] [ name[=value] ] ...\n\t      If name is not given, the names and values of each variable with\n\t      the export attribute are printed with the values quoted in a\n\t      manner that allows them to be re-input.  The export command is\n\t      the same as typeset -x except that if you use export within a\n\t      function, no local variable is created.  The -p option causes\n\t      the word export to be inserted before each one.  Otherwise, the\n\t      given names are marked for automatic export to the environment\n\t      of subsequently-executed commands.\n\n       false  Does nothing, and exits 1. Used with until for infinite loops.\n\n       fg [ job... ]\n\t      This command is only on systems that support job control.  Each\n\t      job specified is brought to the foreground and waited for in the\n\t      specified order.\tOtherwise, the current job is brought into the\n\t      foreground.  See Jobs for a description of the format of job.\n\n       getconf [ name [ pathname ] ]\n\t      Prints the current value of the configuration parameter given by\n\t      name.  The configuration parameters are defined by the IEEE\n\t      POSIX 1003.1 and IEEE POSIX 1003.2 standards.  (See pathconf(2)\n\t      and sysconf(2).)\tThe pathname argument is required for\n\t      parameters whose value depends on the location in the file\n\t      system.  If no arguments are given, getconf prints the names and\n\t      values of the current configuration parameters.  The pathname /\n\t      is used for each of the parameters that requires pathname."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use the export command in ksh to make a variable available to subsequent commands?
  manpageQuestion3: Can you provide an example of using the getconf command to retrieve a system configuration parameter?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\ngetopts [  -a name ] optstring vname [ arg ... ]\n\t      Checks arg for legal options.  If arg is omitted, the positional\n\t      parameters are used.  An option argument begins with a + or a -.\n\t      An option not beginning with + or - or the argument -- ends the\n\t      options.\tOptions beginning with + are only recognized when\n\t      optstring begins with a +.  optstring contains the letters that\n\t      getopts recognizes.  If a letter is followed by a :, that option\n\t      is expected to have an argument.\tThe options can be separated\n\t      from the argument by blanks.  The option -?  causes getopts to\n\t      generate a usage message on standard error.  The -a argument can\n\t      be used to specify the name to use for the usage message, which\n\t      defaults to $0.\n\t      getopts places the next option letter it finds inside variable\n\t      vname each time it is invoked.  The option letter will be\n\t      prepended with a + when arg begins with a +.  The index of the\n\t      next arg is stored in OPTIND.  The option argument, if any, gets\n\t      stored in OPTARG.\n\t      A leading : in optstring causes getopts to store the letter of\n\t      an invalid option in OPTARG, and to set vname to ?  for an\n\t      unknown option and to : when a required option argument is\n\t      missing.\tOtherwise, getopts prints an error message.  The exit\n\t      status is non-zero when there are no more options.\n\t      There is no way to specify any of the options :, +, -, ?, [, and\n\t      ].  The option # can only be specified as the first option."
  manpageQuestion1: What is the primary purpose of the `getopts` command in the context of shell scripting?
  manpageQuestion2: How can you use `getopts` to handle command-line options with arguments, such as -f filename?
  manpageQuestion3: Can you provide an example of using `getopts` to generate a usage message when an invalid option is provided?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nhist [ -e ename\t] [ -nlr ] [ first [ last ] ]\n       hist -s\t[ old=new ] [ command ]\n\t      In the first form, a range of commands from first to last is\n\t      selected from the last HISTSIZE commands that were typed at the\n\t      terminal.  The arguments first and last may be specified as a\n\t      number or as a string.  A string is used to locate the most\n\t      recent command starting with the given string.  A negative\n\t      number is used as an offset to the current command number.  If\n\t      the -l option is selected, the commands are listed on standard\n\t      output.  Otherwise, the editor program ename is invoked on a\n\t      file containing these keyboard commands.\tIf ename is not\n\t      supplied, then the value of the variable HISTEDIT is used.  If\n\t      HISTEDIT is not set, then FCEDIT (default /bin/ed) is used as\n\t      the editor.  When editing is complete, the edited command(s) is\n\t      executed if the changes have been saved.\tIf last is not\n\t      specified, then it will be set to first.\tIf first is not\n\t      specified, the default is the previous command for editing and\n\t      -16 for listing.\tThe option -r reverses the order of the\n\t      commands and the option -n suppresses command numbers when\n\t      listing.\tIn the second form, command is interpreted as first\n\t      described above and defaults to the last command executed.  The\n\t      resulting command is executed after the optional substitution\n\t      old=new is performed."
  manpageQuestion1: What is the primary purpose of the hist command in the ksh shell?
  manpageQuestion2: How can you use the hist command to edit and re-execute a range of previously entered commands?
  manpageQuestion3: Can you provide an example of using the hist command with the -r option to reverse the order of commands and suppress command numbers when listing?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\njobs [ -lnp ] [ job ... ]\n\t      Lists information about each given job; or all active jobs if\n\t      job is omitted.  The -l option lists process ids in addition to\n\t      the normal information.  The -n option only displays jobs that\n\t      have stopped or exited since last notified.  The -p option\n\t      causes only the process group to be listed.  See Jobs for a\n\t      description of the format of job.\n\n       kill [ -s signame ] job ...\n       kill [ -n signum ] job ...\n       kill -Ll [ sig ... ]\n\t      Sends either the TERM (terminate) signal or the specified signal\n\t      to the specified jobs or processes.  Signals are either given by\n\t      number with the -n option or by name with the -s option (as\n\t      given in <signal.h>, stripped of the prefix ``SIG'' with the\n\t      exception that SIGCLD is named CHLD).  For backward\n\t      compatibility, the n and s can be omitted and the number or name\n\t      placed immediately after the -.  If the signal being sent is\n\t      TERM (terminate) or HUP (hangup), then the job or process will\n\t      be sent a CONT (continue) signal if it is stopped.  The argument\n\t      job can be the process id of a process that is not a member of\n\t      one of the active jobs.  See Jobs for a description of the\n\t      format of job.  In the third form, kill -l, or kill -L, if sig\n\t      is not specified, the signal names are listed.  The -l option\n\t      list only the signal names.  -L options lists each signal name\n\t      and corresponding number.  Otherwise, for each sig that is a\n\t      name, the corresponding signal number is listed.\tFor each sig\n\t      that is a number, the signal name corresponding to the least\n\t      significant 8 bits of sig is listed."
  manpageQuestion1: What is the primary purpose of the ksh shell's jobs command?
  manpageQuestion2: How can you use the kill command in ksh to send a SIGTERM signal to all active jobs?
  manpageQuestion3: What is the difference between using kill -l and kill -L in ksh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nlet arg ...\n\t      Each arg is a separate arithmetic expression to be evaluated.\n\t      let only recognizes octal constants starting with 0 when the set\n\t      option letoctal is on.  See Arithmetic Evaluation above, for a\n\t      description of arithmetic expression evaluation.\n\t      The exit status is 0 if the value of the last expression is non-\n\t      zero, and 1 otherwise.\n\n       † newgrp [ arg ... ]\n\t      Equivalent to exec /bin/newgrp arg ....\n\n       print [ -CRenprsv ] [ -u unit] [ -f format ] [ arg ... ]\n\t      With no options or with option - or --, each arg is printed on\n\t      standard output.\tThe -f option causes the arguments to be\n\t      printed as described by printf.  In this case, any e, n, r, R\n\t      options are ignored.  Otherwise, unless the -C, -R, -r, or -v\n\t      are specified, the following escape conventions will be applied:\n\t      \\a     The alert character (ascii 07).\n\t      \\b     The backspace character (ascii 010).\n\t      \\c     Causes print to end without processing more arguments and\n\t\t     not adding a new-line.\n\t      \\f     The formfeed character (ascii 014).\n\t      \\n     The new-line character (ascii 012).\n\t      \\r     The carriage return character (ascii 015).\n\t      \\t     The tab character (ascii 011).\n\t      \\v     The vertical tab character (ascii 013).\n\t      \\E     The escape character (ascii 033).\n\t      \\\\     The backslash character \\.\n\t      \\0x    The character defined by the 1, 2, or 3-digit octal\n\t\t     string given by x."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use the print command in ksh to display the current date and time formatted as YYYY-MM-DD HH:MM:SS?
  manpageQuestion3: Can you explain how to use the let command in ksh to increment a variable by 1 and then check if it is greater than 10?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThe -R option will print all subsequent arguments and options\n\t      other than -n.  The -e causes the above escape conventions to be\n\t      applied.\tThis is the default behavior.  It reverses the effect\n\t      of an earlier -r.  The -p option causes the arguments to be\n\t      written onto the pipe of the process spawned with ⎪& instead of\n\t      standard output.\tThe -v option treats each arg as a variable\n\t      name and writes the value in the printf %B format.  The -C\n\t      option treats each arg as a variable name and writes the value\n\t      in the printf %#B format.  The -s option causes the arguments to\n\t      be written onto the history file instead of standard output.\n\t      The -u option can be used to specify a one digit file descriptor\n\t      unit number unit on which the output will be placed.  The\n\t      default is 1.  If the option -n is used, no new-line is added to\n\t      the output.\n\n       printf format [ arg ... ]\n\t      The arguments arg are printed on standard output in accordance\n\t      with the ANSI-C formatting rules associated with the format\n\t      string format.  If the number of arguments exceeds the number of\n\t      format specifications, the format string is reused to format\n\t      remaining arguments.  The following extensions can also be used:\n\t      %b     A %b format can be used instead of %s to cause escape\n\t\t     sequences in the corresponding arg to be expanded as\n\t\t     described in print.\n\t      %B     A %B option causes each of the arguments to be treated as\n\t\t     variable names and the binary value of variable will be\n\t\t     printed.  The alternate flag # causes a compound variable\n\t\t     to be output on a single line.  This is most useful for\n\t\t     compound variables and variables whose attribute is -b.\n\t      %H     A %H format can be used instead of %s to cause characters\n\t\t     in arg that are special in HTML and XML to be output as\n\t\t     their entity name.  The alternate flag # formats the\n\t\t     output for use as a URI.\n\t      %P     A %P format can be used instead of %s to cause arg to be\n\t\t     interpreted as an extended regular expression and be\n\t\t     printed as a shell pattern.\n\t      %R     A %R format can be used instead of %s to cause arg to be\n\t\t     interpreted as a shell pattern and to be printed as an\n\t\t     extended regular expression.\n\t      %q     A %q format can be used instead of %s to cause the\n\t\t     resulting string to be quoted in a manner than can be\n\t\t     reinput to the shell.  When q is preceded by the\n\t\t     alternative format specifier, #, the string is quoted in\n\t\t     manner suitable as a field in a .csv format file.\n\t      %(date-format)T\n\t\t     A %(date-format)T format can be use to treat an argument\n\t\t     as a date/time string and to format the date/time\n\t\t     according to the date-format as defined for the date(1)\n\t\t     command.\n\t      %Z     A %Z format will output a byte whose value is 0.\n\t      %d     The precision field of the %d format can be followed by a\n\t\t     .\tand the output base.  In this case, the # flag\n\t\t     character causes base# to be prepended.\n\t      #      The # flag, when used with the %d format without an\n\t\t     output base, displays the output in powers of 1000\n\t\t     indicated by one of the following suffixes: k M G T P E,\n\t\t     and when used with the %i format displays the output in\n\t\t     powers of 1024 indicated by one of the following\n\t\t     suffixes: Ki Mi Gi Ti Pi Ei.\n\t      =      The = flag centers the output within the specified field\n\t\t     width.\n\t      L      The L flag, when used with the %c or %s formats, treats\n\t\t     precision as character width instead of byte count.\n\t      ,      The , flag, when used with the %d or %f formats,\n\t\t     separates groups of digits with the grouping delimiter (,\n\t\t     on groups of 3 in the C locale.)"
  manpageQuestion1: What is the primary purpose of the ksh command in this context?
  manpageQuestion2: How can you use the ksh command to print the value of a variable in binary format and on a single line?
  manpageQuestion3: Can you provide an example of using the ksh command to format and output a date string according to specific date formatting rules?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\npwd [ -LP ]\n\t      Outputs the value of the current working directory.  The -L\n\t      option is the default; it prints the logical name of the current\n\t      directory.  If the -P option is given, all symbolic links are\n\t      resolved from the name.  The last instance of -L or -P on the\n\t      command line determines which method is used.\n\n       read [ -ACSprsv ] [ -d delim] [ -n n] [ [ -N n] [ [ -t timeout] [ -u\n       unit] [ vname?prompt ] [ vname ... ]\n\t      The shell input mechanism.  One line is read and is broken up\n\t      into fields using the characters in IFS as separators.  The\n\t      escape character, \\, is used to remove any special meaning for\n\t      the next character and for line continuation.  The -d option\n\t      causes the read to continue to the first character of delim\n\t      rather than new-line.  The -n option causes at most n bytes to\n\t      read rather a full line but will return when reading from a slow\n\t      device as soon as any characters have been read.\tThe -N option\n\t      causes exactly n to be read unless an end-of-file has been\n\t      encountered or the read times out because of the -t option.  In\n\t      raw mode, -r, the \\ character is not treated specially.  The\n\t      first field is assigned to the first vname, the second field to\n\t      the second vname, etc., with leftover fields assigned to the\n\t      last vname.  When vname has the binary attribute and -n or -N is\n\t      specified, the bytes that are read are stored directly into the\n\t      variable.  If the -v is specified, then the value of the first\n\t      vname will be used as a default value when reading from a\n\t      terminal device.\tThe -A option causes the variable vname to be\n\t      unset and each field that is read to be stored in successive\n\t      elements of the indexed array vname.  The -C option causes the\n\t      variable vname to be read as a compound variable.  Blanks will\n\t      be ignored when finding the beginning open parenthesis.  The -S\n\t      option causes the line to be treated like a record in a .csv\n\t      format file so that double quotes can be used to allow the\n\t      delimiter character and the new-line character to appear within\n\t      a field.\tThe -p option causes the input line to be taken from\n\t      the input pipe of a process spawned by the shell using ⎪&.  If\n\t      the -s option is present, the input will be saved as a command\n\t      in the history file.  The option -u can be used to specify a one\n\t      digit file descriptor unit unit to read from.  The file\n\t      descriptor can be opened with the exec special built-in command.\n\t      The default value of unit n is 0.  The option -t is used to\n\t      specify a timeout in seconds when reading from a terminal or\n\t      pipe.  If vname is omitted, then REPLY is used as the default\n\t      vname.  An end-of-file with the -p option causes cleanup for\n\t      this process so that another can be spawned.  If the first\n\t      argument contains a ?, the remainder of this word is used as a\n\t      prompt on standard error when the shell is interactive.  The\n\t      exit status is 0 unless an end-of-file is encountered or read\n\t      has timed out."
  manpageQuestion1: What is the primary purpose of the ksh command?
  manpageQuestion2: How can you use the read command in ksh to read a line of input from the user and store it into a variable named 'user_input'?
  manpageQuestion3: What is the function of the -d option in the read command, and how would you use it to read input up to a specific delimiter?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n†† readonly [ -p ] [ vname[=value] ] ...\n\t      If vname is not given, the names and values of each variable\n\t      with the readonly attribute is printed with the values quoted in\n\t      a manner that allows them to be re-inputted.  The -p option\n\t      causes the word readonly to be inserted before each one.\n\t      Otherwise, the given vnames are marked readonly and these names\n\t      cannot be changed by subsequent assignment.  When defining a\n\t      type, if the value of a readonly sub-variable is not defined the\n\t      value is required when creating each instance.\n\n       † return [ n ]\n\t      Causes a shell function or . script to return to the invoking\n\t      script with the exit status specified by n.  The value will be\n\t      the least significant 8 bits of the specified status.  If n is\n\t      omitted, then the return status is that of the last command\n\t      executed.  If return is invoked while not in a function or a .\n\t      script, then it behaves the same as exit.\n\n       † set [ ±BCGabefhkmnoprstuvx ] [ ±o [ option ] ] ... [ ±A vname ]  [\n       arg ... ]\n\t      The options for this command have meaning as follows:\n\t      -A      Array assignment.  Unset the variable vname and assign\n\t\t      values sequentially from the arg list.  If +A is used,\n\t\t      the variable vname is not unset first.\n\t      -B      Enable brace pattern field generation.  This is the\n\t\t      default behavior.\n\t      -B      Enable brace group expansion.  On by default.\n\t      -C      Prevents redirection > from truncating existing files.\n\t\t      Files that are created are opened with the O_EXCL mode.\n\t\t      Requires >⎪ to truncate a file when turned on.\n\t      -G      Causes the pattern ∗∗ by itself to match files and zero\n\t\t      or more directories and sub-directories when used for\n\t\t      file name generation.  If followed by a / only\n\t\t      directories and sub-directories are matched.\n\t      -a      All subsequent variables that are defined are\n\t\t      automatically exported.\n\t      -b      Prints job completion messages as soon as a background\n\t\t      job changes state rather than waiting for the next\n\t\t      prompt.\n\t      -e      Unless contained in a ⎪⎪ or && command, or the command\n\t\t      following an if while or until command or in the\n\t\t      pipeline following !, if a command has a non-zero exit\n\t\t      status, execute the ERR trap, if set, and exit.  This\n\t\t      mode is disabled while reading profiles.\n\t      -f      Disables file name generation.\n\t      -h      Each command becomes a tracked alias when first\n\t\t      encountered.\n\t      -k      (Obsolete). All variable assignment arguments are placed\n\t\t      in the environment for a command, not just those that\n\t\t      precede the command name.\n\t      -m      Background jobs will run in a separate process group and\n\t\t      a line will print upon completion.  The exit status of\n\t\t      background jobs is reported in a completion message.  On\n\t\t      systems with job control, this option is turned on\n\t\t      automatically for interactive shells.\n\t      -n      Read commands and check them for syntax errors, but do\n\t\t      not execute them.  Ignored for interactive shells.\n\t      -o      The following argument can be one of the following\n\t\t      option names:\n\t\t      allexport\n\t\t\t      Same as -a.\n\t\t      errexit Same as -e.\n\t\t      bgnice  All background jobs are run at a lower priority.\n\t\t\t      This is the default mode.\n\t\t      braceexpand\n\t\t\t      Same as -B.\n\t\t      emacs   Puts you in an emacs style in-line editor for\n\t\t\t      command entry.\n\t\t      globstar\n\t\t\t      Same as -G.\n\t\t      gmacs   Puts you in a gmacs style in-line editor for\n\t\t\t      command entry.\n\t\t      ignoreeof\n\t\t\t      The shell will not exit on end-of-file.  The\n\t\t\t      command exit must be used.\n\t\t      keyword Same as -k.\n\t\t      letoctal\n\t\t\t      The let command allows octal constants starting\n\t\t\t      with 0.\n\t\t      markdirs\n\t\t\t      All directory names resulting from file name\n\t\t\t      generation have a trailing / appended.\n\t\t      monitor Same as -m.\n\t\t      multiline\n\t\t\t      The built-in editors will use multiple lines on\n\t\t\t      the screen for lines that are longer than the\n\t\t\t      width of the screen.  This may not work for all\n\t\t\t      terminals.\n\t\t      noclobber\n\t\t\t      Same as -C.\n\t\t      noexec  Same as -n.\n\t\t      noglob  Same as -f.\n\t\t      nolog   Do not save function definitions in the history\n\t\t\t      file.\n\t\t      notify  Same as -b.\n\t\t      nounset Same as -u.\n\t\t      pipefail\n\t\t\t      A pipeline will not complete until all\n\t\t\t      components of the pipeline have completed, and\n\t\t\t      the return value will be the value of the last\n\t\t\t      non-zero command to fail or zero if no command\n\t\t\t      has failed.\n\t\t      showme  When enabled, simple commands or pipelines\n\t\t\t      preceded by a semicolon (;) will be displayed as\n\t\t\t      if the xtrace option were enabled but will not\n\t\t\t      be executed.  Otherwise, the leading ; will be\n\t\t\t      ignored.\n\t\t      privileged\n\t\t\t      Same as -p.\n\t\t      verbose Same as -v.\n\t\t      trackall\n\t\t\t      Same as -h.\n\t\t      vi      Puts you in insert mode of a vi style in-line\n\t\t\t      editor until you hit the escape character 033.\n\t\t\t      This puts you in control mode.  A return sends\n\t\t\t      the line.\n\t\t      viraw   Each character is processed as it is typed in vi\n\t\t\t      mode.\n\t\t      xtrace  Same as -x.\n\t\t      If no option name is supplied, then the current option\n\t\t      settings are printed.\n\t      -p      Disables processing of the $HOME/.profile file and uses\n\t\t      the file /etc/suid_profile instead of the ENV file.\n\t\t      This mode is on whenever the effective uid (gid) is not\n\t\t      equal to the real uid (gid).  Turning this off causes\n\t\t      the effective uid and gid to be set to the real uid and\n\t\t      gid.\n\t      -r      Enables the restricted shell.  This option cannot be\n\t\t      unset once set.\n\t      -s      Sort the positional parameters lexicographically.\n\t      -t      (Obsolete).  Exit after reading and executing one\n\t\t      command.\n\t      -u      Treat unset parameters as an error when substituting.\n\t      -v      Print shell input lines as they are read.\n\t      -x      Print commands and their arguments as they are executed.\n\t      --      Do not change any of the options; useful in setting $1\n\t\t      to a value beginning with -.  If no arguments follow\n\t\t      this option then the positional parameters are unset."
  manpageQuestion1: What is the primary purpose of the ksh command in a macOS environment?
  manpageQuestion2: How would you use ksh to set a readonly variable that cannot be modified later?
  manpageQuestion3: Can you provide an example of using the ksh 'set' command with the -A option to assign values to a variable?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nAs an obsolete feature, if the first arg is - then the -x and -v\n\t      options are turned off and the next arg is treated as the first\n\t      argument.  Using + rather than - causes these options to be\n\t      turned off.  These options can also be used upon invocation of\n\t      the shell.  The current set of options may be found in $-.\n\t      Unless -A is specified, the remaining arguments are positional\n\t      parameters and are assigned, in order, to $1 $2 ....  If no\n\t      arguments are given, then the names and values of all variables\n\t      are printed on the standard output.\n\n       † shift [ n ]\n\t      The positional parameters from $n+1 ...  are renamed $1 ... ,\n\t      default n is 1.  The parameter n can be any arithmetic\n\t      expression that evaluates to a non-negative number less than or\n\t      equal to $#.\n\n       sleep seconds\n\t      Suspends execution for the number of decimal seconds or\n\t      fractions of a second given by seconds.\n\n       † trap [ -p ] [ action ] [ sig ] ...\n\t      The -p option causes the trap action associated with each trap\n\t      as specified by the arguments to be printed with appropriate\n\t      quoting.\tOtherwise, action will be processed as if it were an\n\t      argument to eval when the shell receives signal(s) sig.  Each\n\t      sig can be given as a number or as the name of the signal.  Trap\n\t      commands are executed in order of signal number.\tAny attempt to\n\t      set a trap on a signal that was ignored on entry to the current\n\t      shell is ineffective.  If action is omitted and the first sig is\n\t      a number, or if action is -, then the trap(s) for each sig are\n\t      reset to their original values.  If action is the null string\n\t      then this signal is ignored by the shell and by the commands it\n\t      invokes.\tIf sig is ERR then action will be executed whenever a\n\t      command has a non-zero exit status.  If sig is DEBUG then action\n\t      will be executed before each command.  The variable .sh.command\n\t      will contain the contents of the current command line when\n\t      action is running.  If the exit status of the trap is 2 the\n\t      command will not be executed.  If the exit status of the trap is\n\t      255 and inside a function or a dot script, the function or dot\n\t      script will return.  If sig is 0 or EXIT and the trap statement\n\t      is executed inside the body of a function defined with the\n\t      function name syntax, then the command action is executed after\n\t      the function completes.  If sig is 0 or EXIT for a trap set\n\t      outside any function then the command action is executed on exit\n\t      from the shell.  If sig is KEYBD, then action will be executed\n\t      whenever a key is read while in emacs, gmacs, or vi mode.  The\n\t      trap command with no arguments prints a list of commands\n\t      associated with each signal number."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use the `trap` command in ksh to execute a function when a specific signal is received?
  manpageQuestion3: What is the effect of using the `shift` command with an arithmetic expression in ksh?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nAn exit or return without an argument in a trap action will preserve\n       the exit status of the command that invoked the trap.\n\n       true   Does nothing, and exits 0. Used with while for infinite loops.\n\n       †† typeset [ ±ACHSfblmnprtux ] [ ±EFLRXZi[n] ]\t[ +-M  [ mapname ] ] [\n       -T  [ tname=(assign_list) ] ] [ -h str ] [ -a [type] ] [ vname[=value ]\n       ] ...  Sets attributes and values for shell variables and functions.\n\t      When invoked inside a function defined with the function name\n\t      syntax, a new instance of the variable vname is created, and the\n\t      variable's value and type are restored when the function\n\t      completes.  The following list of attributes may be specified:\n\t      -A     Declares vname to be an associative array.  Subscripts\n\t\t     are strings rather than arithmetic expressions.\n\t      -C     causes each vname to be a compound variable.  value names\n\t\t     a compound variable it is copied into vname.  Otherwise,\n\t\t     it unsets each vname.\n\t      -a     Declares vname to be an indexed array.  If type is\n\t\t     specified, it must be the name of an enumeration type\n\t\t     created with the enum command and it allows enumeration\n\t\t     constants to be used as subscripts.\n\t      -E     Declares vname to be a double precision floating point\n\t\t     number.  If n is non-zero, it defines the number of\n\t\t     significant figures that are used when expanding vname.\n\t\t     Otherwise, ten significant figures will be used.\n\t      -F     Declares vname to be a double precision floating point\n\t\t     number.  If n is non-zero, it defines the number of\n\t\t     places after the decimal point that are used when\n\t\t     expanding vname.  Otherwise ten places after the decimal\n\t\t     point will be used.\n\t      -H     This option provides UNIX to host-name file mapping on\n\t\t     non-UNIX machines.\n\t      -L     Left justify and remove leading blanks from value.  If n\n\t\t     is non-zero, it defines the width of the field, otherwise\n\t\t     it is determined by the width of the value of first\n\t\t     assignment.  When the variable is assigned to, it is\n\t\t     filled on the right with blanks or truncated, if\n\t\t     necessary, to fit into the field.\tThe -R option is\n\t\t     turned off.\n\t      -M     Use the character mapping mapping defined by wctrans(3).\n\t\t     such as tolower and toupper when assigning a value to\n\t\t     each of the specified operands.  When mapping is\n\t\t     specified and there are not operands, all variables that\n\t\t     use this mapping are written to standard output.  When\n\t\t     mapping is omitted and there are no operands, all mapped\n\t\t     variables are written to standard output.\n\t      -R     Right justify and fill with leading blanks.  If n is non-\n\t\t     zero, it defines the width of the field, otherwise it is\n\t\t     determined by the width of the value of first assignment.\n\t\t     The field is left filled with blanks or truncated from\n\t\t     the end if the variable is reassigned.  The -L option is\n\t\t     turned off.\n\t      -S     When used within the assign_list of a type definition, it\n\t\t     causes the specified sub-variable to be shared by all\n\t\t     instances of the type.  When used inside a function\n\t\t     defined with the function reserved word, the specified\n\t\t     variables will have function static scope.  Otherwise,\n\t\t     the variable is unset prior to processing the assignment\n\t\t     list.\n\t      -T     If followed by tname, it creates a type named by tname\n\t\t     using the compound assignment assign_list to tname.\n\t\t     Otherwise, it writes all the type definitions to standard\n\t\t     output.\n\t      -X     Declares vname to be a double precision floating point\n\t\t     number and expands using the %a format of ISO-C99.  If n\n\t\t     is non-zero, it defines the number of hex digits after\n\t\t     the radix point that is used when expanding vname.  The\n\t\t     default is 10.\n\t      -Z     Right justify and fill with leading zeros if the first\n\t\t     non-blank character is a digit and the -L option has not\n\t\t     been set.\tRemove leading zeros if the -L option is also\n\t\t     set.  If n is non-zero, it defines the width of the\n\t\t     field, otherwise it is determined by the width of the\n\t\t     value of first assignment.\n\t      -f     The names refer to function names rather than variable\n\t\t     names.  No assignments can be made and the only other\n\t\t     valid options are -S, -t, -u and -x.  The -S can be used\n\t\t     with discipline functions defined in a type to indicate\n\t\t     that the function is static.  For a static function, the\n\t\t     same method will be used by all instances of that type no\n\t\t     matter which instance references it.  In addition, it can\n\t\t     only use value of variables from the original type\n\t\t     definition.  These discipline functions cannot be\n\t\t     redefined in any type instance.  The -t option turns on\n\t\t     execution tracing for this function.  The -u option\n\t\t     causes this function to be marked undefined.  The FPATH\n\t\t     variable will be searched to find the function definition\n\t\t     when the function is referenced.  If no options other\n\t\t     than -f is specified, then the function definition will\n\t\t     be displayed on standard output.  If +f is specified,\n\t\t     then a line containing the function name followed by a\n\t\t     shell comment containing the line number and path name of\n\t\t     the file where this function was defined, if any, is\n\t\t     displayed.  The exit status can be used to determine\n\t\t     whether the function is defined so that typeset -f\n\t\t     .sh.math.name will return 0 when math function name is\n\t\t     defined and non-zero otherwise.\n\t      -b     The variable can hold any number of bytes of data.  The\n\t\t     data can be text or binary.  The value is represented by\n\t\t     the base64 encoding of the data.  If -Z is also\n\t\t     specified, the size in bytes of the data in the buffer\n\t\t     will be determined by the size associated with the -Z.\n\t\t     If the base64 string assigned results in more data, it\n\t\t     will be truncated.  Otherwise, it will be filled with\n\t\t     bytes whose value is zero.  The printf format %B can be\n\t\t     used to output the actual data in this buffer instead of\n\t\t     the base64 encoding of the data.\n\t      -h     Used within type definitions to add information when\n\t\t     generating information about the sub-variable on the man\n\t\t     page.  It is ignored when used outside of a type\n\t\t     definition.  When used with -f the information is\n\t\t     associated with the corresponding discipline function.\n\t      -i     Declares vname to be represented internally as integer.\n\t\t     The right hand side of an assignment is evaluated as an\n\t\t     arithmetic expression when assigning to an integer.  If n\n\t\t     is non-zero, it defines the output arithmetic base,\n\t\t     otherwise the output base will be ten.\n\t      -l     Used with -i, -E or -F, to indicate long integer, or long\n\t\t     float.  Otherwise, all upper-case characters are\n\t\t     converted to lower-case.  The upper-case option, -u, is\n\t\t     turned off.  Equivalent to -M tolower .\n\t      -m     moves or renames the variable.  The value is the name of\n\t\t     a variable whose value will be moved to vname.  The\n\t\t     original variable will be unset.  Cannot be used with any\n\t\t     other options.\n\t      -n     Declares vname to be a reference to the variable whose\n\t\t     name is defined by the value of variable vname.  This is\n\t\t     usually used to reference a variable inside a function\n\t\t     whose name has been passed as an argument.  Cannot be\n\t\t     used with any other options.\n\t      -p     The name, attributes and values for the given vnames are\n\t\t     written on standard output in a form that can be used as\n\t\t     shell input.  If +p is specified, then the values are not\n\t\t     displayed.\n\t      -r     The given vnames are marked readonly and these names\n\t\t     cannot be changed by subsequent assignment.\n\t      -t     Tags the variables.  Tags are user definable and have no\n\t\t     special meaning to the shell.\n\t      -u     When given along with -i, specifies unsigned integer.\n\t\t     Otherwise, all lower-case characters are converted to\n\t\t     upper-case.  The lower-case option, -l, is turned off.\n\t\t     Equivalent to -M toupper .\n\t      -x     The given vnames are marked for automatic export to the\n\t\t     environment of subsequently-executed commands.  Variables\n\t\t     whose names contain a . cannot be exported."
  manpageQuestion1: What is the primary purpose of the `typeset` command in the ksh shell?
  manpageQuestion2: How can you declare a variable as an associative array in ksh using the `typeset` command?
  manpageQuestion3: Can you demonstrate an example of using `typeset` to declare a variable as a double-precision floating-point number with 10 significant figures?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nThe -i attribute cannot be specified along with -R, -L, -Z, or\n\t      -f.\n\n\t      Using + rather than - causes these options to be turned off.  If\n\t      no vname arguments are given, a list of vnames (and optionally\n\t      the values) of the variables is printed.\t(Using + rather than -\n\t      keeps the values from being printed.)  The -p option causes\n\t      typeset followed by the option letters to be printed before each\n\t      name rather than the names of the options.  If any option other\n\t      than -p is given, only those variables which have all of the\n\t      given options are printed.  Otherwise, the vnames and attributes\n\t      of all variables that have attributes are printed.\n\n       ulimit [ -HSacdfmnpstv ] [ limit ]\n\t      Set or display a resource limit.\tThe available resource limits\n\t      are listed below.  Many systems do not support one or more of\n\t      these limits.  The limit for a specified resource is set when\n\t      limit is specified.  The value of limit can be a number in the\n\t      unit specified below with each resource, or the value unlimited.\n\t      The -H and -S options specify whether the hard limit or the soft\n\t      limit for the given resource is set.  A hard limit cannot be\n\t      increased once it is set.  A soft limit can be increased up to\n\t      the value of the hard limit.  If neither the H nor S option is\n\t      specified, the limit applies to both.  The current resource\n\t      limit is printed when limit is omitted.  In this case, the soft\n\t      limit is printed unless H is specified.  When more than one\n\t      resource is specified, then the limit name and unit is printed\n\t      before the value.\n\t      -a     Lists all of the current resource limits.\n\t      -c     The number of 512-byte blocks on the size of core dumps.\n\t      -d     The number of K-bytes on the size of the data area.\n\t      -f     The number of 512-byte blocks on files that can be\n\t\t     written by the current process or by child processes\n\t\t     (files of any size may be read).\n\t      -m     The number of K-bytes on the size of physical memory.\n\t      -n     The number of file descriptors plus 1.\n\t      -p     The number of 512-byte blocks for pipe buffering.\n\t      -s     The number of K-bytes on the size of the stack area.\n\t      -t     The number of CPU seconds to be used by each process.\n\t      -v     The number of K-bytes for virtual memory."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you use the ulimit command to set a soft limit on the maximum size of core dumps in kilobytes?
  manpageQuestion3: Can you explain how to display all current resource limits using the ulimit command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nIf no option is given, -f is assumed.\n\n       umask [ -S ] [ mask ]\n\t      The user file-creation mask is set to mask (see umask(2)).  mask\n\t      can either be an octal number or a symbolic value as described\n\t      in chmod(1).  If a symbolic value is given, the new umask value\n\t      is the complement of the result of applying mask to the\n\t      complement of the previous umask value.  If mask is omitted, the\n\t      current value of the mask is printed.  The -S option causes the\n\t      mode to be printed as a symbolic value.  Otherwise, the mask is\n\t      printed in octal.\n\n       † unalias [ -a ] name ...\n\t      The aliases given by the list of names are removed from the\n\t      alias list.  The -a option causes all the aliases to be unset.\n\n       †unset [ -fnv ] vname ...\n\t      The variables given by the list of vnames are unassigned, i.e.,\n\t      except for sub-variables within a type, their values and\n\t      attributes are erased.  For sub-variables of a type, the values\n\t      are reset to the default value from the type definition.\n\t      Readonly variables cannot be unset.  If the -f option is set,\n\t      then the names refer to function names.  If the -v option is\n\t      set, then the names refer to variable names.  The -f option\n\t      overrides -v.  If -n is set and name is a name reference, then\n\t      name will be unset rather than the variable that it references.\n\t      The default is equivalent to -v.\tUnsetting LINENO, MAILCHECK,\n\t      OPTARG, OPTIND, RANDOM, SECONDS, TMOUT, and _ removes their\n\t      special meaning even if they are subsequently assigned to."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How would you use the umask command to set a file creation mask of 022 in octal notation?
  manpageQuestion3: Can you provide an example of using the unset command to remove a variable named "ENVIRONMENT" from the shell session?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nwait [ job ... ]\n\t      Wait for the specified job and report its termination status.\n\t      If job is not given, then all currently active child processes\n\t      are waited for.  The exit status from this command is that of\n\t      the last process waited for if job is specified; otherwise it is\n\t      zero.  See Jobs for a description of the format of job.\n\n       whence [ -afpv ] name ...\n\t      For each name, indicate how it would be interpreted if used as a\n\t      command name.\n\t      The -v option produces a more verbose report.  The -f option\n\t      skips the search for functions.  The -p option does a path\n\t      search for name even if name is an alias, a function, or a\n\t      reserved word.  The -p option turns off the -v option.  The -a\n\t      option is similar to the -v option but causes all\n\t      interpretations of the given name to be reported.\n\n   Invocation.\n       If the shell is invoked by exec(2), and the first character of argument\n       zero ($0) is -, then the shell is assumed to be a login shell and\n       commands are read from /etc/profile and then from either .profile in\n       the current directory or $HOME/.profile, if either file exists.\tNext,\n       for interactive shells, commands are read from the file named by\n       performing parameter expansion, command substitution, and arithmetic\n       substitution on the value of the environment variable ENV if the file\n       exists.\tIf the -s option is not present and arg and a file by the name\n       of arg exists, then it reads and executes this script.  Otherwise, if\n       the first arg does not contain a /, a path search is performed on the\n       first arg to determine the name of the script to execute.  The script\n       arg must have execute permission and any setuid and setgid settings\n       will be ignored.  If the script is not found on the path, arg is\n       processed as if it named a built-in command or function.  Commands are\n       then read as described below; the following options are interpreted by\n       the shell when it is invoked:"
  manpageQuestion1: What is the primary purpose of the ksh shell command 'wait'?
  manpageQuestion2: How can you use the 'whence' command with the -a option to find all possible interpretations of a command name like 'ls'?
  manpageQuestion3: What is the process for invoking the ksh shell with specific options like '-s' and how does it affect script execution?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n-D      Do not execute the script, but output the set of double quoted\n\t       strings preceded by a $.  These strings are needed for\n\t       localization of the script to different locales.\n       -E      Reads the file named by the ENV variable or by $HOME/.kshrc if\n\t       not defined after the profiles.\n       -c\t If the -c option is present, then commands are read from the\n\t\t first arg.  Any remaining arguments become positional\n\t\t parameters starting at 0.\n       -s\t If the -s option is present or if no arguments remain, then\n\t\t commands are read from the standard input.  Shell output,\n\t\t except for the output of the Special Commands listed above,\n\t\t is written to file descriptor 2.\n       -i\t If the -i option is present or if the shell input and output\n\t\t are attached to a terminal (as told by tcgetattr(2)), then\n\t\t this shell is interactive.  In this case TERM is ignored (so\n\t\t that kill 0 does not kill an interactive shell) and INTR is\n\t\t caught and ignored (so that wait is ).  In all cases, QUIT is\n\t\t ignored by the shell.\n       -r\t If the -r option is present, the shell is a restricted shell.\n       -D\t A list of all double quoted strings that are preceded by a $\n\t\t will be printed on standard output and the shell will exit.\n\t\t This set of strings will be subject to language translation\n\t\t when the locale is not C or POSIX.  No commands will be\n\t\t executed."
  manpageQuestion1: What is the primary purpose of the ksh command?
  manpageQuestion2: How can you use the -c option with ksh to execute a command from a string argument?
  manpageQuestion3: What is the function of the -s option in ksh and how does it affect shell input handling?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\n-P\t If -P or -o profile is present, the shell is a profile shell\n\t\t (see pfexec(1)).\n\n       -R filename\n\t\t The -R filename option is used to generate a cross reference\n\t\t database that can be used by a separate utility to find\n\t\t definitions and references for variables and commands.\n\n       The remaining options and arguments are described under the set command\n       above.  An optional - as the first argument is ignored.\n\n   Rksh Only.\n       Rksh is used to set up login names and execution environments whose\n       capabilities are more controlled than those of the standard shell.  The\n       actions of rksh are identical to those of ksh, except that the\n       following are disallowed:\n\t      Unsetting the restricted option.\n\t      changing directory (see cd(1)),\n\t      setting or unsetting the value or attributes of SHELL, ENV,\n\t      FPATH, or PATH,\n\t      specifying path or command names containing /,\n\t      redirecting output (>, >|, <>, and >>).\n\t      adding or deleting built-in commands.\n\t      using command -p to invoke a command."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you generate a cross reference database for variables and commands using ksh?
  manpageQuestion3: What are the restrictions imposed by the rksh shell compared to standard ksh?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    The restrictions above are enforced after .profile and the ENV files
           are interpreted.

           When a command to be executed is found to be a shell procedure, rksh
           invokes ksh to execute it.  Thus, it is possible to provide to the end-
           user shell procedures that have access to the full power of the
           standard shell, while imposing a limited menu of commands; this scheme
           assumes that the end-user does not have write and execute permissions
           in the same directory.

           The net effect of these rules is that the writer of the .profile has
           complete control over user actions, by performing guaranteed setup
           actions and leaving the user in an appropriate directory (probably not
           the login directory).

           The system administrator often sets up a directory of commands (e.g.,
           /usr/rbin) that can be safely invoked by rksh.

    EXIT STATUS
           Errors detected by the shell, such as syntax errors, cause the shell to
           return a non-zero exit status.  If the shell is being used non-
           interactively, then execution of the shell file is abandoned unless the
           error occurs inside a subshell in which case the subshell is abandoned.
           Otherwise, the shell returns the exit status of the last command
           executed (see also the exit command above).  Run time errors detected
           by the shell are reported by printing the command or function name and
           the error condition.  If the line number that the error occurred on is
           greater than one, then the line number is also printed in square
           brackets ([]) after the command or function name.
  manpageQuestion1: What is the primary purpose of the ksh shell in this context?
  manpageQuestion2: How does rksh handle the execution of shell procedures that are not inherently shell commands?
  manpageQuestion3: What is the exit behavior of ksh when encountering syntax errors during non-interactive mode?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nFILES\n       /etc/profile\n\t      The system wide initialization file, executed for login shells.\n\n       $HOME/.profile\n\t      The personal initialization file, executed for login shells\n\t      after /etc/profile.\n\n       $HOME/..kshrc\n\t      Default personal initialization file, executed for interactive\n\t      shells when ENV is not set.\n\n       /etc/suid_profile\n\t      Alternative initialization file, executed instead of the\n\t      personal initialization file when the real and effective user or\n\t      group id do not match.\n\n       /dev/null\n\t      NULL device\n\nSEE ALSO\n       cat(1), cd(1), chmod(1), cut(1), egrep(1), echo(1), emacs(1), env(1),\n       fgrep(1), gmacs(1), grep(1), newgrp(1), pfexec(1), stty(1), test(1),\n       umask(1), vi(1), dup(2), exec(2), fork(2), getpwnam(3), ioctl(2),\n       lseek(2), paste(1), pathconf(2), pipe(2), sysconf(2), umask(2),\n       ulimit(2), wait(2), wctrans(3), rand(3), a.out(5), profile(5),\n       environ(7).\n\n       Morris I. Bolsky and David G. Korn, The New KornShell Command and\n       Programming Language, Prentice Hall, 1995."
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you configure the environment for interactive shells in ksh?
  manpageQuestion3: What is the role of the /dev/null device in the context of ksh commands?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.



    Manpage text:

    POSIX - Part 2: Shell and Utilities, IEEE Std 1003.2-1992, ISO/IEC
           9945-2, IEEE, 1993.

    CAVEATS
           If a command is executed, and then a command with the same name is
           installed in a directory in the search path before the directory where
           the original command was found, the shell will continue to exec the
           original command.  Use the -t option of the alias command to correct
           this situation.

           Some very old shell scripts contain a ^ as a synonym for the pipe
           character ⎪.

           Using the hist built-in command within a compound command will cause
           the whole command to disappear from the history file.

           The built-in command . file reads the whole file before any commands
           are executed.  Therefore, alias and unalias commands in the file will
           not apply to any commands defined in the file.

           Traps are not processed while a job is waiting for a foreground
           process.  Thus, a trap on CHLD won't be executed until the foreground
           job terminates.
  manpageQuestion1: What is the primary purpose of the ksh shell?
  manpageQuestion2: How can you correct the issue where a command with the same name is executed from an earlier directory in the search path?
  manpageQuestion3: What happens when you use the hist built-in command within a compound command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `ksh`.\n\n\n\nManpage text:\n\nIt is a good idea to leave a space after the comma operator in\n       arithmetic expressions to prevent the comma from being interpreted as\n       the decimal point character in certain locales.\n\n\t\t\t\t\t\t\t\t\tKSH(1)"
  manpageQuestion1: What is the primary purpose of the ksh resource?
  manpageQuestion2: How can you prevent the comma from being interpreted as a decimal point in arithmetic expressions when using ksh?
  manpageQuestion3: What is the role of the comma operator in arithmetic expressions within ksh?

