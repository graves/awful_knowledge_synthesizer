- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nMETALVALIDATION(1)\t    General Commands Manual\t    METALVALIDATION(1)\n\nNAME\n     Metal Validation â€“ Metal Runtime Validation\n\nSYNOPSIS\n     MTL_DEBUG_LAYER\n     MTL_DEBUG_LAYER_ERROR_MODE\n     MTL_DEBUG_LAYER_WARNING_MODE\n     MTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS\n     MTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS\n     MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES\n     MTL_SHADER_VALIDATION\n     MTL_SHADER_VALIDATION_DEFAULT_STATE\n     MTL_SHADER_VALIDATION_ENABLE_PIPELINES\n     MTL_SHADER_VALIDATION_DISABLE_PIPELINES\n     MTL_SHADER_VALIDATION_DUMP_PIPELINES\n     MTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING\n     MTL_SHADER_VALIDATION_TEXTURE_USAGE\n     MTL_SHADER_VALIDATION_THREADGROUP_MEMORY\n     MTL_SHADER_VALIDATION_RESOURCE_USAGE\n     MTL_SHADER_VALIDATION_COMPILER_INLINING\n     MTL_SHADER_VALIDATION_FAIL_MODE\n     MTL_SHADER_VALIDATION_REPORT_TO_STDERR\n\nDESCRIPTION\n     Unless otherwise noted all environment variables listed must be set\n     before any Metal device is created in the process.  Any changes to these\n     values after device creation will not take effect."
  manpageQuestion1: What is the primary purpose of the MetalValidation tool?
  manpageQuestion2: How can you enable shader validation for Metal applications on macOS while ensuring error messages are reported to standard error?
  manpageQuestion3: What environment variables are necessary to configure Metal validation settings before creating a Metal device in a macOS application?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nMetal provides two modes of validation, API and GPU.\n\n     API validation validates CPU API usage correctness such as calling draw\n     without a pipeline set.\n\n     GPU validation validates GPU API correctness such as accessing invalid\n     GPU memory.\n\nENVIRONMENT\n     MTL_DEBUG_LAYER\n\t   Defaults to 0.\n\t   All environment variables prefixed with MTL_DEBUG_LAYER only apply\n\t   when MTL_DEBUG_LAYER is non-zero.\n\t   Any value other than 0 will enable API validation.\n\n     MTL_DEBUG_LAYER_ERROR_MODE\n\t   Defaults to \"assert\"\n\t   Valid values are \"assert\", \"ignore\" and \"nslog\"\n\t   Sets the behavior for when a debug layer error occurs.\n\n\t   Setting \"assert\" will cause the debug layer to log and then assert\n\t   on error.\n\n\t   Setting \"ignore\" will cause the debug layer to ignore errors, this\n\t   may cause undefined behavior.\n\n\t   Setting \"nslog\" will cause the debug layer to log errors using\n\t   NSLog, this may cause undefined behavior.\n\n     MTL_DEBUG_LAYER_WARNING_MODE\n\t   Defaults to \"ignore\"\n\t   Valid values are \"assert\", \"ignore\" and \"nslog\"\n\t   Sets the behavior for when a debug layer warning occurs."
  manpageQuestion1: What is the primary purpose of the MetalValidation tool?
  manpageQuestion2: How can you enable API validation in Metal using environment variables?
  manpageQuestion3: What is the effect of setting MTL_DEBUG_LAYER_ERROR_MODE to 'nslog'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nSetting \"assert\" will cause the debug layer to log and then assert\n\t   on warnings.\n\n\t   Setting \"ignore\" will cause the debug layer to ignore warnings.\n\n\t   Setting \"nslog\" will cause the debug layer to log warnings using\n\t   NSLog.\n\n     MTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS\n\t   Defaults to 0\n\t   Setting this value to \"1\" will convert any MTLLoadActionDontCare to\n\t   MTLLoadActionClear of fuchsia.  This can be used to debug incorrect\n\t   load action modes or assumptions on DontCare behavior.\n\n     MTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS\n\t   Defaults to 0\n\t   Setting this value to \"1\" will write an alternating red and white\n\t   checkerboard into each render target with a store action of\n\t   MTLStoreActionDontCare.  This can be used to debug incorrect store\n\t   action modes or assumptions on DontCare behavior.\n\n     MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES\n\t   Defaults to 1\n\t   This option takes a bitfield of modes to enable. The bitfield\n\t   values are:\n\n\t   0x1 : Enabling this flag will cause command buffer to tag any\n\t   objects bound to the command buffer, which are not retained\n\t   internally.\tIf a tagged object is deallocated before the command\n\t   buffer completes, an error is raised."
  manpageQuestion1: What is the primary purpose of the MetalValidation resource?
  manpageQuestion2: How can you configure the Metal debug layer to log warnings using NSLog instead of asserting?
  manpageQuestion3: What is the effect of setting MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES to 0x1?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\n0x2 : Enabling this flag will cause command buffer to tag objects\n\t   that are internally retained by the command buffer.\tThis should\n\t   usually not be needed, because an object cannot be deallocated\n\t   while the command buffer itself isn't complete.\n\n\t   0x4 : Enabling this flag will cause deallocated tagged objects to\n\t   be considered an error even before committing the command buffer.\n\t   This will lead to more immediate error (ie: in the call stack of\n\t   the dealloc) rather than at commit, which is more debuggable.\n\n     MTL_SHADER_VALIDATION\n\t   Defaults to 0\n\t   All environment variables prefixed with MTL_SHADER_VALIDATION only\n\t   apply when MTL_SHADER_VALIDATION is non zero.\n\t   Any value other than 0 will enable GPU validation.\n\t   Sets the behavior of API usage errors. Using a value of \"4\" for\n\t   this setting may result in undefined behavior as otherwise fatal\n\t   errors will be ignored.\n\n     MTL_SHADER_VALIDATION_DEFAULT_STATE\n\t   Defaults to \"all\"\n\t   Defines the default behavior of Shader Validation for all\n\t   pipelines.\n\t   If set to \"all\", every pipeline will be created with Shader\n\t   Validation by default.\n\t   If set to \"none\", no pipeline will be created with Shader\n\t   Validation by default.\n\t   This default behavior can be bypassed with\n\t   MTL_SHADER_VALIDATION_ENABLE_PIPELINES and\n\t   MTL_SHADER_VALIDATION_DISABLE_PIPELINES"
  manpageQuestion1: What is the primary purpose of the MetalValidation resource?
  manpageQuestion2: How would you enable GPU validation for all pipelines using the MTL_SHADER_VALIDATION environment variable?
  manpageQuestion3: Can you provide an example of using the MTL_SHADER_VALIDATION_DEFAULT_STATE environment variable to disable shader validation for all pipelines by default?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nMTL_SHADER_VALIDATION_ENABLE_PIPELINES\n\t   Defaults to an empty string\n\t   List of pipeline labels (or Shader Validation UIDs generated by\n\t   MTL_SHADER_VALIDATION_DUMP_PIPELINES) for which Shader Validation\n\t   should be enabled. Only relevant when\n\t   MTL_SHADER_VALIDATION_DEFAULT_STATE is set to \"none\".\n\t   The list is comma-separated, and spaces are part of the parsed\n\t   name.\n\n     MTL_SHADER_VALIDATION_DISABLE_PIPELINES\n\t   Defaults to an empty string\n\t   List of pipeline labels (or Shader Validation UIDs generated by\n\t   MTL_SHADER_VALIDATION_DUMP_PIPELINES) for which Shader Validation\n\t   should be disabled. Only relevant when\n\t   MTL_SHADER_VALIDATION_DEFAULT_STATE is set to \"all\".\n\t   The list is comma-separated, and spaces are part of the parsed\n\t   name.\n\n     MTL_SHADER_VALIDATION_DUMP_PIPELINES\n\t   Defaults to 0\n\t   If set to \"1\", dumps the list of UIDs referencing the pipelines\n\t   compiled in the program into Console.app\n\t   The UIDs are persistent across multiple runs and can be used as\n\t   inputs to MTL_SHADER_VALIDATION_ENABLE_PIPELINES and\n\t   MTL_SHADER_VALIDATION_DISABLE_PIPELINES\n\t   UIDs are logged using Unified Logging and can be viewed in\n\t   Console.app by filtering with \"Shader Validation UID\""
  manpageQuestion1: What is the primary purpose of the MetalValidation resource?
  manpageQuestion2: How can you enable Shader Validation for specific pipeline labels using MetalValidation?
  manpageQuestion3: What is the purpose of the MTL_SHADER_VALIDATION_DUMP_PIPELINES flag?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nMTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING\n\t   Defaults to 1\n\t   Setting this value to \"0\" will disable shader validation error\n\t   reporting but not instrumentation or detection.\n\n     MTL_SHADER_VALIDATION_GLOBAL_MEMORY\n\t   Defaults to 1\n\t   Setting this value to \"0\" will disable instrumentation of device &\n\t   constant memory access.  The result of accessing invalid global\n\t   memory on the GPU will be undefined.\n\n\t   If this value is set to any non-zero value, shader validation will\n\t   instrument all global memory accesses and result of accessing\n\t   invalid memory is determined by MTL_SHADER_VALIDATION_FAIL_MODE\n\n     MTL_SHADER_VALIDATION_TEXTURE_USAGE\n\t   Defaults to 1\n\t   Setting this value to \"0\" will disable instrumentation of texture\n\t   member functions.  The result of the following operations on the\n\t   GPU will be undefined:\n\t     1. Accessing a nil texture object\n\t     2. Accessing a texture object with a type different than what is\n\t   expected by the shader signature\n\t     3. Accessing a non-resident texture or without the appropriate\n\t   MTLResourceUsage flag set on a useResource or useHeap call"
  manpageQuestion1: What is the primary purpose of the MTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING flag?
  manpageQuestion2: How would you disable instrumentation of device and constant memory access using the MTL_SHADER_VALIDATION_GLOBAL_MEMORY flag?
  manpageQuestion3: Can you provide an example of using the MTL_SHADER_VALIDATION_TEXTURE_USAGE flag to disable texture member function instrumentation?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nIf this value is set to any non-zero value, shader validation will\n\t   instrument all texture member functions (e.g read, write,\n\t   get_width) and the result of the following operations on the GPU is\n\t   determined by MTL_SHADER_VALIDATION_FAIL_MODE\n\t     1. Accessing a nil texture object\n\t     2. Accessing a texture object with a type different than what is\n\t   expected by the shader signature\n\t     3. Accessing a non-resident texture or without the appropriate\n\t   MTLResourceUsage flag set on a useResource or useHeap call\n\n     MTL_SHADER_VALIDATION_THREADGROUP_MEMORY\n\t   Defaults to 1\n\t   Setting this value to \"0\" will disable instrumentation of\n\t   threadgroup memory access.  The result of accessing invalid\n\t   threadgroup memory on the GPU will be undefined.\n\n\t   If this value is set to any non-zero value, shader validation will\n\t   instrument all threadgroup memory accesses and result of accessing\n\t   invalid memory is determined by MTL_SHADER_VALIDATION_FAIL_MODE\n\n     MTL_SHADER_VALIDATION_RESOURCE_USAGE\n\t   Defaults to 1\n\t   Setting this value to \"0\" will disable instrumentation of resource\n\t   usage.  The result of accessing resources that are not resident on\n\t   the GPU will be undefined."
  manpageQuestion1: What is the primary purpose of the MetalValidation resource in macOS?
  manpageQuestion2: How would you configure MetalValidation to disable instrumentation of threadgroup memory accesses?
  manpageQuestion3: Can you explain how to set MetalValidation to disable resource usage instrumentation and what is the impact of this setting?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nIf this value is set to any non-zero value, shader validation will\n\t   instrument all resource accesses to check resource usage. It will\n\t   detect missing calls to useResource and useHeap with the\n\t   appropriate MTLResourceUsage flag on resources used by the GPU. The\n\t   result of accessing invalid memory is determined by\n\t   MTL_SHADER_VALIDATION_FAIL_MODE\n\n     MTL_SHADER_VALIDATION_STACK_OVERFLOW\n\t   Defaults to 1\n\t   Setting this value to \"0\" will disable instrumentation of indirect\n\t   and recursive function calls.  The result of exceeding\n\t   \"maxCallStackDepth\" will be undefined.\n\n\t   If this value is set to any non-zero value, shader validation will\n\t   instrument all indirect calls (calls by function pointer, visible\n\t   functions, intersection functions, dylib calls) and recursive\n\t   calls. If the call stack depth for such functions exeecds the value\n\t   set for \"maxCallStackDepth\" for that stage, an error will be raised\n\t   and the function call will be skipped.\n\n     MTL_SHADER_VALIDATION_COMPILER_INLINING\n\t   Valid options are \"default\", \"full\"."
  manpageQuestion1: What is the primary purpose of the MetalValidation resource?
  manpageQuestion2: How can you configure MetalValidation to disable instrumentation of indirect and recursive function calls?
  manpageQuestion3: What are the valid options for MTL_SHADER_VALIDATION_COMPILER_INLINING and how do they affect shader validation?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nDetermines whether code inlining will occur.\n\t   Setting this value to \"full\" will force inlining\n\t   Adding inlining may result in improved runtime performance at the\n\t   cost of compile time performance.\n\t   Reducing inlining may result in improved compile time performance\n\t   at the cost of runtime performance.\n\n     MTL_SHADER_VALIDATION_FAIL_MODE\n\t   Defaults to \"zerofill\"\n\t   Valid options are \"zerofill\", \"allow\".\n\n\t   Sets the behavior for how invalid accesses should be handled.\n\t   Setting this value to \"zerofill\" causes invalid reads to return 0.\n\t   Invalid writes are dropped.\n\n\t   Setting this value to \"allow\" allows the invalid read or write,\n\t   which may result in command buffer failure depending on platform,\n\t   but has reduced compile & runtime performance impact.\n\n     MTL_SHADER_VALIDATION_REPORT_TO_STDERR\n\t   Defaults to \"0\"\n\t   Setting this value to any value other than \"0\" will redirect shader\n\t   validation error messages to stderr. This is useful if there is any\n\t   issue with the OS logging mechanism."
  manpageQuestion1: What is the primary purpose of the MetalValidation resource?
  manpageQuestion2: How would you configure MetalValidation to force inlining of code and redirect shader validation errors to stderr?
  manpageQuestion3: Can you explain how to set MetalValidation to handle invalid shader accesses by allowing them instead of zerofilling?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `MetalValidation`.\n\n\n\nManpage text:\n\nDarwin\t\t\t\t   05/03/20\t\t\t\tDarwin"
  manpageQuestion1: What is the primary purpose of the MetalValidation tool?
  manpageQuestion2: How would you use MetalValidation to validate a metal program for compatibility with the current GPU architecture?
  manpageQuestion3: Can you provide an example of using MetalValidation to check if a metal program is compatible with the latest GPU drivers?

