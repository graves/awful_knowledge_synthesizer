- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `pt_peg_language`.\n\n\n\nManpage text:\n\npt::peg_language(n)\t\t Parser Tools\t\t   pt::peg_language(n)\n\n______________________________________________________________________________\n\nNAME\n       pt::peg_language - PEG Language Tutorial\n\nSYNOPSIS\n       package require Tcl  8.5\n\n______________________________________________________________________________\n\nDESCRIPTION\n       Are you lost ?  Do you have trouble understanding this document ?  In\n       that case please read the overview provided by the Introduction to\n       Parser Tools. This document is the entrypoint to the whole system the\n       current package is a part of.\n\n       Welcome to the tutorial / introduction for the PEG Specification\n       Language.  If you are already familiar with the language we are about\n       to discuss, and only wish to refresh your memory you can, of course,\n       skip ahead to the aforementioned section and just read the full formal\n       specification.\n\nWHAT IS IT?\n       peg, a language for the specification of parsing expression grammars is\n       meant to be human readable, and writable as well, yet strict enough to\n       allow its processing by machine. Like any computer language. It was\n       defined to make writing the specification of a grammar easy, something\n       the other formats found in the Parser Tools do not lend themselves too.\n\nTHE ELEMENTS OF THE LANGUAGE\n   BASIC STRUCTURE\n       The general outline of a textual PEG is\n\n       PEG <<name>> (<<start-expression>>)\n\t  <<rules>>\n       END;\n\n       Note: We are using text in double angle-brackets as place-holders for\n       things not yet explained.\n\n   NAMES\n       Names are mostly used to identify the nonterminal symbols of the\n       grammar, i.e. that which occurs on the left-hand side of a <rule>.  The\n       exception to that is the name given after the keyword PEG (see previous\n       section), which is the name of the whole grammar itself.\n\n       The structure of a name is simple:\n\n       [1]    It begins with a letter, underscore, or colon, followed by\n\n       [2]    zero or more letters, digits, underscores, or colons.\n\n       Or, in formal textual notation:\n\n\t   ([_:] / <alpha>) ([_:] / <alnum>)*\n\n       Examples of names:\n\n\t   Hello\n\t   ::world\n\t   _:submarine55_\n\n       Examples of text which are not names:\n\n\t   12\n\t   .bogus\n\t   0wrong\n\t   @location"
  manpageQuestion1: What is the primary purpose of the pt::peg_language resource?
  manpageQuestion2: How would you use pt::peg_language to create a PEG grammar for parsing simple arithmetic expressions?
  manpageQuestion3: Can you provide an example of defining a nonterminal symbol in a PEG grammar using pt::peg_language?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `pt_peg_language`.\n\n\n\nManpage text:\n\nRULES\n       The main body of the text of a grammar specification is taken up by the\n       rules. Each rule defines the sentence structure of one nonterminal\n       symbol. Their basic structure is\n\n\t    <<name>>  <-  <<expression>> ;\n\n       The <name> specifies the nonterminal symbol to be defined, the\n       <expression> after the arrow (<-) then declares its structure.\n\n       Note that each rule ends in a single semicolon, even the last.  I.e.\n       the semicolon is a rule terminator, not a separator.\n\n       We can have as many rules as we like, as long as we define each\n       nonterminal symbol at most once, and have at least one rule for each\n       nonterminal symbol which occured in an expression, i.e. in either the\n       start expression of the grammar, or the right-hande side of a rule.\n\n   EXPRESSIONS\n       The parsing expressions are the meat of any specification. They declare\n       the structure of the whole document (<<start-expression>>), and of all\n       nonterminal symbols.\n\n       All expressions are made up out of atomic expressions and operators\n       combining them. We have operators for choosing between alternatives,\n       repetition of parts, and for look-ahead constraints. There is no\n       explicit operator for the sequencing (also known as concatenation) of\n       parts however. This is specified by simply placing the parts adjacent\n       to each other.\n\n       Here are the operators, from highest to lowest priority (i.e. strength\n       of binding):\n\n\t   # Binary operators.\n\n\t   <<expression-1>>\t<<expression-2>>  # sequence. parse 1, then 2.\n\t   <<expression-1>>  /\t<<expression-2>>  # alternative. try to parse 1, and parse 2 if 1 failed to parse.\n\n\t   # Prefix operators. Lookahead constraints. Same priority.\n\n\t   & <<expression>>  # Parse expression, ok on successful parse.\n\t   ! <<expression>>  # Ditto, except ok on failure to parse.\n\n\t   # Suffix operators. Repetition. Same priority.\n\n\t   <<expression>> ?  # Parse expression none, or once (repeat 0 or 1).\n\t   <<expression>> *  # Parse expression zero or more times.\n\t   <<expression>> +  # Parse expression one or more times.\n\n\t   # Expression nesting\n\n\t   ( <<expression>> ) # Put an expression in parens to change its priority.\n\n       With this we can now deconstruct the formal expression for names given\n       in section Names:\n\n\t   ([_:] / <alpha>) ([_:] / <alnum>)*\n\n       It is a sequence of two parts,\n\t   [_:] / <alpha>\n       and\n\t   ([_:] / <alnum>)*\n       The parentheses around the parts kept their inner alternatives bound\n       together against the normally higher priority of the sequence. Each of\n       the two parts is an alternative, with the second part additionally\n       repeated zero or more times, leaving us with the three atomic\n       expressions\n\n\t   [_:]\n\t   <alpha>\n\t   <alnum>\n\n       And atomic expressions are our next topic. They fall into three\n       classes:\n\n       [1]    names, i.e. nonterminal symbols,\n\n       [2]    string literals, and\n\n       [3]    character classes.\n\n       Names we know about already, or see section Names for a refresher.\n\n       String literals are simple. They are delimited by (i.e. start and end\n       with) either a single or double-apostroph, and in between the\n       delimiters we can have any character but the delimiter itself. They can\n       be empty as well. Examples of strings are\n\n\t   ''\n\t   \"\"\n\t   'hello'\n\t   \"umbra\"\n\t   \"'\"\n\t   '\"'\n\n       The last two examples show how to place any of the delimiters into a\n       string.\n\n       For the last, but not least of our atomic expressions, character\n       classes, we have a number of predefined classes, shown below, and the\n       ability to construct or own. The predefined classes are:\n\n\t   <alnum>    # Any unicode alphabet or digit character (string is alnum).\n\t   <alpha>    # Any unicode alphabet character (string is alpha).\n\t   <ascii>    # Any unicode character below codepoint 0x80 (string is ascii).\n\t   <control>  # Any unicode control character (string is control).\n\t   <ddigit>   # The digit characters [0-9].\n\t   <digit>    # Any unicode digit character (string is digit).\n\t   <graph>    # Any unicode printing character, except space (string is graph).\n\t   <lower>    # Any unicode lower-case alphabet character (string is lower).\n\t   <print>    # Any unicode printing character, incl. space (string is print).\n\t   <punct>    # Any unicode punctuation character (string is punct).\n\t   <space>    # Any unicode space character (string is space).\n\t   <upper>    # Any unicode upper-case alphabet character (string is upper).\n\t   <wordchar> # Any unicode word character (string is wordchar).\n\t   <xdigit>   # The hexadecimal digit characters [0-9a-fA-F].\n\t   .\t      # Any character, except end of input.\n\n       And the syntax of custom-defined character classes is\n\n\t   [ <<range>>* ]\n\n       where each range is either a single character, or of the form\n\n\t  <<character>> - <character>>\n\n       Examples for character classes we have seen already in the course of\n       this introduction are\n\n\t   [_:]\n\t   [0-9]\n\t   [0-9a-fA-F]\n\n       We are nearly done with expressions. The only piece left is to tell how\n       the characters in character classes and string literals are specified.\n\n       Basically characters in the input stand for themselves, and in addition\n       to that we several types of escape syntax to to repesent control\n       characters, or characters outside of the encoding the text is in.\n\n       All the escaped forms are started with a backslash character ('\\',\n       unicode codepoint 0x5C). This is then followed by a series of octal\n       digits, or 'u' and hexedecimal digits, or a regular character from a\n       fixed set for various control characters. Some examples:\n\n\t   \\n \\r \\t \\' \\\" \\[ \\] \\\\ #\n\t   \\000 up to \\277\t   # octal escape, all ascii character, leading 0's can be removed.\n\t   \\u2CA7\t\t   # hexadecimal escape, all unicode characters.\n\t   #\t\t\t   # Here 2ca7 <=> Koptic Small Letter Tau"
  manpageQuestion1: What is the primary purpose of the pt_peg_language resource?
  manpageQuestion2: How can you define a grammar rule using the pt_peg_language resource to match an identifier that starts with a letter and is followed by zero or more alphanumeric characters?
  manpageQuestion3: Can you provide an example of using the pt_peg_language resource to create a character class that matches any ASCII letter or digit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `pt_peg_language`.\n\n\n\nManpage text:\n\nWHITESPACE AND COMMENTS\n       One issue not touched upon so far is whitespace and comments.\n\n       Whitespace is any unicode space character, i.e. anything in the\n       character class <space>, and comments. The latter are sequences of\n       characters starting with a '#' (hash, unicode codepoint 0x23) and\n       ending at the next end-of-line.\n\n       Whitespace can be freely used between all syntactical elements of a\n       grammar specification. It cannot be used inside of syntactical\n       elements, like names, string literals, predefined character classes,\n       etc.\n\n   NONTERMINAL ATTRIBUTES\n       Lastly, a more advanced topic. In the section Rules we gave the\n       structure of a rule as\n\n\t    <<name>>  <-  <<expression>> ;\n\n       This is not quite true. It is possible to associate a semantic mode\n       with the nonterminal in the rule, by writing it before the name,\n       separated from it by a colon, i.e. writing\n\n\t   <<mode>> : <<name>>\t<-  <<expression>> ;\n\n       is also allowed. This mode is optional. The known modes and their\n       meanings are:\n\n       value  The semantic value of the nonterminal symbol is an abstract\n\t      syntax tree consisting of a single node node for the nonterminal\n\t      itself, which has the ASTs of the symbol's right hand side as\n\t      its children.\n\n       leaf   The semantic value of the nonterminal symbol is an abstract\n\t      syntax tree consisting of a single node node for the\n\t      nonterminal, without any children. Any ASTs generated by the\n\t      symbol's right hand side are discarded.\n\n       void   The nonterminal has no semantic value. Any ASTs generated by the\n\t      symbol's right hand side are discarded (as well).\n\n       Of these three modes only leaf and void can be specified directly.\n       value is implicitly specified by the absence of a mode before the\n       nonterminal.\n\n       Now, with all the above under our belt it should be possible to not\n       only read, but understand the formal specification of the text\n       representation shown in the next section, written in itself.\n\nPEG SPECIFICATION LANGUAGE\n       peg, a language for the specification of parsing expression grammars is\n       meant to be human readable, and writable as well, yet strict enough to\n       allow its processing by machine. Like any computer language. It was\n       defined to make writing the specification of a grammar easy, something\n       the other formats found in the Parser Tools do not lend themselves too.\n\n       It is formally specified by the grammar shown below, written in itself.\n       For a tutorial / introduction to the language please go and read the\n       PEG Language Tutorial."
  manpageQuestion1: What is the primary purpose of the pt_peg_language resource?
  manpageQuestion2: How can whitespace and comments be used in the pt_peg_language specification?
  manpageQuestion3: What is the difference between the 'leaf' and 'void' modes in nonterminal attributes?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `pt_peg_language`.\n\n\n\nManpage text:\n\nPEG pe-grammar-for-peg (Grammar)\n\n\t    # --------------------------------------------------------------------\n\t       # Syntactical constructs\n\n\t       Grammar\t       <- WHITESPACE Header Definition* Final EOF ;\n\n\t       Header\t       <- PEG Identifier StartExpr ;\n\t       Definition      <- Attribute? Identifier IS Expression SEMICOLON ;\n\t       Attribute       <- (VOID / LEAF) COLON ;\n\t       Expression      <- Sequence (SLASH Sequence)* ;\n\t       Sequence        <- Prefix+ ;\n\t       Prefix\t       <- (AND / NOT)? Suffix ;\n\t       Suffix\t       <- Primary (QUESTION / STAR / PLUS)? ;\n\t       Primary\t       <- ALNUM / ALPHA / ASCII / CONTROL / DDIGIT / DIGIT\n\t\t\t       /  GRAPH / LOWER / PRINTABLE / PUNCT / SPACE / UPPER\n\t\t\t       /  WORDCHAR / XDIGIT\n\t\t\t       / Identifier\n\t\t\t       /  OPEN Expression CLOSE\n\t\t\t       /  Literal\n\t\t\t       /  Class\n\t\t\t       /  DOT\n\t\t\t       ;\n\t       Literal\t       <- APOSTROPH  (!APOSTROPH  Char)* APOSTROPH  WHITESPACE\n\t\t\t       /  DAPOSTROPH (!DAPOSTROPH Char)* DAPOSTROPH WHITESPACE ;\n\t       Class\t       <- OPENB (!CLOSEB Range)* CLOSEB WHITESPACE ;\n\t       Range\t       <- Char TO Char / Char ;\n\n\t       StartExpr       <- OPEN Expression CLOSE ;\n       void:   Final\t       <- END SEMICOLON WHITESPACE ;\n\n\t       # --------------------------------------------------------------------\n\t       # Lexing constructs\n\n\t       Identifier      <- Ident WHITESPACE ;\n       leaf:   Ident\t       <- ('_' / ':' / <alpha>) ('_' / ':' / <alnum>)* ;\n\t       Char\t       <- CharSpecial / CharOctalFull / CharOctalPart\n\t\t\t       /  CharUnicode / CharUnescaped\n\t\t\t       ;\n\n       leaf:   CharSpecial     <- \"\\\\\" [nrt'\"\\[\\]\\\\] ;\n       leaf:   CharOctalFull   <- \"\\\\\" [0-2][0-7][0-7] ;\n       leaf:   CharOctalPart   <- \"\\\\\" [0-7][0-7]? ;\n       leaf:   CharUnicode     <- \"\\\\\" 'u' HexDigit (HexDigit (HexDigit HexDigit?)?)? ;\n       leaf:   CharUnescaped   <- !\"\\\\\" . ;\n\n       void:   HexDigit        <- [0-9a-fA-F] ;\n\n       void:   TO\t       <- '-'\t\t;\n       void:   OPENB\t       <- \"[\"\t\t;\n       void:   CLOSEB\t       <- \"]\"\t\t;\n       void:   APOSTROPH       <- \"'\"\t\t;\n       void:   DAPOSTROPH      <- '\"'\t\t;\n       void:   PEG\t       <- \"PEG\"   WHITESPACE ;\n       void:   IS\t       <- \"<-\"\t  WHITESPACE ;\n       leaf:   VOID\t       <- \"void\"  WHITESPACE ; # Implies that definition has no semantic value.\n       leaf:   LEAF\t       <- \"leaf\"  WHITESPACE ; # Implies that definition has no terminals.\n       void:   END\t       <- \"END\"   WHITESPACE ;\n       void:   SEMICOLON       <- \";\"\t  WHITESPACE ;\n       void:   COLON\t       <- \":\"\t  WHITESPACE ;\n       void:   SLASH\t       <- \"/\"\t  WHITESPACE ;\n       leaf:   AND\t       <- \"&\"\t  WHITESPACE ;\n       leaf:   NOT\t       <- \"!\"\t  WHITESPACE ;\n       leaf:   QUESTION        <- \"?\"\t  WHITESPACE ;\n       leaf:   STAR\t       <- \"*\"\t  WHITESPACE ;\n       leaf:   PLUS\t       <- \"+\"\t  WHITESPACE ;\n       void:   OPEN\t       <- \"(\"\t  WHITESPACE ;\n       void:   CLOSE\t       <- \")\"\t  WHITESPACE ;\n       leaf:   DOT\t       <- \".\"\t  WHITESPACE ;\n\n       leaf:   ALNUM\t       <- \"<alnum>\"    WHITESPACE ;\n       leaf:   ALPHA\t       <- \"<alpha>\"    WHITESPACE ;\n       leaf:   ASCII\t       <- \"<ascii>\"    WHITESPACE ;\n       leaf:   CONTROL\t       <- \"<control>\"  WHITESPACE ;\n       leaf:   DDIGIT\t       <- \"<ddigit>\"   WHITESPACE ;\n       leaf:   DIGIT\t       <- \"<digit>\"    WHITESPACE ;\n       leaf:   GRAPH\t       <- \"<graph>\"    WHITESPACE ;\n       leaf:   LOWER\t       <- \"<lower>\"    WHITESPACE ;\n       leaf:   PRINTABLE       <- \"<print>\"    WHITESPACE ;\n       leaf:   PUNCT\t       <- \"<punct>\"    WHITESPACE ;\n       leaf:   SPACE\t       <- \"<space>\"    WHITESPACE ;\n       leaf:   UPPER\t       <- \"<upper>\"    WHITESPACE ;\n       leaf:   WORDCHAR        <- \"<wordchar>\" WHITESPACE ;\n       leaf:   XDIGIT\t       <- \"<xdigit>\"   WHITESPACE ;\n\n       void:   WHITESPACE      <- (\" \" / \"\\t\" / EOL / COMMENT)* ;\n       void:   COMMENT\t       <- '#' (!EOL .)* EOL ;\n       void:   EOL\t       <- \"\\n\\r\" / \"\\n\" / \"\\r\" ;\n       void:   EOF\t       <- !. ;\n\n\t       # --------------------------------------------------------------------\n       END;"
  manpageQuestion1: What is the primary purpose of the `pt_peg_language` resource?
  manpageQuestion2: How would you define a grammar rule in `pt_peg_language` to match a sequence of one or more alphanumeric characters followed by an optional star?
  manpageQuestion3: Can you provide an example of using `pt_peg_language` to match a literal string like 'hello' and a class range from 'a' to 'z'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `pt_peg_language`.\n\n\n\nManpage text:\n\nEXAMPLE\n       Our example specifies the grammar for a basic 4-operation calculator.\n\n\n       PEG calculator (Expression)\n\t   Digit      <- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'   ;\n\t   Sign       <- '-' / '+'\t\t\t ;\n\t   Number     <- Sign? Digit+\t\t\t      ;\n\t   Expression <- '(' Expression ')' / (Factor (MulOp Factor)*)\t;\n\t   MulOp      <- '*' / '/'\t\t\t ;\n\t   Factor     <- Term (AddOp Term)*\t\t      ;\n\t   AddOp      <- '+'/'-'\t\t\t ;\n\t   Term       <- Number \t\t    ;\n       END;\n\n\n       Using higher-level features of the notation, i.e. the character classes\n       (predefined and custom), this example can be rewritten as\n\n\n       PEG calculator (Expression)\n\t   Sign       <- [-+]\t\t\t\t ;\n\t   Number     <- Sign? <ddigit>+\t\t ;\n\t   Expression <- '(' Expression ')' / (Factor (MulOp Factor)*)\t;\n\t   MulOp      <- [*/]\t\t\t\t ;\n\t   Factor     <- Term (AddOp Term)*\t\t      ;\n\t   AddOp      <- [-+]\t\t\t\t ;\n\t   Term       <- Number \t\t    ;\n       END;\n\n\nBUGS, IDEAS, FEEDBACK\n       This document, and the package it describes, will undoubtedly contain\n       bugs and other problems.  Please report such in the category pt of the\n       Tcllib SF Trackers [http://sourceforge.net/tracker/?group_id=12883].\n       Please also report any ideas for enhancements you may have for either\n       package and/or documentation.\n\nKEYWORDS\n       EBNF, LL(k), PEG, TDPL, context-free languages, expression, grammar,\n       matching, parser, parsing expression, parsing expression grammar, push\n       down automaton, recursive descent, state, top-down parsing languages,\n       transducer\n\nCATEGORY\n       Parsing and Grammars\n\nCOPYRIGHT\n       Copyright (c) 2009 Andreas Kupries <andreas_kupries@users.sourceforge.net>"
  manpageQuestion1: What is the primary purpose of the pt_peg_language resource?
  manpageQuestion2: How can you define a simple calculator grammar using pt_peg_language with character classes for signs and operators?
  manpageQuestion3: What is the function of the pt_peg_language in the context of parsing and grammar definitions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `pt_peg_language`.\n\n\n\nManpage text:\n\npt\t\t\t\t       1\t\t   pt::peg_language(n)"
  manpageQuestion1: What is the primary purpose of the pt_peg_language resource?
  manpageQuestion2: How would you use pt_peg_language to parse a simple expression like '3 + 4 * 2'?
  manpageQuestion3: Can you provide an example of using pt_peg_language to generate a parser for a custom language syntax?

