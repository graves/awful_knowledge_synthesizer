- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nsnitfaq(n)\t\tSnit's Not Incr Tcl, OO system\t\t    snitfaq(n)\n\n______________________________________________________________________________\n\nNAME\n       snitfaq - Snit Frequently Asked Questions\n\nDESCRIPTION\nOVERVIEW\n   WHAT IS THIS DOCUMENT?\n       This is an atypical FAQ list, in that few of the questions are\n       frequently asked.  Rather, these are the questions I think a newcomer\n       to Snit should be asking.  This file is not a complete reference to\n       Snit, however; that information is in the snit man page.\n\n   WHAT IS SNIT?\n       Snit is a framework for defining abstract data types and megawidgets in\n       pure Tcl.  The name \"Snit\" stands for \"Snit's Not Incr Tcl\", signifying\n       that Snit takes a different approach to defining objects than does Incr\n       Tcl, the best known object framework for Tcl.  Had I realized that Snit\n       would become at all popular, I'd probably have chosen something else.\n\n       The primary purpose of Snit is to be object glue--to help you compose\n       diverse objects from diverse sources into types and megawidgets with\n       clean, convenient interfaces so that you can more easily build your\n       application.\n\n       Snit isn't about theoretical purity or minimalist design; it's about\n       being able to do powerful things easily and consistently without having\n       to think about them--so that you can concentrate on building your\n       application.\n\n       Snit isn't about implementing thousands of nearly identical carefully-\n       specified lightweight thingamajigs--not as individual Snit objects.\n       Traditional Tcl methods will be much faster, and not much more\n       complicated.  But Snit is about implementing a clean interface to\n       manage a collection of thousands of nearly identical carefully-\n       specified lightweight thingamajigs (e.g., think of the text widget and\n       text tags, or the canvas widget and canvas objects).  Snit lets you\n       hide the details of just how those thingamajigs are stored--so that you\n       can ignore it, and concentrate on building your application.\n\n       Snit isn't a way of life, a silver bullet, or the Fountain of Youth.\n       It's just a way of managing complexity--and of managing some of the\n       complexity of managing complexity--so that you can concentrate on\n       building your application.\n\n   WHAT VERSION OF TCL DOES SNIT REQUIRE?\n       Snit 1.3 requires Tcl 8.3 or later; Snit 2.2 requires Tcl 8.5 or later.\n       See SNIT VERSIONS for the differences between Snit 1.3 and Snit 2.2.\n\n   WHERE CAN I DOWNLOAD SNIT?\n       Snit is part of Tcllib, the standard Tcl library, so you might already\n       have it.  It's also available at the Snit Home Page,\n       http://www.wjduquette.com/snit.\n\n   WHAT ARE SNIT'S GOALS?\n       •      A Snit object should be at least as efficient as a hand-coded\n\t      Tcl object (see http://www.wjduquette.com/tcl/objects.html).\n\n       •      The fact that Snit was used in an object's implementation should\n\t      be transparent (and irrelevant) to clients of that object.\n\n       •      Snit should be able to encapsulate objects from other sources,\n\t      particularly Tk widgets.\n\n       •      Snit megawidgets should be (to the extent possible)\n\t      indistinguishable in interface from Tk widgets.\n\n       •      Snit should be Tclish--that is, rather than trying to emulate\n\t      C++, Smalltalk, or anything else, it should try to emulate Tcl\n\t      itself.\n\n       •      It should have a simple, easy-to-use, easy-to-remember syntax.\n\n   HOW IS SNIT DIFFERENT FROM OTHER OO FRAMEWORKS?\n       Snit is unique among Tcl object systems in that it is based not on\n       inheritance but on delegation.  Object systems based on inheritance\n       only allow you to inherit from classes defined using the same system,\n       and that's a shame.  In Tcl, an object is anything that acts like an\n       object; it shouldn't matter how the object was implemented.  I designed\n       Snit to help me build applications out of the materials at hand; thus,\n       Snit is designed to be able to incorporate and build on any object,\n       whether it's a hand-coded object, a Tk widget, an Incr Tcl object, a\n       BWidget or almost anything else.\n\n       Note that you can achieve the effect of inheritance using COMPONENTS\n       and DELEGATION--and you can inherit from anything that looks like a Tcl\n       object.\n\n   WHAT CAN I DO WITH SNIT?\n       Using Snit, a programmer can:\n\n       •      Create abstract data types and Tk megawidgets.\n\n       •      Define instance variables, type variables, and Tk-style options.\n\n       •      Define constructors, destructors, instance methods, type\n\t      methods, procs.\n\n       •      Assemble a type out of component types.  Instance methods and\n\t      options can be delegated to the component types automatically.\n\nSNIT VERSIONS\n   WHICH VERSION OF SNIT SHOULD I USE?\n       The current Snit distribution includes two versions, Snit 1.3 and Snit\n       2.2.  The reason that both are included is that Snit 2.2 takes\n       advantage of a number of new features of Tcl 8.5 to improve run-time\n       efficiency; as a side-effect, the ugliness of Snit's error messages and\n       stack traces has been reduced considerably.  The cost of using Snit\n       2.2, of course, is that you must target Tcl 8.5.\n\n       Snit 1.3, on the other hand, lacks Snit 2.2's optimizations, but\n       requires only Tcl 8.3 and later.\n\n       In short, if you're targetting Tcl 8.3 or 8.4 you should use Snit 1.3.\n       If you can afford to target Tcl 8.5, you should definitely use Snit\n       2.2.  If you will be targetting both, you can use Snit 1.3 exclusively,\n       or (if your code is unaffected by the minor incompatibilities between\n       the two versions) you can use Snit 1.3 for Tcl 8.4 and Snit 2.2 for Tcl\n       8.5.\n\n   HOW DO I SELECT THE VERSION OF SNIT I WANT TO USE?\n       To always use Snit 1.3 (or a later version of Snit 1.x), invoke Snit as\n       follows:\n       package require snit 1.3\n\n       To always use Snit 2.2 (or a later version of Snit 2.x), say this\n       instead:\n       package require snit 2.2\n\n       Note that if you request Snit 2.2 explicitly, your application will\n       halt with Tcl 8.4, since Snit 2.2 is unavailable for Tcl 8.4.\n\n       If you wish your application to always use the latest available version\n       of Snit, don't specify a version number:\n       package require snit\n\n       Tcl will find and load the latest version that's available relative to\n       the version of Tcl being used.  In this case, be careful to avoid using\n       any incompatible features.\n\n   HOW ARE SNIT 1.3 AND SNIT 2.2 INCOMPATIBLE?\n       To the extent possible, Snit 2.2 is intended to be a drop-in\n       replacement for Snit 1.3. Unfortunately, some incompatibilities were\n       inevitable because Snit 2.2 uses Tcl 8.5's new namespace ensemble\n       mechanism to implement subcommand dispatch.  This approach is much\n       faster than the mechanism used in Snit 1.3, and also results in much\n       better error messages; however, it also places new constraints on the\n       implementation.\n\n       There are four specific incompatibilities between Snit 1.3 and Snit\n       2.2.\n\n       •      Snit 1.3 supports implicit naming of objects.  Suppose you\n\t      define a new snit::type called dog.  You can create instances of\n\t      dog in three ways:\n\t      dog spot\t\t     ;# Explicit naming\n\t      set obj1 [dog %AUTO%]  ;# Automatic naming\n\t      set obj2 [dog]\t     ;# Implicit naming\n\n\t      In Snit 2.2, type commands are defined using the namespace\n\t      ensemble mechanism; and namespace ensemble doesn't allow an\n\t      ensemble command to be called without a subcommand.  In short,\n\t      using namespace ensemble there's no way to support implicit\n\t      naming.\n\n\t      All is not lost, however.  If the type has no type methods, then\n\t      the type command is a simple command rather than an ensemble,\n\t      and namespace ensemble is not used.  In this case, implicit\n\t      naming is still possible.\n\n\t      In short, you can have implicit naming if you're willing to do\n\t      without type methods (including the standard type methods, like\n\t      $type info).  To do so, use the -hastypemethods pragma:\n\t      pragma -hastypemethods 0\n\n       •      Hierarchical methods and type methods are implemented\n\t      differently in Snit 2.2.\n\n\t      A hierarchical method is an instance method which has\n\t      subcommands; these subcommands are themselves methods.  The Tk\n\t      text widget's tag command and its subcommands are examples of\n\t      hierarchical methods.  You can implement such subcommands in\n\t      Snit simply by including multiple words in the method names:\n\t      method {tag configure} {tag args} { ... }\n\n\t      method {tag cget} {tag option} {...}\n\n\t      Here we've implicitly defined a tag method which has two\n\t      subcommands, configure and cget.\n\n\t      In Snit 1.3, hierarchical methods could be called in two ways:\n\t      $obj tag cget -myoption\t   ;# The good way\n\t      $obj {tag cget} -myoption    ;# The weird way\n\n\t      In the second call, we see that a hierarchical method or type\n\t      method is simply one whose name contains multiple words.\n\n\t      In Snit 2.2 this is no longer the case, and the \"weird\" way of\n\t      calling hierarchical methods and type methods no longer works.\n\n       •      The third incompatibility derives from the second.  In Snit 1.3,\n\t      hierarchical methods were also simply methods whose name\n\t      contains multiple words.\tAs a result, $obj info methods\n\t      returned the full names of all hierarchical methods.  In the\n\t      example above, the list returned by $obj info methods would\n\t      include tag configure and tag cget but not tag, since tag is\n\t      defined only implicitly.\n\n\t      In Snit 2.2, hierarchical methods and type methods are no longer\n\t      simply ones whose name contains multiple words; in the above\n\t      example, the list returned by $obj info methods would include\n\t      tag but not tag configure or tag cget.\n\n       •      The fourth incompatibility is due to a new feature.  Snit 2.2\n\t      uses the new namespace path command so that a type's code can\n\t      call any command defined in the type's parent namespace without\n\t      qualification or importation.  For example, suppose you have a\n\t      package called mypackage which defines a number of commands\n\t      including a type, ::mypackage::mytype.  Thanks to namespace\n\t      path, the type's code can call any of the other commands defined\n\t      in ::mypackage::.\n\n\t      This is extremely convenient.  However, it also means that\n\t      commands defined in the parent namespace, ::mypackage:: can\n\t      block the type's access to identically named commands in the\n\t      global namespace.  This can lead to bugs.  For example, Tcllib\n\t      includes a type called ::tie::std::file.\tThis type's code calls\n\t      the standard file command.  When run with Snit 2.2, the code\n\t      broke-- the type's command, ::tie::std::file, is itself a\n\t      command in the type's parent namespace, and so instead of\n\t      calling the standard file command, the type found itself calling\n\t      itself.\n\n   ARE THERE OTHER DIFFERENCES BETWEEN SNIT 1.X AND SNIT 2.2?\n       Yes.\n\n       •      Method dispatch is considerably faster.\n\n       •      Many error messages and stack traces are cleaner.\n\n       •      The -simpledispatch pragma is obsolete, and ignored if present.\n\t      In Snit 1.x, -simpledispatch substitutes a faster mechanism for\n\t      method dispatch, at the cost of losing certain features.\tSnit\n\t      2.2 method dispatch is faster still in all cases, so\n\t      -simpledispatch is no longer needed.\n\n       •      In Snit 2.2, a type's code (methods, type methods, etc.) can\n\t      call commands from the type's parent namespace without\n\t      qualifying or importing them, i.e., type ::parentns::mytype's\n\t      code can call ::parentns::someproc as just someproc.\n\n\t      This is extremely useful when a type is defined as part of a\n\t      larger package, and shares a parent namespace with the rest of\n\t      the package; it means that the type can call other commands\n\t      defined by the package without any extra work.\n\n\t      This feature depends on the new Tcl 8.5 namespace path command,\n\t      which is why it hasn't been implemented for V1.x.  V1.x code can\n\t      achieve something similar by placing\n\t      namespace import [namespace parent]::*\n\t      in a type constructor.  This is less useful, however, as it\n\t      picks up only those commands which have already been exported by\n\t      the parent namespace at the time the type is defined.\n\nOBJECTS\n   WHAT IS AN OBJECT?\n       A full description of object-oriented programming is beyond the scope\n       of this FAQ, obviously.\tIn simple terms, an object is an instance of\n       an abstract data type--a coherent bundle of code and data.  There are\n       many ways to represent objects in Tcl/Tk; the best known examples are\n       the Tk widgets.\n\n       A Tk widget is an object; it is represented by a Tcl command.  The\n       object's methods are subcommands of the Tcl command.  The object's\n       properties are options accessed using the configure and cget methods.\n       Snit uses the same conventions as Tk widgets do.\n\n   WHAT IS AN ABSTRACT DATA TYPE?\n       In computer science terms, an abstract data type is a complex data\n       structure along with a set of operations--a stack, a queue, a binary\n       tree, etc--that is to say, in modern terms, an object.  In systems that\n       include some form of inheritance the word class is usually used instead\n       of abstract data type, but as Snit doesn't implement inheritance as\n       it's ordinarily understood the older term seems more appropriate.\n       Sometimes this is called object-based programming as opposed to object-\n       oriented programming.  Note that you can easily create the effect of\n       inheritance using COMPONENTS and DELEGATION.\n\n       In Snit, as in Tk, a type is a command that creates instances --\n       objects -- which belong to the type.  Most types define some number of\n       options which can be set at creation time, and usually can be changed\n       later.\n\n       Further, an instance is also a Tcl command--a command that gives access\n       to the operations which are defined for that abstract data type.\n       Conventionally, the operations are defined as subcommands of the\n       instance command.  For example, to insert text into a Tk text widget,\n       you use the text widget's insert subcommand:\n\n\t   # Create a text widget and insert some text in it.\n\t   text .mytext -width 80 -height 24\n\t   .mytext insert end \"Howdy!\""
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can Snit be used to create abstract data types and Tk megawidgets?
  manpageQuestion3: What are the key differences between Snit 1.3 and Snit 2.2 in terms of method dispatch and compatibility?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nIn this example, text is the type command and .mytext is the instance\n       command.\n\n       In Snit, object subcommands are generally called INSTANCE METHODS.\n\n   WHAT KINDS OF ABSTRACT DATA TYPES DOES SNIT PROVIDE?\n       Snit allows you to define three kinds of abstract data type:\n\n       •      snit::type\n\n       •      snit::widget\n\n       •      snit::widgetadaptor\n\n   WHAT IS A SNIT::TYPE?\n       A snit::type is a non-GUI abstract data type, e.g., a stack or a queue.\n       snit::types are defined using the snit::type command.  For example, if\n       you were designing a kennel management system for a dog breeder, you'd\n       need a dog type.\n\n       % snit::type dog {\n\t   # ...\n       }\n       ::dog\n       %\n\n\n       This definition defines a new command (::dog, in this case) that can be\n       used to define dog objects.\n\n       An instance of a snit::type can have INSTANCE METHODS, INSTANCE\n       VARIABLES, OPTIONS, and COMPONENTS.  The type itself can have TYPE\n       METHODS, TYPE VARIABLES, TYPE COMPONENTS, and PROCS.\n\n   WHAT IS A SNIT::WIDGET?, THE SHORT STORY\n       A snit::widget is a Tk megawidget built using Snit; it is very similar\n       to a snit::type.  See WIDGETS.\n\n   WHAT IS A SNIT::WIDGETADAPTOR?, THE SHORT STORY\n       A snit::widgetadaptor uses Snit to wrap an existing widget type (e.g.,\n       a Tk label), modifying its interface to a lesser or greater extent.  It\n       is very similar to a snit::widget.  See WIDGET ADAPTORS.\n\n   HOW DO I CREATE AN INSTANCE OF A SNIT::TYPE?\n       You create an instance of a snit::type by passing the new instance's\n       name to the type's create method.  In the following example, we create\n       a dog object called spot.\n\n       % snit::type dog {\n\t   # ....\n       }\n       ::dog\n       % dog create spot\n       ::spot\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you create an instance of a snit::type called 'dog' using the snit::type command?
  manpageQuestion3: Can you explain how to define a snit::widget that is similar to a snit::type but built using Tk megawidgets?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nIn general, the create method name can be omitted so long as the\n       instance name doesn't conflict with any defined TYPE METHODS. (See TYPE\n       COMPONENTS for the special case in which this doesn't work.)  So the\n       following example is identical to the previous example:\n\n       % snit::type dog {\n\t   # ....\n       }\n       ::dog\n       % dog spot\n       ::spot\n       %\n\n\n       This document generally uses the shorter form.\n\n       If the dog type defines OPTIONS, these can usually be given defaults at\n       creation time:\n\n       % snit::type dog {\n\t   option -breed mongrel\n\t   option -color brown\n\n\t   method bark {} { return \"$self barks.\" }\n       }\n       ::dog\n       % dog create spot -breed dalmation -color spotted\n       ::spot\n       % spot cget -breed\n       dalmation\n       % spot cget -color\n       spotted\n       %\n\n\n       Once created, the instance name now names a new Tcl command that is\n       used to manipulate the object.  For example, the following code makes\n       the dog bark:\n\n       % spot bark\n       ::spot barks.\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you create a new instance of the 'dog' type with specific options using snitfaq?
  manpageQuestion3: Can you provide an example of how to retrieve the value of a specific option from a created snit object?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW DO I REFER TO AN OBJECT INDIRECTLY?\n       Some programmers prefer to save the object name in a variable, and\n       reference it that way.  For example,\n\n       % snit::type dog { ... }\n       ::dog\n       % set d [dog spot -breed dalmation -color spotted]\n       ::spot\n       % $d cget -breed\n       dalmation\n       % $d bark\n       ::spot barks.\n       %\n\n\n       If you prefer this style, you might prefer to have Snit generate the\n       instance's name automatically.\n\n   HOW CAN I GENERATE THE OBJECT NAME AUTOMATICALLY?\n       If you'd like Snit to generate an object name for you, use the %AUTO%\n       keyword as the requested name:\n\n       % snit::type dog { ... }\n       ::dog\n       % set d [dog %AUTO%]\n       ::dog2\n       % $d bark\n       ::dog2 barks.\n       %\n\n\n       The %AUTO% keyword can be embedded in a longer string:\n\n       % set d [dog obj_%AUTO%]\n       ::obj_dog4\n       % $d bark\n       ::obj_dog4 barks.\n       %\n\n\n   CAN TYPES BE RENAMED?\n       Tcl's rename command renames other commands.  It's a common technique\n       in Tcl to modify an existing command by renaming it and defining a new\n       command with the original name; the new command usually calls the\n       renamed command.\n\n       snit::type commands, however, should never be renamed; to do so breaks\n       the connection between the type and its objects.\n\n   CAN OBJECTS BE RENAMED?\n       Tcl's rename command renames other commands.  It's a common technique\n       in Tcl to modify an existing command by renaming it and defining a new\n       command with the original name; the new command usually calls the\n       renamed command.\n\n       All Snit objects (including widgets and widgetadaptors) can be renamed,\n       though this flexibility has some consequences:\n\n       •      In an instance method, the implicit argument self will always\n\t      contain the object's current name, so instance methods can\n\t      always call other instance methods using $self.\n\n       •      If the object is renamed, however, then $self's value will\n\t      change.  Therefore, don't use $self for anything that will break\n\t      if $self changes. For example, don't pass a callback command to\n\t      another object like this:\n\n\t\t  .btn configure -command [list $self ButtonPress]\n\n\t      You'll get an error if .btn calls your command after your object\n\t      is renamed.\n\n       •      Instead, your object should define its callback command like\n\t      this:\n\n\t\t  .btn configure -command [mymethod ButtonPress]\n\n\t      The mymethod command returns code that will call the desired\n\t      method safely; the caller of the callback can add additional\n\t      arguments to the end of the command as usual.\n\n       •      Every object has a private namespace; the name of this namespace\n\t      is available in method bodies, etc., as the value of the\n\t      implicit argument selfns.  This value is constant for the life\n\t      of the object.  Use $selfns instead of $self if you need a\n\t      unique token to identify the object.\n\n       •      When a snit::widget's instance command is renamed, its Tk window\n\t      name remains the same -- and is still extremely important.\n\t      Consequently, the Tk window name is available in method bodies\n\t      as the value of the implicit argument win.  This value is\n\t      constant for the life of the object.  When creating child\n\t      windows, it's best to use $win.child rather than $self.child as\n\t      the name of the child window.\n\n   HOW DO I DESTROY A SNIT OBJECT?\n       Any Snit object of any type can be destroyed by renaming it to the\n       empty string using the Tcl rename command.\n\n       Snit megawidgets (i.e., instances of snit::widget and\n       snit::widgetadaptor) can be destroyed like any other widget: by using\n       the Tk destroy command on the widget or on one of its ancestors in the\n       window hierarchy.\n\n       Every instance of a snit::type has a destroy method:\n\n       % snit::type dog { ... }\n       ::dog\n       % dog spot\n       ::spot\n       % spot bark\n       ::spot barks.\n       % spot destroy\n       % spot barks\n       invalid command name \"spot\"\n       %"
  manpageQuestion1: What is the primary purpose of the `snitfaq` resource?
  manpageQuestion2: How can you generate an object name automatically in Snit, and what is an example of using `%AUTO%`?
  manpageQuestion3: How do you destroy a Snit object, and what are the different methods available for doing so?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nFinally, every Snit type has a type method called destroy; calling it\n       destroys the type and all of its instances:\n       % snit::type dog { ... }\n       ::dog\n       % dog spot\n       ::spot\n       % spot bark\n       ::spot barks.\n       % dog destroy\n       % spot bark\n       invalid command name \"spot\"\n       % dog fido\n       invalid command name \"dog\"\n       %\n\n\nINSTANCE METHODS\n   WHAT IS AN INSTANCE METHOD?\n       An instance method is a procedure associated with a specific object and\n       called as a subcommand of the object's command.\tIt is given free\n       access to all of the object's type variables, instance variables, and\n       so forth.\n\n   HOW DO I DEFINE AN INSTANCE METHOD?\n       Instance methods are defined in the type definition using the method\n       statement.  Consider the following code that might be used to add dogs\n       to a computer simulation:\n\n       % snit::type dog {\n\t   method bark {} {\n\t       return \"$self barks.\"\n\t   }\n\n\t   method chase {thing} {\n\t       return \"$self chases $thing.\"\n\t   }\n       }\n       ::dog\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you define an instance method in Snit to make a dog bark and return a message like 'barks.'?
  manpageQuestion3: What happens when you call the destroy method on a Snit type and its instances?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nA dog can bark, and it can chase things.\n\n       The method statement looks just like a normal Tcl proc, except that it\n       appears in a snit::type definition.  Notice that every instance method\n       gets an implicit argument called self; this argument contains the\n       object's name.  (There's more on implicit method arguments below.)\n\n   HOW DOES A CLIENT CALL AN INSTANCE METHOD?\n       The method name becomes a subcommand of the object.  For example, let's\n       put a simulated dog through its paces:\n\n       % dog spot\n       ::spot\n       % spot bark\n       ::spot barks.\n       % spot chase cat\n       ::spot chases cat.\n       %\n\n\n   HOW DOES AN INSTANCE METHOD CALL ANOTHER INSTANCE METHOD?\n       If method A needs to call method B on the same object, it does so just\n       as a client does: it calls method B as a subcommand of the object\n       itself, using the object name stored in the implicit argument self.\n\n       Suppose, for example, that our dogs never chase anything without\n       barking at them:\n\n       % snit::type dog {\n\t   method bark {} {\n\t       return \"$self barks.\"\n\t   }\n\n\t   method chase {thing} {\n\t       return \"$self chases $thing.  [$self bark]\"\n\t   }\n       }\n       ::dog\n       % dog spot\n       ::spot\n       % spot bark\n       ::spot barks.\n       % spot chase cat\n       ::spot chases cat.  ::spot barks.\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you call an instance method on a snit object to make it bark?
  manpageQuestion3: Can you provide an example of how an instance method in a snit type can call another instance method on the same object?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nARE THERE ANY LIMITATIONS ON INSTANCE METHOD NAMES?\n       Not really, so long as you avoid the standard instance method names:\n       configure, configurelist, cget, destroy, and info.  Also, method names\n       consisting of multiple words define hierarchical methods.\n\n   WHAT IS A HIERARCHICAL METHOD?\n       An object's methods are subcommands of the object's instance command.\n       Hierarchical methods allow an object's methods to have subcommands of\n       their own; and these can in turn have subcommands, and so on.  This\n       allows the programmer to define a tree-shaped command structure, such\n       as is used by many of the Tk widgets--the subcommands of the Tk text\n       widget's tag method are hierarchical methods.\n\n   HOW DO I DEFINE A HIERARCHICAL METHOD?\n       Define methods whose names consist of multiple words.  These words\n       define the hierarchy implicitly.  For example, the following code\n       defines a tag method with subcommands cget and configure:\n       snit::widget mytext {\n\t   method {tag configure} {tag args} { ... }\n\n\t   method {tag cget} {tag option} {...}\n       }\n\n       Note that there is no explicit definition for the tag method; it is\n       implicit in the definition of tag configure and tag cget.  If you tried\n       to define tag explicitly in this example, you'd get an error.\n\n   HOW DO I CALL HIERARCHICAL METHODS?\n       As subcommands of subcommands.\n       % mytext .text\n       % .text tag configure redtext -foreground red -background black\n       % .text tag cget redtext -foreground\n       red\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can hierarchical methods be defined in snit::widget?
  manpageQuestion3: Can you provide an example of calling a hierarchical method in snit::widget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW DO I MAKE AN INSTANCE METHOD PRIVATE?\n       It's often useful to define private methods, that is, instance methods\n       intended to be called only by other methods of the same object.\n\n       Snit doesn't implement any access control on instance methods, so all\n       methods are de facto public.  Conventionally, though, the names of\n       public methods begin with a lower-case letter, and the names of private\n       methods begin with an upper-case letter.\n\n       For example, suppose our simulated dogs only bark in response to other\n       stimuli; they never bark just for fun.  So the bark method becomes Bark\n       to indicate that it is private:\n\n       % snit::type dog {\n\t   # Private by convention: begins with uppercase letter.\n\t   method Bark {} {\n\t       return \"$self barks.\"\n\t   }\n\n\t   method chase {thing} {\n\t       return \"$self chases $thing. [$self Bark]\"\n\t   }\n       }\n       ::dog\n       % dog fido\n       ::fido\n       % fido chase cat\n       ::fido chases cat. ::fido barks.\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can I define a private instance method in Snit based on the convention described in the manpage?
  manpageQuestion3: Can you provide an example of using Snit to create a class with a private method that is called by another method?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nARE THERE ANY LIMITATIONS ON INSTANCE METHOD ARGUMENTS?\n       Method argument lists are defined just like normal Tcl proc argument\n       lists; in particular, they can include arguments with default values\n       and the args argument.\n\n       However, every method also has a number of implicit arguments provided\n       by Snit in addition to those explicitly defined.  The names of these\n       implicit arguments may not used to name explicit arguments.\n\n   WHAT IMPLICIT ARGUMENTS ARE PASSED TO EACH INSTANCE METHOD?\n       The arguments implicitly passed to every method are type, selfns, win,\n       and self.\n\n   WHAT IS $TYPE?\n       The implicit argument type contains the fully qualified name of the\n       object's type:\n\n       % snit::type thing {\n\t   method mytype {} {\n\t       return $type\n\t   }\n       }\n       ::thing\n       % thing something\n       ::something\n       % something mytype\n       ::thing\n       %\n\n\n   WHAT IS $SELF?\n       The implicit argument self contains the object's fully qualified name.\n\n       If the object's command is renamed, then $self will change to match in\n       subsequent calls.  Thus, your code should not assume that $self is\n       constant unless you know for sure that the object will never be\n       renamed.\n\n       % snit::type thing {\n\t   method myself {} {\n\t       return $self\n\t   }\n       }\n       ::thing\n       % thing mutt\n       ::mutt\n       % mutt myself\n       ::mutt\n       % rename mutt jeff\n       % jeff myself\n       ::jeff\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you retrieve the fully qualified name of an object's type using snitfaq?
  manpageQuestion3: What is the behavior of the $self implicit argument when an object's command is renamed?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nWHAT IS $SELFNS?\n       Each Snit object has a private namespace in which to store its INSTANCE\n       VARIABLES and OPTIONS.  The implicit argument selfns contains the name\n       of this namespace; its value never changes, and is constant for the\n       life of the object, even if the object's name changes:\n\n       % snit::type thing {\n\t   method myNameSpace {} {\n\t       return $selfns\n\t   }\n       }\n       ::thing\n       % thing jeff\n       ::jeff\n       % jeff myNameSpace\n       ::thing::Snit_inst3\n       % rename jeff mutt\n       % mutt myNameSpace\n       ::thing::Snit_inst3\n       %\n\n\n       The above example reveals how Snit names an instance's private\n       namespace; however, you should not write code that depends on the\n       specific naming convention, as it might change in future releases.\n\n   WHAT IS $WIN?\n       The implicit argument win is defined for all Snit methods, though it\n       really makes sense only for those of WIDGETS and WIDGET ADAPTORS.  $win\n       is simply the original name of the object, whether it's been renamed or\n       not.  For widgets and widgetadaptors, it is also therefore the name of\n       a Tk window.\n\n       When a snit::widgetadaptor is used to modify the interface of a widget\n       or megawidget, it must rename the widget's original command and replace\n       it with its own.\n\n       Thus, using win whenever the Tk window name is called for means that a\n       snit::widget or snit::widgetadaptor can be adapted by a\n       snit::widgetadaptor.  See WIDGETS for more information.\n\n   HOW DO I PASS AN INSTANCE METHOD AS A CALLBACK?\n       It depends on the context.\n\n       Suppose in my application I have a dog object named fido, and I want\n       fido to bark when a Tk button called .bark is pressed.  In this case, I\n       create the callback command in the usual way, using list:\n\n\t   button .bark -text \"Bark!\" -command [list fido bark]"
  manpageQuestion1: What is the primary purpose of the snitfaq tool?
  manpageQuestion2: How can you pass an instance method as a callback in Snit?
  manpageQuestion3: What is the significance of the $selfns and $win variables in Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nIn typical Tcl style, we use a callback to hook two independent\n       components together.  But suppose that the dog object has a graphical\n       interface and owns the button itself?  In this case, the dog must pass\n       one of its own instance methods to the button it owns.  The obvious\n       thing to do is this:\n\n       % snit::widget dog {\n\t   constructor {args} {\n\t       #...\n\t       button $win.barkbtn -text \"Bark!\" -command [list $self bark]\n\t       #...\n\t   }\n       }\n       ::dog\n       %\n\n\n       (Note that in this example, our dog becomes a snit::widget, because it\n       has GUI behavior.  See WIDGETS for more.)  Thus, if we create a dog\n       called .spot, it will create a Tk button called .spot.barkbtn; when\n       pressed, the button will call $self bark.\n\n       Now, this will work--provided that .spot is never renamed to something\n       else.  But surely renaming widgets is abnormal?\tAnd so it is--unless\n       .spot is the hull component of a snit::widgetadaptor.  If it is, then\n       it will be renamed, and .spot will become the name of the\n       snit::widgetadaptor object.  When the button is pressed, the command\n       $self bark will be handled by the snit::widgetadaptor, which might or\n       might not do the right thing.\n\n       There's a safer way to do it, and it looks like this:\n\n       % snit::widget dog {\n\t   constructor {args} {\n\t       #...\n\t       button $win.barkbtn -text \"Bark!\" -command [mymethod bark]\n\t       #...\n\t   }\n       }\n       ::dog\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you safely bind a button to a method in a snit::widget without relying on the widget's name?
  manpageQuestion3: What is the difference between using [list $self bark] and [mymethod bark] when setting a button's command in a snit::widget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThe command mymethod takes any number of arguments, and can be used\n       like list to build up a callback command; the only difference is that\n       mymethod returns a form of the command that won't change even if the\n       instance's name changes.\n\n       On the other hand, you might prefer to allow a widgetadaptor to\n       override a method such that your renamed widget will call the\n       widgetadaptor's method instead of its own.  In this case, using [list\n       $self bark] will do what you want...but this is a technique which\n       should be used only in carefully controlled circumstances.\n\n   HOW DO I DELEGATE INSTANCE METHODS TO A COMPONENT?\n       See DELEGATION.\n\nINSTANCE VARIABLES\n   WHAT IS AN INSTANCE VARIABLE?\n       An instance variable is a private variable associated with some\n       particular Snit object.\tInstance variables can be scalars or arrays.\n\n   HOW IS A SCALAR INSTANCE VARIABLE DEFINED?\n       Scalar instance variables are defined in the type definition using the\n       variable statement.  You can simply name it, or you can initialize it\n       with a value:\n\n       snit::type mytype {\n\t   # Define variable \"greeting\" and initialize it with \"Howdy!\"\n\t   variable greeting \"Howdy!\"\n       }"
  manpageQuestion1: What is the primary purpose of the `snitfaq` resource?
  manpageQuestion2: How can you define and initialize a scalar instance variable in Snit?
  manpageQuestion3: What is the recommended approach for delegating instance methods to a component in Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW IS AN ARRAY INSTANCE VARIABLE DEFINED?\n       Array instance variables are also defined in the type definition using\n       the variable command.  You can initialize them at the same time by\n       specifying the -array option:\n\n       snit::type mytype {\n\t   # Define array variable \"greetings\"\n\t   variable greetings -array {\n\t       formal \"Good Evening\"\n\t       casual \"Howdy!\"\n\t   }\n       }\n\n\n   WHAT HAPPENS IF I DON'T INITIALIZE AN INSTANCE VARIABLE?\n       Variables do not really exist until they are given values.  If you do\n       not initialize a variable when you define it, then you must be sure to\n       assign a value to it (in the constructor, say, or in some method)\n       before you reference it.\n\n   ARE THERE ANY LIMITATIONS ON INSTANCE VARIABLE NAMES?\n       Just a few.\n\n       First, every Snit object has a built-in instance variable called\n       options, which should never be redefined.\n\n       Second, all names beginning with \"Snit_\" are reserved for use by Snit\n       internal code.\n\n       Third, instance variable names containing the namespace delimiter (::)\n       are likely to cause great confusion.\n\n   DO I NEED TO DECLARE MY INSTANCE VARIABLES IN MY METHODS?\n       No. Once you've defined an instance variable in the type definition, it\n       can be used in any instance code (instance methods, the constructor,\n       and the destructor) without declaration.  This differs from normal Tcl\n       practice, in which all non-local variables in a proc need to be\n       declared.\n\n       There is a speed penalty to having all instance variables implicitly\n       available in all instance code.\tEven though your code need not declare\n       the variables explicitly, Snit must still declare them, and that takes\n       time.  If you have ten instance variables, a method that uses none of\n       them must still pay the declaration penalty for all ten.  In most\n       cases, the additional runtime cost is negligible.  If extreme cases,\n       you might wish to avoid it; there are two methods for doing so.\n\n       The first is to define a single instance variable, an array, and store\n       all of your instance data in the array.\tThis way, you're only paying\n       the declaration penalty for one variable--and you probably need the\n       variable most of the time anyway.  This method breaks down if your\n       instance variables include multiple arrays; in Tcl 8.5, however, the\n       dict command might come to your rescue.\n\n       The second method is to declare your instance variables explicitly in\n       your instance code, while not including them in the type definition:\n       snit::type dog {\n\t   constructor {} {\n\t       variable mood\n\n\t       set mood happy\n\t   }\n\n\t   method setmood {newMood} {\n\t       variable mood\n\n\t       set mood $newMood\n\t   }\n\n\t   method getmood {} {\n\t       variable mood\n\n\t       return $mood\n\t   }\n       }\n\n       This allows you to ensure that only the required variables are included\n       in each method, at the cost of longer code and run-time errors when you\n       forget to declare a variable you need.\n\n   HOW DO I PASS AN INSTANCE VARIABLE'S NAME TO ANOTHER OBJECT?\n       In Tk, it's common to pass a widget a variable name; for example, Tk\n       label widgets have a -textvariable option which names the variable\n       which will contain the widget's text.  This allows the program to\n       update the label's value just by assigning a new value to the variable.\n\n       If you naively pass the instance variable name to the label widget,\n       you'll be confused by the result; Tk will assume that the name names a\n       global variable.  Instead, you need to provide a fully-qualified\n       variable name.  From within an instance method or a constructor, you\n       can fully qualify the variable's name using the myvar command:\n\n       snit::widget mywidget {\n\t   variable labeltext \"\"\n\n\t   constructor {args} {\n\t       # ...\n\n\t       label $win.label -textvariable [myvar labeltext]\n\n\t       # ...\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you define an array instance variable in Snit, and how do you initialize it at the same time?
  manpageQuestion3: How can you pass an instance variable's name to another object in Snit, and what is the correct way to fully qualify the variable name?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW DO I MAKE AN INSTANCE VARIABLE PUBLIC?\n       Practically speaking, you don't.  Instead, you'll implement public\n       variables as OPTIONS.  Alternatively, you can write INSTANCE METHODS to\n       set and get the variable's value.\n\nOPTIONS\n   WHAT IS AN OPTION?\n       A type's options are the equivalent of what other object-oriented\n       languages would call public member variables or properties: they are\n       data values which can be retrieved and (usually) set by the clients of\n       an object.\n\n       Snit's implementation of options follows the Tk model fairly exactly,\n       except that snit::type objects usually don't interact with THE TK\n       OPTION DATABASE; snit::widget and snit::widgetadaptor objects, on the\n       other hand, always do.\n\n   HOW DO I DEFINE AN OPTION?\n       Options are defined in the type definition using the option statement.\n       Consider the following type, to be used in an application that manages\n       a list of dogs for a pet store:\n\n       snit::type dog {\n\t   option -breed -default mongrel\n\t   option -color -default brown\n\t   option -akc\t -default 0\n\t   option -shots -default 0\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can I define an option in Snit using the option statement?
  manpageQuestion3: What is the difference between snit::type objects and snit::widget objects in terms of options?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nAccording to this, a dog has four notable properties: a breed, a color,\n       a flag that says whether it's pedigreed with the American Kennel Club,\n       and another flag that says whether it has had its shots.  The default\n       dog, evidently, is a brown mutt.\n\n       There are a number of options you can specify when defining an option;\n       if -default is the only one, you can omit the word -default as follows:\n\n       snit::type dog {\n\t   option -breed mongrel\n\t   option -color brown\n\t   option -akc\t 0\n\t   option -shots 0\n       }\n\n\n       If no -default value is specified, the option's default value will be\n       the empty string (but see THE TK OPTION DATABASE).\n\n       The Snit man page refers to options like these as \"locally defined\"\n       options.\n\n   HOW CAN A CLIENT SET OPTIONS AT OBJECT CREATION?\n       The normal convention is that the client may pass any number of options\n       and their values after the object's name at object creation.  For\n       example, the ::dog command defined in the previous answer can now be\n       used to create individual dogs.\tAny or all of the options may be set\n       at creation time.\n\n       % dog spot -breed beagle -color \"mottled\" -akc 1 -shots 1\n       ::spot\n       % dog fido -shots 1\n       ::fido\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you use the snit::type command to define a dog object with specific options?
  manpageQuestion3: Can you provide an example of creating a dog object with specific options using the ::dog command?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nSo ::spot is a pedigreed beagle; ::fido is a typical mutt, but his\n       owners evidently take care of him, because he's had his shots.\n\n       Note: If the type defines a constructor, it can specify a different\n       object-creation syntax.\tSee CONSTRUCTORS for more information.\n\n   HOW CAN A CLIENT RETRIEVE AN OPTION'S VALUE?\n       Retrieve option values using the cget method:\n\n       % spot cget -color\n       mottled\n       % fido cget -breed\n       mongrel\n       %\n\n\n   HOW CAN A CLIENT SET OPTIONS AFTER OBJECT CREATION?\n       Any number of options may be set at one time using the configure\n       instance method.  Suppose that closer inspection shows that ::fido is\n       not a brown mongrel, but rather a rare Arctic Boar Hound of a lovely\n       dun color:\n\n       % fido configure -color dun -breed \"Arctic Boar Hound\"\n       % fido cget -color\n       dun\n       % fido cget -breed\n       Arctic Boar Hound\n\n\n       Alternatively, the configurelist method takes a list of options and\n       values; occasionally this is more convenient:\n\n       % set features [list -color dun -breed \"Arctic Boar Hound\"]\n       -color dun -breed {Arctic Boar Hound}\n       % fido configurelist $features\n       % fido cget -color\n       dun\n       % fido cget -breed\n       Arctic Boar Hound\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can a client retrieve the value of an option for an object in snitfaq?
  manpageQuestion3: How can a client set multiple options for an object in snitfaq after it has been created?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nIn Tcl 8.5, the * keyword can be used with configure in this case:\n\n       % set features [list -color dun -breed \"Arctic Boar Hound\"]\n       -color dun -breed {Arctic Boar Hound}\n       % fido configure {*}$features\n       % fido cget -color\n       dun\n       % fido cget -breed\n       Arctic Boar Hound\n       %\n\n\n       The results are the same.\n\n   HOW SHOULD AN INSTANCE METHOD ACCESS AN OPTION VALUE?\n       There are two ways an instance method can set and retrieve an option's\n       value.  One is to use the configure and cget methods, as shown below.\n\n       % snit::type dog {\n\t   option -weight 10\n\n\t   method gainWeight {} {\n\t       set wt [$self cget -weight]\n\t       incr wt\n\t       $self configure -weight $wt\n\t   }\n       }\n       ::dog\n       % dog fido\n       ::fido\n       % fido cget -weight\n       10\n       % fido gainWeight\n       % fido cget -weight\n       11\n       %\n\n\n       Alternatively, Snit provides a built-in array instance variable called\n       options.  The indices are the option names; the values are the option\n       values.\tThe method gainWeight can thus be rewritten as follows:"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can an instance method in Snit access and modify an option's value using the configure and cget methods?
  manpageQuestion3: What is an alternative way for an instance method in Snit to access and modify an option's value without using configure and cget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nmethod gainWeight {} {\n\t       incr options(-weight)\n\t   }\n\n\n       As you can see, using the options variable involves considerably less\n       typing and is the usual way to do it.  But if you use -configuremethod\n       or -cgetmethod (described in the following answers), you might wish to\n       use the configure and cget methods anyway, just so that any special\n       processing you've implemented is sure to get done.  Also, if the option\n       is delegated to a component then configure and cget are the only way to\n       access it without accessing the component directly.  See DELEGATION for\n       more information.\n\n   HOW CAN I MAKE AN OPTION READ-ONLY?\n       Define the option with -readonly yes.\n\n       Suppose you've got an option that determines how instances of your type\n       are constructed; it must be set at creation time, after which it's\n       constant.  For example, a dog never changes its breed; it might or\n       might not have had its shots, and if not can have them at a later time.\n       -breed should be read-only, but -shots should not be.\n\n       % snit::type dog {\n\t   option -breed -default mongrel -readonly yes\n\t   option -shots -default no\n       }\n       ::dog\n       % dog fido -breed retriever\n       ::fido\n       % fido configure -shots yes\n       % fido configure -breed terrier\n       option -breed can only be set at instance creation\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you make an option in a snit::type declaration read-only?
  manpageQuestion3: What is the recommended approach for accessing options that are delegated to a component in snit::type?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW CAN I CATCH ACCESSES TO AN OPTION'S VALUE?\n       Define a -cgetmethod for the option.\n\n   WHAT IS A -CGETMETHOD?\n       A -cgetmethod is a method that's called whenever the related option's\n       value is queried via the cget instance method.  The handler can compute\n       the option's value, retrieve it from a database, or do anything else\n       you'd like it to do.\n\n       Here's what the default behavior would look like if written using a\n       -cgetmethod:\n\n       snit::type dog {\n\t   option -color -default brown -cgetmethod GetOption\n\n\t   method GetOption {option} {\n\t       return $options($option)\n\t   }\n       }\n\n\n       Any instance method can be used, provided that it takes one argument,\n       the name of the option whose value is to be retrieved.\n\n   HOW CAN I CATCH CHANGES TO AN OPTION'S VALUE?\n       Define a -configuremethod for the option.\n\n   WHAT IS A -CONFIGUREMETHOD?\n       A -configuremethod is a method that's called whenever the related\n       option is given a new value via the configure or configurelist instance\n       methods. The method can pass the value on to some other object, store\n       it in a database, or do anything else you'd like it to do.\n\n       Here's what the default configuration behavior would look like if\n       written using a -configuremethod:\n\n       snit::type dog {\n\t   option -color -default brown -configuremethod SetOption\n\n\t   method SetOption {option value} {\n\t       set options($option) $value\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you use a -cgetmethod to retrieve the value of an option in snit?
  manpageQuestion3: How can you use a -configuremethod to handle changes to an option's value in snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nAny instance method can be used, provided that it takes two arguments,\n       the name of the option and the new value.\n\n       Note that if your method doesn't store the value in the options array,\n       the options array won't get updated.\n\n   HOW CAN I VALIDATE AN OPTION'S VALUE?\n       Define a -validatemethod.\n\n   WHAT IS A -VALIDATEMETHOD?\n       A -validatemethod is a method that's called whenever the related option\n       is given a new value via the configure or configurelist instance\n       methods.  It's the method's responsibility to determine whether the new\n       value is valid, and throw an error if it isn't.\tThe -validatemethod,\n       if any, is called before the value is stored in the options array; in\n       particular, it's called before the -configuremethod, if any.\n\n       For example, suppose an option always takes a Boolean value.  You can\n       ensure that the value is in fact a valid Boolean like this:\n       % snit::type dog {\n\t   option -shots -default no -validatemethod BooleanOption\n\n\t   method BooleanOption {option value} {\n\t       if {![string is boolean -strict $value]} {\n\t\t   error \"expected a boolean value, got \\\"$value\\\"\"\n\t       }\n\t   }\n       }\n       ::dog\n       % dog fido\n       % fido configure -shots yes\n       % fido configure -shots NotABooleanValue\n       expected a boolean value, got \"NotABooleanValue\"\n       %\n\n       Note that the same -validatemethod can be used to validate any number\n       of boolean options.\n\n       Any method can be a -validatemethod provided that it takes two\n       arguments, the option name and the new option value.\n\nTYPE VARIABLES\n   WHAT IS A TYPE VARIABLE?\n       A type variable is a private variable associated with a Snit type\n       rather than with a particular instance of the type.  In C++ and Java,\n       the term static member variable is used for the same notion.  Type\n       variables can be scalars or arrays.\n\n   HOW IS A SCALAR TYPE VARIABLE DEFINED?\n       Scalar type variables are defined in the type definition using the\n       typevariable statement.\tYou can simply name it, or you can initialize\n       it with a value:"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you validate an option's value using the snitfaq resource?
  manpageQuestion3: Can you explain how to define a scalar type variable in snitfaq?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nsnit::type mytype {\n\t   # Define variable \"greeting\" and initialize it with \"Howdy!\"\n\t   typevariable greeting \"Howdy!\"\n       }\n\n\n       Every object of type mytype now has access to a single variable called\n       greeting.\n\n   HOW IS AN ARRAY-VALUED TYPE VARIABLE DEFINED?\n       Array-valued type variables are also defined using the typevariable\n       command; to initialize them, include the -array option:\n\n       snit::type mytype {\n\t   # Define typearray variable \"greetings\"\n\t   typevariable greetings -array {\n\t       formal \"Good Evening\"\n\t       casual \"Howdy!\"\n\t   }\n       }\n\n\n   WHAT HAPPENS IF I DON'T INITIALIZE A TYPE VARIABLE?\n       Variables do not really exist until they are given values.  If you do\n       not initialize a variable when you define it, then you must be sure to\n       assign a value to it (in the type constructor, say) before you\n       reference it.\n\n   ARE THERE ANY LIMITATIONS ON TYPE VARIABLE NAMES?\n       Type variable names have the same restrictions as the names of INSTANCE\n       VARIABLES do.\n\n   DO I NEED TO DECLARE MY TYPE VARIABLES IN MY METHODS?\n       No. Once you've defined a type variable in the type definition, it can\n       be used in INSTANCE METHODS or TYPE METHODS without declaration.  This\n       differs from normal Tcl practice, in which all non-local variables in a\n       proc need to be declared.\n\n       Type variables are subject to the same speed/readability tradeoffs as\n       instance variables; see Do I need to declare my instance variables in\n       my methods?\n\n   HOW DO I PASS A TYPE VARIABLE'S NAME TO ANOTHER OBJECT?\n       In Tk, it's common to pass a widget a variable name; for example, Tk\n       label widgets have a -textvariable option which names the variable\n       which will contain the widget's text.  This allows the program to\n       update the label's value just by assigning a new value to the variable.\n\n       If you naively pass a type variable name to the label widget, you'll be\n       confused by the result; Tk will assume that the name names a global\n       variable.  Instead, you need to provide a fully-qualified variable\n       name.  From within an instance method or a constructor, you can fully\n       qualify the type variable's name using the mytypevar command:\n\n       snit::widget mywidget {\n\t   typevariable labeltext \"\"\n\n\t   constructor {args} {\n\t       # ...\n\n\t       label $win.label -textvariable [mytypevar labeltext]\n\n\t       # ...\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snit::type command in Tcl?
  manpageQuestion2: How can you define an array-valued type variable using the snit::type command?
  manpageQuestion3: How do you pass a type variable's name to another object in Tcl, such as a Tk widget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW DO I MAKE A TYPE VARIABLE PUBLIC?\n       There are two ways to do this.  The preferred way is to write a pair of\n       TYPE METHODS to set and query the type variable's value.\n\n       Type variables are stored in the type's namespace, which has the same\n       name as the type itself.  Thus, you can also publicize the type\n       variable's name in your documentation so that clients can access it\n       directly.  For example,\n\n       snit::type mytype {\n\t   typevariable myvariable\n       }\n\n       set ::mytype::myvariable \"New Value\"\n\n\nTYPE METHODS\n   WHAT IS A TYPE METHOD?\n       A type method is a procedure associated with the type itself rather\n       than with any specific instance of the type, and called as a subcommand\n       of the type command.\n\n   HOW DO I DEFINE A TYPE METHOD?\n       Type methods are defined in the type definition using the typemethod\n       statement:\n\n       snit::type dog {\n\t   # List of pedigreed dogs\n\t   typevariable pedigreed\n\n\t   typemethod pedigreedDogs {} {\n\t       return $pedigreed\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you define a type method in snit to retrieve the value of a type variable?
  manpageQuestion3: Can you provide an example of making a type variable public in snit using the preferred method?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nSuppose the dog type maintains a list of the names of the dogs that\n       have pedigrees.\tThe pedigreedDogs type method returns this list.\n\n       The typemethod statement looks just like a normal Tcl proc, except that\n       it appears in a snit::type definition.  Notice that every type method\n       gets an implicit argument called type, which contains the fully-\n       qualified type name.\n\n   HOW DOES A CLIENT CALL A TYPE METHOD?\n       The type method name becomes a subcommand of the type's command.  For\n       example, assuming that the constructor adds each pedigreed dog to the\n       list of pedigreedDogs,\n\n       snit::type dog {\n\t   option -pedigreed 0\n\n\t   # List of pedigreed dogs\n\t   typevariable pedigreed\n\n\t   typemethod pedigreedDogs {} {\n\t       return $pedigreed\n\t   }\n\n\t   # ...\n       }\n\n       dog spot -pedigreed 1\n       dog fido\n\n       foreach dog [dog pedigreedDogs] { ... }\n\n\n   ARE THERE ANY LIMITATIONS ON TYPE METHOD NAMES?\n       Not really, so long as you avoid the standard type method names:\n       create, destroy, and info.\n\n   HOW DO I MAKE A TYPE METHOD PRIVATE?\n       It's sometimes useful to define private type methods, that is, type\n       methods intended to be called only by other type or instance methods of\n       the same object.\n\n       Snit doesn't implement any access control on type methods; by\n       convention, the names of public methods begin with a lower-case letter,\n       and the names of private methods begin with an upper-case letter.\n\n       Alternatively, a Snit proc can be used as a private type method; see\n       PROCS.\n\n   ARE THERE ANY LIMITATIONS ON TYPE METHOD ARGUMENTS?\n       Method argument lists are defined just like normal Tcl proc argument\n       lists; in particular, they can include arguments with default values\n       and the args argument.\n\n       However, every type method is called with an implicit argument called\n       type that contains the name of the type command.  In addition, type\n       methods should by convention avoid using the names of the arguments\n       implicitly defined for INSTANCE METHODS.\n\n   HOW DOES AN INSTANCE OR TYPE METHOD CALL A TYPE METHOD?\n       If an instance or type method needs to call a type method, it should\n       use $type to do so:\n\n       snit::type dog {\n\n\t   typemethod pedigreedDogs {} { ... }\n\n\t   typemethod printPedigrees {} {\n\t       foreach obj [$type pedigreedDogs] { ... }\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq tool?
  manpageQuestion2: How would you use the snit::type command to define a type method that returns a list of pedigreed dogs?
  manpageQuestion3: Can you provide an example of how to call a type method from within another type or instance method in Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW DO I PASS A TYPE METHOD AS A CALLBACK?\n       It's common in Tcl to pass a snippet of code to another object, for it\n       to call later.  Because types cannot be renamed, you can just use the\n       type name, or, if the callback is registered from within a type method,\n       type.  For example, suppose we want to print a list of pedigreed dogs\n       when a Tk button is pushed:\n\n\n       button .btn -text \"Pedigrees\" -command [list dog printPedigrees]\n       pack .btn\n\n       Alternatively, from a method or type method you can use the\n       mytypemethod command, just as you would use mymethod to define a\n       callback command for INSTANCE METHODS.\n\n   CAN TYPE METHODS BE HIERARCHICAL?\n       Yes, you can define hierarchical type methods in just the same way as\n       you can define hierarchical instance methods.  See INSTANCE METHODS for\n       more.\n\nPROCS\n   WHAT IS A PROC?\n       A Snit proc is really just a Tcl proc defined within the type's\n       namespace.  You can use procs for private code that isn't related to\n       any particular instance.\n\n   HOW DO I DEFINE A PROC?\n       Procs are defined by including a proc statement in the type definition:\n\n       snit::type mytype {\n\t   # Pops and returns the first item from the list stored in the\n\t   # listvar, updating the listvar\n\t  proc pop {listvar} { ... }\n\n\t  # ...\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you define a Snit proc within a type definition?
  manpageQuestion3: Can you provide an example of using the mytypemethod command to register a callback for a type method?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nARE THERE ANY LIMITATIONS ON PROC NAMES?\n       Any name can be used, so long as it does not begin with Snit_; names\n       beginning with Snit_ are reserved for Snit's own use.  However, the\n       wise programmer will avoid proc names (set, list, if, etc.) that would\n       shadow standard Tcl command names.\n\n       proc names, being private, should begin with a capital letter according\n       to convention; however, as there are typically no public procs in the\n       type's namespace it doesn't matter much either way.\n\n   HOW DOES A METHOD CALL A PROC?\n       Just like it calls any Tcl command.  For example,\n\n       snit::type mytype {\n\t   # Pops and returns the first item from the list stored in the\n\t   # listvar, updating the listvar\n\t   proc pop {listvar} { ... }\n\n\t   variable requestQueue {}\n\n\t   # Get one request from the queue and process it.\n\t   method processRequest {} {\n\t       set req [pop requestQueue]\n\t   }\n       }\n\n\n   HOW CAN I PASS A PROC TO ANOTHER OBJECT AS A CALLBACK?\n       The myproc command returns a callback command for the proc, just as\n       mymethod does for a method.\n\nTYPE CONSTRUCTORS\n   WHAT IS A TYPE CONSTRUCTOR?\n       A type constructor is a body of code that initializes the type as a\n       whole, rather like a C++ static initializer.  The body of a type\n       constructor is executed once when the type is defined, and never again.\n\n       A type can have at most one type constructor.\n\n   HOW DO I DEFINE A TYPE CONSTRUCTOR?\n       A type constructor is defined by using the typeconstructor statement in\n       the type definition.  For example, suppose the type uses an array-\n       valued type variable as a look-up table, and the values in the array\n       have to be computed at start-up.\n\n       % snit::type mytype {\n\t   typevariable lookupTable\n\n\t   typeconstructor {\n\t       array set lookupTable {key value...}\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you pass a procedure to another object as a callback using snit?
  manpageQuestion3: Can you provide an example of defining a type constructor in snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nCONSTRUCTORS\n   WHAT IS A CONSTRUCTOR?\n       In object-oriented programming, an object's constructor is responsible\n       for initializing the object completely at creation time. The\n       constructor receives the list of options passed to the snit::type\n       command's create method and can then do whatever it likes.  That might\n       include computing instance variable values, reading data from files,\n       creating other objects, updating type and instance variables, and so\n       forth.\n\n       The constructor's return value is ignored (unless it's an error, of\n       course).\n\n   HOW DO I DEFINE A CONSTRUCTOR?\n       A constructor is defined by using the constructor statement in the type\n       definition.  Suppose that it's desired to keep a list of all pedigreed\n       dogs.  The list can be maintained in a type variable and retrieved by a\n       type method.  Whenever a dog is created, it can add itself to the\n       list--provided that it's registered with the American Kennel Club.\n\n       % snit::type dog {\n\t   option -akc 0\n\n\t   typevariable akcList {}\n\n\t   constructor {args} {\n\t       $self configurelist $args\n\n\t       if {$options(-akc)} {\n\t\t   lappend akcList $self\n\t       }\n\t   }\n\n\t   typemethod akclist {} {\n\t       return $akcList\n\t   }\n       }\n       ::dog\n       % dog spot -akc 1\n       ::spot\n       % dog fido\n       ::fido\n       % dog akclist\n       ::spot\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you define a constructor in a snit::type definition to maintain a list of pedigree dogs registered with the American Kennel Club?
  manpageQuestion3: Can you provide an example of using a constructor to initialize a snit::type object and add it to a type variable list if it meets certain conditions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nWHAT DOES THE DEFAULT CONSTRUCTOR DO?\n       If you don't provide a constructor explicitly, you get the default\n       constructor, which is identical to the explicitly-defined constructor\n       shown here:\n\n       snit::type dog {\n\t   constructor {args} {\n\t       $self configurelist $args\n\t   }\n       }\n\n\n       When the constructor is called, args will be set to the list of\n       arguments that follow the object's name.  The constructor is allowed to\n       interpret this list any way it chooses; the normal convention is to\n       assume that it's a list of option names and values, as shown in the\n       example above.  If you simply want to save the option values, you\n       should use the configurelist method, as shown.\n\n   CAN I CHOOSE A DIFFERENT SET OF ARGUMENTS FOR THE CONSTRUCTOR?\n       Yes, you can.  For example, suppose we wanted to be sure that the breed\n       was explicitly stated for every dog at creation time, and couldn't be\n       changed thereafter.  One way to do that is as follows:\n\n       % snit::type dog {\n\t   variable breed\n\n\t   option -color brown\n\t   option -akc 0\n\n\t   constructor {theBreed args} {\n\t       set breed $theBreed\n\t       $self configurelist $args\n\t   }\n\n\t   method breed {} { return $breed }\n       }\n       ::dog\n       % dog spot dalmatian -color spotted -akc 1\n       ::spot\n       % spot breed\n       dalmatian"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you modify the constructor of a snit::type to require an explicit breed argument when creating a dog object?
  manpageQuestion3: Can you provide an example of using the constructor with additional arguments to set both breed and other options for a dog object?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThe drawback is that this syntax is non-standard, and may limit the\n       compatibility of your new type with other people's code.  For example,\n       Snit assumes that it can create COMPONENTS using the standard creation\n       syntax.\n\n   ARE THERE ANY LIMITATIONS ON CONSTRUCTOR ARGUMENTS?\n       Constructor argument lists are subject to the same limitations as those\n       on instance method argument lists.  It has the same implicit arguments,\n       and can contain default values and the args argument.\n\n   IS THERE ANYTHING SPECIAL ABOUT WRITING THE CONSTRUCTOR?\n       Yes.  Writing the constructor can be tricky if you're delegating\n       options to components, and there are specific issues relating to\n       snit::widgets and snit::widgetadaptors.\tSee DELEGATION, WIDGETS,\n       WIDGET ADAPTORS, and THE TK OPTION DATABASE.\n\nDESTRUCTORS\n   WHAT IS A DESTRUCTOR?\n       A destructor is a special kind of method that's called when an object\n       is destroyed.  It's responsible for doing any necessary clean-up when\n       the object goes away: destroying COMPONENTS, closing files, and so\n       forth.\n\n   HOW DO I DEFINE A DESTRUCTOR?\n       Destructors are defined by using the destructor statement in the type\n       definition.\n\n       Suppose we're maintaining a list of pedigreed dogs; then we'll want to\n       remove dogs from it when they are destroyed.\n\n       snit::type dog {\n\t   option -akc 0\n\n\t   typevariable akcList {}\n\n\t   constructor {args} {\n\t       $self configurelist $args\n\n\t       if {$options(-akc)} {\n\t\t   lappend akcList $self\n\t       }\n\t   }\n\n\t   destructor {\n\t       set ndx [lsearch $akcList $self]\n\n\t       if {$ndx != -1} {\n\t\t   set akcList [lreplace $akcList $ndx $ndx]\n\t       }\n\t   }\n\n\t   typemethod akclist {} {\n\t       return $akcList\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you define a destructor in a Snit type definition?
  manpageQuestion3: Can you provide an example of using the snit::type command to manage a list of objects with a destructor that removes them from a shared list?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nARE THERE ANY LIMITATIONS ON DESTRUCTOR ARGUMENTS?\n       Yes; a destructor has no explicit arguments.\n\n   WHAT IMPLICIT ARGUMENTS ARE PASSED TO THE DESTRUCTOR?\n       The destructor gets the same implicit arguments that are passed to\n       INSTANCE METHODS: type, selfns, win, and self.\n\n   MUST COMPONENTS BE DESTROYED EXPLICITLY?\n       Yes and no.\n\n       Any Tk widgets created by a snit::widget or snit::widgetadaptor will be\n       destroyed automatically by Tk when the megawidget is destroyed, in\n       keeping with normal Tk behavior (destroying a parent widget destroys\n       the whole tree).\n\n       Components of normal snit::types, on the other hand, are never\n       destroyed automatically, nor are non-widget components of Snit\n       megawidgets.  If your object creates them in its constructor, then it\n       should generally destroy them in its destructor.\n\n   IS THERE ANY SPECIAL ABOUT WRITING A DESTRUCTOR?\n       Yes.  If an object's constructor throws an error, the object's\n       destructor will be called to clean up; this means that the object might\n       not be completely constructed when the destructor is called.  This can\n       cause the destructor to throw its own error; the result is usually\n       misleading, confusing, and unhelpful.  Consequently, it's important to\n       write your destructor so that it's fail-safe.\n\n       For example, a dog might create a tail component; the component will\n       need to be destroyed.  But suppose there's an error while processing\n       the creation options--the destructor will be called, and there will be\n       no tail to destroy.  The simplest solution is generally to catch and\n       ignore any errors while destroying components.\n       snit::type dog {\n\t   component tail\n\n\t   constructor {args} {\n\t       $self configurelist $args\n\n\t       set tail [tail %AUTO%]\n\t   }\n\n\t   destructor {\n\t       catch {$tail destroy}\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can a destructor in a Snit type handle potential errors when destroying components?
  manpageQuestion3: What are the implicit arguments passed to a destructor in Snit, and why is it important to handle errors during destruction?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nCOMPONENTS\n   WHAT IS A COMPONENT?\n       Often an object will create and manage a number of other objects.  A\n       Snit megawidget, for example, will often create a number of Tk widgets.\n       These objects are part of the main object; it is composed of them, so\n       they are called components of the object.\n\n       But Snit also has a more precise meaning for COMPONENT.\tThe components\n       of a Snit object are those objects to which methods or options can be\n       delegated.  (See DELEGATION for more information about delegation.)\n\n   HOW DO I DECLARE A COMPONENT?\n       First, you must decide what role a component plays within your object,\n       and give the role a name.  Then, you declare the component using its\n       role name and the component statement.  The component statement\n       declares an instance variable which is used to store the component's\n       command name when the component is created.\n\n       For example, suppose your dog object creates a tail object (the better\n       to wag with, no doubt):\n\n       snit::type dog {\n\t   component mytail\n\n\t   constructor {args} {\n\t       # Create and save the component's command\n\t       set mytail [tail %AUTO% -partof $self]\n\t       $self configurelist $args\n\t   }\n\n\t   method wag {} {\n\t       $mytail wag\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How do you declare a component in a Snit object, and what is an example of its usage?
  manpageQuestion3: Can you provide an example of how a Snit object can delegate method calls to its components?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nAs shown here, it doesn't matter what the tail object's real name is;\n       the dog object refers to it by its component name.\n\n       The above example shows one way to delegate the wag method to the\n       mytail component; see DELEGATION for an easier way.\n\n   HOW IS A COMPONENT NAMED?\n       A component has two names.  The first name is that of the component\n       variable; this represents the role the component object plays within\n       the Snit object.  This is the component name proper, and is the name\n       used to refer to the component within Snit code.  The second name is\n       the name of the actual component object created by the Snit object's\n       constructor.  This second name is always a Tcl command name, and is\n       referred to as the component's object name.\n\n       In the example in the previous question, the component name is mytail;\n       the mytail component's object name is chosen automatically by Snit\n       since %AUTO% was used when the component object was created.\n\n   ARE THERE ANY LIMITATIONS ON COMPONENT NAMES?\n       Yes.  snit::widget and snit::widgetadaptor objects have a special\n       component called the hull component; thus, the name hull should be used\n       for no other purpose.\n\n       Otherwise, since component names are in fact instance variable names\n       they must follow the rules for INSTANCE VARIABLES.\n\n   WHAT IS AN OWNED COMPONENT?\n       An owned component is a component whose object command's lifetime is\n       controlled by the snit::type or snit::widget.\n\n       As stated above, a component is an object to which our object can\n       delegate methods or options.  Under this definition, our object will\n       usually create its component objects, but not necessarily.  Consider\n       the following: a dog object has a tail component; but tail knows that\n       it's part of the dog:\n       snit::type dog {\n\t   component mytail\n\n\t   constructor {args} {\n\t       set mytail [tail %AUTO% -partof $self]\n\t       $self configurelist $args\n\t   }\n\n\t   destructor {\n\t       catch {$mytail destroy}\n\t   }\n\n\t   delegate method wagtail to mytail as wag\n\n\t   method bark {} {\n\t       return \"$self barked.\"\n\t   }\n       }\n\n\tsnit::type tail {\n\t    component mydog\n\t    option -partof -readonly yes\n\n\t    constructor {args} {\n\t\t$self configurelist $args\n\t\tset mydog $options(-partof)\n\t    }\n\n\t    method wag {} {\n\t\treturn \"Wag, wag.\"\n\t    }\n\n\t    method pull {} {\n\t\t$mydog bark\n\t    }\n\t}\n\n       Thus, if you ask a dog to wag its tail, it tells its tail to wag; and\n       if you pull the dog's tail, the tail tells the dog to bark.  In this\n       scenario, the tail is a component of the dog, and the dog is a\n       component of the tail, but the dog owns the tail and not the other way\n       around.\n\n   WHAT DOES THE INSTALL COMMAND DO?\n       The install command creates an owned component using a specified\n       command, and assigns the result to the component's instance variable.\n       For example:\n       snit::type dog {\n\t   component mytail\n\n\t   constructor {args} {\n\t       # set mytail [tail %AUTO% -partof $self]\n\t       install mytail using tail %AUTO% -partof $self\n\t       $self configurelist $args\n\t   }\n       }\n\n       In a snit::type's code, the install command shown above is equivalent\n       to the set mytail command that's commented out.\tIn a snit::widget's or\n       snit::widgetadaptor's, code, however, the install command also queries\n       THE TK OPTION DATABASE and initializes the new component's options\n       accordingly.  For consistency, it's a good idea to get in the habit of\n       using install for all owned components.\n\n   MUST OWNED COMPONENTS BE CREATED IN THE CONSTRUCTOR?\n       No, not necessarily.  In fact, there's no reason why an object can't\n       destroy and recreate a component multiple times over its own lifetime.\n\n   ARE THERE ANY LIMITATIONS ON COMPONENT OBJECT NAMES?\n       Yes.\n\n       Component objects which are Tk widgets or megawidgets must have valid\n       Tk window names.\n\n       Component objects which are not widgets or megawidgets must have fully-\n       qualified command names, i.e., names which include the full namespace\n       of the command.\tNote that Snit always creates objects with fully\n       qualified names.\n\n       Next, the object names of components and owned by your object must be\n       unique.\tThis is no problem for widget components, since widget names\n       are always unique; but consider the following code:\n\n       snit::type tail { ... }\n\n       snit::type dog {\n\t   delegate method wag to mytail\n\n\t   constructor {} {\n\t       install mytail using tail mytail\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq tool?
  manpageQuestion2: How can you create an owned component in a Snit type using the install command?
  manpageQuestion3: What are the limitations on component object names when using Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThis code uses the component name, mytail, as the component object\n       name.  This is not good, and here's why: Snit instance code executes in\n       the Snit type's namespace.  In this case, the mytail component is\n       created in the ::dog:: namespace, and will thus have the name\n       ::dog::mytail.\n\n       Now, suppose you create two dogs.  Both dogs will attempt to create a\n       tail called ::dog::mytail.  The first will succeed, and the second will\n       fail, since Snit won't let you create an object if its name is already\n       a command.  Here are two ways to avoid this situation:\n\n       First, if the component type is a snit::type you can specify %AUTO% as\n       its name, and be guaranteed to get a unique name.  This is the safest\n       thing to do:\n\n\n\t   install mytail using tail %AUTO%\n\n\n       If the component type isn't a snit::type you can create the component\n       in the object's instance namespace:\n\n\n\t   install mytail using tail ${selfns}::mytail\n\n\n       Make sure you pick a unique name within the instance namespace.\n\n   MUST I DESTROY THE COMPONENTS I OWN?\n       That depends.  When a parent widget is destroyed, all child widgets are\n       destroyed automatically. Thus, if your object is a snit::widget or\n       snit::widgetadaptor you don't need to destroy any components that are\n       widgets, because they will generally be children or descendants of your\n       megawidget.\n\n       If your object is an instance of snit::type, though, none of its owned\n       components will be destroyed automatically, nor will be non-widget\n       components of a snit::widget be destroyed automatically.  All such\n       owned components must be destroyed explicitly, or they won't be\n       destroyed at all.\n\n   CAN I EXPOSE A COMPONENT'S OBJECT COMMAND AS PART OF MY INTERFACE?\n       Yes, and there are two ways to do it.  The most appropriate way is\n       usually to use DELEGATION.  Delegation allows you to pass the options\n       and methods you specify along to particular components.\tThis\n       effectively hides the components from the users of your type, and\n       ensures good encapsulation.\n\n       However, there are times when it's appropriate, not to mention simpler,\n       just to make the entire component part of your type's public interface.\n\n   HOW DO I EXPOSE A COMPONENT'S OBJECT COMMAND?\n       When you declare the component, specify the component statement's\n       -public option.\tThe value of this option is the name of a method which\n       will be delegated to your component's object command.\n\n       For example, supposed you've written a combobox megawidget which owns a\n       listbox widget, and you want to make the listbox's entire interface\n       public.\tYou can do it like this:\n\n       snit::widget combobox {\n\t    component listbox -public listbox\n\n\t    constructor {args} {\n\t\tinstall listbox using listbox $win.listbox ....\n\t    }\n       }\n\n       combobox .mycombo"
  manpageQuestion1: What is the primary purpose of the snitfaq tool?
  manpageQuestion2: How can you ensure that a component's name is unique when using snit::type in Snit?
  manpageQuestion3: What is the method to expose a component's object command as part of your type's public interface in Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nYour comobox widget, .mycombo, now has a listbox method which has all\n       of the same subcommands as the listbox widget itself.  Thus, the above\n       code sets the listbox component's width to 30.\n\n       Usually you'll let the method name be the same as the component name;\n       however, you can name it anything you like.\n\nTYPE COMPONENTS\n   WHAT IS A TYPE COMPONENT?\n       A type component is a component that belongs to the type itself instead\n       of to a particular instance of the type.  The relationship between\n       components and type components is the same as the relationship between\n       INSTANCE VARIABLES and TYPE VARIABLES.  Both INSTANCE METHODS and TYPE\n       METHODS can be delegated to type components.\n\n       Once you understand COMPONENTS and DELEGATION, type components are just\n       more of the same.\n\n   HOW DO I DECLARE A TYPE COMPONENT?\n       Declare a type component using the typecomponent statement.  It takes\n       the same options (-inherit and -public) as the component statement\n       does, and defines a type variable to hold the type component's object\n       command.\n\n       Suppose in your model you've got many dogs, but only one veterinarian.\n       You might make the veterinarian a type component.\n       snit::type veterinarian { ... }\n\n       snit::type dog {\n\t   typecomponent vet\n\n\t   # ...\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you declare a type component in snitfaq, and what are the key options used?
  manpageQuestion3: Can you provide an example of using a type component in a snitfaq application, such as assigning a veterinarian to all instances of a 'dog' type?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW DO I INSTALL A TYPE COMPONENT?\n       Just use the set command to assign the component's object command to\n       the type component.  Because types (even snit::widget types) are not\n       widgets, and do not have options anyway, the extra features of the\n       install command are not needed.\n\n       You'll usually install type components in the type constructor, as\n       shown here:\n       snit::type veterinarian { ... }\n\n       snit::type dog {\n\t   typecomponent vet\n\n\t   typeconstructor {\n\t       set vet [veterinarian %AUTO%]\n\t   }\n       }\n\n\n   ARE THERE ANY LIMITATIONS ON TYPE COMPONENT NAMES?\n       Yes, the same as on INSTANCE VARIABLES, TYPE VARIABLES, and normal\n       COMPONENTS.\n\nDELEGATION\n   WHAT IS DELEGATION?\n       Delegation, simply put, is when you pass a task you've been given to\n       one of your assistants.\t(You do have assistants, don't you?)  Snit\n       objects can do the same thing.  The following example shows one way in\n       which the dog object can delegate its wag method and its -taillength\n       option to its tail component.\n\n       snit::type dog {\n\t   variable mytail\n\n\t   option -taillength -configuremethod SetTailOption -cgetmethod GetTailOption"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you install a type component in the type constructor using snit?
  manpageQuestion3: Can you provide an example of delegation in snit objects as described in the manpage?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nmethod SetTailOption {option value} {\n\t\t$mytail configure $option $value\n\t   }\n\n\t   method GetTailOption {option} {\n\t\t$mytail cget $option\n\t   }\n\n\t   method wag {} {\n\t       $mytail wag\n\t   }\n\n\t   constructor {args} {\n\t       install mytail using tail %AUTO% -partof $self\n\t       $self configurelist $args\n\t   }\n\n       }\n\n\n       This is the hard way to do it, by it demonstrates what delegation is\n       all about.  See the following answers for the easy way to do it.\n\n       Note that the constructor calls the configurelist method after it\n       creates its tail; otherwise, if -taillength appeared in the list of\n       args we'd get an error.\n\n   HOW CAN I DELEGATE A METHOD TO A COMPONENT OBJECT?\n       Delegation occurs frequently enough that Snit makes it easy. Any method\n       can be delegated to any component or type component by placing a single\n       delegate statement in the type definition.  (See COMPONENTS and TYPE\n       COMPONENTS for more information about component names.)\n\n       For example, here's a much better way to delegate the dog object's wag\n       method:\n\n       % snit::type dog {\n\t   delegate method wag to mytail\n\n\t   constructor {} {\n\t       install mytail using tail %AUTO%\n\t   }\n       }\n       ::dog\n       % snit::type tail {\n\t   method wag {} { return \"Wag, wag, wag.\"}\n       }\n       ::tail\n       % dog spot\n       ::spot\n       % spot wag\n       Wag, wag, wag."
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you delegate a method from one object to another using Snit?
  manpageQuestion3: Can you provide an example of how to delegate a method called 'wag' from a 'tail' object to a 'dog' object using Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThis code has the same effect as the code shown under the previous\n       question: when a dog's wag method is called, the call and its arguments\n       are passed along automatically to the tail object.\n\n       Note that when a component is mentioned in a delegate statement, the\n       component's instance variable is defined implicitly.  However, it's\n       still good practice to declare it explicitly using the component\n       statement.\n\n       Note also that you can define a method name using the method statement,\n       or you can define it using delegate; you can't do both.\n\n   CAN I DELEGATE TO A METHOD WITH A DIFFERENT NAME?\n       Suppose you wanted to delegate the dog's wagtail method to the tail's\n       wag method.  After all you wag the tail, not the dog.  It's easily\n       done:\n\n       snit::type dog {\n\t   delegate method wagtail to mytail as wag\n\n\t   constructor {args} {\n\t       install mytail using tail %AUTO% -partof $self\n\t       $self configurelist $args\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you delegate a method in snit to another method with a different name?
  manpageQuestion3: What is the recommended practice when dealing with components mentioned in a delegate statement?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nCAN I DELEGATE TO A METHOD WITH ADDITIONAL ARGUMENTS?\n       Suppose the tail's wag method takes as an argument the number of times\n       the tail should be wagged.  You want to delegate the dog's wagtail\n       method to the tail's wag method, specifying that the tail should be\n       wagged exactly three times.  This is easily done, too:\n\n       snit::type dog {\n\t   delegate method wagtail to mytail as {wag 3}\n\t   # ...\n       }\n\n       snit::type tail {\n\t   method wag {count} {\n\t       return [string repeat \"Wag \" $count]\n\t   }\n\t   # ...\n       }\n\n\n   CAN I DELEGATE A METHOD TO SOMETHING OTHER THAN AN OBJECT?\n       Normal method delegation assumes that you're delegating a method (a\n       subcommand of an object command) to a method of another object (a\n       subcommand of a different object command).  But not all Tcl objects\n       follow Tk conventions, and not everything you'd to which you'd like to\n       delegate a method is necessary an object.  Consequently, Snit makes it\n       easy to delegate a method to pretty much anything you like using the\n       delegate statement's using clause.\n\n       Suppose your dog simulation stores dogs in a database, each dog as a\n       single record.  The database API you're using provides a number of\n       commands to manage records; each takes the record ID (a string you\n       choose) as its first argument.  For example, saverec saves a record.\n       If you let the record ID be the name of the dog object, you can\n       delegate the dog's save method to the saverec command as follows:\n       snit::type dog {\n\t   delegate method save using {saverec %s}\n       }\n\n       The %s is replaced with the instance name when the save method is\n       called; any additional arguments are the appended to the resulting\n       command.\n\n       The using clause understands a number of other %-conversions; in\n       addition to the instance name, you can substitute in the method name\n       (%m), the type name (%t), the instance namespace (%n), the Tk window\n       name (%w), and, if a component or typecomponent name was given in the\n       delegate statement, the component's object command (%c).\n\n   HOW CAN I DELEGATE A METHOD TO A TYPE COMPONENT OBJECT?\n       Just exactly as you would to a component object.  The delegate method\n       statement accepts both component and type component names in its to\n       clause.\n\n   HOW CAN I DELEGATE A TYPE METHOD TO A TYPE COMPONENT OBJECT?\n       Use the delegate typemethod statement.  It works like delegate method,\n       with these differences: first, it defines a type method instead of an\n       instance method; second, the using clause ignores the %s, %n, and %w\n       %-conversions.\n\n       Naturally, you can't delegate a type method to an instance\n       component...Snit wouldn't know which instance should receive it.\n\n   HOW CAN I DELEGATE AN OPTION TO A COMPONENT OBJECT?\n       The first question in this section (see DELEGATION) shows one way to\n       delegate an option to a component; but this pattern occurs often enough\n       that Snit makes it easy.  For example, every tail object has a -length\n       option; we want to allow the creator of a dog object to set the tail's\n       length.\tWe can do this:\n\n       % snit::type dog {\n\t   delegate option -length to mytail\n\n\t   constructor {args} {\n\t       install mytail using tail %AUTO% -partof $self\n\t       $self configurelist $args\n\t   }\n       }\n       ::dog\n       % snit::type tail {\n\t   option -partof\n\t   option -length 5\n       }\n       ::tail\n       % dog spot -length 7\n       ::spot\n       % spot cget -length\n       7"
  manpageQuestion1: What is the primary purpose of the snitfaq tool?
  manpageQuestion2: How would you delegate a method to a database API command using the snit::type syntax?
  manpageQuestion3: Can you provide an example of delegating an option to a component object in Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThis produces nearly the same result as the -configuremethod and\n       -cgetmethod shown under the first question in this section: whenever a\n       dog object's -length option is set or retrieved, the underlying tail\n       object's option is set or retrieved in turn.\n\n       Note that you can define an option name using the option statement, or\n       you can define it using delegate; you can't do both.\n\n   CAN I DELEGATE TO AN OPTION WITH A DIFFERENT NAME?\n       In the previous answer we delegated the dog's -length option down to\n       its tail.  This is, of course, wrong.  The dog has a length, and the\n       tail has a length, and they are different.  What we'd really like to do\n       is give the dog a -taillength option, but delegate it to the tail's\n       -length option:\n\n       snit::type dog {\n\t   delegate option -taillength to mytail as -length\n\n\t   constructor {args} {\n\t       set mytail [tail %AUTO% -partof $self]\n\t       $self configurelist $args\n\t   }\n       }\n\n\n   HOW CAN I DELEGATE ANY UNRECOGNIZED METHOD OR OPTION TO A COMPONENT OBJECT?\n       It may happen that a Snit object gets most of its behavior from one of\n       its components.\tThis often happens with snit::widgetadaptors, for\n       example, where we wish to slightly the modify the behavior of an\n       existing widget.  To carry on with our dog example, however, suppose\n       that we have a snit::type called animal that implements a variety of\n       animal behaviors--moving, eating, sleeping, and so forth.  We want our\n       dog objects to inherit these same behaviors, while adding dog-like\n       behaviors of its own.  Here's how we can give a dog methods and options\n       of its own while delegating all other methods and options to its animal\n       component:\n\n       snit::type dog {\n\t   delegate option * to animal\n\t   delegate method * to animal\n\n\t   option -akc 0\n\n\t   constructor {args} {\n\t       install animal using animal %AUTO% -name $self\n\t       $self configurelist $args\n\t   }\n\n\t   method wag {} {\n\t       return \"$self wags its tail\"\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you delegate a specific option, like -taillength, from one object to another in Snit?
  manpageQuestion3: How can you delegate all methods and options of a Snit object to another object, such as an animal component, while adding custom methods and options?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThat's it.  A dog is now an animal that has a -akc option and can wag\n       its tail.\n\n       Note that we don't need to specify the full list of method names or\n       option names that animal will receive.  It gets anything dog doesn't\n       recognize--and if it doesn't recognize it either, it will simply throw\n       an error, just as it should.\n\n       You can also delegate all unknown type methods to a type component\n       using delegate typemethod *.\n\n   HOW CAN I DELEGATE ALL BUT CERTAIN METHODS OR OPTIONS TO A COMPONENT?\n       In the previous answer, we said that every dog is an animal by\n       delegating all unknown methods and options to the animal component. But\n       what if the animal type has some methods or options that we'd like to\n       suppress?\n\n       One solution is to explicitly delegate all the options and methods, and\n       forgo the convenience of delegate method * and delegate option *.  But\n       if we wish to suppress only a few options or methods, there's an easier\n       way:\n\n       snit::type dog {\n\t   delegate option * to animal except -numlegs\n\t   delegate method * to animal except {fly climb}\n\n\t   # ...\n\n\t   constructor {args} {\n\t       install animal using animal %AUTO% -name $self -numlegs 4\n\t       $self configurelist $args\n\t   }\n\n\t   # ...\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq tool?
  manpageQuestion2: How would you use snitfaq to delegate all methods and options to the animal component except for -numlegs and fly/climb?
  manpageQuestion3: Can you provide an example of using snitfaq to delegate specific methods and options to a component while suppressing certain ones?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nDogs have four legs, so we specify that explicitly when we create the\n       animal component, and explicitly exclude -numlegs from the set of\n       delegated options.  Similarly, dogs can neither fly nor climb, so we\n       exclude those animal methods as shown.\n\n   CAN A HIERARCHICAL METHOD BE DELEGATED?\n       Yes; just specify multiple words in the delegated method's name:\n\n       snit::type tail {\n\t   method wag {} {return \"Wag, wag\"}\n\t   method droop {} {return \"Droop, droop\"}\n       }\n\n\n       snit::type dog {\n\t   delegate method {tail wag} to mytail\n\t   delegate method {tail droop} to mytail\n\n\t   # ...\n\n\t   constructor {args} {\n\t       install mytail using tail %AUTO%\n\t       $self configurelist $args\n\t   }\n\n\t   # ...\n       }\n\n\n       Unrecognized hierarchical methods can also be delegated; the following\n       code delegates all subcommands of the \"tail\" method to the \"mytail\"\n       component:\n\n       snit::type dog {\n\t   delegate method {tail *} to mytail\n\n\t   # ...\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq tool?
  manpageQuestion2: How would you use snit::type to define a hierarchical method delegation for a dog component that delegates the 'wag' and 'droop' methods to another component?
  manpageQuestion3: Can you provide an example of using snit::type to delegate all subcommands of the 'tail' method to another component in a dog type definition?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nWIDGETS\n   WHAT IS A SNIT::WIDGET?\n       A snit::widget is the Snit version of what Tcl programmers usually call\n       a megawidget: a widget-like object usually consisting of one or more Tk\n       widgets all contained within a Tk frame.\n\n       A snit::widget is also a special kind of snit::type.  Just about\n       everything in this FAQ list that relates to snit::types also applies to\n       snit::widgets.\n\n   HOW DO I DEFINE A SNIT::WIDGET?\n       snit::widgets are defined using the snit::widget command, just as\n       snit::types are defined by the snit::type command.\n\n       The body of the definition can contain all of the same kinds of\n       statements, plus a couple of others which will be mentioned below.\n\n   HOW DO SNIT::WIDGETS DIFFER FROM SNIT::TYPES?\n       •      The name of an instance of a snit::type can be any valid Tcl\n\t      command name, in any namespace.  The name of an instance of a\n\t      snit::widget must be a valid Tk widget name, and its parent\n\t      widget must already exist.\n\n       •      An instance of a snit::type can be destroyed by calling its\n\t      destroy method.  Instances of a snit::widget have no destroy\n\t      method; use the Tk destroy command instead.\n\n       •      Every instance of a snit::widget has one predefined component\n\t      called its hull component.  The hull is usually a Tk frame or\n\t      toplevel widget; any other widgets created as part of the\n\t      snit::widget will usually be contained within the hull.\n\n       •      snit::widgets can have their options receive default values from\n\t      THE TK OPTION DATABASE.\n\n   WHAT IS A HULL COMPONENT?\n       Snit can't create a Tk widget object; only Tk can do that.  Thus, every\n       instance of a snit::widget must be wrapped around a genuine Tk widget;\n       this Tk widget is called the hull component.  Snit effectively\n       piggybacks the behavior you define (methods, options, and so forth) on\n       top of the hull component so that the whole thing behaves like a\n       standard Tk widget.\n\n       For snit::widgets the hull component must be a Tk widget that defines\n       the -class option.\n\n       snit::widgetadaptors differ from snit::widgets chiefly in that any kind\n       of widget can be used as the hull component; see WIDGET ADAPTORS.\n\n   HOW CAN I SET THE HULL TYPE FOR A SNIT::WIDGET?\n       A snit::widget's hull component will usually be a Tk frame widget;\n       however, it may be any Tk widget that defines the -class option.  You\n       can explicitly choose the hull type you prefer by including the\n       hulltype command in the widget definition:\n\n       snit::widget mytoplevel {\n\t   hulltype toplevel\n\n\t   # ...\n       }"
  manpageQuestion1: What is the primary purpose of the snit::widget in the Snit framework?
  manpageQuestion2: How do you define a snit::widget in Tcl using the snit::widget command?
  manpageQuestion3: Can you explain how to set a custom hull type for a snit::widget and provide an example of its usage?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nIf no hulltype command appears, the hull will be a frame.\n\n       By default, Snit recognizes the following hull types: the Tk widgets\n       frame, labelframe, toplevel, and the Tile widgets ttk::frame,\n       ttk::labelframe, and ttk::toplevel.  To enable the use of some other\n       kind of widget as the hull type, you can lappend the widget command to\n       the variable snit::hulltypes (always provided the widget defines the\n       -class option.  For example, suppose Tk gets a new widget type called a\n       prettyframe:\n\n       lappend snit::hulltypes prettyframe\n\n       snit::widget mywidget {\n\t   hulltype prettyframe\n\n\t   # ...\n       }\n\n\n   HOW SHOULD I NAME WIDGETS WHICH ARE COMPONENTS OF A SNIT::WIDGET?\n       Every widget, whether a genuine Tk widget or a Snit megawidget, has to\n       have a valid Tk window name.  When a snit::widget is first created, its\n       instance name, self, is a Tk window name; however, if the snit::widget\n       is used as the hull component by a snit::widgetadaptor its instance\n       name will be changed to something else.\tFor this reason, every\n       snit::widget method, constructor, destructor, and so forth is passed\n       another implicit argument, win, which is the window name of the\n       megawidget.  Any children should be named using win as the root.\n\n       Thus, suppose you're writing a toolbar widget, a frame consisting of a\n       number of buttons placed side-by-side.  It might look something like\n       this:\n\n       snit::widget toolbar {\n\t   delegate option * to hull\n\n\t   constructor {args} {\n\t       button $win.open -text Open -command [mymethod open]\n\t       button $win.save -text Save -command [mymethod save]\n\n\t       # ....\n\n\t       $self configurelist $args\n\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you customize the hull type for a snit::widget to use a new widget type like 'prettyframe'?
  manpageQuestion3: What is the recommended way to name child widgets within a snit::widget to ensure valid Tk window names?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nSee also the question on renaming objects, toward the top of this file.\n\nWIDGET ADAPTORS\n   WHAT IS A SNIT::WIDGETADAPTOR?\n       A snit::widgetadaptor is a kind of snit::widget.  Whereas a\n       snit::widget's hull is automatically created and is always a Tk frame,\n       a snit::widgetadaptor can be based on any Tk widget--or on any Snit\n       megawidget, or even (with luck) on megawidgets defined using some other\n       package.\n\n       It's called a widget adaptor because it allows you to take an existing\n       widget and customize its behavior.\n\n   HOW DO I DEFINE A SNIT::WIDGETADAPTOR?\n       Use the snit::widgetadaptor command.  The definition for a\n       snit::widgetadaptor looks just like that for a snit::type or\n       snit::widget, except that the constructor must create and install the\n       hull component.\n\n       For example, the following code creates a read-only text widget by the\n       simple device of turning its insert and delete methods into no-ops.\n       Then, we define new methods, ins and del, which get delegated to the\n       hull component as insert and delete.  Thus, we've adapted the text\n       widget and given it new behavior while still leaving it fundamentally a\n       text widget.\n\n       ::snit::widgetadaptor rotext {\n\n\t   constructor {args} {\n\t       # Create the text widget; turn off its insert cursor\n\t       installhull using text -insertwidth 0\n\n\t       # Apply any options passed at creation time.\n\t       $self configurelist $args\n\t   }\n\n\t   # Disable the text widget's insert and delete methods, to\n\t   # make this readonly.\n\t   method insert {args} {}\n\t   method delete {args} {}\n\n\t   # Enable ins and del as synonyms, so the program can insert and\n\t   # delete.\n\t   delegate method ins to hull as insert\n\t   delegate method del to hull as delete\n\n\t   # Pass all other methods and options to the real text widget, so\n\t   # that the remaining behavior is as expected.\n\t   delegate method * to hull\n\t   delegate option * to hull\n       }"
  manpageQuestion1: What is the primary purpose of the snit::widgetadaptor in Tcl?
  manpageQuestion2: How can you define a snit::widgetadaptor to create a read-only text widget?
  manpageQuestion3: Can you provide an example of using snit::widgetadaptor to adapt a Tk widget into a custom behavior?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThe most important part is in the constructor.  Whereas snit::widget\n       creates the hull for you, snit::widgetadaptor cannot -- it doesn't know\n       what kind of widget you want.  So the first thing the constructor does\n       is create the hull component (a Tk text widget in this case), and then\n       installs it using the installhull command.\n\n       Note: There is no instance command until you create one by installing a\n       hull component.\tAny attempt to pass methods to $self prior to calling\n       installhull will fail.\n\n   CAN I ADAPT A WIDGET CREATED ELSEWHERE IN THE PROGRAM?\n       Yes.\n\n       At times, it can be convenient to adapt a pre-existing widget instead\n       of creating your own.  For example, the Bwidget PagesManager widget\n       manages a set of frame widgets, only one of which is visible at a time.\n       The application chooses which frame is visible.\tAll of the These\n       frames are created by the PagesManager itself, using its add method.\n       It's convenient to adapt these frames to do what we'd like them to do.\n\n       In a case like this, the Tk widget will already exist when the\n       snit::widgetadaptor is created.\tSnit provides an alternate form of the\n       installhull command for this purpose:\n\n       snit::widgetadaptor pageadaptor {\n\t   constructor {args} {\n\t       # The widget already exists; just install it.\n\t       installhull $win\n\n\t       # ...\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you adapt an existing Tk widget using snit::widgetadaptor?
  manpageQuestion3: Can you provide an example of using snit::widgetadaptor to adapt a pre-existing widget like the Bwidget PagesManager frames?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nCAN I ADAPT ANOTHER MEGAWIDGET?\n       Maybe. If the other megawidget is a snit::widget or\n       snit::widgetadaptor, then yes.  If it isn't then, again, maybe.\tYou'll\n       have to try it and see.\tYou're most likely to have trouble with widget\n       destruction--you have to make sure that your megawidget code receives\n       the <Destroy> event before the megawidget you're adapting does.\n\nTHE TK OPTION DATABASE\n   WHAT IS THE TK OPTION DATABASE?\n       The Tk option database is a database of default option values\n       maintained by Tk itself; every Tk application has one.  The concept of\n       the option database derives from something called the X Windows\n       resource database; however, the option database is available in every\n       Tk implementation, including those which do not use the X Windows\n       system (e.g., Microsoft Windows).\n\n       Full details about the Tk option database are beyond the scope of this\n       document; both Practical Programming in Tcl and Tk by Welch, Jones, and\n       Hobbs, and Effective Tcl/Tk Programming by Harrison and McClennan.,\n       have good introductions to it.\n\n       Snit is implemented so that most of the time it will simply do the\n       right thing with respect to the option database, provided that the\n       widget developer does the right thing by Snit.  The body of this\n       section goes into great deal about what Snit requires.  The following\n       is a brief statement of the requirements, for reference.\n\n       •      If the widget's default widget class is not what is desired, set\n\t      it explicitly using the widgetclass statement in the widget\n\t      definition.\n\n       •      When defining or delegating options, specify the resource and\n\t      class names explicitly when necessary.\n\n       •      Use the installhull using command to create and install the hull\n\t      for snit::widgetadaptors.\n\n       •      Use the install command to create and install all components\n\t      which are widgets.\n\n       •      Use the install command to create and install components which\n\t      aren't widgets if you'd like them to receive option values from\n\t      the option database.\n\n       The interaction of Tk widgets with the option database is a complex\n       thing; the interaction of Snit with the option database is even more\n       so, and repays attention to detail.\n\n   DO SNIT::TYPES USE THE TK OPTION DATABASE?\n       No, they don't; querying the option database requires a Tk window name,\n       and snit::types don't have one.\n\n       If you create an instance of a snit::type as a component of a\n       snit::widget or snit::widgetadaptor, on the other hand, and if any\n       options are delegated to the component, and if you use install to\n       create and install it, then the megawidget will query the option\n       database on the snit::type's behalf.  This might or might not be what\n       you want, so take care.\n\n   WHAT IS MY SNIT::WIDGET'S WIDGET CLASS?\n       Every Tk widget has a \"widget class\": a name that is used when adding\n       option settings to the database.  For Tk widgets, the widget class is\n       the same as the widget command name with an initial capital.  For\n       example, the widget class of the Tk button widget is Button.\n\n       Similarly, the widget class of a snit::widget defaults to the\n       unqualified type name with the first letter capitalized.  For example,\n       the widget class of\n\n       snit::widget ::mylibrary::scrolledText { ... }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can a developer ensure that a snit::widget correctly interacts with the Tk option database?
  manpageQuestion3: Can you explain how snit::types interact with the Tk option database compared to snit::widgets?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nis ScrolledText.\n\n       The widget class can also be set explicitly using the widgetclass\n       statement within the snit::widget definition:\n\n       snit::widget ::mylibrary::scrolledText {\n\t   widgetclass Text\n\n\t   # ...\n       }\n\n\n       The above definition says that a scrolledText megawidget has the same\n       widget class as an ordinary text widget.  This might or might not be a\n       good idea, depending on how the rest of the megawidget is defined, and\n       how its options are delegated.\n\n   WHAT IS MY SNIT::WIDGETADAPTOR'S WIDGET CLASS?\n       The widget class of a snit::widgetadaptor is just the widget class of\n       its hull widget; Snit has no control over this.\n\n       Note that the widget class can be changed only for frame and toplevel\n       widgets, which is why these are the valid hull types for snit::widgets.\n\n       Try to use snit::widgetadaptors only to make small modifications to\n       another widget's behavior.  Then, it will usually not make sense to\n       change the widget's widget class anyway.\n\n   WHAT ARE OPTION RESOURCE AND CLASS NAMES?\n       Every Tk widget option has three names: the option name, the resource\n       name, and the class name.  The option name begins with a hyphen and is\n       all lowercase; it's used when creating widgets, and with the configure\n       and cget commands.\n\n       The resource and class names are used to initialize option default\n       values by querying the option database.\tThe resource name is usually\n       just the option name minus the hyphen, but may contain uppercase\n       letters at word boundaries; the class name is usually just the resource\n       name with an initial capital, but not always.  For example, here are\n       the option, resource, and class names for several Tk text widget\n       options:\n\n\t   -background\t       background\t  Background\n\t   -borderwidth        borderWidth\t  BorderWidth\n\t   -insertborderwidth  insertBorderWidth  BorderWidth\n\t   -padx\t       padX\t\t  Pad"
  manpageQuestion1: What is the primary purpose of the snit::widget class in Tcl/Tk?
  manpageQuestion2: How can you set the widgetclass for a snit::widget to match an ordinary text widget?
  manpageQuestion3: Can you explain how option names, resource names, and class names are related in Tk widgets?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nAs is easily seen, sometimes the resource and class names can be\n       inferred from the option name, but not always.\n\n   WHAT ARE THE RESOURCE AND CLASS NAMES FOR MY MEGAWIDGET'S OPTIONS?\n       For options implicitly delegated to a component using delegate option\n       *, the resource and class names will be exactly those defined by the\n       component.  The configure method returns these names, along with the\n       option's default and current values:\n\n       % snit::widget mytext {\n\t   delegate option * to text\n\n\t   constructor {args} {\n\t       install text using text .text\n\t       # ...\n\t   }\n\n\t   # ...\n       }\n       ::mytext\n       % mytext .text\n       % .text configure -padx\n       -padx padX Pad 1 1\n       %\n\n\n       For all other options (whether locally defined or explicitly\n       delegated), the resource and class names can be defined explicitly, or\n       they can be allowed to have default values.\n\n       By default, the resource name is just the option name minus the hyphen;\n       the the class name is just the option name with an initial capital\n       letter.\tFor example, suppose we explicitly delegate \"-padx\":\n\n       % snit::widget mytext {\n\t   option -myvalue 5\n\n\t   delegate option -padx to text\n\t   delegate option * to text\n\n\t   constructor {args} {\n\t       install text using text .text\n\t       # ...\n\t   }\n\n\t   # ...\n       }\n       ::mytext\n       % mytext .text\n       % .text configure -myvalue\n       -myvalue myvalue Myvalue 5 5\n       % .text configure -padx\n       -padx padx Padx 1 1\n       %"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you determine the resource and class names for a specific option in a custom widget using snit?
  manpageQuestion3: Can you provide an example of explicitly defining resource and class names for a delegated option in a snit widget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHere the resource and class names are chosen using the default rules.\n       Often these rules are sufficient, but in the case of \"-padx\" we'd most\n       likely prefer that the option's resource and class names are the same\n       as for the built-in Tk widgets.\tThis is easily done:\n\n       % snit::widget mytext {\n\t   delegate option {-padx padX Pad} to text\n\n\t   # ...\n       }\n       ::mytext\n       % mytext .text\n       % .text configure -padx\n       -padx padX Pad 1 1\n       %\n\n\n   HOW DOES SNIT INITIALIZE MY MEGAWIDGET'S LOCALLY-DEFINED OPTIONS?\n       The option database is queried for each of the megawidget's locally-\n       defined options, using the option's resource and class name.  If the\n       result isn't \"\", then it replaces the default value given in widget\n       definition.  In either case, the default can be overridden by the\n       caller.\tFor example,\n\n       option add *Mywidget.texture pebbled\n\n       snit::widget mywidget {\n\t   option -texture smooth\n\t   # ...\n       }\n\n       mywidget .mywidget -texture greasy"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you configure a custom option in a megawidget using the snit::widget command?
  manpageQuestion3: Can you provide an example of how to override the default value of a locally-defined option in a snit::widget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHere, -texture would normally default to \"smooth\", but because of the\n       entry added to the option database it defaults to \"pebbled\".  However,\n       the caller has explicitly overridden the default, and so the new widget\n       will be \"greasy\".\n\n   HOW DOES SNIT INITIALIZE DELEGATED OPTIONS?\n       That depends on whether the options are delegated to the hull, or to\n       some other component.\n\n   HOW DOES SNIT INITIALIZE OPTIONS DELEGATED TO THE HULL?\n       A snit::widget's hull is a widget, and given that its class has been\n       set it is expected to query the option database for itself.  The only\n       exception concerns options that are delegated to it with a different\n       name.  Consider the following code:\n\n       option add *Mywidget.borderWidth 5\n       option add *Mywidget.relief sunken\n       option add *Mywidget.hullbackground red\n       option add *Mywidget.background green\n\n       snit::widget mywidget {\n\t   delegate option -borderwidth to hull\n\t   delegate option -hullbackground to hull as -background\n\t   delegate option * to hull\n\t   # ...\n       }\n\n       mywidget .mywidget\n\n       set A [.mywidget cget -relief]\n       set B [.mywidget cget -hullbackground]\n       set C [.mywidget cget -background]\n       set D [.mywidget cget -borderwidth]"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How does snit initialize options delegated to the hull according to the manpage?
  manpageQuestion3: Can you provide an example of how snit delegates options to the hull with a different name?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThe question is, what are the values of variables A, B, C and D?\n\n       The value of A is \"sunken\".  The hull is a Tk frame which has been\n       given the widget class Mywidget; it will automatically query the option\n       database and pick up this value.  Since the -relief option is\n       implicitly delegated to the hull, Snit takes no action.\n\n       The value of B is \"red\".  The hull will automatically pick up the value\n       \"green\" for its -background option, just as it picked up the -relief\n       value.  However, Snit knows that -hullbackground is mapped to the\n       hull's -background option; hence, it queries the option database for\n       -hullbackground and gets \"red\" and updates the hull accordingly.\n\n       The value of C is also \"red\", because -background is implicitly\n       delegated to the hull; thus, retrieving it is the same as retrieving\n       -hullbackground.  Note that this case is unusual; the -background\n       option should probably have been excluded using the delegate\n       statement's except clause, or (more likely) delegated to some other\n       component.\n\n       The value of D is \"5\", but not for the reason you think.  Note that as\n       it is defined above, the resource name for -borderwidth defaults to\n       borderwidth, whereas the option database entry is borderWidth, in\n       accordance with the standard Tk naming for this option.\tAs with\n       -relief, the hull picks up its own -borderwidth option before Snit does\n       anything.  Because the option is delegated under its own name, Snit\n       assumes that the correct thing has happened, and doesn't worry about it\n       any further.  To avoid confusion, the -borderwidth option should have\n       been delegated like this:\n\n\t   delegate option {-borderwidth borderWidth BorderWidth} to hull"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How does Snit determine the value of variable B in the given example?
  manpageQuestion3: What is the correct way to delegate the -borderwidth option in Snit according to the manpage?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nFor snit::widgetadaptors, the case is somewhat altered.\tWidget\n       adaptors retain the widget class of their hull, and the hull is not\n       created automatically by Snit.  Instead, the snit::widgetadaptor must\n       call installhull in its constructor.  The normal way to do this is as\n       follows:\n\n       snit::widgetadaptor mywidget {\n\t   # ...\n\t   constructor {args} {\n\t       # ...\n\t       installhull using text -foreground white\n\t       # ...\n\t   }\n\t   # ...\n       }\n\n\n       In this case, the installhull command will create the hull using a\n       command like this:\n\n\t   set hull [text $win -foreground white]\n\n\n       The hull is a text widget, so its widget class is Text.\tJust as with\n       snit::widget hulls, Snit assumes that it will pick up all of its normal\n       option values automatically, without help from Snit.  Options delegated\n       from a different name are initialized from the option database in the\n       same way as described above.\n\n       In earlier versions of Snit, snit::widgetadaptors were expected to call\n       installhull like this:\n\n\t   installhull [text $win -foreground white]"
  manpageQuestion1: What is the primary purpose of the snit::widgetadaptor in Tcl/Tk?
  manpageQuestion2: How would you use snit::widgetadaptor to create a text widget with specific options in its constructor?
  manpageQuestion3: What is the difference between the old and new ways of calling installhull for snit::widgetadaptors?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThis form still works--but Snit will not query the option database as\n       described above.\n\n   HOW DOES SNIT INITIALIZE OPTIONS DELEGATED TO OTHER COMPONENTS?\n       For hull components, Snit assumes that Tk will do most of the work\n       automatically.  Non-hull components are somewhat more complicated,\n       because they are matched against the option database twice.\n\n       A component widget remains a widget still, and is therefore initialized\n       from the option database in the usual way.  A text widget remains a\n       text widget whether it is a component of a megawidget or not, and will\n       be created as such.\n\n       But then, the option database is queried for all options delegated to\n       the component, and the component is initialized accordingly--provided\n       that the install command is used to create it.\n\n       Before option database support was added to Snit, the usual way to\n       create a component was to simply create it in the constructor and\n       assign its command name to the component variable:\n\n       snit::widget mywidget {\n\t   delegate option -background to myComp\n\n\t   constructor {args} {\n\t       set myComp [text $win.text -foreground black]\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How does Snit handle option delegation for non-hull components according to the manpage?
  manpageQuestion3: Can you provide an example of Snit code that delegates the -background option to a component widget and initializes it as a text widget?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nThe drawback of this method is that Snit has no opportunity to\n       initialize the component properly.  Hence, the following approach is\n       now used:\n\n       snit::widget mywidget {\n\t   delegate option -background to myComp\n\n\t   constructor {args} {\n\t       install myComp using text $win.text -foreground black\n\t   }\n       }\n\n\n       The install command does the following:\n\n       •      Builds a list of the options explicitly included in the install\n\t      command--in this case, -foreground.\n\n       •      Queries the option database for all options delegated explicitly\n\t      to the named component.\n\n       •      Creates the component using the specified command, after\n\t      inserting into it a list of options and values read from the\n\t      option database.\tThus, the explicitly included options (like\n\t      -foreground) will override anything read from the option\n\t      database.\n\n       •      If the widget definition implicitly delegated options to the\n\t      component using delegate option *, then Snit calls the newly\n\t      created component's configure method to receive a list of all of\n\t      the component's options.\tFrom this Snit builds a list of\n\t      options implicitly delegated to the component which were not\n\t      explicitly included in the install command.  For all such\n\t      options, Snit queries the option database and configures the\n\t      component accordingly.\n\n       You don't really need to know all of this; just use install to install\n       your components, and Snit will try to do the right thing.\n\n   WHAT HAPPENS IF I INSTALL A NON-WIDGET AS A COMPONENT OF WIDGET?\n       A snit::type never queries the option database.\tHowever, a\n       snit::widget can have non-widget components.  And if options are\n       delegated to those components, and if the install command is used to\n       install those components, then they will be initialized from the option\n       database just as widget components are.\n\n       However, when used within a megawidget, install assumes that the\n       created component uses a reasonably standard widget-like creation\n       syntax.\tIf it doesn't, don't use install.\n\nENSEMBLE COMMANDS\n   WHAT IS AN ENSEMBLE COMMAND?\n       An ensemble command is a command with subcommands.  Snit objects are\n       all ensemble commands; however, the term more usually refers to\n       commands like the standard Tcl commands string, file, and clock.  In a\n       sense, these are singleton objects--there's only one instance of them.\n\n   HOW CAN I CREATE AN ENSEMBLE COMMAND USING SNIT?\n       There are two ways--as a snit::type, or as an instance of a snit::type.\n\n   HOW CAN I CREATE AN ENSEMBLE COMMAND USING AN INSTANCE OF A SNIT::TYPE?\n       Define a type whose INSTANCE METHODS are the subcommands of your\n       ensemble command.  Then, create an instance of the type with the\n       desired name.\n\n       For example, the following code uses DELEGATION to create a work-alike\n       for the standard string command:\n       snit::type ::mynamespace::mystringtype {\n\t   delegate method * to stringhandler\n\n\t   constructor {} {\n\t       set stringhandler string\n\t   }\n       }\n\n       ::mynamespace::mystringtype mystring\n\n       We create the type in a namespace, so that the type command is hidden;\n       then we create a single instance with the desired name-- mystring, in\n       this case.\n\n       This method has two drawbacks.  First, it leaves the type command\n       floating about.\tMore seriously, your shiny new ensemble command will\n       have info and destroy subcommands that you probably have no use for.\n       But read on.\n\n   HOW CAN I CREATE AN ENSEMBLE COMMAND USING A SNIT::TYPE?\n       Define a type whose TYPE METHODS are the subcommands of your ensemble\n       command.\n\n       For example, the following code uses DELEGATION to create a work-alike\n       for the standard string command:\n       snit::type mystring {\n\t   delegate typemethod * to stringhandler\n\n\t   typeconstructor {\n\t       set stringhandler string\n\t   }\n       }\n\n       Now the type command itself is your ensemble command.\n\n       This method has only one drawback, and though it's major, it's also\n       surmountable.  Your new ensemble command will have create, info and\n       destroy subcommands you don't want.  And worse yet, since the create\n       method can be implicit, users of your command will accidentally be\n       creating instances of your mystring type if they should mispell one of\n       the subcommands.  The command will succeed--the first time--but won't\n       do what's wanted.  This is very bad.\n\n       The work around is to set some PRAGMAS, as shown here:\n       snit::type mystring {\n\t   pragma -hastypeinfo\t  no\n\t   pragma -hastypedestroy no\n\t   pragma -hasinstances   no\n\n\t   delegate typemethod * to stringhandler\n\n\t   typeconstructor {\n\t       set stringhandler string\n\t   }\n       }\n\n       Here we've used the pragma statement to tell Snit that we don't want\n       the info typemethod or the destroy typemethod, and that our type has no\n       instances; this eliminates the create typemethod and all related code.\n       As a result, our ensemble command will be well-behaved, with no\n       unexpected subcommands.\n\nPRAGMAS\n   WHAT IS A PRAGMA?\n       A pragma is an option you can set in your type definitions that affects\n       how the type is defined and how it works once it is defined.\n\n   HOW DO I SET A PRAGMA?\n       Use the pragma statement.  Each pragma is an option with a value; each\n       time you use the pragma statement you can set one or more of them.\n\n   HOW CAN I GET RID OF THE  INFO\" TYPE METHOD?\"\n       Set the -hastypeinfo pragma to no:\n       snit::type dog {\n\t   pragma -hastypeinfo no\n\t   # ...\n       }\n\n       Snit will refrain from defining the info type method.\n\n   HOW CAN I GET RID OF THE  DESTROY\" TYPE METHOD?\"\n       Set the -hastypedestroy pragma to no:\n       snit::type dog {\n\t   pragma -hastypedestroy no\n\t   # ...\n       }\n\n       Snit will refrain from defining the destroy type method.\n\n   HOW CAN I GET RID OF THE  CREATE\" TYPE METHOD?\"\n       Set the -hasinstances pragma to no:\n       snit::type dog {\n\t   pragma -hasinstances no\n\t   # ...\n       }\n\n       Snit will refrain from defining the create type method; if you call the\n       type command with an unknown method name, you'll get an error instead\n       of a new instance of the type.\n\n       This is useful if you wish to use a snit::type to define an ensemble\n       command rather than a type with instances.\n\n       Pragmas -hastypemethods and -hasinstances cannot both be false (or\n       there'd be nothing left).\n\n   HOW CAN I GET RID OF TYPE METHODS ALTOGETHER?\n       Normal Tk widget type commands don't have subcommands; all they do is\n       create widgets--in Snit terms, the type command calls the create type\n       method directly.  To get the same behavior from Snit, set the\n       -hastypemethods pragma to no:\n       snit::type dog {\n\t   pragma -hastypemethods no\n\t   #...\n       }\n\n       # Creates ::spot\n       dog spot\n\n       # Tries to create an instance called ::create\n       dog create spot\n\n       Pragmas -hastypemethods and -hasinstances cannot both be false (or\n       there'd be nothing left).\n\n   WHY CAN'T I CREATE AN OBJECT THAT REPLACES AN OLD OBJECT WITH THE SAME\n       NAME?\n       Up until Snit 0.95, you could use any name for an instance of a\n       snit::type, even if the name was already in use by some other object or\n       command.  You could do the following, for example:\n       snit::type dog { ... }\n\n       dog proc\n\n       You now have a new dog named \"proc\", which is probably not something\n       that you really wanted to do.  As a result, Snit now throws an error if\n       your chosen instance name names an existing command.  To restore the\n       old behavior, set the -canreplace pragma to yes:\n       snit::type dog {\n\t   pragma -canreplace yes\n\t   # ...\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you create an ensemble command using a snit::type and prevent it from having the 'create' subcommand?
  manpageQuestion3: What is the process for defining a snit::type to act as an ensemble command without including the 'info' or 'destroy' subcommands?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW CAN I MAKE MY SIMPLE TYPE RUN FASTER?\n       In Snit 1.x, you can set the -simpledispatch pragma to yes.\n\n       Snit 1.x method dispatch is both flexible and fast, but the flexibility\n       comes with a price.  If your type doesn't require the flexibility, the\n       -simpledispatch pragma allows you to substitute a simpler dispatch\n       mechanism that runs quite a bit faster.\tThe limitations are these:\n\n       •      Methods cannot be delegated.\n\n       •      uplevel and upvar do not work as expected: the caller's scope is\n\t      two levels up rather than one.\n\n       •      The option-handling methods (cget, configure, and configurelist)\n\t      are very slightly slower.\n\n       In Snit 2.2, the -simpledispatch macro is obsolete, and ignored; all\n       Snit 2.2 method dispatch is faster than Snit 1.x's -simpledispatch.\n\nMACROS\n   WHAT IS A MACRO?\n       A Snit macro is nothing more than a Tcl proc that's defined in the Tcl\n       interpreter used to compile Snit type definitions.\n\n   WHAT ARE MACROS GOOD FOR?\n       You can use Snit macros to define new type definition syntax, and to\n       support conditional compilation.\n\n   HOW DO I DO CONDITIONAL COMPILATION?\n       Suppose you want your type to use a fast C extension if it's available;\n       otherwise, you'll fallback to a slower Tcl implementation.  You want to\n       define one set of methods in the first case, and another set in the\n       second case.  But how can your type definition know whether the fast C\n       extension is available or not?\n\n       It's easily done.  Outside of any type definition, define a macro that\n       returns 1 if the extension is available, and 0 otherwise:\n       if {$gotFastExtension} {\n\t   snit::macro fastcode {} {return 1}\n       } else {\n\t   snit::macro fastcode {} {return 0}\n       }\n\n       Then, use your macro in your type definition:\n       snit::type dog {\n\n\t   if {[fastcode]} {\n\t       # Fast methods\n\t       method bark {} {...}\n\t       method wagtail {} {...}\n\t   } else {\n\t       # Slow methods\n\t       method bark {} {...}\n\t       method wagtail {} {...}\n\t   }\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you optimize the performance of a simple type in Snit 1.x?
  manpageQuestion3: Can you provide an example of using macros for conditional compilation in Snit type definitions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nHOW DO I DEFINE NEW TYPE DEFINITION SYNTAX?\n       Use a macro.  For example, your snit::widget's -background option\n       should be propagated to a number of component widgets.  You could\n       implement that like this:\n       snit::widget mywidget {\n\t   option -background -default white -configuremethod PropagateBackground\n\n\t   method PropagateBackground {option value} {\n\t       $comp1 configure $option $value\n\t       $comp2 configure $option $value\n\t       $comp3 configure $option $value\n\t   }\n       }\n\n       For one option, this is fine; if you've got a number of options, it\n       becomes tedious and error prone.  So package it as a macro:\n       snit::macro propagate {option \"to\" components} {\n\t   option $option -configuremethod Propagate$option\n\n\t   set body \"\\n\"\n\n\t   foreach comp $components {\n\t       append body \"\\$$comp configure $option \\$value\\n\"\n\t   }\n\n\t   method Propagate$option {option value} $body\n       }\n\n       Then you can use it like this:\n       snit::widget mywidget {\n\t   option -background default -white\n\t   option -foreground default -black\n\n\t   propagate -background to {comp1 comp2 comp3}\n\t   propagate -foreground to {comp1 comp2 comp3}\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can you define a macro in snit to propagate multiple options to a set of components?
  manpageQuestion3: Can you provide an example of using the 'propagate' macro to propagate the -background option to multiple components?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nARE THERE ARE RESTRICTIONS ON MACRO NAMES?\n       Yes, there are.\tYou can't redefine any standard Tcl commands or Snit\n       type definition statements.  You can use any other command name,\n       including the name of a previously defined macro.\n\n       If you're using Snit macros in your application, go ahead and name them\n       in the global namespace, as shown above.  But if you're using them to\n       define types or widgets for use by others, you should define your\n       macros in the same namespace as your types or widgets.  That way, they\n       won't conflict with other people's macros.\n\n       If my fancy snit::widget is called ::mylib::mywidget, for example, then\n       I should define my propagate macro as ::mylib::propagate:\n       snit::macro mylib::propagate {option \"to\" components} { ... }\n\n       snit::widget ::mylib::mywidget {\n\t   option -background default -white\n\t   option -foreground default -black\n\n\t   mylib::propagate -background to {comp1 comp2 comp3}\n\t   mylib::propagate -foreground to {comp1 comp2 comp3}\n       }"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How would you define a macro named propagate in the namespace mylib for use with a Snit widget called ::mylib::mywidget?
  manpageQuestion3: What is the recommended practice for naming macros when they are used to define types or widgets in Snit?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `snitfaq`.\n\n\n\nManpage text:\n\nBUGS, IDEAS, FEEDBACK\n       This document, and the package it describes, will undoubtedly contain\n       bugs and other problems.  Please report such in the category snit of\n       the Tcllib SF Trackers\n       [http://sourceforge.net/tracker/?group_id=12883].  Please also report\n       any ideas for enhancements you may have for either package and/or\n       documentation.\n\nKEYWORDS\n       BWidget, C++, Incr Tcl, adaptors, class, mega widget, object, object\n       oriented, widget, widget adaptors\n\nCATEGORY\n       Programming tools\n\nCOPYRIGHT\n       Copyright (c) 2003-2006, by William H. Duquette\n\n\nsnit\t\t\t\t      2.2\t\t\t    snitfaq(n)"
  manpageQuestion1: What is the primary purpose of the snitfaq resource?
  manpageQuestion2: How can users contribute to improving the snitfaq documentation or functionality?
  manpageQuestion3: What are the key categories or keywords associated with the snitfaq resource?

