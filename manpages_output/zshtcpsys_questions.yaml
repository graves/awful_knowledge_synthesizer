- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nZSHTCPSYS(1)\t\t    General Commands Manual\t\t  ZSHTCPSYS(1)\n\nNAME\n       zshtcpsys - zsh tcp system\n\nDESCRIPTION\n       A module zsh/net/tcp is provided to provide network I/O over TCP/IP\n       from within the shell; see its description in zshmodules(1).  This\n       manual page describes a function suite based on the module.  If the\n       module is installed, the functions are usually installed at the same\n       time, in which case they will be available for autoloading in the\n       default function search path.  In addition to the zsh/net/tcp module,\n       the zsh/zselect module is used to implement timeouts on read\n       operations.  For troubleshooting tips, consult the corresponding advice\n       for the zftp functions described in zshzftpsys(1).\n\n       There are functions corresponding to the basic I/O operations open,\n       close, read and send, named tcp_open etc., as well as a function\n       tcp_expect for pattern match analysis of data read as input.  The\n       system makes it easy to receive data from and send data to multiple\n       named sessions at once.\tIn addition, it can be linked with the shell's\n       line editor in such a way that input data is automatically shown at the\n       terminal.  Other facilities available including logging, filtering and\n       configurable output prompts.\n\n       To use the system where it is available, it should be enough to\n       `autoload -U tcp_open' and run tcp_open as documented below to start a\n       session.  The tcp_open function will autoload the remaining functions.\n\nTCP USER FUNCTIONS\n   Basic I/O\n       tcp_open [ -qz ] host port [ sess ]\n       tcp_open [ -qz ] [ -s sess | -l sess[,...] ] ...\n       tcp_open [ -qz ] [ -a fd | -f fd ] [ sess ]\n\t      Open a new session.  In the first and simplest form, open a TCP\n\t      connection to host host at port port; numeric and symbolic forms\n\t      are understood for both.\n\n\t      If sess is given, this becomes the name of the session which can\n\t      be used to refer to multiple different TCP connections.  If sess\n\t      is not given, the function will invent a numeric name value\n\t      (note this is not the same as the file descriptor to which the\n\t      session is attached).  It is recommended that session names not\n\t      include `funny' characters, where funny characters are not\n\t      well-defined but certainly do not include alphanumerics or\n\t      underscores, and certainly do include whitespace.\n\n\t      In the second case, one or more sessions to be opened are given\n\t      by name.\tA single session name is given after -s and a\n\t      comma-separated list after -l; both options may be repeated as\n\t      many times as necessary.\tA failure to open any session causes\n\t      tcp_open to abort.  The host and port are read from the file\n\t      .ztcp_sessions in the same directory as the user's zsh\n\t      initialisation files, i.e. usually the home directory, but\n\t      $ZDOTDIR if that is set.\tThe file consists of lines each giving\n\t      a session name and the corresponding host and port, in that\n\t      order (note the session name comes first, not last), separated\n\t      by whitespace.\n\n\t      The third form allows passive and fake TCP connections.  If the\n\t      option -a is used, its argument is a file descriptor open for\n\t      listening for connections.  No function front-end is provided to\n\t      open such a file descriptor, but a call to `ztcp -l port' will\n\t      create one with the file descriptor stored in the parameter\n\t      $REPLY.  The listening port can be closed with `ztcp -c fd'.  A\n\t      call to `tcp_open -a fd' will block until a remote TCP\n\t      connection is made to port on the local machine.\tAt this point,\n\t      a session is created in the usual way and is largely\n\t      indistinguishable from an active connection created with one of\n\t      the first two forms.\n\n\t      If the option -f is used, its argument is a file descriptor\n\t      which is used directly as if it were a TCP session.  How well\n\t      the remainder of the TCP function system copes with this depends\n\t      on what actually underlies this file descriptor.\tA regular file\n\t      is likely to be unusable; a FIFO (pipe) of some sort will work\n\t      better, but note that it is not a good idea for two different\n\t      sessions to attempt to read from the same FIFO at once.\n\n\t      If the option -q is given with any of the three forms, tcp_open\n\t      will not print informational messages, although it will in any\n\t      case exit with an appropriate status.\n\n\t      If the line editor (zle) is in use, which is typically the case\n\t      if the shell is interactive, tcp_open installs a handler inside\n\t      zle which will check for new data at the same time as it checks\n\t      for keyboard input.  This is convenient as the shell consumes no\n\t      CPU time while waiting; the test is performed by the operating\n\t      system.  Giving the option -z to any of the forms of tcp_open\n\t      prevents the handler from being installed, so data must be read\n\t      explicitly.  Note, however, this is not necessary for executing\n\t      complete sets of send and read commands from a function, as zle\n\t      is not active at this point.  Generally speaking, the handler is\n\t      only active when the shell is waiting for input at a command\n\t      prompt or in the vared builtin.  The option has no effect if zle\n\t      is not active; `[[ -o zle]]' will test for this.\n\n\t      The first session to be opened becomes the current session and\n\t      subsequent calls to tcp_open do not change it.  The current\n\t      session is stored in the parameter $TCP_SESS; see below for more\n\t      detail about the parameters used by the system.\n\n\t      The function tcp_on_open, if defined, is called when a session\n\t      is opened.  See the description below.\n\n       tcp_close [ -qn ] [ -a | -l sess[,...] | sess ... ]\n\t      Close the named sessions, or the current session if none is\n\t      given, or all open sessions if -a is given.  The options -l and\n\t      -s are both handled for consistency with tcp_open, although the\n\t      latter is redundant.\n\n\t      If the session being closed is the current one, $TCP_SESS is\n\t      unset, leaving no current session, even if there are other\n\t      sessions still open.\n\n\t      If the session was opened with tcp_open -f, the file descriptor\n\t      is closed so long as it is in the range 0 to 9 accessible\n\t      directly from the command line.  If the option -n is given, no\n\t      attempt will be made to close file descriptors in this case.\n\t      The -n option is not used for genuine ztcp session; the file\n\t      descriptors are always closed with the session.\n\n\t      If the option -q is given, no informational messages will be\n\t      printed."
  manpageQuestion1: What is the primary purpose of the zshtcpsys tool?
  manpageQuestion2: How can you use the zshtcpsys module to establish a TCP connection to a server running on 'example.com' port 8080?
  manpageQuestion3: What command would you use to close the current TCP session using zshtcpsys?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\ntcp_read [ -bdq ] [ -t TO ] [ -T TO ]\n\t\t[ -a | -u fd[,...] | -l sess[,...] | -s sess ... ]\n\t      Perform a read operation on the current session, or on a list of\n\t      sessions if any are given with -u, -l or -s, or all open\n\t      sessions if the option -a is given.  Any of the -u, -l or -s\n\t      options may be repeated or mixed together.  The -u option\n\t      specifies a file descriptor directly (only those managed by this\n\t      system are useful), the other two specify sessions as described\n\t      for tcp_open above.\n\n\t      The function checks for new data available on all the sessions\n\t      listed.  Unless the -b option is given, it will not block\n\t      waiting for new data.  Any one line of data from any of the\n\t      available sessions will be read, stored in the parameter\n\t      $TCP_LINE, and displayed to standard output unless $TCP_SILENT\n\t      contains a non-empty string.  When printed to standard output\n\t      the string $TCP_PROMPT will be shown at the start of the line;\n\t      the default form for this includes the name of the session being\n\t      read.  See below for more information on these parameters.  In\n\t      this mode, tcp_read can be called repeatedly until it returns\n\t      status 2 which indicates all pending input from all specified\n\t      sessions has been handled.\n\n\t      With the option -b, equivalent to an infinite timeout, the\n\t      function will block until a line is available to read from one\n\t      of the specified sessions.  However, only a single line is\n\t      returned.\n\n\t      The option -d indicates that all pending input should be\n\t      drained.\tIn this case tcp_read may process multiple lines in\n\t      the manner given above; only the last is stored in $TCP_LINE,\n\t      but the complete set is stored in the array $tcp_lines.  This is\n\t      cleared at the start of each call to tcp_read.\n\n\t      The options -t and -T specify a timeout in seconds, which may be\n\t      a floating point number for increased accuracy.  With -t the\n\t      timeout is applied before each line read.  With -T, the timeout\n\t      applies to the overall operation, possibly including multiple\n\t      read operations if the option -d is present; without this\n\t      option, there is no distinction between -t and -T.\n\n\t      The function does not print informational messages, but if the\n\t      option -q is given, no error message is printed for a\n\t      non-existent session.\n\n\t      A return status of 2 indicates a timeout or no data to read.\n\t      Any other non-zero return status indicates some error condition.\n\n\t      See tcp_log for how to control where data is sent by tcp_read.\n\n       tcp_send [ -cnq ] [ -s sess | -l sess[,...] ] data ...\n       tcp_send [ -cnq ] -a data ...\n\t      Send the supplied data strings to all the specified sessions in\n\t      turn.  The underlying operation differs little from a `print -r'\n\t      to the session's file descriptor, although it attempts to\n\t      prevent the shell from dying owing to a SIGPIPE caused by an\n\t      attempt to write to a defunct session.\n\n\t      The option -c causes tcp_send to behave like cat.  It reads\n\t      lines from standard input until end of input and sends them in\n\t      turn to the specified session(s) exactly as if they were given\n\t      as data arguments to individual tcp_send commands.\n\n\t      The option -n prevents tcp_send from putting a newline at the\n\t      end of the data strings.\n\n\t      The remaining options all behave as for tcp_read.\n\n\t      The data arguments are not further processed once they have been\n\t      passed to tcp_send; they are simply passed down to print -r.\n\n\t      If the parameter $TCP_OUTPUT is a non-empty string and logging\n\t      is enabled then the data sent to each session will be echoed to\n\t      the log file(s) with $TCP_OUTPUT in front where appropriate,\n\t      much in the manner of $TCP_PROMPT.\n\n   Session Management\n       tcp_alias [ -q ] alias=sess ...\n       tcp_alias [ -q ] [ alias ... ]\n       tcp_alias -d [ -q ] alias ...\n\t      This function is not particularly well tested.\n\n\t      The first form creates an alias for a session name; alias can\n\t      then be used to refer to the existing session sess.  As many\n\t      aliases may be listed as required.\n\n\t      The second form lists any aliases specified, or all aliases if\n\t      none.\n\n\t      The third form deletes all the aliases listed.  The underlying\n\t      sessions are not affected.\n\n\t      The option -q suppresses an inconsistently chosen subset of\n\t      error messages.\n\n       tcp_log [ -asc ] [ -n | -N ] [ logfile ]\n\t      With an argument logfile, all future input from tcp_read will be\n\t      logged to the named file.  Unless -a (append) is given, this\n\t      file will first be truncated or created empty.  With no\n\t      arguments, show the current status of logging.\n\n\t      With the option -s, per-session logging is enabled.  Input from\n\t      tcp_read is output to the file logfile.sess.  As the session is\n\t      automatically discriminated by the filename, the contents are\n\t      raw (no $TCP_PROMPT).  The option  -a applies as above.\n\t      Per-session logging and logging of all data in one file are not\n\t      mutually exclusive.\n\n\t      The option -c closes all logging, both complete and per-session\n\t      logs.\n\n\t      The options -n and -N respectively turn off or restore output of\n\t      data read by tcp_read to standard output; hence `tcp_log -cn'\n\t      turns off all output by tcp_read.\n\n\t      The function is purely a convenient front end to setting the\n\t      parameters $TCP_LOG, $TCP_LOG_SESS, $TCP_SILENT, which are\n\t      described below.\n\n       tcp_rename old new\n\t      Rename session old to session new.  The old name becomes\n\t      invalid.\n\n       tcp_sess [ sess [ command [ arg ... ] ] ]\n\t      With no arguments, list all the open sessions and associated\n\t      file descriptors.  The current session is marked with a star.\n\t      For use in functions, direct access to the parameters\n\t      $tcp_by_name, $tcp_by_fd and $TCP_SESS is probably more\n\t      convenient; see below.\n\n\t      With a sess argument, set the current session to sess.  This is\n\t      equivalent to changing $TCP_SESS directly.\n\n\t      With additional arguments, temporarily set the current session\n\t      while executing `command arg ...'.  command is re-evaluated so\n\t      as to expand aliases etc., but the remaining args are passed\n\t      through as that appear to tcp_sess.  The original session is\n\t      restored when tcp_sess exits.\n\n   Advanced I/O\n       tcp_command send-option ... send-argument ...\n\t      This is a convenient front-end to tcp_send.  All arguments are\n\t      passed to tcp_send, then the function pauses waiting for data.\n\t      While data is arriving at least every $TCP_TIMEOUT (default 0.3)\n\t      seconds, data is handled and printed out according to the\n\t      current settings.  Status 0 is always returned.\n\n\t      This is generally only useful for interactive use, to prevent\n\t      the display becoming fragmented by output returned from the\n\t      connection.  Within a programme or function it is generally\n\t      better to handle reading data by a more explicit method."
  manpageQuestion1: What is the primary purpose of the `zshtcpsys` resource?
  manpageQuestion2: How would you use `tcp_read` to read data from all open sessions without blocking?
  manpageQuestion3: Can you provide an example of using `tcp_send` to send the string 'Hello, World!' to a specific session with the -n flag to prevent adding a newline?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\ntcp_expect [ -q ] [ -p var | -P var ] [ -t TO | -T TO ]\n\t\t  [ -a | -s sess | -l sess[,...] ] pattern ...\n\t      Wait for input matching any of the given patterns from any of\n\t      the specified sessions.  Input is ignored until an input line\n\t      matches one of the given patterns; at this point status zero is\n\t      returned, the matching line is stored in $TCP_LINE, and the full\n\t      set of lines read during the call to tcp_expect is stored in the\n\t      array $tcp_expect_lines.\n\n\t      Sessions are specified in the same way as tcp_read: the default\n\t      is to use the current session, otherwise the sessions specified\n\t      by -a, -s, or -l are used.\n\n\t      Each pattern is a standard zsh extended-globbing pattern; note\n\t      that it needs to be quoted to avoid it being expanded\n\t      immediately by filename generation.  It must match the full\n\t      line, so to match a substring there must be a `*' at the start\n\t      and end.\tThe line matched against includes the $TCP_PROMPT\n\t      added by tcp_read.  It is possible to include the globbing flags\n\t      `#b' or `#m' in the patterns to make backreferences available in\n\t      the parameters $MATCH, $match, etc., as described in the base\n\t      zsh documentation on pattern matching."
  manpageQuestion1: What is the primary purpose of the tcp_expect command in the context of interactive shell scripting?
  manpageQuestion2: How can you use tcp_expect to wait for a line containing the substring 'password' in the current session?
  manpageQuestion3: Can you provide an example of using tcp_expect with the -s option to monitor a specific session and match lines that end with 'logout'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nUnlike tcp_read, the default behaviour of tcp_expect is to block\n\t      indefinitely until the required input is found.  This can be\n\t      modified by specifying a timeout with -t or -T; these function\n\t      as in tcp_read, specifying a per-read or overall timeout,\n\t      respectively, in seconds, as an integer or floating-point\n\t      number.  As tcp_read, the function returns status 2 if a timeout\n\t      occurs.\n\n\t      The function returns as soon as any one of the patterns given\n\t      match.  If the caller needs to know which of the patterns\n\t      matched, the option -p var can be used; on return, $var is set\n\t      to the number of the pattern using ordinary zsh indexing, i.e.\n\t      the first is 1, and so on.  Note the absence of a `$' in front\n\t      of var.  To avoid clashes, the parameter cannot begin with\n\t      `_expect'.  The index -1 is used if there is a timeout and 0 if\n\t      there is no match.\n\n\t      The option -P var works similarly to -p, but instead of\n\t      numerical indexes the regular arguments must begin with a prefix\n\t      followed by a colon: that prefix is then used as a tag to which\n\t      var is set when the argument matches.  The tag timeout is used\n\t      if there is a timeout and the empty string if there is no match.\n\t      Note it is acceptable for different arguments to start with the\n\t      same prefix if the matches do not need to be distinguished."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you set a timeout of 5 seconds for the tcp_expect function in zshtcpsys?
  manpageQuestion3: Can you explain how to use the -p and -P options in zshtcpsys to track which pattern matches or tags a matched argument?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThe option -q is passed directly down to tcp_read.\n\n\t      As all input is done via tcp_read, all the usual rules about\n\t      output of lines read apply.  One exception is that the parameter\n\t      $tcp_lines will only reflect the line actually matched by\n\t      tcp_expect; use $tcp_expect_lines for the full set of lines read\n\t      during the function call.\n\n       tcp_proxy\n\t      This is a simple-minded function to accept a TCP connection and\n\t      execute a command with I/O redirected to the connection.\n\t      Extreme caution should be taken as there is no security\n\t      whatsoever and this can leave your computer open to the world.\n\t      Ideally, it should only be used behind a firewall.\n\n\t      The first argument is a TCP port on which the function will\n\t      listen.\n\n\t      The remaining arguments give a command and its arguments to\n\t      execute with standard input, standard output and standard error\n\t      redirected to the file descriptor on which the TCP session has\n\t      been accepted.  If no command is given, a new zsh is started.\n\t      This gives everyone on your network direct access to your\n\t      account, which in many cases will be a bad thing."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you use the tcp_proxy function to set up a TCP server that executes a command with input/output redirected to a connection?
  manpageQuestion3: What is the cautionary note associated with using the tcp_proxy function, and how does it affect security?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThe command is run in the background, so tcp_proxy can then\n\t      accept new connections.  It continues to accept new connections\n\t      until interrupted.\n\n       tcp_spam [ -ertv ] [ -a | -s sess | -l sess[,...] ] cmd [ arg ... ]\n\t      Execute `cmd [ arg ... ]' for each session in turn.  Note this\n\t      executes the command and arguments; it does not send the command\n\t      line as data unless the -t (transmit) option is given.\n\n\t      The sessions may be selected explicitly with the standard -a, -s\n\t      or -l options, or may be chosen implicitly.  If none of the\n\t      three options is given the rules are: first, if the array\n\t      $tcp_spam_list is set, this is taken as the list of sessions,\n\t      otherwise all sessions are taken.  Second, any sessions given in\n\t      the array $tcp_no_spam_list are removed from the list of\n\t      sessions.\n\n\t      Normally, any sessions added by the `-a' flag or when all\n\t      sessions are chosen implicitly are spammed in alphabetic order;\n\t      sessions given by the $tcp_spam_list array or on the command\n\t      line are spammed in the order given.  The -r flag reverses the\n\t      order however it was arrived it."
  manpageQuestion1: What is the primary purpose of the zshtcpsys tool?
  manpageQuestion2: How can you use zshtcpsys to execute a command for all sessions in the system, excluding those listed in $tcp_no_spam_list?
  manpageQuestion3: Can you provide an example of using zshtcpsys to spam a command in reverse order, specifying a particular session?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThe -v flag specifies that a $TCP_PROMPT will be output before\n\t      each session.  This is output after any modification to TCP_SESS\n\t      by the user-defined tcp_on_spam function described below.\n\t      (Obviously that function is able to generate its own output.)\n\n\t      If the option -e is present, the line given as `cmd [ arg ... ]'\n\t      is executed using eval, otherwise it is executed without any\n\t      further processing.\n\n       tcp_talk\n\t      This is a fairly simple-minded attempt to force input to the\n\t      line editor to go straight to the default TCP_SESS.\n\n\t      An escape string, $TCP_TALK_ESCAPE, default `:', is used to\n\t      allow access to normal shell operation.  If it is on its own at\n\t      the start of the line, or followed only by whitespace, the line\n\t      editor returns to normal operation.  Otherwise, the string and\n\t      any following whitespace are skipped and the remainder of the\n\t      line executed as shell input without any change of the line\n\t      editor's operating mode."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you use the -v flag with zshtcpsys to enable a TCP prompt before each session?
  manpageQuestion3: What is the function of the tcp_talk command in zshtcpsys and how does it handle escape sequences?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThe current implementation is somewhat deficient in terms of use\n\t      of the command history.  For this reason, many users will prefer\n\t      to use some form of alternative approach for sending data easily\n\t      to the current session.  One simple approach is to alias some\n\t      special character (such as `%') to `tcp_command --'.\n\n       tcp_wait\n\t      The sole argument is an integer or floating point number which\n\t      gives the seconds to delay.  The shell will do nothing for that\n\t      period except wait for input on all TCP sessions by calling\n\t      tcp_read -a.  This is similar to the interactive behaviour at\n\t      the command prompt when zle handlers are installed.\n\n   `One-shot' file transfer\n       tcp_point port\n       tcp_shoot host port\n\t      This pair of functions provide a simple way to transfer a file\n\t      between two hosts within the shell.  Note, however, that bulk\n\t      data transfer is currently done using cat.  tcp_point reads any\n\t      data arriving at port and sends it to standard output; tcp_shoot\n\t      connects to port on host and sends its standard input.  Any\n\t      unused port may be used; the standard mechanism for picking a\n\t      port is to think of a random four-digit number above 1024 until\n\t      one works."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you use tcp_point and tcp_shoot to transfer a file between two hosts?
  manpageQuestion3: What is the recommended method for handling command history in zshtcpsys?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nTo transfer a file from host woodcock to host springes, on\n\t      springes:\n\n\t\t     tcp_point 8091 >output_file\n\n\t      and on woodcock:\n\n\t\t     tcp_shoot springes 8091 <input_file\n\n\t      As these two functions do not require tcp_open to set up a TCP\n\t      connection first, they may need to be autoloaded separately.\n\nTCP USER-DEFINED FUNCTIONS\n       Certain functions, if defined by the user, will be called by the\n       function system in certain contexts.  This facility depends on the\n       module zsh/parameter, which is usually available in interactive shells\n       as the completion system depends on it.\tNone of the functions need be\n       defined; they simply provide convenient hooks when necessary.\n\n       Typically, these are called after the requested action has been taken,\n       so that the various parameters will reflect the new state.\n\n       tcp_on_alias alias fd\n\t      When an alias is defined, this function will be called with two\n\t      arguments: the name of the alias, and the file descriptor of the\n\t      corresponding session."
  manpageQuestion1: What is the primary purpose of the `zshtcpsys` resource?
  manpageQuestion2: How would you use `tcp_point` and `tcp_shoot` to transfer a file between two hosts using TCP?
  manpageQuestion3: What is the function of `tcp_on_alias` in the context of TCP user-defined functions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\ntcp_on_awol sess fd\n\t      If the function tcp_fd_handler is handling input from the line\n\t      editor and detects that the file descriptor is no longer\n\t      reusable, by default it removes it from the list of file\n\t      descriptors handled by this method and prints a message.\tIf the\n\t      function tcp_on_awol is defined it is called immediately before\n\t      this point.  It may return status 100, which indicates that the\n\t      normal handling should still be performed; any other return\n\t      status indicates that no further action should be taken and the\n\t      tcp_fd_handler should return immediately with the given status.\n\t      Typically the action of tcp_on_awol will be to close the\n\t      session.\n\n\t      The variable TCP_INVALIDATE_ZLE will be a non-empty string if it\n\t      is necessary to invalidate the line editor display using `zle\n\t      -I' before printing output from the function.\n\n\t      (`AWOL' is military jargon for `absent without leave' or some\n\t      variation.  It has no pre-existing technical meaning known to\n\t      the author.)"
  manpageQuestion1: What is the primary purpose of the `zshtcpsys' resource?
  manpageQuestion2: How would you use the `tcp_on_awol' function to handle a file descriptor that is no longer reusable?
  manpageQuestion3: Can you provide an example of using the `TCP_INVALIDATE_ZLE' variable to invalidate the line editor display before printing output from `tcp_on_awol'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\ntcp_on_close sess fd\n\t      This is called with the name of a session being closed and the\n\t      file descriptor which corresponded to that session.  Both will\n\t      be invalid by the time the function is called.\n\n       tcp_on_open sess fd\n\t      This is called after a new session has been defined with the\n\t      session name and file descriptor as arguments.  If it returns a\n\t      non-zero status, opening the session is assumed to fail and the\n\t      session is closed again; however, tcp_open will continue to\n\t      attempt to open any remaining sessions given on the command\n\t      line.\n\n       tcp_on_rename oldsess fd newsess\n\t      This is called after a session has been renamed with the three\n\t      arguments old session name, file descriptor, new session name.\n\n       tcp_on_spam sess command ...\n\t      This is called once for each session spammed, just before a\n\t      command is executed for a session by tcp_spam.  The arguments\n\t      are the session name followed by the command list to be\n\t      executed.  If tcp_spam was called with the option -t, the first\n\t      command will be tcp_send."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How would you use the tcp_on_close function to handle a session closure event?
  manpageQuestion3: Can you provide an example of using the tcp_on_rename function to rename a session and update its file descriptor?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThis function is called after $TCP_SESS is set to reflect the\n\t      session to be spammed, but before any use of it is made.\tHence\n\t      it is possible to alter the value of $TCP_SESS within this\n\t      function.  For example, the session arguments to tcp_spam could\n\t      include extra information to be stripped off and processed in\n\t      tcp_on_spam.\n\n\t      If the function sets the parameter $REPLY to `done', the command\n\t      line is not executed; in addition, no prompt is printed for the\n\t      -v option to tcp_spam.\n\n       tcp_on_unalias alias fd\n\t      This is called with the name of an alias and the corresponding\n\t      session's file descriptor after an alias has been deleted.\n\nTCP UTILITY FUNCTIONS\n       The following functions are used by the TCP function system but will\n       rarely if ever need to be called directly.\n\n       tcp_fd_handler\n\t      This is the function installed by tcp_open for handling input\n\t      from within the line editor, if that is required.  It is in the\n\t      format documented for the builtin `zle -F' in zshzle(1) ."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How would you use the tcp_on_unalias function to handle an alias deletion event?
  manpageQuestion3: Can you explain how the tcp_fd_handler function is used within the TCP utility system?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nWhile active, the function sets the parameter TCP_HANDLER_ACTIVE\n\t      to 1.  This allows shell code called internally (for example, by\n\t      setting tcp_on_read) to tell if is being called when the shell\n\t      is otherwise idle at the editor prompt.\n\n       tcp_output [ -q ] -P prompt -F fd -S sess\n\t      This function is used for both logging and handling output to\n\t      standard output, from within tcp_read and (if $TCP_OUTPUT is\n\t      set) tcp_send.\n\n\t      The prompt to use is specified by -P; the default is the empty\n\t      string.  It can contain:\n\t      %c     Expands to 1 if the session is the current session,\n\t\t     otherwise 0.  Used with ternary expressions such as\n\t\t     `%(c.-.+)' to output `+' for the current session and `-'\n\t\t     otherwise.\n\n\t      %f     Replaced by the session's file descriptor.\n\n\t      %s     Replaced by the session name.\n\n\t      %%     Replaced by a single `%'.\n\n\t      The option -q suppresses output to standard output, but not to\n\t      any log files which are configured."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you use the tcp_output function to set a custom prompt that includes session-specific information?
  manpageQuestion3: What is the effect of using the -q option with the tcp_output function?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThe -S and -F options are used to pass in the session name and\n\t      file descriptor for possible replacement in the prompt.\n\nTCP USER PARAMETERS\n       Parameters follow the usual convention that uppercase is used for\n       scalars and integers, while lowercase is used for normal and\n       associative array.  It is always safe for user code to read these\n       parameters.  Some parameters may also be set; these are noted\n       explicitly.  Others are included in this group as they are set by the\n       function system for the user's benefit, i.e. setting them is typically\n       not useful but is benign.\n\n       It is often also useful to make settable parameters local to a\n       function.  For example, `local TCP_SILENT=1' specifies that data read\n       during the function call will not be printed to standard output,\n       regardless of the setting outside the function.\tLikewise, `local\n       TCP_SESS=sess' sets a session for the duration of a function, and\n       `local TCP_PROMPT=' specifies that no prompt is used for input during\n       the function."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you set a local parameter in a function to control the prompt behavior using zshtcpsys?
  manpageQuestion3: What is the function of the -S and -F options in zshtcpsys, and how are they used in the context of session management?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\ntcp_expect_lines\n\t      Array.  The set of lines read during the last call to\n\t      tcp_expect, including the last ($TCP_LINE).\n\n       tcp_filter\n\t      Array. May be set directly.  A set of extended globbing patterns\n\t      which, if matched in tcp_output, will cause the line not to be\n\t      printed to standard output.  The patterns should be defined as\n\t      described for the arguments to tcp_expect.  Output of line to\n\t      log files is not affected.\n\n       TCP_HANDLER_ACTIVE\n\t      Scalar.  Set to 1 within tcp_fd_handler to indicate to functions\n\t      called recursively that they have been called during an editor\n\t      session.\tOtherwise unset.\n\n       TCP_LINE\n\t      The last line read by tcp_read, and hence also tcp_expect.\n\n       TCP_LINE_FD\n\t      The file descriptor from which $TCP_LINE was read.\n\t      ${tcp_by_fd[$TCP_LINE_FD]} will give the corresponding session\n\t      name.\n\n       tcp_lines\n\t      Array. The set of lines read during the last call to tcp_read,\n\t      including the last ($TCP_LINE)."
  manpageQuestion1: What is the primary purpose of the tcp_* variables and functions in the macOS resource `zshtcpsys`?
  manpageQuestion2: How can you use the tcp_filter array to exclude specific lines from being printed to standard output?
  manpageQuestion3: What is the function and usage of the TCP_HANDLER_ACTIVE scalar variable in the context of editor sessions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nTCP_LOG\n\t      May be set directly, although it is also controlled by tcp_log.\n\t      The name of a file to which output from all sessions will be\n\t      sent.  The output is proceeded by the usual $TCP_PROMPT.\tIf it\n\t      is not an absolute path name, it will follow the user's current\n\t      directory.\n\n       TCP_LOG_SESS\n\t      May be set directly, although it is also controlled by tcp_log.\n\t      The prefix for a set of files to which output from each session\n\t      separately will be sent; the full filename is\n\t      ${TCP_LOG_SESS}.sess.  Output to each file is raw; no prompt is\n\t      added.  If it is not an absolute path name, it will follow the\n\t      user's current directory.\n\n       tcp_no_spam_list\n\t      Array.  May be set directly.  See tcp_spam for how this is used.\n\n       TCP_OUTPUT\n\t      May be set directly.  If a non-empty string, any data sent to a\n\t      session by tcp_send will be logged.  This parameter gives the\n\t      prompt to be used in a file specified by $TCP_LOG but not in a\n\t      file generated from $TCP_LOG_SESS.  The prompt string has the\n\t      same format as TCP_PROMPT and the same rules for its use apply."
  manpageQuestion1: What is the primary purpose of the TCP_LOG and TCP_LOG_SESS parameters in the context of this resource?
  manpageQuestion2: How can you configure the system to log all session outputs to a specific file named 'tcp_log.txt' while ensuring that each session's output is logged separately into its own file?
  manpageQuestion3: What is the function of the TCP_OUTPUT parameter, and how would you set it to use a custom prompt format for logging sessions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nTCP_PROMPT\n\t      May be set directly.  Used as the prefix for data read by\n\t      tcp_read which is printed to standard output or to the log file\n\t      given by $TCP_LOG, if any.  Any `%s', `%f' or `%%' occurring in\n\t      the string will be replaced by the name of the session, the\n\t      session's underlying file descriptor, or a single `%',\n\t      respectively.  The expression `%c' expands to 1 if the session\n\t      being read is the current session, else 0; this is most useful\n\t      in ternary expressions such as `%(c.-.+)' which outputs `+' if\n\t      the session is the current one, else `-'.\n\n\t      If the prompt starts with %P, this is stripped and the complete\n\t      result of the previous stage is passed through standard prompt\n\t      %-style formatting before being output.\n\n       TCP_READ_DEBUG\n\t      May be set directly.  If this has non-zero length, tcp_read will\n\t      give some limited diagnostics about data being read.\n\n       TCP_SECONDS_START\n\t      This value is created and initialised to zero by tcp_open."
  manpageQuestion1: What is the primary purpose of the TCP_PROMPT variable in the context of the tcp_read function?
  manpageQuestion2: How can you configure tcp_read to provide diagnostic information about the data being read?
  manpageQuestion3: What does the TCP_SECONDS_START variable do in the tcp_open function?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThe functions tcp_read and tcp_expect use the shell's SECONDS\n\t      parameter for their own timing purposes.\tIf that parameter is\n\t      not of floating point type on entry to one of the functions, it\n\t      will create a local parameter SECONDS which is floating point\n\t      and set the parameter TCP_SECONDS_START to the previous value of\n\t      $SECONDS.  If the parameter is already floating point, it is\n\t      used without a local copy being created and TCP_SECONDS_START is\n\t      not set.\tAs the global value is zero, the shell elapsed time is\n\t      guaranteed to be the sum of $SECONDS and $TCP_SECONDS_START.\n\n\t      This can be avoided by setting SECONDS globally to a floating\n\t      point value using `typeset -F SECONDS'; then the TCP functions\n\t      will never make a local copy and never set TCP_SECONDS_START to\n\t      a non-zero value.\n\n       TCP_SESS\n\t      May be set directly.  The current session; must refer to one of\n\t      the sessions established by tcp_open.\n\n       TCP_SILENT\n\t      May be set directly, although it is also controlled by tcp_log.\n\t      If of non-zero length, data read by tcp_read will not be written\n\t      to standard output, though may still be written to a log file."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you ensure that the TCP functions do not create a local copy of the SECONDS parameter?
  manpageQuestion3: What is the effect of setting the TCP_SILENT variable to a non-zero length value?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\ntcp_spam_list\n\t      Array.  May be set directly.  See the description of the\n\t      function tcp_spam for how this is used.\n\n       TCP_TALK_ESCAPE\n\t      May be set directly.  See the description of the function\n\t      tcp_talk for how this is used.\n\n       TCP_TIMEOUT\n\t      May be set directly.  Currently this is only used by the\n\t      function tcp_command, see above.\n\nTCP USER-DEFINED PARAMETERS\n       The following parameters are not set by the function system, but have a\n       special effect if set by the user.\n\n       tcp_on_read\n\t      This should be an associative array; if it is not, the behaviour\n\t      is undefined.  Each key is the name of a shell function or other\n\t      command, and the corresponding value is a shell pattern (using\n\t      EXTENDED_GLOB).  Every line read from a TCP session directly or\n\t      indirectly using tcp_read (which includes lines read by\n\t      tcp_expect) is compared against the pattern.  If the line\n\t      matches, the command given in the key is called with two\n\t      arguments: the name of the session from which the line was read,\n\t      and the line itself."
  manpageQuestion1: What is the primary purpose of the tcp_spam_list, TCP_TALK_ESCAPE, and TCP_TIMEOUT parameters in the context of the macOS system?
  manpageQuestion2: How can a user define custom shell functions to be executed when specific lines are received from a TCP session using the tcp_on_read parameter?
  manpageQuestion3: What is the function of the TCP_TIMEOUT parameter, and in which context is it typically used?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nIf any function called to handle a line returns a non-zero\n\t      status, the line is not output.  Thus a tcp_on_read handler\n\t      containing only the instruction `return 1' can be used to\n\t      suppress output of particular lines (see, however, tcp_filter\n\t      above).  However, the line is still stored in TCP_LINE and\n\t      tcp_lines; this occurs after all tcp_on_read processing.\n\nTCP UTILITY PARAMETERS\n       These parameters are controlled by the function system; they may be\n       read directly, but should not usually be set by user code.\n\n       tcp_aliases\n\t      Associative array.  The keys are the names of sessions\n\t      established with tcp_open; each value is a space-separated list\n\t      of aliases which refer to that session.\n\n       tcp_by_fd\n\t      Associative array.  The keys are session file descriptors; each\n\t      value is the name of that session.\n\n       tcp_by_name\n\t      Associative array.  The keys are the names of sessions; each\n\t      value is the file descriptor associated with that session."
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How can you suppress output of specific lines using the tcp_on_read handler?
  manpageQuestion3: What is the function and usage of the tcp_aliases parameter in zshtcpsys?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nTCP EXAMPLES\n       Here is a trivial example using a remote calculator.\n\n       To create a calculator server on port 7337 (see the dc manual page for\n       quite how infuriating the underlying command is):\n\n\t      tcp_proxy 7337 dc\n\n       To connect to this from the same host with a session also named `dc':\n\n\t      tcp_open localhost 7337 dc\n\n       To send a command to the remote session and wait a short while for\n       output (assuming dc is the current session):\n\n\t      tcp_command 2 4 + p\n\n       To close the session:\n\n\t      tcp_close\n\n       The tcp_proxy needs to be killed to be stopped.\tNote this will not\n       usually kill any connections which have already been accepted, and also\n       that the port is not immediately available for reuse.\n\n       The following chunk of code puts a list of sessions into an xterm\n       header, with the current session followed by a star.\n\n\t      print -n \"\\033]2;TCP:\" ${(k)tcp_by_name:/$TCP_SESS/$TCP_SESS\\*} \"\\a\"\n\nTCP BUGS\n       The function tcp_read uses the shell's normal read builtin.  As this\n       reads a complete line at once, data arriving without a terminating\n       newline can cause the function to block indefinitely."
  manpageQuestion1: What is the primary purpose of the `zshtcpsys` resource?
  manpageQuestion2: How would you use the `tcp_proxy` command to forward traffic from port 7337 to a remote calculator program?
  manpageQuestion3: Can you provide an example of using the `tcp_command` function to send a mathematical operation to a TCP session?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `zshtcpsys`.\n\n\n\nManpage text:\n\nThough the function suite works well for interactive use and for data\n       arriving in small amounts, the performance when large amounts of data\n       are being exchanged is likely to be extremely poor.\n\nzsh 5.9 \t\t\t May 14, 2022\t\t\t  ZSHTCPSYS(1)"
  manpageQuestion1: What is the primary purpose of the zshtcpsys resource?
  manpageQuestion2: How would you use zshtcpsys to handle large data transfers efficiently?
  manpageQuestion3: Can you describe a scenario where zshtcpsys would be particularly useful despite its performance limitations?

