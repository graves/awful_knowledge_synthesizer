- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.



    Manpage text:

    PERLXSTYPEMAP(1)       Perl Programmers Reference Guide       PERLXSTYPEMAP(1)
  manpageQuestion1: What is the primary purpose of the perlxstypemap utility?
  manpageQuestion2: How can you use perlxstypemap to define a custom typemap for Perl extensions?
  manpageQuestion3: Can you provide an example of using perlxstypemap to specify a typemap that maps the C type 'double' to a Perl scalar?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.



    Manpage text:

    NAME
           perlxstypemap - Perl XS C/Perl type mapping

    DESCRIPTION
           The more you think about interfacing between two languages, the more
           you'll realize that the majority of programmer effort has to go into
           converting between the data structures that are native to either of the
           languages involved.  This trumps other matter such as differing calling
           conventions because the problem space is so much greater.  There are
           simply more ways to shove data into memory than there are ways to
           implement a function call.

           Perl XS' attempt at a solution to this is the concept of typemaps.  At
           an abstract level, a Perl XS typemap is nothing but a recipe for
           converting from a certain Perl data structure to a certain C data
           structure and vice versa.  Since there can be C types that are
           sufficiently similar to one another to warrant converting with the same
           logic, XS typemaps are represented by a unique identifier, henceforth
           called an XS type in this document.  You can then tell the XS compiler
           that multiple C types are to be mapped with the same XS typemap.
  manpageQuestion1: What is the primary purpose of the perlxstypemap tool?
  manpageQuestion2: How would you use perlxstypemap to define a typemap that maps Perl's reference type to C's void* type?
  manpageQuestion3: Can you provide an example of using perlxstypemap to create a typemap that converts between Perl's scalar and C's int type?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nIn your XS code, when you define an argument with a C type or when you\n       are using a \"CODE:\" and an \"OUTPUT:\" section together with a C return\n       type of your XSUB, it'll be the typemapping mechanism that makes this\n       easy.\n\n   Anatomy of a typemap\n       In more practical terms, the typemap is a collection of code fragments\n       which are used by the xsubpp compiler to map C function parameters and\n       values to Perl values.  The typemap file may consist of three sections\n       labelled \"TYPEMAP\", \"INPUT\", and \"OUTPUT\".  An unlabelled initial\n       section is assumed to be a \"TYPEMAP\" section.  The INPUT section tells\n       the compiler how to translate Perl values into variables of certain C\n       types.  The OUTPUT section tells the compiler how to translate the\n       values from certain C types into values Perl can understand.  The\n       TYPEMAP section tells the compiler which of the INPUT and OUTPUT code\n       fragments should be used to map a given C type to a Perl value.\tThe\n       section labels \"TYPEMAP\", \"INPUT\", or \"OUTPUT\" must begin in the first\n       column on a line by themselves, and must be in uppercase."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you define a typemap to convert a C integer type to a Perl integer value?
  manpageQuestion3: Can you explain how the perlxstypemap is used in XS code to map C function parameters to Perl values?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nEach type of section can appear an arbitrary number of times and does\n       not have to appear at all.  For example, a typemap may commonly lack\n       \"INPUT\" and \"OUTPUT\" sections if all it needs to do is associate\n       additional C types with core XS types like T_PTROBJ.  Lines that start\n       with a hash \"#\" are considered comments and ignored in the \"TYPEMAP\"\n       section, but are considered significant in \"INPUT\" and \"OUTPUT\". Blank\n       lines are generally ignored.\n\n       Traditionally, typemaps needed to be written to a separate file,\n       conventionally called \"typemap\" in a CPAN distribution.\tWith\n       ExtUtils::ParseXS (the XS compiler) version 3.12 or better which comes\n       with perl 5.16, typemaps can also be embedded directly into XS code\n       using a HERE-doc like syntax:\n\n\t TYPEMAP: <<HERE\n\t ...\n\t HERE\n\n       where \"HERE\" can be replaced by other identifiers like with normal Perl\n       HERE-docs.  All details below about the typemap textual format remain\n       valid."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How can you embed a typemap directly into XS code using the HERE-doc syntax?
  manpageQuestion3: What are the key differences between traditional typemap files and embedded typemaps in XS code?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nThe \"TYPEMAP\" section should contain one pair of C type and XS type per\n       line as follows.  An example from the core typemap file:\n\n\t TYPEMAP\n\t # all variants of char* is handled by the T_PV typemap\n\t char * \t T_PV\n\t const char *\t T_PV\n\t unsigned char * T_PV\n\t ...\n\n       The \"INPUT\" and \"OUTPUT\" sections have identical formats, that is, each\n       unindented line starts a new in- or output map respectively.  A new in-\n       or output map must start with the name of the XS type to map on a line\n       by itself, followed by the code that implements it indented on the\n       following lines. Example:\n\n\t INPUT\n\t T_PV\n\t   $var = ($type)SvPV_nolen($arg)\n\t T_PTR\n\t   $var = INT2PTR($type,SvIV($arg))\n\n       We'll get to the meaning of those Perlish-looking variables in a little\n       bit.\n\n       Finally, here's an example of the full typemap file for mapping C\n       strings of the \"char *\" type to Perl scalars/strings:\n\n\t TYPEMAP\n\t char *  T_PV\n\n\t INPUT\n\t T_PV\n\t   $var = ($type)SvPV_nolen($arg)"
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you define a typemap entry in perlxstypemap to map the C type 'unsigned char *' to the XS type 'T_PV'?
  manpageQuestion3: Can you provide an example of how to implement an input map in perlxstypemap for the XS type 'T_PTR' that converts a Perl scalar to an C pointer?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nOUTPUT\n\t T_PV\n\t   sv_setpv((SV*)$arg, $var);\n\n       Here's a more complicated example: suppose that you wanted \"struct\n       netconfig\" to be blessed into the class \"Net::Config\".  One way to do\n       this is to use underscores (_) to separate package names, as follows:\n\n\t typedef struct netconfig * Net_Config;\n\n       And then provide a typemap entry \"T_PTROBJ_SPECIAL\" that maps\n       underscores to double-colons (::), and declare \"Net_Config\" to be of\n       that type:\n\n\t TYPEMAP\n\t Net_Config\t T_PTROBJ_SPECIAL\n\n\t INPUT\n\t T_PTROBJ_SPECIAL\n\t   if (sv_derived_from($arg, \\\"${(my $ntt=$ntype)=~s/_/::/g;\\$ntt}\\\")){\n\t     IV tmp = SvIV((SV*)SvRV($arg));\n\t     $var = INT2PTR($type, tmp);\n\t   }\n\t   else\n\t     croak(\\\"$var is not of type ${(my $ntt=$ntype)=~s/_/::/g;\\$ntt}\\\")\n\n\t OUTPUT\n\t T_PTROBJ_SPECIAL\n\t   sv_setref_pv($arg, \\\"${(my $ntt=$ntype)=~s/_/::/g;\\$ntt}\\\",\n\t\t\t(void*)$var);\n\n       The INPUT and OUTPUT sections substitute underscores for double-colons\n       on the fly, giving the desired effect.  This example demonstrates some\n       of the power and versatility of the typemap facility."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How can you use perlxstypemap to map a struct netconfig to the class Net::Config in Perl?
  manpageQuestion3: Can you provide an example of how to define a typemap entry for converting underscores to double-colons in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nThe \"INT2PTR\" macro (defined in perl.h) casts an integer to a pointer\n       of a given type, taking care of the possible different size of integers\n       and pointers.  There are also \"PTR2IV\", \"PTR2UV\", \"PTR2NV\" macros, to\n       map the other way, which may be useful in OUTPUT sections.\n\n   The Role of the typemap File in Your Distribution\n       The default typemap in the lib/ExtUtils directory of the Perl source\n       contains many useful types which can be used by Perl extensions.  Some\n       extensions define additional typemaps which they keep in their own\n       directory.  These additional typemaps may reference INPUT and OUTPUT\n       maps in the main typemap.  The xsubpp compiler will allow the\n       extension's own typemap to override any mappings which are in the\n       default typemap.  Instead of using an additional typemap file, typemaps\n       may be embedded verbatim in XS with a heredoc-like syntax.  See the\n       documentation on the \"TYPEMAP:\" XS keyword.\n\n       For CPAN distributions, you can assume that the XS types defined by the\n       perl core are already available. Additionally, the core typemap has\n       default XS types for a large number of C types.\tFor example, if you\n       simply return a \"char *\" from your XSUB, the core typemap will have\n       this C type associated with the T_PV XS type.  That means your C string\n       will be copied into the PV (pointer value) slot of a new scalar that\n       will be returned from your XSUB to Perl."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use the "PTR2IV" macro in an XS module to convert a pointer to an integer value?
  manpageQuestion3: Can you provide an example of how the default typemap in Perl's lib/ExtUtils directory handles a "char *" return type in an XSUB function?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nIf you're developing a CPAN distribution using XS, you may add your own\n       file called typemap to the distribution.  That file may contain\n       typemaps that either map types that are specific to your code or that\n       override the core typemap file's mappings for common C types.\n\n   Sharing typemaps Between CPAN Distributions\n       Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16\n       and better), it is rather easy to share typemap code between multiple\n       CPAN distributions. The general idea is to share it as a module that\n       offers a certain API and have the dependent modules declare that as a\n       built-time requirement and import the typemap into the XS. An example\n       of such a typemap-sharing module on CPAN is\n       \"ExtUtils::Typemaps::Basic\". Two steps to getting that module's\n       typemaps available in your code:\n\n       •   Declare \"ExtUtils::Typemaps::Basic\" as a build-time dependency in\n\t   \"Makefile.PL\" (use \"BUILD_REQUIRES\"), or in your \"Build.PL\" (use\n\t   \"build_requires\")."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How can you share typemap code between multiple CPAN distributions using ExtUtils::Typemaps::Basic?
  manpageQuestion3: What steps are required to incorporate the ExtUtils::Typemaps::Basic module into your CPAN distribution's XS code?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\n•   Include the following line in the XS section of your XS file:\n\t   (don't break the line)\n\n\t     INCLUDE_COMMAND: $^X -MExtUtils::Typemaps::Cmd\n\t\t\t      -e \"print embeddable_typemap(q{Basic})\"\n\n   Writing typemap Entries\n       Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that\n       will be evaluated in the presence of certain variables to get the final\n       C code for mapping a certain C type.\n\n       This means that you can embed Perl code in your typemap (C) code using\n       constructs such as \"${ perl code that evaluates to scalar reference\n       here }\". A common use case is to generate error messages that refer to\n       the true function name even when using the ALIAS XS feature:\n\n\t ${ $ALIAS ? \\q[GvNAME(CvGV(cv))] : \\qq[\\\"$pname\\\"] }\n\n       For many typemap examples, refer to the core typemap file that can be\n       found in the perl source tree at lib/ExtUtils/typemap.\n\n       The Perl variables that are available for interpolation into typemaps\n       are the following:"
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use perlxstypemap to generate a typemap entry for converting a C integer type to a Perl scalar?
  manpageQuestion3: Can you provide an example of using perlxstypemap to create a typemap entry that includes embedded Perl code for error messages?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\n•   $var - the name of the input or output variable, eg. RETVAL for\n\t   return values.\n\n       •   $type - the raw C type of the parameter, any \":\" replaced with \"_\".\n\t   e.g. for a type of \"Foo::Bar\", $type is \"Foo__Bar\"\n\n       •   $ntype - the supplied type with \"*\" replaced with \"Ptr\".  e.g. for\n\t   a type of \"Foo*\", $ntype is \"FooPtr\"\n\n       •   $arg - the stack entry, that the parameter is input from or output\n\t   to, e.g. ST(0)\n\n       •   $argoff - the argument stack offset of the argument.  ie. 0 for the\n\t   first argument, etc.\n\n       •   $pname - the full name of the XSUB, with including the \"PACKAGE\"\n\t   name, with any \"PREFIX\" stripped.  This is the non-ALIAS name.\n\n       •   $Package - the package specified by the most recent \"PACKAGE\"\n\t   keyword.\n\n       •   $ALIAS - non-zero if the current XSUB has any aliases declared with\n\t   \"ALIAS\".\n\n   Full Listing of Core Typemaps\n       Each C type is represented by an entry in the typemap file that is\n       responsible for converting perl variables (SV, AV, HV, CV, etc.)  to\n       and from that type. The following sections list all XS types that come\n       with perl by default."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you define a typemap entry for converting a Perl scalar to a C integer in XS code?
  manpageQuestion3: Can you explain how the $type variable is used in typemap entries to represent C types?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nT_SV\n\t   This simply passes the C representation of the Perl variable (an\n\t   SV*) in and out of the XS layer. This can be used if the C code\n\t   wants to deal directly with the Perl variable.\n\n       T_SVREF\n\t   Used to pass in and return a reference to an SV.\n\n\t   Note that this typemap does not decrement the reference count when\n\t   returning the reference to an SV*.  See also:\n\t   T_SVREF_REFCOUNT_FIXED\n\n       T_SVREF_FIXED\n\t   Used to pass in and return a reference to an SV. This is a fixed\n\t   variant of T_SVREF that decrements the refcount appropriately when\n\t   returning a reference to an SV*. Introduced in perl 5.15.4.\n\n       T_AVREF\n\t   From the perl level this is a reference to a perl array.  From the\n\t   C level this is a pointer to an AV.\n\n\t   Note that this typemap does not decrement the reference count when\n\t   returning an AV*. See also: T_AVREF_REFCOUNT_FIXED\n\n       T_AVREF_REFCOUNT_FIXED\n\t   From the perl level this is a reference to a perl array.  From the\n\t   C level this is a pointer to an AV. This is a fixed variant of\n\t   T_AVREF that decrements the refcount appropriately when returning\n\t   an AV*. Introduced in perl 5.15.4."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use T_SVREF_FIXED to pass a reference to an SV in and out of the XS layer?
  manpageQuestion3: Can you provide an example of using T_AVREF_REFCOUNT_FIXED to handle a reference to a Perl array in XS code?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nT_HVREF\n\t   From the perl level this is a reference to a perl hash.  From the C\n\t   level this is a pointer to an HV.\n\n\t   Note that this typemap does not decrement the reference count when\n\t   returning an HV*. See also: T_HVREF_REFCOUNT_FIXED\n\n       T_HVREF_REFCOUNT_FIXED\n\t   From the perl level this is a reference to a perl hash.  From the C\n\t   level this is a pointer to an HV. This is a fixed variant of\n\t   T_HVREF that decrements the refcount appropriately when returning\n\t   an HV*. Introduced in perl 5.15.4.\n\n       T_CVREF\n\t   From the perl level this is a reference to a perl subroutine (e.g.\n\t   $sub = sub { 1 };). From the C level this is a pointer to a CV.\n\n\t   Note that this typemap does not decrement the reference count when\n\t   returning an HV*. See also: T_HVREF_REFCOUNT_FIXED\n\n       T_CVREF_REFCOUNT_FIXED\n\t   From the perl level this is a reference to a perl subroutine (e.g.\n\t   $sub = sub { 1 };). From the C level this is a pointer to a CV.\n\n\t   This is a fixed variant of T_HVREF that decrements the refcount\n\t   appropriately when returning an HV*. Introduced in perl 5.15.4."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use T_HVREF_REFCOUNT_FIXED in a C program to return a hash reference from Perl?
  manpageQuestion3: Can you provide an example of using T_CVREF in a C program to interface with a Perl subroutine?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nT_SYSRET\n\t   The T_SYSRET typemap is used to process return values from system\n\t   calls.  It is only meaningful when passing values from C to perl\n\t   (there is no concept of passing a system return value from Perl to\n\t   C).\n\n\t   System calls return -1 on error (setting ERRNO with the reason) and\n\t   (usually) 0 on success. If the return value is -1 this typemap\n\t   returns \"undef\". If the return value is not -1, this typemap\n\t   translates a 0 (perl false) to \"0 but true\" (which is perl true) or\n\t   returns the value itself, to indicate that the command succeeded.\n\n\t   The POSIX module makes extensive use of this type.\n\n       T_UV\n\t   An unsigned integer.\n\n       T_IV\n\t   A signed integer. This is cast to the required integer type when\n\t   passed to C and converted to an IV when passed back to Perl.\n\n       T_INT\n\t   A signed integer. This typemap converts the Perl value to a native\n\t   integer type (the \"int\" type on the current platform). When\n\t   returning the value to perl it is processed in the same way as for\n\t   T_IV."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use T_IV typemap to pass a signed integer from Perl to C and back?
  manpageQuestion3: Can you provide an example of using T_SYSRET typemap to handle the return value of a system call in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nIts behaviour is identical to using an \"int\" type in XS with T_IV.\n\n       T_ENUM\n\t   An enum value. Used to transfer an enum component from C. There is\n\t   no reason to pass an enum value to C since it is stored as an IV\n\t   inside perl.\n\n       T_BOOL\n\t   A boolean type. This can be used to pass true and false values to\n\t   and from C.\n\n       T_U_INT\n\t   This is for unsigned integers. It is equivalent to using T_UV but\n\t   explicitly casts the variable to type \"unsigned int\".  The default\n\t   type for \"unsigned int\" is T_UV.\n\n       T_SHORT\n\t   Short integers. This is equivalent to T_IV but explicitly casts the\n\t   return to type \"short\". The default typemap for \"short\" is T_IV.\n\n       T_U_SHORT\n\t   Unsigned short integers. This is equivalent to T_UV but explicitly\n\t   casts the return to type \"unsigned short\". The default typemap for\n\t   \"unsigned short\" is T_UV.\n\n\t   T_U_SHORT is used for type \"U16\" in the standard typemap.\n\n       T_LONG\n\t   Long integers. This is equivalent to T_IV but explicitly casts the\n\t   return to type \"long\". The default typemap for \"long\" is T_IV."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use perlxstypemap to specify that a C function should receive an unsigned integer as input?
  manpageQuestion3: Can you provide an example of using perlxstypemap to define the typemap for a 16-bit unsigned integer in C?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nT_U_LONG\n\t   Unsigned long integers. This is equivalent to T_UV but explicitly\n\t   casts the return to type \"unsigned long\". The default typemap for\n\t   \"unsigned long\" is T_UV.\n\n\t   T_U_LONG is used for type \"U32\" in the standard typemap.\n\n       T_CHAR\n\t   Single 8-bit characters.\n\n       T_U_CHAR\n\t   An unsigned byte.\n\n       T_FLOAT\n\t   A floating point number. This typemap guarantees to return a\n\t   variable cast to a \"float\".\n\n       T_NV\n\t   A Perl floating point number. Similar to T_IV and T_UV in that the\n\t   return type is cast to the requested numeric type rather than to a\n\t   specific type.\n\n       T_DOUBLE\n\t   A double precision floating point number. This typemap guarantees\n\t   to return a variable cast to a \"double\".\n\n       T_PV\n\t   A string (char *).\n\n       T_PTR\n\t   A memory address (pointer). Typically associated with a \"void *\"\n\t   type.\n\n       T_PTRREF\n\t   Similar to T_PTR except that the pointer is stored in a scalar and\n\t   the reference to that scalar is returned to the caller. This can be\n\t   used to hide the actual pointer value from the programmer since it\n\t   is usually not required directly from within perl."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use perlxstypemap to specify that a variable should be treated as an unsigned long integer?
  manpageQuestion3: Can you provide an example of using perlxstypemap to handle a pointer type in C when interfacing with Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nThe typemap checks that a scalar reference is passed from perl to\n\t   XS.\n\n       T_PTROBJ\n\t   Similar to T_PTRREF except that the reference is blessed into a\n\t   class.  This allows the pointer to be used as an object. Most\n\t   commonly used to deal with C structs. The typemap checks that the\n\t   perl object passed into the XS routine is of the correct class (or\n\t   part of a subclass).\n\n\t   The pointer is blessed into a class that is derived from the name\n\t   of type of the pointer but with all '*' in the name replaced with\n\t   'Ptr'.\n\n\t   For \"DESTROY\" XSUBs only, a T_PTROBJ is optimized to a T_PTRREF.\n\t   This means the class check is skipped.\n\n       T_REF_IV_REF\n\t   NOT YET\n\n       T_REF_IV_PTR\n\t   Similar to T_PTROBJ in that the pointer is blessed into a scalar\n\t   object.  The difference is that when the object is passed back into\n\t   XS it must be of the correct type (inheritance is not supported)\n\t   while T_PTROBJ supports inheritance.\n\n\t   The pointer is blessed into a class that is derived from the name\n\t   of type of the pointer but with all '*' in the name replaced with\n\t   'Ptr'."
  manpageQuestion1: What is the primary purpose of the perlxstypemap tool?
  manpageQuestion2: How would you use T_PTROBJ in perlxstypemap to handle a C struct passed from Perl to an XS function?
  manpageQuestion3: Can you provide an example of using T_REF_IV_PTR in perlxstypemap to ensure a pointer is blessed into a scalar object with specific type constraints?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nFor \"DESTROY\" XSUBs only, a T_REF_IV_PTR is optimized to a\n\t   T_PTRREF. This means the class check is skipped.\n\n       T_PTRDESC\n\t   NOT YET\n\n       T_REFREF\n\t   Similar to T_PTRREF, except the pointer stored in the referenced\n\t   scalar is dereferenced and copied to the output variable. This\n\t   means that T_REFREF is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR.\n\t   All clear?\n\n\t   Only the INPUT part of this is implemented (Perl to XSUB) and there\n\t   are no known users in core or on CPAN.\n\n       T_REFOBJ\n\t   Like T_REFREF, except it does strict type checking (inheritance is\n\t   not supported).\n\n\t   For \"DESTROY\" XSUBs only, a T_REFOBJ is optimized to a T_REFREF.\n\t   This means the class check is skipped.\n\n       T_OPAQUEPTR\n\t   This can be used to store bytes in the string component of the SV.\n\t   Here the representation of the data is irrelevant to perl and the\n\t   bytes themselves are just stored in the SV. It is assumed that the\n\t   C variable is a pointer (the bytes are copied from that memory\n\t   location).  If the pointer is pointing to something that is\n\t   represented by 8 bytes then those 8 bytes are stored in the SV (and\n\t   length() will report a value of 8). This entry is similar to\n\t   T_OPAQUE."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How can T_OPAQUEPTR be used to store bytes in the string component of an SV?
  manpageQuestion3: What is the difference between T_REFREF and T_REFOBJ in the context of XSUBs?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nIn principle the unpack() command can be used to convert the bytes\n\t   back to a number (if the underlying type is known to be a number).\n\n\t   This entry can be used to store a C structure (the number of bytes\n\t   to be copied is calculated using the C \"sizeof\" function) and can\n\t   be used as an alternative to T_PTRREF without having to worry about\n\t   a memory leak (since Perl will clean up the SV).\n\n       T_OPAQUE\n\t   This can be used to store data from non-pointer types in the string\n\t   part of an SV. It is similar to T_OPAQUEPTR except that the typemap\n\t   retrieves the pointer directly rather than assuming it is being\n\t   supplied. For example, if an integer is imported into Perl using\n\t   T_OPAQUE rather than T_IV the underlying bytes representing the\n\t   integer will be stored in the SV but the actual integer value will\n\t   not be available. i.e. The data is opaque to perl.\n\n\t   The data may be retrieved using the \"unpack\" function if the\n\t   underlying type of the byte stream is known."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How can T_OPAQUE be used to store data in an SV without Perl knowing the underlying integer value?
  manpageQuestion3: Can you explain how to retrieve data stored using T_OPAQUE from an SV?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nT_OPAQUE supports input and output of simple types.\tT_OPAQUEPTR\n\t   can be used to pass these bytes back into C if a pointer is\n\t   acceptable.\n\n       Implicit array\n\t   xsubpp supports a special syntax for returning packed C arrays to\n\t   perl. If the XS return type is given as\n\n\t     array(type, nelem)\n\n\t   xsubpp will copy the contents of \"nelem * sizeof(type)\" bytes from\n\t   RETVAL to an SV and push it onto the stack. This is only really\n\t   useful if the number of items to be returned is known at compile\n\t   time and you don't mind having a string of bytes in your SV.  Use\n\t   T_ARRAY to push a variable number of arguments onto the return\n\t   stack (they won't be packed as a single string though).\n\n\t   This is similar to using T_OPAQUEPTR but can be used to process\n\t   more than one element.\n\n       T_PACKED\n\t   Calls user-supplied functions for conversion. For \"OUTPUT\" (XSUB to\n\t   Perl), a function named \"XS_pack_$ntype\" is called with the output\n\t   Perl scalar and the C variable to convert from.  $ntype is the\n\t   normalized C type that is to be mapped to Perl. Normalized means\n\t   that all \"*\" are replaced by the string \"Ptr\". The return value of\n\t   the function is ignored."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use T_OPAQUEPTR in perlxstypemap to pass bytes back into C for a pointer?
  manpageQuestion3: Can you provide an example of using T_PACKED in perlxstypemap to convert a C variable to a Perl scalar?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nConversely for \"INPUT\" (Perl to XSUB) mapping, the function named\n\t   \"XS_unpack_$ntype\" is called with the input Perl scalar as argument\n\t   and the return value is cast to the mapped C type and assigned to\n\t   the output C variable.\n\n\t   An example conversion function for a typemapped struct \"foo_t *\"\n\t   might be:\n\n\t     static void\n\t     XS_pack_foo_tPtr(SV *out, foo_t *in)\n\t     {\n\t       dTHX; /* alas, signature does not include pTHX_ */\n\t       HV* hash = newHV();\n\t       hv_stores(hash, \"int_member\", newSViv(in->int_member));\n\t       hv_stores(hash, \"float_member\", newSVnv(in->float_member));\n\t       /* ... */\n\n\t       /* mortalize as thy stack is not refcounted */\n\t       sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));\n\t     }\n\n\t   The conversion from Perl to C is left as an exercise to the reader,\n\t   but the prototype would be:\n\n\t     static foo_t *\n\t     XS_unpack_foo_tPtr(SV *in);\n\n\t   Instead of an actual C function that has to fetch the thread\n\t   context using \"dTHX\", you can define macros of the same name and\n\t   avoid the overhead. Also, keep in mind to possibly free the memory\n\t   allocated by \"XS_unpack_foo_tPtr\"."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use perlxstypemap to define a typemapped struct for converting Perl data to C?
  manpageQuestion3: Can you provide an example of the XS_unpack_foo_tPtr function for converting Perl to C data types?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nT_PACKEDARRAY\n\t   T_PACKEDARRAY is similar to T_PACKED. In fact, the \"INPUT\" (Perl to\n\t   XSUB) typemap is identical, but the \"OUTPUT\" typemap passes an\n\t   additional argument to the \"XS_pack_$ntype\" function. This third\n\t   parameter indicates the number of elements in the output so that\n\t   the function can handle C arrays sanely. The variable needs to be\n\t   declared by the user and must have the name \"count_$ntype\" where\n\t   $ntype is the normalized C type name as explained above. The\n\t   signature of the function would be for the example above and \"foo_t\n\t   **\":\n\n\t     static void\n\t     XS_pack_foo_tPtrPtr(SV *out, foo_t *in, UV count_foo_tPtrPtr);\n\n\t   The type of the third parameter is arbitrary as far as the typemap\n\t   is concerned. It just has to be in line with the declared variable.\n\n\t   Of course, unless you know the number of elements in the \"sometype\n\t   **\" C array, within your XSUB, the return value from \"foo_t **\n\t   XS_unpack_foo_tPtrPtr(...)\" will be hard to decipher.  Since the\n\t   details are all up to the XS author (the typemap user), there are\n\t   several solutions, none of which particularly elegant.  The most\n\t   commonly seen solution has been to allocate memory for N+1 pointers\n\t   and assign \"NULL\" to the (N+1)th to facilitate iteration."
  manpageQuestion1: What is the primary purpose of the T_PACKEDARRAY typemap in Perl's XS interface?
  manpageQuestion2: How can T_PACKEDARRAY be used to handle a C array of pointers in an XSUB function?
  manpageQuestion3: What is a common approach to manage the count of elements when using T_PACKEDARRAY with an array of pointers?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nAlternatively, using a customized typemap for your purposes in the\n\t   first place is probably preferable.\n\n       T_DATAUNIT\n\t   NOT YET\n\n       T_CALLBACK\n\t   NOT YET\n\n       T_ARRAY\n\t   This is used to convert the perl argument list to a C array and for\n\t   pushing the contents of a C array onto the perl argument stack.\n\n\t   The usual calling signature is\n\n\t     @out = array_func( @in );\n\n\t   Any number of arguments can occur in the list before the array but\n\t   the input and output arrays must be the last elements in the list.\n\n\t   When used to pass a perl list to C the XS writer must provide a\n\t   function (named after the array type but with 'Ptr' substituted for\n\t   '*') to allocate the memory required to hold the list. A pointer\n\t   should be returned. It is up to the XS writer to free the memory on\n\t   exit from the function. The variable \"ix_$var\" is set to the number\n\t   of elements in the new array.\n\n\t   When returning a C array to Perl the XS writer must provide an\n\t   integer variable called \"size_$var\" containing the number of\n\t   elements in the array. This is used to determine how many elements\n\t   should be pushed onto the return argument stack. This is not\n\t   required on input since Perl knows how many arguments are on the\n\t   stack when the routine is called. Ordinarily this variable would be\n\t   called \"size_RETVAL\"."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use perlxstypemap to define a custom typemap for handling array data in XS code?
  manpageQuestion3: Can you provide an example of how to use perlxstypemap to convert a Perl list to a C array in an XS function?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nAdditionally, the type of each element is determined from the type\n\t   of the array. If the array uses type \"intArray *\" xsubpp will\n\t   automatically work out that it contains variables of type \"int\" and\n\t   use that typemap entry to perform the copy of each element. All\n\t   pointer '*' and 'Array' tags are removed from the name to determine\n\t   the subtype.\n\n       T_STDIO\n\t   This is used for passing perl filehandles to and from C using \"FILE\n\t   *\" structures.\n\n       T_INOUT\n\t   This is used for passing perl filehandles to and from C using\n\t   \"PerlIO *\" structures. The file handle can used for reading and\n\t   writing. This corresponds to the \"+<\" mode, see also T_IN and\n\t   T_OUT.\n\n\t   See perliol for more information on the Perl IO abstraction layer.\n\t   Perl must have been built with \"-Duseperlio\".\n\n\t   There is no check to assert that the filehandle passed from Perl to\n\t   C was created with the right \"open()\" mode.\n\n\t   Hint: The perlxstut tutorial covers the T_INOUT, T_IN, and T_OUT XS\n\t   types nicely."
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use the T_INOUT type in perlxstypemap to pass a Perl filehandle to C for both reading and writing operations?
  manpageQuestion3: Can you explain how the type of elements in an array is determined using perlxstypemap?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlxstypemap`.\n\n\n\nManpage text:\n\nT_IN\n\t   Same as T_INOUT, but the filehandle that is returned from C to Perl\n\t   can only be used for reading (mode \"<\").\n\n       T_OUT\n\t   Same as T_INOUT, but the filehandle that is returned from C to Perl\n\t   is set to use the open mode \"+>\".\n\nperl v5.34.1\t\t\t  2022-02-19\t\t      PERLXSTYPEMAP(1)"
  manpageQuestion1: What is the primary purpose of the perlxstypemap resource?
  manpageQuestion2: How would you use perlxstypmap to define a type map for converting C filehandles to Perl filehandles with read-only access?
  manpageQuestion3: Can you provide an example of using perlxstypmap to set up a type map for C filehandles that are returned with write-only access in Perl?

