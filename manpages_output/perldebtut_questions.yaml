- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nPERLDEBTUT(1)\t       Perl Programmers Reference Guide \t PERLDEBTUT(1)"
  manpageQuestion1: What is the primary purpose of the perldebtut tool?
  manpageQuestion2: How would you use perldebtut to generate a detailed explanation of a specific Perl function?
  manpageQuestion3: Can you provide an example of using perldebtut to explain the behavior of a Perl regular expression?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nNAME\n       perldebtut - Perl debugging tutorial\n\nDESCRIPTION\n       A (very) lightweight introduction in the use of the perl debugger, and\n       a pointer to existing, deeper sources of information on the subject of\n       debugging perl programs.\n\n       There's an extraordinary number of people out there who don't appear to\n       know anything about using the perl debugger, though they use the\n       language every day.  This is for them.\n\nuse strict\n       First of all, there's a few things you can do to make your life a lot\n       more straightforward when it comes to debugging perl programs, without\n       using the debugger at all.  To demonstrate, here's a simple script,\n       named \"hello\", with a problem:\n\n\t       #!/usr/bin/perl\n\n\t       $var1 = 'Hello World'; # always wanted to do that :-)\n\t       $var2 = \"$varl\\n\";\n\n\t       print $var2;\n\t       exit;\n\n       While this compiles and runs happily, it probably won't do what's\n       expected, namely it doesn't print \"Hello World\\n\" at all;  It will on\n       the other hand do exactly what it was told to do, computers being a bit\n       that way inclined.  That is, it will print out a newline character, and\n       you'll get what looks like a blank line.  It looks like there's 2\n       variables when (because of the typo) there's really 3:"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use perldebtut to learn about debugging Perl programs without using the debugger directly?
  manpageQuestion3: Can you provide an example of a simple Perl script that demonstrates a common mistake in variable naming, as shown in the manpage?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\n$var1 = 'Hello World';\n\t       $varl = undef;\n\t       $var2 = \"\\n\";\n\n       To catch this kind of problem, we can force each variable to be\n       declared before use by pulling in the strict module, by putting 'use\n       strict;' after the first line of the script.\n\n       Now when you run it, perl complains about the 3 undeclared variables\n       and we get four error messages because one variable is referenced\n       twice:\n\n\tGlobal symbol \"$var1\" requires explicit package name at ./t1 line 4.\n\tGlobal symbol \"$var2\" requires explicit package name at ./t1 line 5.\n\tGlobal symbol \"$varl\" requires explicit package name at ./t1 line 5.\n\tGlobal symbol \"$var2\" requires explicit package name at ./t1 line 7.\n\tExecution of ./hello aborted due to compilation errors.\n\n       Luvverly! and to fix this we declare all variables explicitly and now\n       our script looks like this:\n\n\t       #!/usr/bin/perl\n\t       use strict;\n\n\t       my $var1 = 'Hello World';\n\t       my $varl = undef;\n\t       my $var2 = \"$varl\\n\";"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you modify a Perl script to catch undeclared variable references and ensure all variables are explicitly declared?
  manpageQuestion3: Can you provide an example of a Perl script that uses the 'use strict;' directive to declare and initialize variables properly?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nprint $var2;\n\t       exit;\n\n       We then do (always a good idea) a syntax check before we try to run it\n       again:\n\n\t       > perl -c hello\n\t       hello syntax OK\n\n       And now when we run it, we get \"\\n\" still, but at least we know why.\n       Just getting this script to compile has exposed the '$varl' (with the\n       letter 'l') variable, and simply changing $varl to $var1 solves the\n       problem.\n\nLooking at data and -w and v\n       Ok, but how about when you want to really see your data, what's in that\n       dynamic variable, just before using it?\n\n\t       #!/usr/bin/perl\n\t       use strict;\n\n\t       my $key = 'welcome';\n\t       my %data = (\n\t\t       'this' => qw(that),\n\t\t       'tom' => qw(and jerry),\n\t\t       'welcome' => q(Hello World),\n\t\t       'zip' => q(welcome),\n\t       );\n\t       my @data = keys %data;\n\n\t       print \"$data{$key}\\n\";\n\t       exit;\n\n       Looks OK, after it's been through the syntax check (perl -c\n       scriptname), we run it and all we get is a blank line again!  Hmmmm."
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you check the syntax of a Perl script before running it?
  manpageQuestion3: What is an example of using Perl to print the value of a dynamic variable from a hash?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nOne common debugging approach here, would be to liberally sprinkle a\n       few print statements, to add a check just before we print out our data,\n       and another just after:\n\n\t       print \"All OK\\n\" if grep($key, keys %data);\n\t       print \"$data{$key}\\n\";\n\t       print \"done: '$data{$key}'\\n\";\n\n       And try again:\n\n\t       > perl data\n\t       All OK\n\n\t       done: ''\n\n       After much staring at the same piece of code and not seeing the wood\n       for the trees for some time, we get a cup of coffee and try another\n       approach.  That is, we bring in the cavalry by giving perl the '-d'\n       switch on the command line:\n\n\t       > perl -d data\n\t       Default die handler restored.\n\n\t       Loading DB routines from perl5db.pl version 1.07\n\t       Editor support available.\n\n\t       Enter h or `h h' for help, or `man perldebug' for more help.\n\n\t       main::(./data:4):     my $key = 'welcome';\n\n       Now, what we've done here is to launch the built-in perl debugger on\n       our script.  It's stopped at the first line of executable code and is\n       waiting for input."
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use the perl debugger to debug a script named 'data'?
  manpageQuestion3: What is the purpose of adding print statements in debugging a Perl script?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nBefore we go any further, you'll want to know how to quit the debugger:\n       use just the letter 'q', not the words 'quit' or 'exit':\n\n\t       DB<1> q\n\t       >\n\n       That's it, you're back on home turf again.\n\nhelp\n       Fire the debugger up again on your script and we'll look at the help\n       menu.  There's a couple of ways of calling help: a simple 'h' will get\n       the summary help list, '|h' (pipe-h) will pipe the help through your\n       pager (which is (probably 'more' or 'less'), and finally, 'h h'\n       (h-space-h) will give you the entire help screen.  Here is the summary\n       page:\n\n       D1h\n\n\tList/search source lines:\t\tControl script execution:\n\t l [ln|sub]  List source code\t\t T\t     Stack trace\n\t - or .      List previous/current line  s [expr]    Single step\n\t\t\t\t\t\t\t\t      [in expr]\n\t v [line]    View around line\t\t n [expr]    Next, steps over\n\t\t\t\t\t\t\t\t\t   subs\n\t f filename  View source in file\t <CR/Enter>  Repeat last n or s\n\t /pattern/ ?patt?   Search forw/backw\t r\t     Return from\n\t\t\t\t\t\t\t\t     subroutine\n\t M\t     Show module versions\t c [ln|sub]  Continue until\n\t\t\t\t\t\t\t\t       position\n\tDebugger controls:\t\t\t L\t     List break/watch/\n\t\t\t\t\t\t\t\t\tactions\n\t o [...]     Set debugger options\t t [expr]    Toggle trace\n\t\t\t\t\t\t\t\t   [trace expr]\n\t <[<]|{[{]|>[>] [cmd] Do pre/post-prompt b [ln|event|sub] [cnd] Set\n\t\t\t\t\t\t\t\t     breakpoint\n\t ! [N|pat]   Redo a previous command\t B ln|*      Delete a/all\n\t\t\t\t\t\t\t\t    breakpoints\n\t H [-num]    Display last num commands\t a [ln] cmd  Do cmd before line\n\t = [a val]   Define/list an alias\t A ln|*      Delete a/all\n\t\t\t\t\t\t\t\t\tactions\n\t h [db_cmd]  Get help on command\t w expr      Add a watch\n\t\t\t\t\t\t\t\t     expression\n\t h h\t     Complete help page \t W expr|*    Delete a/all watch\n\t\t\t\t\t\t\t\t\t  exprs\n\t |[|]db_cmd  Send output to pager\t ![!] syscmd Run cmd in a\n\t\t\t\t\t\t\t\t     subprocess\n\t q or ^D     Quit\t\t\t R\t     Attempt a restart\n\tData Examination:     expr     Execute perl code, also see: s,n,t expr\n\t x|m expr\tEvals expr in list context, dumps the result or lists\n\t\t\t\t\t\t\t\t       methods.\n\t p expr \tPrint expression (uses script's current package).\n\t S [[!]pat]\tList subroutine names [not] matching pattern\n\t V [Pk [Vars]]\tList Variables in Package.  Vars can be ~pattern or\n\t\t\t\t\t\t\t\t      !pattern.\n\t X [Vars]\tSame as \"V current_package [Vars]\".\n\t y [n [Vars]]\tList lexicals in higher scope <n>.  Vars same as V.\n\tFor more help, type h cmd_letter, or run man perldebug for all docs."
  manpageQuestion1: What is the primary purpose of the perldebtut tool?
  manpageQuestion2: How can you exit the Perl debugger using the perldebtut tool?
  manpageQuestion3: What are the different ways to invoke help within the Perl debugger as described in the manpage?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nMore confusing options than you can shake a big stick at!  It's not as\n       bad as it looks and it's very useful to know more about all of it, and\n       fun too!\n\n       There's a couple of useful ones to know about straight away.  You\n       wouldn't think we're using any libraries at all at the moment, but 'M'\n       will show which modules are currently loaded, and their version number,\n       while 'm' will show the methods, and 'S' shows all subroutines (by\n       pattern) as shown below.  'V' and 'X' show variables in the program by\n       package scope and can be constrained by pattern.\n\n\t       DB<2>S str\n\t       dumpvar::stringify\n\t       strict::bits\n\t       strict::import\n\t       strict::unimport\n\n       Using 'X' and cousins requires you not to use the type identifiers\n       ($@%), just the 'name':\n\n\t       DM<3>X ~err\n\t       FileHandle(stderr) => fileno(2)\n\n       Remember we're in our tiny program with a problem, we should have a\n       look at where we are, and what our data looks like. First of all let's\n       view some code at our present position (the first line of code in this\n       case), via 'v':"
  manpageQuestion1: What is the primary purpose of the perldebtut tool?
  manpageQuestion2: How would you use perldebtut to display all subroutines in the current package that match the pattern 'str'?
  manpageQuestion3: Can you provide an example of using perldebtut to examine the value of a variable named 'err' in the current scope?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nDB<4> v\n\t       1       #!/usr/bin/perl\n\t       2:      use strict;\n\t       3\n\t       4==>    my $key = 'welcome';\n\t       5:      my %data = (\n\t       6\t       'this' => qw(that),\n\t       7\t       'tom' => qw(and jerry),\n\t       8\t       'welcome' => q(Hello World),\n\t       9\t       'zip' => q(welcome),\n\t       10      );\n\n       At line number 4 is a helpful pointer, that tells you where you are\n       now.  To see more code, type 'v' again:\n\n\t       DB<4> v\n\t       8\t       'welcome' => q(Hello World),\n\t       9\t       'zip' => q(welcome),\n\t       10      );\n\t       11:     my @data = keys %data;\n\t       12:     print \"All OK\\n\" if grep($key, keys %data);\n\t       13:     print \"$data{$key}\\n\";\n\t       14:     print \"done: '$data{$key}'\\n\";\n\t       15:     exit;\n\n       And if you wanted to list line 5 again, type 'l 5', (note the space):\n\n\t       DB<4> l 5\n\t       5:      my %data = (\n\n       In this case, there's not much to see, but of course normally there's\n       pages of stuff to wade through, and 'l' can be very useful.  To reset\n       your view to the line we're about to execute, type a lone period '.':"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you view line 5 of the code in the perldebtut environment?
  manpageQuestion3: What command can you use to reset your view in the perldebtut environment to the line about to be executed?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nDB<5> .\n\t       main::(./data_a:4):     my $key = 'welcome';\n\n       The line shown is the one that is about to be executed next, it hasn't\n       happened yet.  So while we can print a variable with the letter 'p', at\n       this point all we'd get is an empty (undefined) value back.  What we\n       need to do is to step through the next executable statement with an\n       's':\n\n\t       DB<6> s\n\t       main::(./data_a:5):     my %data = (\n\t       main::(./data_a:6):\t       'this' => qw(that),\n\t       main::(./data_a:7):\t       'tom' => qw(and jerry),\n\t       main::(./data_a:8):\t       'welcome' => q(Hello World),\n\t       main::(./data_a:9):\t       'zip' => q(welcome),\n\t       main::(./data_a:10):    );\n\n       Now we can have a look at that first ($key) variable:\n\n\t       DB<7> p $key\n\t       welcome\n\n       line 13 is where the action is, so let's continue down to there via the\n       letter 'c', which by the way, inserts a 'one-time-only' breakpoint at\n       the given line or sub routine:"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How would you use perldebtut to step through the execution of a Perl script in the DB debugger?
  manpageQuestion3: Can you provide an example of using perldebtut to set a one-time-only breakpoint at line 13 of a Perl script?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nDB<8> c 13\n\t       All OK\n\t       main::(./data_a:13):    print \"$data{$key}\\n\";\n\n       We've gone past our check (where 'All OK' was printed) and have stopped\n       just before the meat of our task.  We could try to print out a couple\n       of variables to see what is happening:\n\n\t       DB<9> p $data{$key}\n\n       Not much in there, lets have a look at our hash:\n\n\t       DB<10> p %data\n\t       Hello Worldziptomandwelcomejerrywelcomethisthat\n\n\t       DB<11> p keys %data\n\t       Hello Worldtomwelcomejerrythis\n\n       Well, this isn't very easy to read, and using the helpful manual (h h),\n       the 'x' command looks promising:\n\n\t       DB<12> x %data\n\t       0  'Hello World'\n\t       1  'zip'\n\t       2  'tom'\n\t       3  'and'\n\t       4  'welcome'\n\t       5  undef\n\t       6  'jerry'\n\t       7  'welcome'\n\t       8  'this'\n\t       9  'that'\n\n       That's not much help, a couple of welcomes in there, but no indication\n       of which are keys, and which are values, it's just a listed array dump\n       and, in this case, not particularly helpful.  The trick here, is to use\n       a reference to the data structure:"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How would you use the perldebtut tool to inspect the contents of a hash in a more readable format?
  manpageQuestion3: Can you provide an example of using perldebtut to examine the structure of a reference to a hash?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nDB<13> x \\%data\n\t       0  HASH(0x8194bc4)\n\t\t  'Hello World' => 'zip'\n\t\t  'jerry' => 'welcome'\n\t\t  'this' => 'that'\n\t\t  'tom' => 'and'\n\t\t  'welcome' => undef\n\n       The reference is truly dumped and we can finally see what we're dealing\n       with.  Our quoting was perfectly valid but wrong for our purposes, with\n       'and jerry' being treated as 2 separate words rather than a phrase,\n       thus throwing the evenly paired hash structure out of alignment.\n\n       The '-w' switch would have told us about this, had we used it at the\n       start, and saved us a lot of trouble:\n\n\t       > perl -w data\n\t       Odd number of elements in hash assignment at ./data line 5.\n\n       We fix our quoting: 'tom' => q(and jerry), and run it again, this time\n       we get our expected output:\n\n\t       > perl -w data\n\t       Hello World\n\n       While we're here, take a closer look at the 'x' command, it's really\n       useful and will merrily dump out nested references, complete objects,\n       partial objects - just about whatever you throw at it:"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use the 'x' command in perldebtut to inspect a reference's contents?
  manpageQuestion3: What is the benefit of using the '-w' switch in perldebtut when debugging a Perl script?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nLet's make a quick object and x-plode it, first we'll start the\n       debugger: it wants some form of input from STDIN, so we give it\n       something non-committal, a zero:\n\n\t> perl -de 0\n\tDefault die handler restored.\n\n\tLoading DB routines from perl5db.pl version 1.07\n\tEditor support available.\n\n\tEnter h or `h h' for help, or `man perldebug' for more help.\n\n\tmain::(-e:1):\t0\n\n       Now build an on-the-fly object over a couple of lines (note the\n       backslash):\n\n\tDB<1> $obj = bless({'unique_id'=>'123', 'attr'=> \\\n\tcont:  {'col' => 'black', 'things' => [qw(this that etc)]}}, 'MY_class')\n\n       And let's have a look at it:\n\n\t       DB<2> x $obj\n\t0  MY_class=HASH(0x828ad98)\n\t\t       'attr' => HASH(0x828ad68)\n\t       'col' => 'black'\n\t       'things' => ARRAY(0x828abb8)\n\t\t       0  'this'\n\t\t       1  'that'\n\t\t       2  'etc'\n\t\t       'unique_id' => 123\n\t       DB<3>\n\n       Useful, huh?  You can eval nearly anything in there, and experiment\n       with bits of code or regexes until the cows come home:"
  manpageQuestion1: What is the primary purpose of the perldebtut tool?
  manpageQuestion2: How would you use perldebtut to debug a Perl script and inspect the contents of an object?
  manpageQuestion3: Can you provide an example of using perldebtut to evaluate and display the structure of a Perl object during debugging?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nDB<3> @data = qw(this that the other atheism leather theory scythe)\n\n\tDB<4> p 'saw -> '.($cnt += map { print \"\\t:\\t$_\\n\" } grep(/the/, sort @data))\n\tatheism\n\tleather\n\tother\n\tscythe\n\tthe\n\ttheory\n\tsaw -> 6\n\n       If you want to see the command History, type an 'H':\n\n\tDB<5> H\n\t4: p 'saw -> '.($cnt += map { print \"\\t:\\t$_\\n\" } grep(/the/, sort @data))\n\t3: @data = qw(this that the other atheism leather theory scythe)\n\t2: x $obj\n\t1: $obj = bless({'unique_id'=>'123', 'attr'=>\n\t{'col' => 'black', 'things' => [qw(this that etc)]}}, 'MY_class')\n\tDB<5>\n\n       And if you want to repeat any previous command, use the exclamation:\n       '!':\n\n\tDB<5> !4\n\tp 'saw -> '.($cnt += map { print \"$_\\n\" } grep(/the/, sort @data))\n\tatheism\n\tleather\n\tother\n\tscythe\n\tthe\n\ttheory\n\tsaw -> 12\n\n       For more on references see perlref and perlreftut\n\nStepping through code\n       Here's a simple program which converts between Celsius and Fahrenheit,\n       it too has a problem:\n\n\t#!/usr/bin/perl -w\n\tuse strict;\n\n\tmy $arg = $ARGV[0] || '-c20';"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use the perldebtut tool to execute a command and view its output history?
  manpageQuestion3: Can you provide an example of using the perldebtut resource to debug a simple Celsius to Fahrenheit conversion program?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nif ($arg =~ /^\\-(c|f)((\\-|\\+)*\\d+(\\.\\d+)*)$/) {\n\t       my ($deg, $num) = ($1, $2);\n\t       my ($in, $out) = ($num, $num);\n\t       if ($deg eq 'c') {\n\t\t       $deg = 'f';\n\t\t       $out = &c2f($num);\n\t       } else {\n\t\t       $deg = 'c';\n\t\t       $out = &f2c($num);\n\t       }\n\t       $out = sprintf('%0.2f', $out);\n\t       $out =~ s/^((\\-|\\+)*\\d+)\\.0+$/$1/;\n\t       print \"$out $deg\\n\";\n\t} else {\n\t       print \"Usage: $0 -[c|f] num\\n\";\n\t}\n\texit;\n\n\tsub f2c {\n\t       my $f = shift;\n\t       my $c = 5 * $f - 32 / 9;\n\t       return $c;\n\t}\n\n\tsub c2f {\n\t       my $c = shift;\n\t       my $f = 9 * $c / 5 + 32;\n\t       return $f;\n\t}\n\n       For some reason, the Fahrenheit to Celsius conversion fails to return\n       the expected output.  This is what it does:\n\n\t> temp -c0.72\n\t33.30 f\n\n\t> temp -f33.3\n\t162.94 c\n\n       Not very consistent!  We'll set a breakpoint in the code manually and\n       run it under the debugger to see what's going on.  A breakpoint is a\n       flag, to which the debugger will run without interruption, when it\n       reaches the breakpoint, it will stop execution and offer a prompt for\n       further interaction.  In normal use, these debugger commands are\n       completely ignored, and they are safe - if a little messy, to leave in\n       production code."
  manpageQuestion1: What is the primary purpose of the perldebtut script?
  manpageQuestion2: How would you use the perldebtut script to convert 33.3 degrees Fahrenheit to Celsius?
  manpageQuestion3: What is the issue with the Fahrenheit to Celsius conversion in the perldebtut script, and how can it be fixed?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nmy ($in, $out) = ($num, $num);\n\t       $DB::single=2; # insert at line 9!\n\t       if ($deg eq 'c')\n\t\t       ...\n\n\t       > perl -d temp -f33.3\n\t       Default die handler restored.\n\n\t       Loading DB routines from perl5db.pl version 1.07\n\t       Editor support available.\n\n\t       Enter h or `h h' for help, or `man perldebug' for more help.\n\n\t       main::(temp:4): my $arg = $ARGV[0] || '-c100';\n\n       We'll simply continue down to our pre-set breakpoint with a 'c':\n\n\t       DB<1> c\n\t       main::(temp:10): \t       if ($deg eq 'c') {\n\n       Followed by a view command to see where we are:\n\n\t       DB<1> v\n\t       7:\t       my ($deg, $num) = ($1, $2);\n\t       8:\t       my ($in, $out) = ($num, $num);\n\t       9:\t       $DB::single=2;\n\t       10==>\t       if ($deg eq 'c') {\n\t       11:\t\t       $deg = 'f';\n\t       12:\t\t       $out = &c2f($num);\n\t       13\t       } else {\n\t       14:\t\t       $deg = 'c';\n\t       15:\t\t       $out = &f2c($num);\n\t       16\t       }\n\n       And a print to show what values we're currently using:"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use perldebtut to set a breakpoint and continue execution at a specific line in a script?
  manpageQuestion3: Can you provide an example of using perldebtut to inspect the current state of a script while debugging?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nDB<1> p $deg, $num\n\t       f33.3\n\n       We can put another break point on any line beginning with a colon,\n       we'll use line 17 as that's just as we come out of the subroutine, and\n       we'd like to pause there later on:\n\n\t       DB<2> b 17\n\n       There's no feedback from this, but you can see what breakpoints are set\n       by using the list 'L' command:\n\n\t       DB<3> L\n\t       temp:\n\t\t       17:\t      print \"$out $deg\\n\";\n\t\t       break if (1)\n\n       Note that to delete a breakpoint you use 'B'.\n\n       Now we'll continue down into our subroutine, this time rather than by\n       line number, we'll use the subroutine name, followed by the now\n       familiar 'v':\n\n\t       DB<3> c f2c\n\t       main::f2c(temp:30):\t       my $f = shift;\n\n\t       DB<4> v\n\t       24:     exit;\n\t       25\n\t       26      sub f2c {\n\t       27==>\t       my $f = shift;\n\t       28:\t       my $c = 5 * $f - 32 / 9;\n\t       29:\t       return $c;\n\t       30      }\n\t       31\n\t       32      sub c2f {\n\t       33:\t       my $c = shift;"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How would you set a breakpoint in the Perl script at line 17 using the dbx debugger?
  manpageQuestion3: Can you provide an example of continuing execution in a Perl script using the dbx debugger to step into a subroutine named 'f2c'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nNote that if there was a subroutine call between us and line 29, and we\n       wanted to single-step through it, we could use the 's' command, and to\n       step over it we would use 'n' which would execute the sub, but not\n       descend into it for inspection.\tIn this case though, we simply\n       continue down to line 29:\n\n\t       DB<4> c 29\n\t       main::f2c(temp:29):\t       return $c;\n\n       And have a look at the return value:\n\n\t       DB<5> p $c\n\t       162.944444444444\n\n       This is not the right answer at all, but the sum looks correct.\tI\n       wonder if it's anything to do with operator precedence?\tWe'll try a\n       couple of other possibilities with our sum:\n\n\t       DB<6> p (5 * $f - 32 / 9)\n\t       162.944444444444\n\n\t       DB<7> p 5 * $f - (32 / 9)\n\t       162.944444444444\n\n\t       DB<8> p (5 * $f) - 32 / 9\n\t       162.944444444444\n\n\t       DB<9> p 5 * ($f - 32) / 9\n\t       0.722222222222221\n\n       :-) that's more like it!  Ok, now we can set our return variable and\n       we'll return out of the sub with an 'r':"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use perldebtut to debug a Perl script and inspect the value of a variable at a specific line?
  manpageQuestion3: What is an example of using perldebtut to step through a subroutine and examine the result of a calculation?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nDB<10> $c = 5 * ($f - 32) / 9\n\n\t       DB<11> r\n\t       scalar context return from main::f2c: 0.722222222222221\n\n       Looks good, let's just continue off the end of the script:\n\n\t       DB<12> c\n\t       0.72 c\n\t       Debugged program terminated.  Use q to quit or R to restart,\n\t       use O inhibit_exit to avoid stopping after program termination,\n\t       h q, h R or h O to get additional info.\n\n       A quick fix to the offending line (insert the missing parentheses) in\n       the actual program and we're finished.\n\nPlaceholder for a, w, t, T\n       Actions, watch variables, stack traces etc.: on the TODO list.\n\n\t       a\n\n\t       w\n\n\t       t\n\n\t       T\n\nREGULAR EXPRESSIONS\n       Ever wanted to know what a regex looked like?  You'll need perl\n       compiled with the DEBUGGING flag for this one:\n\n\t > perl -Dr -e '/^pe(a)*rl$/i'\n\t Compiling REx `^pe(a)*rl$'\n\t size 17 first at 2\n\t rarest char\n\t  at 0\n\t    1: BOL(2)\n\t    2: EXACTF <pe>(4)\n\t    4: CURLYN[1] {0,32767}(14)\n\t    6:\t NOTHING(8)\n\t    8:\t EXACTF <a>(0)\n\t   12:\t WHILEM(0)\n\t   13: NOTHING(14)\n\t   14: EXACTF <rl>(16)\n\t   16: EOL(17)\n\t   17: END(0)\n\t floating `'$ at 4..2147483647 (checking floating) stclass\n\t   `EXACTF <pe>' anchored(BOL) minlen 4\n\t Omitting $` $& $' support."
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use perldebtut to debug a script and inspect variables during the debugging process?
  manpageQuestion3: Can you provide an example of using perldebtut to examine the structure of a regular expression and its internal representation?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nEXECUTING...\n\n\t Freeing REx: `^pe(a)*rl$'\n\n       Did you really want to know? :-) For more gory details on getting\n       regular expressions to work, have a look at perlre, perlretut, and to\n       decode the mysterious labels (BOL and CURLYN, etc. above), see\n       perldebguts.\n\nOUTPUT TIPS\n       To get all the output from your error log, and not miss any messages\n       via helpful operating system buffering, insert a line like this, at the\n       start of your script:\n\n\t       $|=1;\n\n       To watch the tail of a dynamically growing logfile, (from the command\n       line):\n\n\t       tail -f $error_log\n\n       Wrapping all die calls in a handler routine can be useful to see how,\n       and from where, they're being called, perlvar has more information:\n\n\t   BEGIN { $SIG{__DIE__} = sub { require Carp; Carp::confess(@_) } }\n\n       Various useful techniques for the redirection of STDOUT and STDERR\n       filehandles are explained in perlopentut and perlfaq8.\n\nCGI\n       Just a quick hint here for all those CGI programmers who can't figure\n       out how on earth to get past that 'waiting for input' prompt, when\n       running their CGI script from the command-line, try something like\n       this:"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you redirect STDOUT and STDERR in a Perl script to capture all output for debugging purposes?
  manpageQuestion3: What is a recommended method to monitor die calls in a Perl script for debugging?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\n> perl -d my_cgi.pl -nodebug\n\n       Of course CGI and perlfaq9 will tell you more.\n\nGUIs\n       The command line interface is tightly integrated with an emacs\n       extension and there's a vi interface too.\n\n       You don't have to do this all on the command line, though, there are a\n       few GUI options out there.  The nice thing about these is you can wave\n       a mouse over a variable and a dump of its data will appear in an\n       appropriate window, or in a popup balloon, no more tiresome typing of\n       'x $varname' :-)\n\n       In particular have a hunt around for the following:\n\n       ptkdb perlTK based wrapper for the built-in debugger\n\n       ddd data display debugger\n\n       PerlDevKit and PerlBuilder are NT specific\n\n       NB. (more info on these and others would be appreciated).\n\nSUMMARY\n       We've seen how to encourage good coding practices with use strict and\n       -w.  We can run the perl debugger perl -d scriptname to inspect your\n       data from within the perl debugger with the p and x commands.  You can\n       walk through your code, set breakpoints with b and step through that\n       code with s or n, continue with c and return from a sub with r.\tFairly\n       intuitive stuff when you get down to it."
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can you use the perl debugger to inspect and examine variables in a Perl script?
  manpageQuestion3: What are some GUI options available for interacting with the Perl debugger on macOS?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perldebtut`.\n\n\n\nManpage text:\n\nThere is of course lots more to find out about, this has just scratched\n       the surface.  The best way to learn more is to use perldoc to find out\n       more about the language, to read the on-line help (perldebug is\n       probably the next place to go), and of course, experiment.\n\nSEE ALSO\n       perldebug, perldebguts, perl5db.pl, perldiag, perlrun\n\nAUTHOR\n       Richard Foley <richard.foley@rfi.net> Copyright (c) 2000\n\nCONTRIBUTORS\n       Various people have made helpful suggestions and contributions, in\n       particular:\n\n       Ronald J Kimball <rjk@linguist.dartmouth.edu>\n\n       Hugo van der Sanden <hv@crypt0.demon.co.uk>\n\n       Peter Scott <Peter@PSDT.com>\n\nperl v5.34.1\t\t\t  2022-02-19\t\t\t PERLDEBTUT(1)"
  manpageQuestion1: What is the primary purpose of the perldebtut resource?
  manpageQuestion2: How can I use perldebtut to learn more about debugging Perl scripts?
  manpageQuestion3: What resources are recommended for further learning after using perldebtut?

