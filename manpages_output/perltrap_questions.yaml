- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perltrap`.\n\n\n\nManpage text:\n\nPERLTRAP(1)\t       Perl Programmers Reference Guide \t   PERLTRAP(1)\n\n\nNAME\n       perltrap - Perl traps for the unwary\n\nDESCRIPTION\n       The biggest trap of all is forgetting to \"use warnings\" or use the -w\n       switch; see warnings and \"-w\" in perlrun. The second biggest trap is\n       not making your entire program runnable under \"use strict\".  The third\n       biggest trap is not reading the list of changes in this version of\n       Perl; see perldelta.\n\n   Awk Traps\n       Accustomed awk users should take special note of the following:\n\n       •   A Perl program executes only once, not once for each input line.\n\t   You can do an implicit loop with \"-n\" or \"-p\".\n\n       •   The English module, loaded via\n\n\t       use English;\n\n\t   allows you to refer to special variables (like $/) with names (like\n\t   $RS), as though they were in awk; see perlvar for details.\n\n       •   Semicolons are required after all simple statements in Perl (except\n\t   at the end of a block).  Newline is not a statement delimiter.\n\n       •   Curly brackets are required on \"if\"s and \"while\"s.\n\n       •   Variables begin with \"$\", \"@\" or \"%\" in Perl.\n\n       •   Arrays index from 0.  Likewise string positions in substr() and\n\t   index().\n\n       •   You have to decide whether your array has numeric or string\n\t   indices.\n\n       •   Hash values do not spring into existence upon mere reference.\n\n       •   You have to decide whether you want to use string or numeric\n\t   comparisons.\n\n       •   Reading an input line does not split it for you.  You get to split\n\t   it to an array yourself.  And the split() operator has different\n\t   arguments than awk's.\n\n       •   The current input line is normally in $_, not $0.  It generally\n\t   does not have the newline stripped.\t($0 is the name of the program\n\t   executed.)  See perlvar.\n\n       •   $<digit> does not refer to fields--it refers to substrings matched\n\t   by the last match pattern.\n\n       •   The print() statement does not add field and record separators\n\t   unless you set $, and \"$\\\".\tYou can set $OFS and $ORS if you're\n\t   using the English module.\n\n       •   You must open your files before you print to them.\n\n       •   The range operator is \"..\", not comma.  The comma operator works as\n\t   in C.\n\n       •   The match operator is \"=~\", not \"~\".  (\"~\" is the one's complement\n\t   operator, as in C.)\n\n       •   The exponentiation operator is \"**\", not \"^\".  \"^\" is the XOR\n\t   operator, as in C.  (You know, one could get the feeling that awk\n\t   is basically incompatible with C.)\n\n       •   The concatenation operator is \".\", not the null string.  (Using the\n\t   null string would render \"/pat/ /pat/\" unparsable, because the\n\t   third slash would be interpreted as a division operator--the\n\t   tokenizer is in fact slightly context sensitive for operators like\n\t   \"/\", \"?\", and \">\".  And in fact, \".\" itself can be the beginning of\n\t   a number.)\n\n       •   The \"next\", \"exit\", and \"continue\" keywords work differently.\n\n       •   The following variables work differently:\n\n\t\t Awk\t   Perl\n\t\t ARGC\t   scalar @ARGV (compare with $#ARGV)\n\t\t ARGV[0]   $0\n\t\t FILENAME  $ARGV\n\t\t FNR\t   $. - something\n\t\t FS\t   (whatever you like)\n\t\t NF\t   $#Fld, or some such\n\t\t NR\t   $.\n\t\t OFMT\t   $#\n\t\t OFS\t   $,\n\t\t ORS\t   $\\\n\t\t RLENGTH   length($&)\n\t\t RS\t   $/\n\t\t RSTART    length($`)\n\t\t SUBSEP    $;\n\n       •   You cannot set $RS to a pattern, only a string.\n\n       •   When in doubt, run the awk construct through a2p and see what it\n\t   gives you.\n\n   C/C++ Traps\n       Cerebral C and C++ programmers should take note of the following:\n\n       •   Curly brackets are required on \"if\"'s and \"while\"'s.\n\n       •   You must use \"elsif\" rather than \"else if\".\n\n       •   The \"break\" and \"continue\" keywords from C become in Perl \"last\"\n\t   and \"next\", respectively.  Unlike in C, these do not work within a\n\t   \"do { } while\" construct.  See \"Loop Control\" in perlsyn.\n\n       •   The switch statement is called \"given\"/\"when\" and only available in\n\t   perl 5.10 or newer.\tSee \"Switch Statements\" in perlsyn.\n\n       •   Variables begin with \"$\", \"@\" or \"%\" in Perl.\n\n       •   Comments begin with \"#\", not \"/*\" or \"//\".  Perl may interpret\n\t   C/C++ comments as division operators, unterminated regular\n\t   expressions or the defined-or operator.\n\n       •   You can't take the address of anything, although a similar operator\n\t   in Perl is the backslash, which creates a reference.\n\n       •   \"ARGV\" must be capitalized.\t$ARGV[0] is C's \"argv[1]\", and\n\t   \"argv[0]\" ends up in $0.\n\n       •   System calls such as link(), unlink(), rename(), etc. return\n\t   nonzero for success, not 0. (system(), however, returns zero for\n\t   success.)\n\n       •   Signal handlers deal with signal names, not numbers.  Use \"kill -l\"\n\t   to find their names on your system.\n\n   JavaScript Traps\n       Judicious JavaScript programmers should take note of the following:\n\n       •   In Perl, binary \"+\" is always addition.  \"$string1 + $string2\"\n\t   converts both strings to numbers and then adds them.  To\n\t   concatenate two strings, use the \".\" operator.\n\n       •   The \"+\" unary operator doesn't do anything in Perl.\tIt exists to\n\t   avoid syntactic ambiguities.\n\n       •   Unlike \"for...in\", Perl's \"for\" (also spelled \"foreach\") does not\n\t   allow the left-hand side to be an arbitrary expression.  It must be\n\t   a variable:\n\n\t      for my $variable (keys %hash) {\n\t\t   ...\n\t      }\n\n\t   Furthermore, don't forget the \"keys\" in there, as \"foreach my $kv\n\t   (%hash) {}\" iterates over the keys and values, and is generally not\n\t   useful ($kv would be a key, then a value, and so on).\n\n       •   To iterate over the indices of an array, use \"foreach my $i (0 ..\n\t   $#array) {}\".  \"foreach my $v (@array) {}\" iterates over the\n\t   values.\n\n       •   Perl requires braces following \"if\", \"while\", \"foreach\", etc.\n\n       •   In Perl, \"else if\" is spelled \"elsif\".\n\n       •   \"? :\" has higher precedence than assignment.  In JavaScript, one\n\t   can write:\n\n\t       condition ? do_something() : variable = 3\n\n\t   and the variable is only assigned if the condition is false.  In\n\t   Perl, you need parentheses:\n\n\t       $condition ? do_something() : ($variable = 3);\n\n\t   Or just use \"if\".\n\n       •   Perl requires semicolons to separate statements.\n\n       •   Variables declared with \"my\" only affect code after the\n\t   declaration.  You cannot write \"$x = 1; my $x;\" and expect the\n\t   first assignment to affect the same variable.  It will instead\n\t   assign to an $x declared previously in an outer scope, or to a\n\t   global variable.\n\n\t   Note also that the variable is not visible until the following\n\t   statement.  This means that in \"my $x = 1 + $x\" the second $x\n\t   refers to one declared previously.\n\n       •   \"my\" variables are scoped to the current block, not to the current\n\t   function.  If you write \"{my $x;} $x;\", the second $x does not\n\t   refer to the one declared inside the block.\n\n       •   An object's members cannot be made accessible as variables.\tThe\n\t   closest Perl equivalent to \"with(object) { method() }\" is \"for\",\n\t   which can alias $_ to the object:\n\n\t       for ($object) {\n\t\t   $_->method;\n\t       }\n\n       •   The object or class on which a method is called is passed as one of\n\t   the method's arguments, not as a separate \"this\" value.\n\n   Sed Traps\n       Seasoned sed programmers should take note of the following:\n\n       •   A Perl program executes only once, not once for each input line.\n\t   You can do an implicit loop with \"-n\" or \"-p\".\n\n       •   Backreferences in substitutions use \"$\" rather than \"\\\".\n\n       •   The pattern matching metacharacters \"(\", \")\", and \"|\" do not have\n\t   backslashes in front.\n\n       •   The range operator is \"...\", rather than comma.\n\n   Shell Traps\n       Sharp shell programmers should take note of the following:\n\n       •   The backtick operator does variable interpolation without regard to\n\t   the presence of single quotes in the command.\n\n       •   The backtick operator does no translation of the return value,\n\t   unlike csh.\n\n       •   Shells (especially csh) do several levels of substitution on each\n\t   command line.  Perl does substitution in only certain constructs\n\t   such as double quotes, backticks, angle brackets, and search\n\t   patterns.\n\n       •   Shells interpret scripts a little bit at a time.  Perl compiles the\n\t   entire program before executing it (except for \"BEGIN\" blocks,\n\t   which execute at compile time).\n\n       •   The arguments are available via @ARGV, not $1, $2, etc.\n\n       •   The environment is not automatically made available as separate\n\t   scalar variables.\n\n       •   The shell's \"test\" uses \"=\", \"!=\", \"<\" etc for string comparisons\n\t   and \"-eq\", \"-ne\", \"-lt\" etc for numeric comparisons. This is the\n\t   reverse of Perl, which uses \"eq\", \"ne\", \"lt\" for string\n\t   comparisons, and \"==\", \"!=\" \"<\" etc for numeric comparisons.\n\n   Perl Traps\n       Practicing Perl Programmers should take note of the following:\n\n       •   Remember that many operations behave differently in a list context\n\t   than they do in a scalar one.  See perldata for details.\n\n       •   Avoid barewords if you can, especially all lowercase ones.  You\n\t   can't tell by just looking at it whether a bareword is a function\n\t   or a string.  By using quotes on strings and parentheses on\n\t   function calls, you won't ever get them confused.\n\n       •   You cannot discern from mere inspection which builtins are unary\n\t   operators (like chop() and chdir()) and which are list operators\n\t   (like print() and unlink()).  (Unless prototyped, user-defined\n\t   subroutines can only be list operators, never unary ones.)  See\n\t   perlop and perlsub.\n\n       •   People have a hard time remembering that some functions default to\n\t   $_, or @ARGV, or whatever, but that others which you might expect\n\t   to do not.\n\n       •   The <FH> construct is not the name of the filehandle, it is a\n\t   readline operation on that handle.  The data read is assigned to $_\n\t   only if the file read is the sole condition in a while loop:\n\n\t       while (<FH>)\t { }\n\t       while (defined($_ = <FH>)) { }..\n\t       <FH>;  # data discarded!\n\n       •   Remember not to use \"=\" when you need \"=~\"; these two constructs\n\t   are quite different:\n\n\t       $x =  /foo/;\n\t       $x =~ /foo/;\n\n       •   The \"do {}\" construct isn't a real loop that you can use loop\n\t   control on.\n\n       •   Use \"my()\" for local variables whenever you can get away with it\n\t   (but see perlform for where you can't).  Using \"local()\" actually\n\t   gives a local value to a global variable, which leaves you open to\n\t   unforeseen side-effects of dynamic scoping.\n\n       •   If you localize an exported variable in a module, its exported\n\t   value will not change.  The local name becomes an alias to a new\n\t   value but the external name is still an alias for the original.\n\n       As always, if any of these are ever officially declared as bugs,\n       they'll be fixed and removed.\n\nperl v5.34.1\t\t\t  2022-02-19\t\t\t   PERLTRAP(1)"
  manpageQuestion1: What is the primary purpose of the perltrap resource?
  manpageQuestion2: How can Perl programmers avoid common pitfalls when working with the English module and special variables?
  manpageQuestion3: What are some key differences between Perl and awk when handling input lines and special variables like $0, $ARGV, and FILENAME?

