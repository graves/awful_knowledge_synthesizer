- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `sample`.\n\n\n\nManpage text:\n\nsample(1)\t\t    General Commands Manual\t\t     sample(1)\n\nNAME\n     sample â€“ Profile a process during a time interval\n\nSYNOPSIS\n     sample pid | partial-executable-name [duration [samplingInterval]]\n\t    [-wait] [-mayDie] [-fullPaths] [-e] [-file filename]\n\nDESCRIPTION\n     sample is a command-line tool for gathering data about the running\n     behavior of a process.  It suspends the process at specified intervals\n     (by default, every 1 millisecond), records the call stacks of all threads\n     in the process at that time, then resumes the process.  The analysis done\n     by sample is called ``sampling'' because it only checks the state of the\n     program at the sampling points.  The analysis may miss execution of some\n     functions that are not executing during one of the samples, but sample\n     still provides useful data about commonly executing functions.\n\n     At the end of the sampling duration, sample produces a report showing\n     which functions were executing during the sampling.  The data is\n     condensed into a call tree, showing the functions seen on the stack and\n     how they were called.  (This tree is a subset of the actual call tree for\n     the execution, since some functions may not have been executing during\n     any of the sampling events.)  The tree is displayed textually, with\n     called functions indented one level to the right of the callee."
  manpageQuestion1: What is the primary purpose of the sample command?
  manpageQuestion2: How would you use the sample command to profile a process with PID 1234 for 5 seconds, sampling every 0.5 milliseconds?
  manpageQuestion3: Can you provide an example of using the sample command to profile a process named 'myapp' and save the output to a file called 'profile.txt'?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `sample`.\n\n\n\nManpage text:\n\nIn the call tree, if a function calls more than one function then a\n     vertical line is printed to visually connect those separate children\n     functions, making it easier to see which functions are at the same level.\n     The characters used to draw those lines, such as + | : ! are arbitrary\n     and have no specific meaning.\n\nARGUMENTS\n     The user of sample specifies a target process (either by process id, or\n     by name), the duration of the sampling run (in seconds), and a sampling\n     rate (in milliseconds).\n\n     If the sampling duration is not specified, a default of 10 seconds is\n     used.  Longer sampling durations provide better data by collecting more\n     samples, but could also be confusing if the target process performs many\n     different types of operations during that period.\n\n     The default sampling rate is 1 millisecond.  Fast sampling rates provide\n     more samples and a better chance to capture all the functions that are\n     executing.\n\n     -wait tells sample to wait for the process specified (usually as a\n     partial name or hint) to exist, then start sampling that process.\tThis\n     option allows you to sample from an application's launch."
  manpageQuestion1: What is the primary purpose of the sample tool?
  manpageQuestion2: How would you use the sample command to profile a process named 'myapp' for 15 seconds with a sampling rate of 2 milliseconds?
  manpageQuestion3: Can you provide an example of using the sample tool with the -wait option to start sampling after waiting for a process named 'myprocess' to exist?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `sample`.\n\n\n\nManpage text:\n\n-mayDie tells sample to immediately grab the location of symbols from the\n     application, on the assumption that the application may exit or crash at\n     any point during the sampling.  This ensures that sample can give\n     information about the call stacks even if the process no longer exists.\n\n     -fullPaths tells sample to show the full path to the source code (rather\n     than just the file name) for any symbol in a binary image for which debug\n     information is available.\tThe full path was the path to the source code\n     when the binary image was built.\n\n     -e tells sample to open the output in TextEdit automatically when\n     sampling completes.\n\n     -file filename tells sample the full path to where the output should be\n     written.  If this flag is not specified, results are written to a file in\n     /tmp called <application name>_<date>_<time>.<XXXX>.sample.txt, where\n     each 'X' is replaced by a random alphanumeric character.\n\n     If neither the -e nor -file flags are given, the output gets written to\n     stdout as well as saved to the file in /tmp."
  manpageQuestion1: What is the primary purpose of the sample tool?
  manpageQuestion2: How would you use the sample tool to generate a profiling output file with full source paths and save it to a specific location?
  manpageQuestion3: Can you provide an example of using the sample tool to automatically open the output in TextEdit after sampling completes?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `sample`.\n\n\n\nManpage text:\n\nSEE ALSO\n     filtercalltree(1), spindump(8)\n\n     The Xcode developer tools also include Instruments, a graphical\n     application that can give information similar to that provided by sample.\n     The Time Profiler instrument graphically displays dynamic, real-time CPU\n     sampling information.\n\nmacOS 15.3\t\t\t Mar. 16, 2013\t\t\t    macOS 15.3"
  manpageQuestion1: What is the primary purpose of the 'sample' tool?
  manpageQuestion2: How can you use 'sample' to profile the CPU usage of a running process with dynamic sampling?
  manpageQuestion3: What are some alternatives to the 'sample' tool for CPU profiling on macOS?

