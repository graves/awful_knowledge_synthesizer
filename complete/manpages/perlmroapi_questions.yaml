- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlmroapi`.\n\n\n\nManpage text:\n\nPERLMROAPI(1)\t       Perl Programmers Reference Guide \t PERLMROAPI(1)\n\n\nNAME\n       perlmroapi - Perl method resolution plugin interface\n\nDESCRIPTION\n       As of Perl 5.10.1 there is a new interface for plugging and using\n       method resolution orders other than the default (linear depth first\n       search).  The C3 method resolution order added in 5.10.0 has been re-\n       implemented as a plugin, without changing its Perl-space interface.\n\n       Each plugin should register itself by providing the following structure\n\n\t   struct mro_alg {\n\t       AV *(*resolve)(pTHX_ HV *stash, U32 level);\n\t       const char *name;\n\t       U16 length;\n\t       U16 kflags;\n\t       U32 hash;\n\t   };\n\n       and calling \"Perl_mro_register\":\n\n\t   Perl_mro_register(aTHX_ &my_mro_alg);\n\n       resolve\n\t   Pointer to the linearisation function, described below.\n\n       name\n\t   Name of the MRO, either in ISO-8859-1 or UTF-8.\n\n       length\n\t   Length of the name.\n\n       kflags\n\t   If the name is given in UTF-8, set this to \"HVhek_UTF8\". The value\n\t   is passed direct as the parameter kflags to \"hv_common()\".\n\n       hash\n\t   A precomputed hash value for the MRO's name, or 0.\n\nCallbacks\n       The \"resolve\" function is called to generate a linearised ISA for the\n       given stash, using this MRO. It is called with a pointer to the stash,\n       and a level of 0. The core always sets level to 0 when it calls your\n       function - the parameter is provided to allow your implementation to\n       track depth if it needs to recurse.\n\n       The function should return a reference to an array containing the\n       parent classes in order. The names of the classes should be the result\n       of calling \"HvENAME()\" on the stash. In those cases where \"HvENAME()\"\n       returns null, \"HvNAME()\" should be used instead.\n\n       The caller is responsible for incrementing the reference count of the\n       array returned if it wants to keep the structure. Hence, if you have\n       created a temporary value that you keep no pointer to, \"sv_2mortal()\"\n       to ensure that it is disposed of correctly. If you have cached your\n       return value, then return a pointer to it without changing the\n       reference count.\n\nCaching\n       Computing MROs can be expensive. The implementation provides a cache,\n       in which you can store a single \"SV *\", or anything that can be cast to\n       \"SV *\", such as \"AV *\". To read your private value, use the macro\n       \"MRO_GET_PRIVATE_DATA()\", passing it the \"mro_meta\" structure from the\n       stash, and a pointer to your \"mro_alg\" structure:\n\n\t   meta = HvMROMETA(stash);\n\t   private_sv = MRO_GET_PRIVATE_DATA(meta, &my_mro_alg);\n\n       To set your private value, call \"Perl_mro_set_private_data()\":\n\n\t   Perl_mro_set_private_data(aTHX_ meta, &c3_alg, private_sv);\n\n       The private data cache will take ownership of a reference to\n       private_sv, much the same way that \"hv_store()\" takes ownership of a\n       reference to the value that you pass it.\n\nExamples\n       For examples of MRO implementations, see \"S_mro_get_linear_isa_c3()\"\n       and the \"BOOT:\" section of ext/mro/mro.xs, and\n       \"S_mro_get_linear_isa_dfs()\" in mro_core.c\n\nAUTHORS\n       The implementation of the C3 MRO and switchable MROs within the perl\n       core was written by Brandon L Black. Nicholas Clark created the\n       pluggable interface, refactored Brandon's implementation to work with\n       it, and wrote this document.\n\nperl v5.34.1\t\t\t  2022-02-19\t\t\t PERLMROAPI(1)"
  manpageQuestion1: What is the primary purpose of the perlmroapi tool?
  manpageQuestion2: How would you implement a custom method resolution order (MRO) plugin using perlmroapi?
  manpageQuestion3: Can you explain how to cache private data when using perlmroapi for MRO plugins?

