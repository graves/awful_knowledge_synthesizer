- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/upgrade.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
    mod support;
    use support::server;
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    #[tokio::test]
    async fn http_upgrade() {
        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.headers()["connection"], "upgrade");
            assert_eq!(req.headers()["upgrade"], "foobar");

            tokio::spawn(async move {
                let mut upgraded = hyper_util::rt::TokioIo::new(hyper::upgrade::on(req).await.unwrap());

                let mut buf = vec![0; 7];
                upgraded.read_exact(&mut buf).await.unwrap();
                assert_eq!(buf, b"foo=bar");

                upgraded.write_all(b"bar=foo").await.unwrap();
            });

            async {
                http::Response::builder()
                    .status(http::StatusCode::SWITCHING_PROTOCOLS)
                    .header(http::header::CONNECTION, "upgrade")
                    .header(http::header::UPGRADE, "foobar")
                    .body(reqwest::Body::default())
                    .unwrap()
            }
        });

        let res = reqwest::Client::builder()
            .build()
            .unwrap()
            .get(format!("http://{}", server.addr()))
            .header(http::header::CONNECTION, "upgrade")
            .header(http::header::UPGRADE, "foobar")
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), http::StatusCode::SWITCHING_PROTOCOLS);
        let mut upgraded = res.upgrade().await.unwrap();

        upgraded.write_all(b"foo=bar").await.unwrap();

        let mut buf = vec![];
        upgraded.read_to_end(&mut buf).await.unwrap();
        assert_eq!(buf, b"bar=foo");
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP/1.1 Upgrade requests and what system calls or libraries are used to manage the connection switch?
  codeQuestion3: What steps are taken to verify and process the HTTP headers during the upgrade process?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/badssl.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]

    #[cfg(all(feature = "__tls", not(feature = "rustls-tls-manual-roots")))]
    #[tokio::test]
    async fn test_badssl_modern() {
        let text = reqwest::Client::builder()
            .no_proxy()
            .build()
            .unwrap()
            .get("https://mozilla-modern.badssl.com/")
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();

        assert!(text.contains("<title>mozilla-modern.badssl.com</title>"));
    }

    #[cfg(any(
        feature = "rustls-tls-webpki-roots-no-provider",
        feature = "rustls-tls-native-roots-no-provider"
    ))]
    #[tokio::test]
    async fn test_rustls_badssl_modern() {
        let text = reqwest::Client::builder()
            .use_rustls_tls()
            .no_proxy()
            .build()
            .unwrap()
            .get("https://mozilla-modern.badssl.com/")
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();

        assert!(text.contains("<title>mozilla-modern.badssl.com</title>"));
    }

    #[cfg(feature = "__tls")]
    #[tokio::test]
    async fn test_badssl_self_signed() {
        let text = reqwest::Client::builder()
            .danger_accept_invalid_certs(true)
            .no_proxy()
            .build()
            .unwrap()
            .get("https://self-signed.badssl.com/")
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();

        assert!(text.contains("<title>self-signed.badssl.com</title>"));
    }

    #[cfg(feature = "__tls")]
    #[tokio::test]
    async fn test_badssl_no_built_in_roots() {
        let result = reqwest::Client::builder()
            .tls_built_in_root_certs(false)
            .no_proxy()
            .build()
            .unwrap()
            .get("https://mozilla-modern.badssl.com/")
            .send()
            .await;

        assert!(result.is_err());
    }

    #[cfg(any(feature = "native-tls", feature = "rustls-tls"))]
    #[tokio::test]
    async fn test_badssl_wrong_host() {
        let text = reqwest::Client::builder()
            .danger_accept_invalid_hostnames(true)
            .no_proxy()
            .build()
            .unwrap()
            .get("https://wrong.host.badssl.com/")
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();

        assert!(text.contains("<title>wrong.host.badssl.com</title>"));

        let result = reqwest::Client::builder()
            .danger_accept_invalid_hostnames(true)
            .build()
            .unwrap()
            .get("https://self-signed.badssl.com/")
            .send()
            .await;

        assert!(result.is_err());
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure the HTTP client to accept invalid SSL certificates for a specific test case?
  codeQuestion3: What steps are taken to configure the client to use a different set of root certificates when making an HTTPS request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/timeouts.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
    mod support;
    use support::server;

    use std::time::Duration;

    #[tokio::test]
    async fn client_timeout() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| {
            async {
                // delay returning the response
                tokio::time::sleep(Duration::from_millis(300)).await;
                http::Response::default()
            }
        });

        let client = reqwest::Client::builder()
            .timeout(Duration::from_millis(100))
            .no_proxy()
            .build()
            .unwrap();

        let url = format!("http://{}/slow", server.addr());

        let res = client.get(&url).send().await;

        let err = res.unwrap_err();

        assert!(err.is_timeout());
        assert_eq!(err.url().map(|u| u.as_str()), Some(url.as_str()));
    }

    #[tokio::test]
    async fn request_timeout() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| {
            async {
                // delay returning the response
                tokio::time::sleep(Duration::from_millis(300)).await;
                http::Response::default()
            }
        });

        let client = reqwest::Client::builder().no_proxy().build().unwrap();

        let url = format!("http://{}/slow", server.addr());

        let res = client
            .get(&url)
            .timeout(Duration::from_millis(100))
            .send()
            .await;

        let err = res.unwrap_err();

        if cfg!(not(target_arch = "wasm32")) {
            assert!(err.is_timeout() && !err.is_connect());
        } else {
            assert!(err.is_timeout());
        }
        assert_eq!(err.url().map(|u| u.as_str()), Some(url.as_str()));
    }

    #[tokio::test]
    async fn connect_timeout() {
        let _ = env_logger::try_init();

        let client = reqwest::Client::builder()
            .connect_timeout(Duration::from_millis(100))
            .no_proxy()
            .build()
            .unwrap();

        let url = "http://192.0.2.1:81/slow";

        let res = client
            .get(url)
            .timeout(Duration::from_millis(1000))
            .send()
            .await;

        let err = res.unwrap_err();

        assert!(err.is_connect() && err.is_timeout());
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn connect_many_timeout_succeeds() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });
        let port = server.addr().port();

        let client = reqwest::Client::builder()
            .resolve_to_addrs(
                "many_addrs",
                &["192.0.2.1:81".parse().unwrap(), server.addr()],
            )
            .connect_timeout(Duration::from_millis(100))
            .no_proxy()
            .build()
            .unwrap();

        let url = format!("http://many_addrs:{port}/eventual");

        let _res = client
            .get(url)
            .timeout(Duration::from_millis(1000))
            .send()
            .await
            .unwrap();
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn connect_many_timeout() {
        let _ = env_logger::try_init();

        let client = reqwest::Client::builder()
            .resolve_to_addrs(
                "many_addrs",
                &[
                    "192.0.2.1:81".parse().unwrap(),
                    "192.0.2.2:81".parse().unwrap(),
                ],
            )
            .connect_timeout(Duration::from_millis(100))
            .no_proxy()
            .build()
            .unwrap();

        let url = "http://many_addrs:81/slow".to_string();

        let res = client
            .get(url)
            .timeout(Duration::from_millis(1000))
            .send()
            .await;

        let err = res.unwrap_err();

        assert!(err.is_connect() && err.is_timeout());
    }

    #[cfg(feature = "stream")]
    #[tokio::test]
    async fn response_timeout() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| {
            async {
                // immediate response, but delayed body
                let body = reqwest::Body::wrap_stream(futures_util::stream::once(async {
                    tokio::time::sleep(Duration::from_secs(1)).await;
                    Ok::<_, std::convert::Infallible>("Hello")
                }));

                http::Response::new(body)
            }
        });

        let client = reqwest::Client::builder()
            .timeout(Duration::from_millis(500))
            .no_proxy()
            .build()
            .unwrap();

        let url = format!("http://{}/slow", server.addr());
        let res = client.get(&url).send().await.expect("Failed to get");
        let body = res.text().await;

        let err = body.unwrap_err();

        assert!(err.is_timeout());
    }

    #[tokio::test]
    async fn read_timeout_applies_to_headers() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| {
            async {
                // delay returning the response
                tokio::time::sleep(Duration::from_millis(300)).await;
                http::Response::default()
            }
        });

        let client = reqwest::Client::builder()
            .read_timeout(Duration::from_millis(100))
            .no_proxy()
            .build()
            .unwrap();

        let url = format!("http://{}/slow", server.addr());

        let res = client.get(&url).send().await;

        let err = res.unwrap_err();

        assert!(err.is_timeout());
        assert_eq!(err.url().map(|u| u.as_str()), Some(url.as_str()));
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `client_timeout` test demonstrate handling a timeout for a request, and what APIs are used to set the timeout?
  codeQuestion3: What steps are taken in the `connect_timeout` test to handle connection-related timeouts, and how do the APIs differ from request timeouts?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/timeouts.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "stream")]
    #[tokio::test]
    async fn read_timeout_applies_to_body() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| {
            async {
                // immediate response, but delayed body
                let body = reqwest::Body::wrap_stream(futures_util::stream::once(async {
                    tokio::time::sleep(Duration::from_millis(300)).await;
                    Ok::<_, std::convert::Infallible>("Hello")
                }));

                http::Response::new(body)
            }
        });

        let client = reqwest::Client::builder()
            .read_timeout(Duration::from_millis(100))
            .no_proxy()
            .build()
            .unwrap();

        let url = format!("http://{}/slow", server.addr());
        let res = client.get(&url).send().await.expect("Failed to get");
        let body = res.text().await;

        let err = body.unwrap_err();

        assert!(err.is_timeout());
    }

    #[cfg(feature = "stream")]
    #[tokio::test]
    async fn read_timeout_allows_slow_response_body() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| {
            async {
                // immediate response, but body that has slow chunks

                let slow = futures_util::stream::unfold(0, |state| async move {
                    if state < 3 {
                        tokio::time::sleep(Duration::from_millis(100)).await;
                        Some((
                            Ok::<_, std::convert::Infallible>(state.to_string()),
                            state + 1,
                        ))
                    } else {
                        None
                    }
                });
                let body = reqwest::Body::wrap_stream(slow);

                http::Response::new(body)
            }
        });

        let client = reqwest::Client::builder()
            .read_timeout(Duration::from_millis(200))
            //.timeout(Duration::from_millis(200))
            .no_proxy()
            .build()
            .unwrap();

        let url = format!("http://{}/slow", server.addr());
        let res = client.get(&url).send().await.expect("Failed to get");
        let body = res.text().await.expect("body text");

        assert_eq!(body, "012");
    }

    /// Tests that internal client future cancels when the oneshot channel
    /// is canceled.
    #[cfg(feature = "blocking")]
    #[test]
    fn timeout_closes_connection() {
        let _ = env_logger::try_init();

        // Make Client drop *after* the Server, so the background doesn't
        // close too early.
        let client = reqwest::blocking::Client::builder()
            .timeout(Duration::from_millis(500))
            .build()
            .unwrap();

        let server = server::http(move |_req| {
            async {
                // delay returning the response
                tokio::time::sleep(Duration::from_secs(2)).await;
                http::Response::default()
            }
        });

        let url = format!("http://{}/closes", server.addr());
        let err = client.get(&url).send().unwrap_err();

        assert!(err.is_timeout());
        assert_eq!(err.url().map(|u| u.as_str()), Some(url.as_str()));
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn timeout_blocking_request() {
        let _ = env_logger::try_init();

        // Make Client drop *after* the Server, so the background doesn't
        // close too early.
        let client = reqwest::blocking::Client::builder().build().unwrap();

        let server = server::http(move |_req| {
            async {
                // delay returning the response
                tokio::time::sleep(Duration::from_secs(2)).await;
                http::Response::default()
            }
        });

        let url = format!("http://{}/closes", server.addr());
        let err = client
            .get(&url)
            .timeout(Duration::from_millis(500))
            .send()
            .unwrap_err();

        assert!(err.is_timeout());
        assert_eq!(err.url().map(|u| u.as_str()), Some(url.as_str()));
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn connect_timeout_blocking_request() {
        let _ = env_logger::try_init();

        let client = reqwest::blocking::Client::builder()
            .connect_timeout(Duration::from_millis(100))
            .build()
            .unwrap();

        // never returns
        let url = "http://192.0.2.1:81/slow";

        let err = client.get(url).send().unwrap_err();

        assert!(err.is_timeout());
    }

    #[cfg(feature = "blocking")]
    #[cfg(feature = "stream")]
    #[test]
    fn blocking_request_timeout_body() {
        let _ = env_logger::try_init();

        let client = reqwest::blocking::Client::builder()
            // this should be overridden
            .connect_timeout(Duration::from_millis(200))
            // this should be overridden
            .timeout(Duration::from_millis(200))
            .build()
            .unwrap();

        let server = server::http(move |_req| {
            async {
                // immediate response, but delayed body
                let body = reqwest::Body::wrap_stream(futures_util::stream::once(async {
                    tokio::time::sleep(Duration::from_secs(1)).await;
                    Ok::<_, std::convert::Infallible>("Hello")
                }));

                http::Response::new(body)
            }
        });

        let url = format!("http://{}/closes", server.addr());
        let res = client
            .get(&url)
            // longer than client timeout
            .timeout(Duration::from_secs(5))
            .send()
            .expect("get response");

        let text = res.text().unwrap();
        assert_eq!(text, "Hello");
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `read_timeout` feature work in the `reqwest` library, and how can it be applied to a request's body?
  codeQuestion3: What steps are taken in the `blocking_request_timeout_body` test to ensure that a request with a specified timeout is handled correctly, and how does the timeout interact with the body's loading time?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/timeouts.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "blocking")]
    #[test]
    fn write_timeout_large_body() {
        let _ = env_logger::try_init();
        let body = vec![b'x'; 20_000];
        let len = 8192;

        // Make Client drop *after* the Server, so the background doesn't
        // close too early.
        let client = reqwest::blocking::Client::builder()
            .timeout(Duration::from_millis(500))
            .build()
            .unwrap();

        let server = server::http(move |_req| {
            async {
                // delay returning the response
                tokio::time::sleep(Duration::from_secs(2)).await;
                http::Response::default()
            }
        });

        let cursor = std::io::Cursor::new(body);
        let url = format!("http://{}/write-timeout", server.addr());
        let err = client
            .post(&url)
            .body(reqwest::blocking::Body::sized(cursor, len as u64))
            .send()
            .unwrap_err();

        assert!(err.is_timeout());
        assert_eq!(err.url().map(|u| u.as_str()), Some(url.as_str()));
    }

    #[tokio::test]
    async fn response_body_timeout_forwards_size_hint() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::new(b"hello".to_vec().into()) });

        let client = reqwest::Client::builder().no_proxy().build().unwrap();

        let url = format!("http://{}/slow", server.addr());

        let res = client
            .get(&url)
            .timeout(Duration::from_secs(1))
            .send()
            .await
            .expect("response");

        assert_eq!(res.content_length(), Some(5));
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle a timeout for a large body request, and what system calls or functions are involved in this scenario?
  codeQuestion3: What steps are taken to handle the response body timeout and ensure that the size hint is correctly forwarded to the client?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
    mod support;
    use support::server;

    use std::env;

    use once_cell::sync::Lazy;
    use tokio::sync::Mutex;

    // serialize tests that read from / write to environment variables
    static HTTP_PROXY_ENV_MUTEX: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));

    #[tokio::test]
    async fn http_proxy() {
        let url = "http://hyper.rs/prox";
        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.uri(), url);
            assert_eq!(req.headers()["host"], "hyper.rs");

            async { http::Response::default() }
        });

        let proxy = format!("http://{}", server.addr());

        let res = reqwest::Client::builder()
            .proxy(reqwest::Proxy::http(&proxy).unwrap())
            .build()
            .unwrap()
            .get(url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn http_proxy_basic_auth() {
        let url = "http://hyper.rs/prox";
        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.uri(), url);
            assert_eq!(req.headers()["host"], "hyper.rs");
            assert_eq!(
                req.headers()["proxy-authorization"],
                "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
            );

            async { http::Response::default() }
        });

        let proxy = format!("http://{}", server.addr());

        let res = reqwest::Client::builder()
            .proxy(
                reqwest::Proxy::http(&proxy)
                    .unwrap()
                    .basic_auth("Aladdin", "open sesame"),
            )
            .build()
            .unwrap()
            .get(url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn http_proxy_basic_auth_parsed() {
        let url = "http://hyper.rs/prox";
        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.uri(), url);
            assert_eq!(req.headers()["host"], "hyper.rs");
            assert_eq!(
                req.headers()["proxy-authorization"],
                "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
            );

            async { http::Response::default() }
        });

        let proxy = format!("http://Aladdin:open sesame@{}", server.addr());

        let res = reqwest::Client::builder()
            .proxy(reqwest::Proxy::http(&proxy).unwrap())
            .build()
            .unwrap()
            .get(url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn system_http_proxy_basic_auth_parsed() {
        let url = "http://hyper.rs/prox";
        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.uri(), url);
            assert_eq!(req.headers()["host"], "hyper.rs");
            assert_eq!(
                req.headers()["proxy-authorization"],
                "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
            );

            async { http::Response::default() }
        });

        // avoid races with other tests that change "http_proxy"
        let _env_lock = HTTP_PROXY_ENV_MUTEX.lock().await;

        // save system setting first.
        let system_proxy = env::var("http_proxy");

        // set-up http proxy.
        env::set_var(
            "http_proxy",
            format!("http://Aladdin:open sesame@{}", server.addr()),
        );

        let res = reqwest::Client::builder()
            .build()
            .unwrap()
            .get(url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);

        // reset user setting.
        match system_proxy {
            Err(_) => env::remove_var("http_proxy"),
            Ok(proxy) => env::set_var("http_proxy", proxy),
        }
    }

    #[tokio::test]
    async fn test_no_proxy() {
        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.uri(), "/4");

            async { http::Response::default() }
        });
        let proxy = format!("http://{}", server.addr());
        let url = format!("http://{}/4", server.addr());

        // set up proxy and use no_proxy to clear up client builder proxies.
        let res = reqwest::Client::builder()
            .proxy(reqwest::Proxy::http(&proxy).unwrap())
            .no_proxy()
            .build()
            .unwrap()
            .get(&url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn test_using_system_proxy() {
        let url = "http://not.a.real.sub.hyper.rs/prox";
        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.uri(), url);
            assert_eq!(req.headers()["host"], "not.a.real.sub.hyper.rs");

            async { http::Response::default() }
        });

        // avoid races with other tests that change "http_proxy"
        let _env_lock = HTTP_PROXY_ENV_MUTEX.lock().await;

        // save system setting first.
        let system_proxy = env::var("http_proxy");
        // set-up http proxy.
        env::set_var("http_proxy", format!("http://{}", server.addr()));

        // system proxy is used by default
        let res = reqwest::get(url).await.unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);

        // reset user setting.
        match system_proxy {
            Err(_) => env::remove_var("http_proxy"),
            Ok(proxy) => env::set_var("http_proxy", proxy),
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure a proxy with basic authentication and handle the corresponding headers in a request?
  codeQuestion3: What steps are taken to ensure that the client uses the system proxy settings when making HTTP requests?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn http_over_http() {
        let url = "http://hyper.rs/prox";

        let server = server::http(move |req| {
            assert_eq!(req.method(), "GET");
            assert_eq!(req.uri(), url);
            assert_eq!(req.headers()["host"], "hyper.rs");

            async { http::Response::default() }
        });

        let proxy = format!("http://{}", server.addr());

        let res = reqwest::Client::builder()
            .proxy(reqwest::Proxy::http(&proxy).unwrap())
            .build()
            .unwrap()
            .get(url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code demonstrate the use of reqwest's proxy functionality, and what steps are taken to verify that the request is properly proxied?
  codeQuestion3: What system calls or APIs are used to handle the HTTP server and client interactions in this test?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/redirect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
    mod support;
    use http_body_util::BodyExt;
    use reqwest::Body;
    use support::server;

    #[tokio::test]
    async fn test_redirect_301_and_302_and_303_changes_post_to_get() {
        let client = reqwest::Client::new();
        let codes = [301u16, 302, 303];

        for &code in &codes {
            let redirect = server::http(move |req| async move {
                if req.method() == "POST" {
                    assert_eq!(req.uri(), &*format!("/{code}"));
                    http::Response::builder()
                        .status(code)
                        .header("location", "/dst")
                        .header("server", "test-redirect")
                        .body(Body::default())
                        .unwrap()
                } else {
                    assert_eq!(req.method(), "GET");

                    http::Response::builder()
                        .header("server", "test-dst")
                        .body(Body::default())
                        .unwrap()
                }
            });

            let url = format!("http://{}/{}", redirect.addr(), code);
            let dst = format!("http://{}/{}", redirect.addr(), "dst");
            let res = client.post(&url).send().await.unwrap();
            assert_eq!(res.url().as_str(), dst);
            assert_eq!(res.status(), reqwest::StatusCode::OK);
            assert_eq!(
                res.headers().get(reqwest::header::SERVER).unwrap(),
                &"test-dst"
            );
        }
    }

    #[tokio::test]
    async fn test_redirect_307_and_308_tries_to_get_again() {
        let client = reqwest::Client::new();
        let codes = [307u16, 308];
        for &code in &codes {
            let redirect = server::http(move |req| async move {
                assert_eq!(req.method(), "GET");
                if req.uri() == &*format!("/{code}") {
                    http::Response::builder()
                        .status(code)
                        .header("location", "/dst")
                        .header("server", "test-redirect")
                        .body(Body::default())
                        .unwrap()
                } else {
                    assert_eq!(req.uri(), "/dst");

                    http::Response::builder()
                        .header("server", "test-dst")
                        .body(Body::default())
                        .unwrap()
                }
            });

            let url = format!("http://{}/{}", redirect.addr(), code);
            let dst = format!("http://{}/{}", redirect.addr(), "dst");
            let res = client.get(&url).send().await.unwrap();
            assert_eq!(res.url().as_str(), dst);
            assert_eq!(res.status(), reqwest::StatusCode::OK);
            assert_eq!(
                res.headers().get(reqwest::header::SERVER).unwrap(),
                &"test-dst"
            );
        }
    }

    #[tokio::test]
    async fn test_redirect_307_and_308_tries_to_post_again() {
        let _ = env_logger::try_init();
        let client = reqwest::Client::new();
        let codes = [307u16, 308];
        for &code in &codes {
            let redirect = server::http(move |mut req| async move {
                assert_eq!(req.method(), "POST");
                assert_eq!(req.headers()["content-length"], "5");

                let data = req
                    .body_mut()
                    .frame()
                    .await
                    .unwrap()
                    .unwrap()
                    .into_data()
                    .unwrap();
                assert_eq!(&*data, b"Hello");

                if req.uri() == &*format!("/{code}") {
                    http::Response::builder()
                        .status(code)
                        .header("location", "/dst")
                        .header("server", "test-redirect")
                        .body(Body::default())
                        .unwrap()
                } else {
                    assert_eq!(req.uri(), "/dst");

                    http::Response::builder()
                        .header("server", "test-dst")
                        .body(Body::default())
                        .unwrap()
                }
            });

            let url = format!("http://{}/{}", redirect.addr(), code);
            let dst = format!("http://{}/{}", redirect.addr(), "dst");
            let res = client.post(&url).body("Hello").send().await.unwrap();
            assert_eq!(res.url().as_str(), dst);
            assert_eq!(res.status(), reqwest::StatusCode::OK);
            assert_eq!(
                res.headers().get(reqwest::header::SERVER).unwrap(),
                &"test-dst"
            );
        }
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn test_redirect_307_does_not_try_if_reader_cannot_reset() {
        let client = reqwest::blocking::Client::new();
        let codes = [307u16, 308];
        for &code in &codes {
            let redirect = server::http(move |mut req| async move {
                assert_eq!(req.method(), "POST");
                assert_eq!(req.uri(), &*format!("/{code}"));
                assert_eq!(req.headers()["transfer-encoding"], "chunked");

                let data = req
                    .body_mut()
                    .frame()
                    .await
                    .unwrap()
                    .unwrap()
                    .into_data()
                    .unwrap();
                assert_eq!(&*data, b"Hello");

                http::Response::builder()
                    .status(code)
                    .header("location", "/dst")
                    .header("server", "test-redirect")
                    .body(Body::default())
                    .unwrap()
            });

            let url = format!("http://{}/{}", redirect.addr(), code);
            let res = client
                .post(&url)
                .body(reqwest::blocking::Body::new(&b"Hello"[..]))
                .send()
                .unwrap();
            assert_eq!(res.url().as_str(), url);
            assert_eq!(res.status(), code);
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP redirects for different status codes (e.g., 301, 302) and what is the expected behavior when a POST request is redirected?
  codeQuestion3: What steps are taken in the code to handle the 'GET' and 'POST' requests differently when dealing with HTTP redirect status codes 307 and 308?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/redirect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn test_redirect_removes_sensitive_headers() {
        use tokio::sync::watch;

        let (tx, rx) = watch::channel::<Option<std::net::SocketAddr>>(None);

        let end_server = server::http(move |req| {
            let mut rx = rx.clone();
            async move {
                assert_eq!(req.headers().get("cookie"), None);

                rx.changed().await.unwrap();
                let mid_addr = rx.borrow().unwrap();
                assert_eq!(
                    req.headers()["referer"],
                    format!("http://{mid_addr}/sensitive")
                );
                http::Response::default()
            }
        });

        let end_addr = end_server.addr();

        let mid_server = server::http(move |req| async move {
            assert_eq!(req.headers()["cookie"], "foo=bar");
            http::Response::builder()
                .status(302)
                .header("location", format!("http://{end_addr}/end"))
                .body(Body::default())
                .unwrap()
        });

        tx.send(Some(mid_server.addr())).unwrap();

        reqwest::Client::builder()
            .build()
            .unwrap()
            .get(&format!("http://{}/sensitive", mid_server.addr()))
            .header(
                reqwest::header::COOKIE,
                reqwest::header::HeaderValue::from_static("foo=bar"),
            )
            .send()
            .await
            .unwrap();
    }

    #[tokio::test]
    async fn test_redirect_policy_can_return_errors() {
        let server = server::http(move |req| async move {
            assert_eq!(req.uri(), "/loop");
            http::Response::builder()
                .status(302)
                .header("location", "/loop")
                .body(Body::default())
                .unwrap()
        });

        let url = format!("http://{}/loop", server.addr());
        let err = reqwest::get(&url).await.unwrap_err();
        assert!(err.is_redirect());
    }

    #[tokio::test]
    async fn test_redirect_policy_can_stop_redirects_without_an_error() {
        let server = server::http(move |req| async move {
            assert_eq!(req.uri(), "/no-redirect");
            http::Response::builder()
                .status(302)
                .header("location", "/dont")
                .body(Body::default())
                .unwrap()
        });

        let url = format!("http://{}/no-redirect", server.addr());

        let res = reqwest::Client::builder()
            .redirect(reqwest::redirect::Policy::none())
            .build()
            .unwrap()
            .get(&url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::FOUND);
    }

    #[tokio::test]
    async fn test_referer_is_not_set_if_disabled() {
        let server = server::http(move |req| async move {
            if req.uri() == "/no-refer" {
                http::Response::builder()
                    .status(302)
                    .header("location", "/dst")
                    .body(Body::default())
                    .unwrap()
            } else {
                assert_eq!(req.uri(), "/dst");
                assert_eq!(req.headers().get("referer"), None);

                http::Response::default()
            }
        });

        reqwest::Client::builder()
            .referer(false)
            .build()
            .unwrap()
            .get(&format!("http://{}/no-refer", server.addr()))
            .send()
            .await
            .unwrap();
    }

    #[tokio::test]
    async fn test_invalid_location_stops_redirect_gh484() {
        let server = server::http(move |_req| async move {
            http::Response::builder()
                .status(302)
                .header("location", "http://www.yikes{KABOOM}")
                .body(Body::default())
                .unwrap()
        });

        let url = format!("http://{}/yikes", server.addr());

        let res = reqwest::get(&url).await.unwrap();

        assert_eq!(res.url().as_str(), url);
        assert_eq!(res.status(), reqwest::StatusCode::FOUND);
    }

    #[tokio::test]
    async fn test_invalid_scheme_is_rejected() {
        let server = server::http(move |_req| async move {
            http::Response::builder()
                .status(302)
                .header("location", "htt://www.yikes.com/")
                .body(Body::default())
                .unwrap()
        });

        let url = format!("http://{}/yikes", server.addr());

        let err = reqwest::get(&url).await.unwrap_err();
        assert!(err.is_builder());
    }

    #[cfg(feature = "cookies")]
    #[tokio::test]
    async fn test_redirect_302_with_set_cookies() {
        let code = 302;
        let server = server::http(move |req| async move {
            if req.uri() == "/302" {
                http::Response::builder()
                    .status(302)
                    .header("location", "/dst")
                    .header("set-cookie", "key=value")
                    .body(Body::default())
                    .unwrap()
            } else {
                assert_eq!(req.uri(), "/dst");
                assert_eq!(req.headers()["cookie"], "key=value");
                http::Response::default()
            }
        });

        let url = format!("http://{}/{}", server.addr(), code);
        let dst = format!("http://{}/{}", server.addr(), "dst");

        let client = reqwest::ClientBuilder::new()
            .cookie_store(true)
            .build()
            .unwrap();
        let res = client.get(&url).send().await.unwrap();

        assert_eq!(res.url().as_str(), dst);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `test_redirect_removes_sensitive_headers` function ensure that sensitive headers like 'cookie' are not included in redirect responses?
  codeQuestion3: What steps are taken to handle invalid or malformed 'location' URLs in redirect responses, and how does the code ensure that such errors are properly reported?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/redirect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__rustls")]
    #[tokio::test]
    #[ignore = "Needs TLS support in the test server"]
    async fn test_redirect_https_only_enforced_gh1312() {
        let server = server::http(move |_req| async move {
            http::Response::builder()
                .status(302)
                .header("location", "http://insecure")
                .body(Body::default())
                .unwrap()
        });

        let url = format!("https://{}/yikes", server.addr());

        let res = reqwest::Client::builder()
            .danger_accept_invalid_certs(true)
            .use_rustls_tls()
            .https_only(true)
            .build()
            .expect("client builder")
            .get(&url)
            .send()
            .await;

        let err = res.unwrap_err();
        assert!(err.is_redirect());
    }

    #[tokio::test]
    async fn test_redirect_limit_to_1() {
        let server = server::http(move |req| async move {
            let i: i32 = req
                .uri()
                .path()
                .rsplit('/')
                .next()
                .unwrap()
                .parse::<i32>()
                .unwrap();
            assert!(req.uri().path().ends_with(&format!("/redirect/{i}")));
            http::Response::builder()
                .status(302)
                .header("location", format!("/redirect/{}", i + 1))
                .body(Body::default())
                .unwrap()
        });
        // The number at the end of the uri indicates the total number of redirections
        let url = format!("http://{}/redirect/0", server.addr());

        let client = reqwest::Client::builder()
            .redirect(reqwest::redirect::Policy::limited(1))
            .build()
            .unwrap();
        let res = client.get(&url).send().await.unwrap_err();
        // If the maxmium limit is 1, then the final uri should be /redirect/1
        assert_eq!(
            res.url().unwrap().as_str(),
            format!("http://{}/redirect/1", server.addr()).as_str()
        );
        assert!(res.is_redirect());
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `test_redirect_https_only_enforced_gh1312` function ensure that only HTTPS connections are allowed, and what system calls or API methods are involved in this process?
  codeQuestion3: What steps are taken in the `test_redirect_limit_to_1` function to limit the number of redirects, and what is the role of the `redirect::Policy` in this context?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/wasm_simple.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(target_arch = "wasm32")]
    use std::time::Duration;

    use wasm_bindgen::prelude::*;
    use wasm_bindgen_test::*;
    wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);

    #[wasm_bindgen]
    extern "C" {
        // Use `js_namespace` here to bind `console.log(..)` instead of just
        // `log(..)`
        #[wasm_bindgen(js_namespace = console)]
        fn log(s: &str);
    }

    #[wasm_bindgen_test]
    async fn simple_example() {
        let res = reqwest::get("https://hyper.rs")
            .await
            .expect("http get example");
        log(&format!("Status: {}", res.status()));

        let body = res.text().await.expect("response to utf-8 text");
        log(&format!("Body:\n\n{body}"));
    }

    #[wasm_bindgen_test]
    async fn request_with_timeout() {
        let client = reqwest::Client::new();
        let err = client
            .get("https://hyper.rs")
            .timeout(Duration::from_millis(1))
            .send()
            .await
            .expect_err("Expected error from aborted request");

        assert!(err.is_request());
        assert!(err.is_timeout());
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP requests with a timeout, and what is the expected outcome when the timeout is exceeded?
  codeQuestion3: What steps are taken to log the response status and body of an HTTP request in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/deflate.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod support;
    use flate2::write::ZlibEncoder;
    use flate2::Compression;
    use std::io::Write;
    use support::server;
    use tokio::io::AsyncWriteExt;

    #[tokio::test]
    async fn deflate_response() {
        deflate_case(10_000, 4096).await;
    }

    #[tokio::test]
    async fn deflate_single_byte_chunks() {
        deflate_case(10, 1).await;
    }

    #[tokio::test]
    async fn test_deflate_empty_body() {
        let server = server::http(move |req| async move {
            assert_eq!(req.method(), "HEAD");

            http::Response::builder()
                .header("content-encoding", "deflate")
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::new();
        let res = client
            .head(&format!("http://{}/deflate", server.addr()))
            .send()
            .await
            .unwrap();

        let body = res.text().await.unwrap();

        assert_eq!(body, "");
    }

    #[tokio::test]
    async fn test_accept_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "application/json");
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("deflate"));
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept", server.addr()))
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn test_accept_encoding_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "*/*");
            assert_eq!(req.headers()["accept-encoding"], "identity");
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept-encoding", server.addr()))
            .header(
                reqwest::header::ACCEPT_ENCODING,
                reqwest::header::HeaderValue::from_static("identity"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    async fn deflate_case(response_size: usize, chunk_size: usize) {
        use futures_util::stream::StreamExt;

        let content: String = (0..response_size)
            .into_iter()
            .map(|i| format!("test {i}"))
            .collect();

        let mut encoder = ZlibEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(content.as_bytes()).unwrap();
        let deflated_content = encoder.finish().unwrap();

        let mut response = format!(
            "\
             HTTP/1.1 200 OK\r\n\
             Server: test-accept\r\n\
             Content-Encoding: deflate\r\n\
             Content-Length: {}\r\n\
             \r\n",
            &deflated_content.len()
        )
        .into_bytes();
        response.extend(&deflated_content);

        let server = server::http(move |req| {
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("deflate"));

            let deflated = deflated_content.clone();
            async move {
                let len = deflated.len();
                let stream =
                    futures_util::stream::unfold((deflated, 0), move |(deflated, pos)| async move {
                        let chunk = deflated.chunks(chunk_size).nth(pos)?.to_vec();

                        Some((chunk, (deflated, pos + 1)))
                    });

                let body = reqwest::Body::wrap_stream(stream.map(Ok::<_, std::convert::Infallible>));

                http::Response::builder()
                    .header("content-encoding", "deflate")
                    .header("content-length", len)
                    .body(body)
                    .unwrap()
            }
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/deflate", server.addr()))
            .send()
            .await
            .expect("response");

        let body = res.text().await.expect("text");
        assert_eq!(body, content);
    }

    const COMPRESSED_RESPONSE_HEADERS: &[u8] = b"HTTP/1.1 200 OK\x0d\x0a\
                Content-Type: text/plain\x0d\x0a\
                Connection: keep-alive\x0d\x0a\
                Content-Encoding: deflate\x0d\x0a";

    const RESPONSE_CONTENT: &str = "some message here";

    fn deflate_compress(input: &[u8]) -> Vec<u8> {
        let mut encoder = ZlibEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(input).unwrap();
        encoder.finish().unwrap()
    }

    #[tokio::test]
    async fn test_non_chunked_non_fragmented_response() {
        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let deflated_content = deflate_compress(RESPONSE_CONTENT.as_bytes());
                let content_length_header =
                    format!("Content-Length: {}\r\n\r\n", deflated_content.len()).into_bytes();
                let response = [
                    COMPRESSED_RESPONSE_HEADERS,
                    &content_length_header,
                    &deflated_content,
                ]
                .concat();

                client_socket
                    .write_all(response.as_slice())
                    .await
                    .expect("response write_all failed");
                client_socket.flush().await.expect("response flush failed");
            })
        });

        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
    }
    ```
  codeQuestion1: What is the main purpose of this code?
  codeQuestion2: How does the `deflate_case` function handle large responses and what system calls are involved in managing the chunked transfer encoding?
  codeQuestion3: What steps are taken to ensure that the client correctly decodes a deflate-compressed response and how is this handled in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/deflate.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn test_chunked_fragmented_response_1() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let deflated_content = deflate_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        deflated_content.len()
                    )
                    .as_bytes(),
                    &deflated_content,
                ]
                .concat();
                let response_second_part = b"\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_2() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let deflated_content = deflate_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        deflated_content.len()
                    )
                    .as_bytes(),
                    &deflated_content,
                    b"\r\n",
                ]
                .concat();
                let response_second_part = b"0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_with_extra_bytes() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let deflated_content = deflate_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        deflated_content.len()
                    )
                    .as_bytes(),
                    &deflated_content,
                ]
                .concat();
                let response_second_part = b"\r\n2ab\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        let err = res.text().await.expect_err("there must be an error");
        assert!(err.is_decode());
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the server handle sending a response in two parts with chunked encoding, and what is the role of the `tokio::time::sleep` function in this process?
  codeQuestion3: What is the difference between `test_chunked_fragmented_response_1` and `test_chunked_fragmented_response_2`, and how does the client handle unexpected extra bytes in the response?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/http3.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(feature = "http3")]
    #![cfg(not(target_arch = "wasm32"))]

    mod support;

    use http::header::CONTENT_LENGTH;
    use std::error::Error;
    use support::server;

    #[tokio::test]
    async fn http3_request_full() {
        use http_body_util::BodyExt;

        let server = server::Http3::new().build(move |req| async move {
            assert_eq!(req.headers()[CONTENT_LENGTH], "5");
            let reqb = req.collect().await.unwrap().to_bytes();
            assert_eq!(reqb, "hello");
            http::Response::default()
        });

        let url = format!("https://{}/content-length", server.addr());
        let res = reqwest::Client::builder()
            .http3_prior_knowledge()
            .danger_accept_invalid_certs(true)
            .build()
            .expect("client builder")
            .post(url)
            .version(http::Version::HTTP_3)
            .body("hello")
            .send()
            .await
            .expect("request");

        assert_eq!(res.version(), http::Version::HTTP_3);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    async fn find_free_tcp_addr() -> std::net::SocketAddr {
        let listener = tokio::net::TcpListener::bind("[::1]:0").await.unwrap();
        listener.local_addr().unwrap()
    }

    #[cfg(feature = "http3")]
    #[tokio::test]
    async fn http3_test_failed_connection() {
        let addr = find_free_tcp_addr().await;
        let port = addr.port();

        let url = format!("https://[::1]:{port}/");
        let client = reqwest::Client::builder()
            .http3_prior_knowledge()
            .danger_accept_invalid_certs(true)
            .http3_max_idle_timeout(std::time::Duration::from_millis(20))
            .build()
            .expect("client builder");

        let err = client
            .get(&url)
            .version(http::Version::HTTP_3)
            .send()
            .await
            .unwrap_err();

        let err = err
            .source()
            .unwrap()
            .source()
            .unwrap()
            .downcast_ref::<quinn::ConnectionError>()
            .unwrap();
        assert_eq!(*err, quinn::ConnectionError::TimedOut);

        let err = client
            .get(&url)
            .version(http::Version::HTTP_3)
            .send()
            .await
            .unwrap_err();

        let err = err
            .source()
            .unwrap()
            .source()
            .unwrap()
            .downcast_ref::<quinn::ConnectionError>()
            .unwrap();
        assert_eq!(*err, quinn::ConnectionError::TimedOut);

        let server = server::Http3::new()
            .with_addr(addr)
            .build(|_| async { http::Response::default() });

        let res = client
            .post(&url)
            .version(http::Version::HTTP_3)
            .body("hello")
            .send()
            .await
            .expect("request");

        assert_eq!(res.version(), http::Version::HTTP_3);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        drop(server);
    }

    #[cfg(feature = "http3")]
    #[tokio::test]
    async fn http3_test_concurrent_request() {
        let server = server::Http3::new().build(|req| async move {
            let mut res = http::Response::default();
            *res.body_mut() = reqwest::Body::from(format!("hello {}", req.uri().path()));
            res
        });
        let addr = server.addr();

        let client = reqwest::Client::builder()
            .http3_prior_knowledge()
            .danger_accept_invalid_certs(true)
            .http3_max_idle_timeout(std::time::Duration::from_millis(20))
            .build()
            .expect("client builder");

        let mut tasks = vec![];
        for i in 0..10 {
            let client = client.clone();
            tasks.push(async move {
                let url = format!("https://{}/{}", addr, i);

                client
                    .post(&url)
                    .version(http::Version::HTTP_3)
                    .send()
                    .await
                    .expect("request")
            });
        }

        let handlers = tasks.into_iter().map(tokio::spawn).collect::<Vec<_>>();

        for (i, handler) in handlers.into_iter().enumerate() {
            let result = handler.await.unwrap();

            assert_eq!(result.version(), http::Version::HTTP_3);
            assert_eq!(result.status(), reqwest::StatusCode::OK);

            let body = result.text().await.unwrap();
            assert_eq!(body, format!("hello /{}", i));
        }

        drop(server);
    }

    #[cfg(feature = "http3")]
    #[tokio::test]
    async fn http3_test_reconnection() {
        use std::error::Error;

        use h3::error::StreamError;

        let server = server::Http3::new().build(|_| async { http::Response::default() });
        let addr = server.addr();

        let url = format!("https://{}/", addr);
        let client = reqwest::Client::builder()
            .http3_prior_knowledge()
            .danger_accept_invalid_certs(true)
            .http3_max_idle_timeout(std::time::Duration::from_millis(20))
            .build()
            .expect("client builder");

        let res = client
            .post(&url)
            .version(http::Version::HTTP_3)
            .send()
            .await
            .expect("request");

        assert_eq!(res.version(), http::Version::HTTP_3);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        drop(server);

        let err = client
            .get(&url)
            .version(http::Version::HTTP_3)
            .send()
            .await
            .unwrap_err();

        let err = err
            .source()
            .unwrap()
            .source()
            .unwrap()
            .downcast_ref::<StreamError>()
            .unwrap();

        // Why is it so hard to inspect h3 errors? :/
        assert!(err.to_string().contains("Timeout"));

        let server = server::Http3::new()
            .with_addr(addr)
            .build(|_| async { http::Response::default() });

        let res = client
            .post(&url)
            .version(http::Version::HTTP_3)
            .body("hello")
            .send()
            .await
            .expect("request");

        assert_eq!(res.version(), http::Version::HTTP_3);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        drop(server);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle failed HTTP/3 connections, and what system calls or APIs are used to manage reconnection attempts?
  codeQuestion3: What steps are involved in setting up a concurrent HTTP/3 request with multiple clients, and how does the code ensure proper handling of simultaneous requests?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
    mod support;

    use support::server;

    use http::header::{CONTENT_LENGTH, CONTENT_TYPE, TRANSFER_ENCODING};
    #[cfg(feature = "json")]
    use std::collections::HashMap;

    use reqwest::Client;

    #[tokio::test]
    async fn auto_headers() {
        let server = server::http(move |req| async move {
            assert_eq!(req.method(), "GET");

            assert_eq!(req.headers()["accept"], "*/*");
            assert_eq!(req.headers().get("user-agent"), None);
            if cfg!(feature = "gzip") {
                assert!(req.headers()["accept-encoding"]
                    .to_str()
                    .unwrap()
                    .contains("gzip"));
            }
            if cfg!(feature = "brotli") {
                assert!(req.headers()["accept-encoding"]
                    .to_str()
                    .unwrap()
                    .contains("br"));
            }
            if cfg!(feature = "zstd") {
                assert!(req.headers()["accept-encoding"]
                    .to_str()
                    .unwrap()
                    .contains("zstd"));
            }
            if cfg!(feature = "deflate") {
                assert!(req.headers()["accept-encoding"]
                    .to_str()
                    .unwrap()
                    .contains("deflate"));
            }

            http::Response::default()
        });

        let url = format!("http://{}/1", server.addr());
        let res = reqwest::Client::builder()
            .no_proxy()
            .build()
            .unwrap()
            .get(&url)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        assert_eq!(res.remote_addr(), Some(server.addr()));
    }

    #[tokio::test]
    async fn donot_set_content_length_0_if_have_no_body() {
        let server = server::http(move |req| async move {
            let headers = req.headers();
            assert_eq!(headers.get(CONTENT_LENGTH), None);
            assert!(headers.get(CONTENT_TYPE).is_none());
            assert!(headers.get(TRANSFER_ENCODING).is_none());
            dbg!(&headers);
            http::Response::default()
        });

        let url = format!("http://{}/content-length", server.addr());
        let res = reqwest::Client::builder()
            .no_proxy()
            .build()
            .expect("client builder")
            .get(&url)
            .send()
            .await
            .expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn user_agent() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["user-agent"], "reqwest-test-agent");
            http::Response::default()
        });

        let url = format!("http://{}/ua", server.addr());
        let res = reqwest::Client::builder()
            .user_agent("reqwest-test-agent")
            .build()
            .expect("client builder")
            .get(&url)
            .send()
            .await
            .expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn response_text() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let client = Client::new();

        let res = client
            .get(&format!("http://{}/text", server.addr()))
            .send()
            .await
            .expect("Failed to get");
        assert_eq!(res.content_length(), Some(5));
        let text = res.text().await.expect("Failed to get text");
        assert_eq!("Hello", text);
    }

    #[tokio::test]
    async fn response_bytes() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let client = Client::new();

        let res = client
            .get(&format!("http://{}/bytes", server.addr()))
            .send()
            .await
            .expect("Failed to get");
        assert_eq!(res.content_length(), Some(5));
        let bytes = res.bytes().await.expect("res.bytes()");
        assert_eq!("Hello", bytes);
    }

    #[tokio::test]
    #[cfg(feature = "json")]
    async fn response_json() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::new("\"Hello\"".into()) });

        let client = Client::new();

        let res = client
            .get(&format!("http://{}/json", server.addr()))
            .send()
            .await
            .expect("Failed to get");
        let text = res.json::<String>().await.expect("Failed to get json");
        assert_eq!("Hello", text);
    }

    #[tokio::test]
    async fn body_pipe_response() {
        use http_body_util::BodyExt;
        let _ = env_logger::try_init();

        let server = server::http(move |req| async move {
            if req.uri() == "/get" {
                http::Response::new("pipe me".into())
            } else {
                assert_eq!(req.uri(), "/pipe");
                assert_eq!(req.headers()["content-length"], "7");

                let full: Vec<u8> = req
                    .into_body()
                    .collect()
                    .await
                    .expect("must succeed")
                    .to_bytes()
                    .to_vec();

                assert_eq!(full, b"pipe me");

                http::Response::default()
            }
        });

        let client = Client::new();

        let res1 = client
            .get(&format!("http://{}/get", server.addr()))
            .send()
            .await
            .expect("get1");

        assert_eq!(res1.status(), reqwest::StatusCode::OK);
        assert_eq!(res1.content_length(), Some(7));

        // and now ensure we can "pipe" the response to another request
        let res2 = client
            .post(&format!("http://{}/pipe", server.addr()))
            .body(res1)
            .send()
            .await
            .expect("res2");

        assert_eq!(res2.status(), reqwest::StatusCode::OK);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `auto_headers` test ensure that the client is correctly setting default headers for HTTP requests?
  codeQuestion3: What steps are taken in the `response_text` test to verify that the server's response is properly handled as text data?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn overridden_dns_resolution_with_gai() {
        let _ = env_logger::builder().is_test(true).try_init();
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let overridden_domain = "rust-lang.org";
        let url = format!(
            "http://{overridden_domain}:{}/domain_override",
            server.addr().port()
        );
        let client = reqwest::Client::builder()
            .no_proxy()
            .resolve(overridden_domain, server.addr())
            .build()
            .expect("client builder");
        let req = client.get(&url);
        let res = req.send().await.expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
        let text = res.text().await.expect("Failed to get text");
        assert_eq!("Hello", text);
    }

    #[tokio::test]
    async fn overridden_dns_resolution_with_gai_multiple() {
        let _ = env_logger::builder().is_test(true).try_init();
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let overridden_domain = "rust-lang.org";
        let url = format!(
            "http://{overridden_domain}:{}/domain_override",
            server.addr().port()
        );
        // the server runs on IPv4 localhost, so provide both IPv4 and IPv6 and let the happy eyeballs
        // algorithm decide which address to use.
        let client = reqwest::Client::builder()
            .no_proxy()
            .resolve_to_addrs(
                overridden_domain,
                &[
                    std::net::SocketAddr::new(
                        std::net::IpAddr::V6(std::net::Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)),
                        server.addr().port(),
                    ),
                    server.addr(),
                ],
            )
            .build()
            .expect("client builder");
        let req = client.get(&url);
        let res = req.send().await.expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
        let text = res.text().await.expect("Failed to get text");
        assert_eq!("Hello", text);
    }

    #[cfg(feature = "hickory-dns")]
    #[tokio::test]
    async fn overridden_dns_resolution_with_hickory_dns() {
        let _ = env_logger::builder().is_test(true).try_init();
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let overridden_domain = "rust-lang.org";
        let url = format!(
            "http://{overridden_domain}:{}/domain_override",
            server.addr().port()
        );
        let client = reqwest::Client::builder()
            .no_proxy()
            .resolve(overridden_domain, server.addr())
            .hickory_dns(true)
            .build()
            .expect("client builder");
        let req = client.get(&url);
        let res = req.send().await.expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
        let text = res.text().await.expect("Failed to get text");
        assert_eq!("Hello", text);
    }

    #[cfg(feature = "hickory-dns")]
    #[tokio::test]
    async fn overridden_dns_resolution_with_hickory_dns_multiple() {
        let _ = env_logger::builder().is_test(true).try_init();
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let overridden_domain = "rust-lang.org";
        let url = format!(
            "http://{overridden_domain}:{}/domain_override",
            server.addr().port()
        );
        // the server runs on IPv4 localhost, so provide both IPv4 and IPv6 and let the happy eyeballs
        // algorithm decide which address to use.
        let client = reqwest::Client::builder()
            .no_proxy()
            .resolve_to_addrs(
                overridden_domain,
                &[
                    std::net::SocketAddr::new(
                        std::net::IpAddr::V6(std::net::Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)),
                        server.addr().port(),
                    ),
                    server.addr(),
                ],
            )
            .hickory_dns(true)
            .build()
            .expect("client builder");
        let req = client.get(&url);
        let res = req.send().await.expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
        let text = res.text().await.expect("Failed to get text");
        assert_eq!("Hello", text);
    }

    #[cfg(any(feature = "native-tls", feature = "__rustls",))]
    #[test]
    fn use_preconfigured_tls_with_bogus_backend() {
        struct DefinitelyNotTls;

        reqwest::Client::builder()
            .use_preconfigured_tls(DefinitelyNotTls)
            .build()
            .expect_err("definitely is not TLS");
    }

    #[cfg(feature = "native-tls")]
    #[test]
    fn use_preconfigured_native_tls_default() {
        extern crate native_tls_crate;

        let tls = native_tls_crate::TlsConnector::builder()
            .build()
            .expect("tls builder");

        reqwest::Client::builder()
            .use_preconfigured_tls(tls)
            .build()
            .expect("preconfigured default tls");
    }

    #[cfg(feature = "__rustls")]
    #[test]
    fn use_preconfigured_rustls_default() {
        extern crate rustls;

        let root_cert_store = rustls::RootCertStore::empty();
        let tls = rustls::ClientConfig::builder()
            .with_root_certificates(root_cert_store)
            .with_no_client_auth();

        reqwest::Client::builder()
            .use_preconfigured_tls(tls)
            .build()
            .expect("preconfigured rustls tls");
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user override DNS resolution for a specific domain and what APIs are used to achieve this in the code?
  codeQuestion3: What steps are taken to handle TLS configuration when using a preconfigured TLS backend in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__rustls")]
    #[tokio::test]
    #[ignore = "Needs TLS support in the test server"]
    async fn http2_upgrade() {
        let server = server::http(move |_| async move { http::Response::default() });

        let url = format!("https://localhost:{}", server.addr().port());
        let res = reqwest::Client::builder()
            .danger_accept_invalid_certs(true)
            .use_rustls_tls()
            .build()
            .expect("client builder")
            .get(&url)
            .send()
            .await
            .expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
        assert_eq!(res.version(), reqwest::Version::HTTP_2);
    }

    #[cfg(feature = "default-tls")]
    #[cfg_attr(feature = "http3", ignore = "enabling http3 seems to break this, why?")]
    #[tokio::test]
    async fn test_allowed_methods() {
        let resp = reqwest::Client::builder()
            .https_only(true)
            .build()
            .expect("client builder")
            .get("https://google.com")
            .send()
            .await;

        assert!(resp.is_ok());

        let resp = reqwest::Client::builder()
            .https_only(true)
            .build()
            .expect("client builder")
            .get("http://google.com")
            .send()
            .await;

        assert!(resp.is_err());
    }

    #[test]
    #[cfg(feature = "json")]
    fn add_json_default_content_type_if_not_set_manually() {
        let mut map = HashMap::new();
        map.insert("body", "json");
        let content_type = http::HeaderValue::from_static("application/vnd.api+json");
        let req = Client::new()
            .post("https://google.com/")
            .header(CONTENT_TYPE, &content_type)
            .json(&map)
            .build()
            .expect("request is not valid");

        assert_eq!(content_type, req.headers().get(CONTENT_TYPE).unwrap());
    }

    #[test]
    #[cfg(feature = "json")]
    fn update_json_content_type_if_set_manually() {
        let mut map = HashMap::new();
        map.insert("body", "json");
        let req = Client::new()
            .post("https://google.com/")
            .json(&map)
            .build()
            .expect("request is not valid");

        assert_eq!("application/json", req.headers().get(CONTENT_TYPE).unwrap());
    }

    #[cfg(all(feature = "__tls", not(feature = "rustls-tls-manual-roots")))]
    #[tokio::test]
    async fn test_tls_info() {
        let resp = reqwest::Client::builder()
            .tls_info(true)
            .build()
            .expect("client builder")
            .get("https://google.com")
            .send()
            .await
            .expect("response");
        let tls_info = resp.extensions().get::<reqwest::tls::TlsInfo>();
        assert!(tls_info.is_some());
        let tls_info = tls_info.unwrap();
        let peer_certificate = tls_info.peer_certificate();
        assert!(peer_certificate.is_some());
        let der = peer_certificate.unwrap();
        assert_eq!(der[0], 0x30); // ASN.1 SEQUENCE

        let resp = reqwest::Client::builder()
            .build()
            .expect("client builder")
            .get("https://google.com")
            .send()
            .await
            .expect("response");
        let tls_info = resp.extensions().get::<reqwest::tls::TlsInfo>();
        assert!(tls_info.is_none());
    }

    // NOTE: using the default "current_thread" runtime here would cause the test to
    // fail, because the only thread would block until `panic_rx` receives a
    // notification while the client needs to be driven to get the graceful shutdown
    // done.
    #[cfg(feature = "http2")]
    #[tokio::test(flavor = "multi_thread", worker_threads = 2)]
    async fn highly_concurrent_requests_to_http2_server_with_low_max_concurrent_streams() {
        let client = reqwest::Client::builder()
            .http2_prior_knowledge()
            .build()
            .unwrap();

        let server = server::http_with_config(
            move |req| async move {
                assert_eq!(req.version(), http::Version::HTTP_2);
                http::Response::default()
            },
            |builder| {
                builder.http2().max_concurrent_streams(1);
            },
        );

        let url = format!("http://{}", server.addr());

        let futs = (0..100).map(|_| {
            let client = client.clone();
            let url = url.clone();
            async move {
                let res = client.get(&url).send().await.unwrap();
                assert_eq!(res.status(), reqwest::StatusCode::OK);
            }
        });
        futures_util::future::join_all(futs).await;
    }

    #[cfg(feature = "http2")]
    #[tokio::test]
    async fn highly_concurrent_requests_to_slow_http2_server_with_low_max_concurrent_streams() {
        use support::delay_server;

        let client = reqwest::Client::builder()
            .http2_prior_knowledge()
            .build()
            .unwrap();

        let server = delay_server::Server::new(
            move |req| async move {
                assert_eq!(req.version(), http::Version::HTTP_2);
                http::Response::default()
            },
            |http| {
                http.http2().max_concurrent_streams(1);
            },
            std::time::Duration::from_secs(2),
        )
        .await;

        let url = format!("http://{}", server.addr());

        let futs = (0..100).map(|_| {
            let client = client.clone();
            let url = url.clone();
            async move {
                let res = client.get(&url).send().await.unwrap();
                assert_eq!(res.status(), reqwest::StatusCode::OK);
            }
        });
        futures_util::future::join_all(futs).await;

        server.shutdown().await;
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `http2_upgrade` test ensure that an HTTP/2 connection is established with a local server?
  codeQuestion3: What steps are taken in the `test_tls_info` test to retrieve and verify TLS certificate details from a server response?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn close_connection_after_idle_timeout() {
        let mut server = server::http(move |_| async move { http::Response::default() });

        let client = reqwest::Client::builder()
            .pool_idle_timeout(std::time::Duration::from_secs(1))
            .build()
            .unwrap();

        let url = format!("http://{}", server.addr());

        client.get(&url).send().await.unwrap();

        tokio::time::sleep(std::time::Duration::from_secs(2)).await;

        assert!(server
            .events()
            .iter()
            .any(|e| matches!(e, server::Event::ConnectionClosed)));
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code ensure that a connection is closed after an idle timeout?
  codeQuestion3: What steps are taken to verify that the connection has been closed after the timeout?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/connector_layers.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
    mod support;

    use std::time::Duration;

    use futures_util::future::join_all;
    use tower::layer::util::Identity;
    use tower::limit::ConcurrencyLimitLayer;
    use tower::timeout::TimeoutLayer;

    use support::{delay_layer::DelayLayer, server};

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn non_op_layer() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::Client::builder()
            .connector_layer(Identity::new())
            .no_proxy()
            .build()
            .unwrap();

        let res = client.get(url).send().await;

        assert!(res.is_ok());
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn non_op_layer_with_timeout() {
        let _ = env_logger::try_init();

        let client = reqwest::Client::builder()
            .connector_layer(Identity::new())
            .connect_timeout(Duration::from_millis(200))
            .no_proxy()
            .build()
            .unwrap();

        // never returns
        let url = "http://192.0.2.1:81/slow";

        let res = client.get(url).send().await;

        let err = res.unwrap_err();

        assert!(err.is_connect() && err.is_timeout());
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn with_connect_timeout_layer_never_returning() {
        let _ = env_logger::try_init();

        let client = reqwest::Client::builder()
            .connector_layer(TimeoutLayer::new(Duration::from_millis(100)))
            .no_proxy()
            .build()
            .unwrap();

        // never returns
        let url = "http://192.0.2.1:81/slow";

        let res = client.get(url).send().await;

        let err = res.unwrap_err();

        assert!(err.is_connect() && err.is_timeout());
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn with_connect_timeout_layer_slow() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(200)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(100)))
            .no_proxy()
            .build()
            .unwrap();

        let res = client.get(url).send().await;

        let err = res.unwrap_err();

        assert!(err.is_connect() && err.is_timeout());
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn multiple_timeout_layers_under_threshold() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(100)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(200)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(300)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(500)))
            .connect_timeout(Duration::from_millis(200))
            .no_proxy()
            .build()
            .unwrap();

        let res = client.get(url).send().await;

        assert!(res.is_ok());
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn multiple_timeout_layers_over_threshold() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(100)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(50)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(50)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(50)))
            .connect_timeout(Duration::from_millis(50))
            .no_proxy()
            .build()
            .unwrap();

        let res = client.get(url).send().await;

        let err = res.unwrap_err();

        assert!(err.is_connect() && err.is_timeout());
    }

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn with_concurrency_limit_layer_timeout() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(100)))
            .connector_layer(ConcurrencyLimitLayer::new(1))
            .timeout(Duration::from_millis(200))
            .pool_max_idle_per_host(0) // disable connection reuse to force resource contention on the concurrency limit semaphore
            .no_proxy()
            .build()
            .unwrap();

        // first call succeeds since no resource contention
        let res = client.get(url.clone()).send().await;
        assert!(res.is_ok());

        // 3 calls where the second two wait on the first and time out
        let mut futures = Vec::new();
        for _ in 0..3 {
            futures.push(client.clone().get(url.clone()).send());
        }

        let all_res = join_all(futures).await;

        let timed_out = all_res
            .into_iter()
            .any(|res| res.is_err_and(|err| err.is_timeout()));

        assert!(timed_out, "at least one request should have timed out");
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure a client to handle timeout and concurrency limits for HTTP requests?
  codeQuestion3: What is the process for setting up multiple timeout layers with varying thresholds and how do they interact when a request exceeds the shortest timeout?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/connector_layers.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn with_concurrency_limit_layer_success() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(100)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(200)))
            .connector_layer(ConcurrencyLimitLayer::new(1))
            .timeout(Duration::from_millis(1000))
            .pool_max_idle_per_host(0) // disable connection reuse to force resource contention on the concurrency limit semaphore
            .no_proxy()
            .build()
            .unwrap();

        // first call succeeds since no resource contention
        let res = client.get(url.clone()).send().await;
        assert!(res.is_ok());

        // 3 calls of which all are individually below the inner timeout
        // and the sum is below outer timeout which affects the final call which waited the whole time
        let mut futures = Vec::new();
        for _ in 0..3 {
            futures.push(client.clone().get(url.clone()).send());
        }

        let all_res = join_all(futures).await;

        for res in all_res.into_iter() {
            assert!(
                res.is_ok(),
                "neither outer long timeout or inner short timeout should be exceeded"
            );
        }
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn non_op_layer_blocking_client() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::blocking::Client::builder()
            .connector_layer(Identity::new())
            .build()
            .unwrap();

        let res = client.get(url).send();

        assert!(res.is_ok());
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn timeout_layer_blocking_client() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::blocking::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(100)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(50)))
            .no_proxy()
            .build()
            .unwrap();

        let res = client.get(url).send();
        let err = res.unwrap_err();

        assert!(err.is_connect() && err.is_timeout());
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn concurrency_layer_blocking_client_timeout() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::blocking::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(100)))
            .connector_layer(ConcurrencyLimitLayer::new(1))
            .timeout(Duration::from_millis(200))
            .pool_max_idle_per_host(0) // disable connection reuse to force resource contention on the concurrency limit semaphore
            .build()
            .unwrap();

        let res = client.get(url.clone()).send();

        assert!(res.is_ok());

        // 3 calls where the second two wait on the first and time out
        let mut join_handles = Vec::new();
        for _ in 0..3 {
            let client = client.clone();
            let url = url.clone();
            let join_handle = std::thread::spawn(move || client.get(url.clone()).send());
            join_handles.push(join_handle);
        }

        let timed_out = join_handles
            .into_iter()
            .any(|handle| handle.join().unwrap().is_err_and(|err| err.is_timeout()));

        assert!(timed_out, "at least one request should have timed out");
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn concurrency_layer_blocking_client_success() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::blocking::Client::builder()
            .connector_layer(DelayLayer::new(Duration::from_millis(100)))
            .connector_layer(TimeoutLayer::new(Duration::from_millis(200)))
            .connector_layer(ConcurrencyLimitLayer::new(1))
            .timeout(Duration::from_millis(1000))
            .pool_max_idle_per_host(0) // disable connection reuse to force resource contention on the concurrency limit semaphore
            .build()
            .unwrap();

        let res = client.get(url.clone()).send();

        assert!(res.is_ok());

        // 3 calls of which all are individually below the inner timeout
        // and the sum is below outer timeout which affects the final call which waited the whole time
        let mut join_handles = Vec::new();
        for _ in 0..3 {
            let client = client.clone();
            let url = url.clone();
            let join_handle = std::thread::spawn(move || client.get(url.clone()).send());
            join_handles.push(join_handle);
        }

        for handle in join_handles {
            let res = handle.join().unwrap();
            assert!(
                res.is_ok(),
                "neither outer long timeout or inner short timeout should be exceeded"
            );
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure a blocking HTTP client with multiple layers for delay, timeout, and concurrency limits, and what system calls are involved in handling the input for this action?
  codeQuestion3: What steps are taken to handle terminal input and output settings for the game?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/connector_layers.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::test]
    async fn no_generic_bounds_required_for_client_new() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::Client::new();
        let res = client.get(url).send().await;

        assert!(res.is_ok());
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn no_generic_bounds_required_for_client_new_blocking() {
        let _ = env_logger::try_init();

        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}", server.addr());

        let client = reqwest::blocking::Client::new();
        let res = client.get(url).send();

        assert!(res.is_ok());
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code demonstrate the use of different client types (blocking and async) in reqwest?
  codeQuestion3: What steps are taken to set up a test server and verify the client's ability to connect to it?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    mod support;
    use http_body_util::BodyExt;
    use support::server;

    #[tokio::test]
    async fn text_part() {
        let _ = env_logger::try_init();

        let form = reqwest::multipart::Form::new().text("foo", "bar");

        let expected_body = format!(
            "\
             --{0}\r\n\
             Content-Disposition: form-data; name=\"foo\"\r\n\r\n\
             bar\r\n\
             --{0}--\r\n\
             ",
            form.boundary()
        );

        let ct = format!("multipart/form-data; boundary={}", form.boundary());

        let server = server::http(move |mut req| {
            let ct = ct.clone();
            let expected_body = expected_body.clone();
            async move {
                assert_eq!(req.method(), "POST");
                assert_eq!(req.headers()["content-type"], ct);
                assert_eq!(
                    req.headers()["content-length"],
                    expected_body.len().to_string()
                );

                let mut full: Vec<u8> = Vec::new();
                while let Some(item) = req.body_mut().frame().await {
                    full.extend(&*item.unwrap().into_data().unwrap());
                }

                assert_eq!(full, expected_body.as_bytes());

                http::Response::default()
            }
        });

        let url = format!("http://{}/multipart/1", server.addr());

        let res = reqwest::Client::new()
            .post(&url)
            .multipart(form)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[cfg(feature = "stream")]
    #[tokio::test]
    async fn stream_part() {
        use futures_util::{future, stream};

        let _ = env_logger::try_init();

        let stream = reqwest::Body::wrap_stream(stream::once(future::ready(Ok::<_, reqwest::Error>(
            "part1 part2".to_owned(),
        ))));
        let part = reqwest::multipart::Part::stream(stream);

        let form = reqwest::multipart::Form::new()
            .text("foo", "bar")
            .part("part_stream", part);

        let expected_body = format!(
            "\
             --{0}\r\n\
             Content-Disposition: form-data; name=\"foo\"\r\n\
             \r\n\
             bar\r\n\
             --{0}\r\n\
             Content-Disposition: form-data; name=\"part_stream\"\r\n\
             \r\n\
             part1 part2\r\n\
             --{0}--\r\n\
             ",
            form.boundary()
        );

        let ct = format!("multipart/form-data; boundary={}", form.boundary());

        let server = server::http(move |req| {
            let ct = ct.clone();
            let expected_body = expected_body.clone();
            async move {
                assert_eq!(req.method(), "POST");
                assert_eq!(req.headers()["content-type"], ct);
                assert_eq!(req.headers()["transfer-encoding"], "chunked");

                let full = req.collect().await.unwrap().to_bytes();

                assert_eq!(full, expected_body.as_bytes());

                http::Response::default()
            }
        });

        let url = format!("http://{}/multipart/1", server.addr());

        let client = reqwest::Client::new();

        let res = client
            .post(&url)
            .multipart(form)
            .send()
            .await
            .expect("Failed to post multipart");
        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[cfg(feature = "blocking")]
    #[test]
    fn blocking_file_part() {
        let _ = env_logger::try_init();

        let form = reqwest::blocking::multipart::Form::new()
            .file("foo", "Cargo.lock")
            .unwrap();

        let fcontents = std::fs::read_to_string("Cargo.lock").unwrap();

        let expected_body = format!(
            "\
             --{0}\r\n\
             Content-Disposition: form-data; name=\"foo\"; filename=\"Cargo.lock\"\r\n\
             Content-Type: application/octet-stream\r\n\r\n\
             {1}\r\n\
             --{0}--\r\n\
             ",
            form.boundary(),
            fcontents
        );

        let ct = format!("multipart/form-data; boundary={}", form.boundary());

        let server = server::http(move |req| {
            let ct = ct.clone();
            let expected_body = expected_body.clone();
            async move {
                assert_eq!(req.method(), "POST");
                assert_eq!(req.headers()["content-type"], ct);
                // files know their exact size
                assert_eq!(
                    req.headers()["content-length"],
                    expected_body.len().to_string()
                );

                let full = req.collect().await.unwrap().to_bytes();

                assert_eq!(full, expected_body.as_bytes());

                http::Response::default()
            }
        });

        let url = format!("http://{}/multipart/2", server.addr());

        let res = reqwest::blocking::Client::new()
            .post(&url)
            .multipart(form)
            .send()
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[cfg(feature = "stream")]
    #[tokio::test]
    async fn async_impl_file_part() {
        let _ = env_logger::try_init();

        let form = reqwest::multipart::Form::new()
            .file("foo", "Cargo.lock")
            .await
            .unwrap();

        let fcontents = std::fs::read_to_string("Cargo.lock").unwrap();

        let expected_body = format!(
            "\
             --{0}\r\n\
             Content-Disposition: form-data; name=\"foo\"; filename=\"Cargo.lock\"\r\n\
             Content-Type: application/octet-stream\r\n\r\n\
             {1}\r\n\
             --{0}--\r\n\
             ",
            form.boundary(),
            fcontents
        );

        let ct = format!("multipart/form-data; boundary={}", form.boundary());

        let server = server::http(move |req| {
            let ct = ct.clone();
            let expected_body = expected_body.clone();
            async move {
                assert_eq!(req.method(), "POST");
                assert_eq!(req.headers()["content-type"], ct);
                // files know their exact size
                assert_eq!(
                    req.headers()["content-length"],
                    expected_body.len().to_string()
                );
                let full = req.collect().await.unwrap().to_bytes();

                assert_eq!(full, expected_body.as_bytes());

                http::Response::default()
            }
        });

        let url = format!("http://{}/multipart/3", server.addr());

        let res = reqwest::Client::new()
            .post(&url)
            .multipart(form)
            .send()
            .await
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the code handle multipart/form-data requests with both text and stream-based parts?
  codeQuestion3: What system calls or APIs are used to handle file uploads in the blocking mode of this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/gzip.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod support;
    use flate2::write::GzEncoder;
    use flate2::Compression;
    use support::server;

    use std::io::Write;
    use tokio::io::AsyncWriteExt;
    use tokio::time::Duration;

    #[tokio::test]
    async fn gzip_response() {
        gzip_case(10_000, 4096).await;
    }

    #[tokio::test]
    async fn gzip_single_byte_chunks() {
        gzip_case(10, 1).await;
    }

    #[tokio::test]
    async fn test_gzip_empty_body() {
        let server = server::http(move |req| async move {
            assert_eq!(req.method(), "HEAD");

            http::Response::builder()
                .header("content-encoding", "gzip")
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::new();
        let res = client
            .head(&format!("http://{}/gzip", server.addr()))
            .send()
            .await
            .unwrap();

        let body = res.text().await.unwrap();

        assert_eq!(body, "");
    }

    #[tokio::test]
    async fn test_accept_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "application/json");
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("gzip"));
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept", server.addr()))
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn test_accept_encoding_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "*/*");
            assert_eq!(req.headers()["accept-encoding"], "identity");
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept-encoding", server.addr()))
            .header(
                reqwest::header::ACCEPT_ENCODING,
                reqwest::header::HeaderValue::from_static("identity"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    async fn gzip_case(response_size: usize, chunk_size: usize) {
        use futures_util::stream::StreamExt;

        let content: String = (0..response_size)
            .into_iter()
            .map(|i| format!("test {i}"))
            .collect();

        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(content.as_bytes()).unwrap();
        let gzipped_content = encoder.finish().unwrap();

        let mut response = format!(
            "\
             HTTP/1.1 200 OK\r\n\
             Server: test-accept\r\n\
             Content-Encoding: gzip\r\n\
             Content-Length: {}\r\n\
             \r\n",
            &gzipped_content.len()
        )
        .into_bytes();
        response.extend(&gzipped_content);

        let server = server::http(move |req| {
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("gzip"));

            let gzipped = gzipped_content.clone();
            async move {
                let len = gzipped.len();
                let stream =
                    futures_util::stream::unfold((gzipped, 0), move |(gzipped, pos)| async move {
                        let chunk = gzipped.chunks(chunk_size).nth(pos)?.to_vec();

                        Some((chunk, (gzipped, pos + 1)))
                    });

                let body = reqwest::Body::wrap_stream(stream.map(Ok::<_, std::convert::Infallible>));

                http::Response::builder()
                    .header("content-encoding", "gzip")
                    .header("content-length", len)
                    .body(body)
                    .unwrap()
            }
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/gzip", server.addr()))
            .send()
            .await
            .expect("response");

        let body = res.text().await.expect("text");
        assert_eq!(body, content);
    }

    const COMPRESSED_RESPONSE_HEADERS: &[u8] = b"HTTP/1.1 200 OK\x0d\x0a\
                Content-Type: text/plain\x0d\x0a\
                Connection: keep-alive\x0d\x0a\
                Content-Encoding: gzip\x0d\x0a";

    const RESPONSE_CONTENT: &str = "some message here";

    fn gzip_compress(input: &[u8]) -> Vec<u8> {
        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(input).unwrap();
        encoder.finish().unwrap()
    }

    #[tokio::test]
    async fn test_non_chunked_non_fragmented_response() {
        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let gzipped_content = gzip_compress(RESPONSE_CONTENT.as_bytes());
                let content_length_header =
                    format!("Content-Length: {}\r\n\r\n", gzipped_content.len()).into_bytes();
                let response = [
                    COMPRESSED_RESPONSE_HEADERS,
                    &content_length_header,
                    &gzipped_content,
                ]
                .concat();

                client_socket
                    .write_all(response.as_slice())
                    .await
                    .expect("response write_all failed");
                client_socket.flush().await.expect("response flush failed");
            })
        });

        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle different chunk sizes when sending a GZIP-compressed response?
  codeQuestion3: What is the role of the `gzip_compress` function in this code? Provide an example of its usage.

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/gzip.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn test_chunked_fragmented_response_1() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let gzipped_content = gzip_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        gzipped_content.len()
                    )
                    .as_bytes(),
                    &gzipped_content,
                ]
                .concat();
                let response_second_part = b"\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_2() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let gzipped_content = gzip_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        gzipped_content.len()
                    )
                    .as_bytes(),
                    &gzipped_content,
                    b"\r\n",
                ]
                .concat();
                let response_second_part = b"0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_with_extra_bytes() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let gzipped_content = gzip_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        gzipped_content.len()
                    )
                    .as_bytes(),
                    &gzipped_content,
                ]
                .concat();
                let response_second_part = b"\r\n2ab\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        let err = res.text().await.expect_err("there must be an error");
        assert!(err.is_decode());
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle fragmented responses with chunked transfer encoding, and what system calls or APIs are used to manage this?
  codeQuestion3: What steps are taken in the code to handle unexpected extra bytes after a chunked response, and how is this handled in the client-side code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/support/delay_layer.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::{
        future::Future,
        pin::Pin,
        task::{Context, Poll},
        time::Duration,
    };

    use pin_project_lite::pin_project;
    use tokio::time::Sleep;
    use tower::{BoxError, Layer, Service};

    /// This tower layer injects an arbitrary delay before calling downstream layers.
    #[derive(Clone)]
    pub struct DelayLayer {
        delay: Duration,
    }

    impl DelayLayer {
        pub const fn new(delay: Duration) -> Self {
            DelayLayer { delay }
        }
    }

    impl<S> Layer<S> for DelayLayer {
        type Service = Delay<S>;
        fn layer(&self, service: S) -> Self::Service {
            Delay::new(service, self.delay)
        }
    }

    impl std::fmt::Debug for DelayLayer {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("DelayLayer")
                .field("delay", &self.delay)
                .finish()
        }
    }

    /// This tower service injects an arbitrary delay before calling downstream layers.
    #[derive(Debug, Clone)]
    pub struct Delay<S> {
        inner: S,
        delay: Duration,
    }
    impl<S> Delay<S> {
        pub fn new(inner: S, delay: Duration) -> Self {
            Delay { inner, delay }
        }
    }

    impl<S, Request> Service<Request> for Delay<S>
    where
        S: Service<Request>,
        S::Error: Into<BoxError>,
    {
        type Response = S::Response;

        type Error = BoxError;

        type Future = ResponseFuture<S::Future>;

        fn poll_ready(
            &mut self,
            cx: &mut std::task::Context<'_>,
        ) -> std::task::Poll<Result<(), Self::Error>> {
            match self.inner.poll_ready(cx) {
                Poll::Pending => Poll::Pending,
                Poll::Ready(r) => Poll::Ready(r.map_err(Into::into)),
            }
        }

        fn call(&mut self, req: Request) -> Self::Future {
            let response = self.inner.call(req);
            let sleep = tokio::time::sleep(self.delay);

            ResponseFuture::new(response, sleep)
        }
    }

    // `Delay` response future
    pin_project! {
        #[derive(Debug)]
        pub struct ResponseFuture<S> {
            #[pin]
            response: S,
            #[pin]
            sleep: Sleep,
        }
    }

    impl<S> ResponseFuture<S> {
        pub(crate) fn new(response: S, sleep: Sleep) -> Self {
            ResponseFuture { response, sleep }
        }
    }

    impl<F, S, E> Future for ResponseFuture<F>
    where
        F: Future<Output = Result<S, E>>,
        E: Into<BoxError>,
    {
        type Output = Result<S, BoxError>;

        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            let this = self.project();

            // First poll the sleep until complete
            match this.sleep.poll(cx) {
                Poll::Pending => return Poll::Pending,
                Poll::Ready(_) => {}
            }

            // Then poll the inner future
            match this.response.poll(cx) {
                Poll::Ready(v) => Poll::Ready(v.map_err(Into::into)),
                Poll::Pending => Poll::Pending,
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure a delay layer to add a 500-millisecond delay before processing requests in a tower service?
  codeQuestion3: What steps are involved in handling the delay and ensuring the response is correctly processed after the delay expires?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/support/delay_server.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    #![allow(unused)]
    use std::convert::Infallible;
    use std::future::Future;
    use std::net;
    use std::time::Duration;

    use futures_util::FutureExt;
    use http::{Request, Response};
    use hyper::service::service_fn;
    use tokio::net::TcpListener;
    use tokio::select;
    use tokio::sync::oneshot;

    /// This server, unlike [`super::server::Server`], allows for delaying the
    /// specified amount of time after each TCP connection is established. This is
    /// useful for testing the behavior of the client when the server is slow.
    ///
    /// For example, in case of HTTP/2, once the TCP/TLS connection is established,
    /// both endpoints are supposed to send a preface and an initial `SETTINGS`
    /// frame (See [RFC9113 3.4] for details). What if these frames are delayed for
    /// whatever reason? This server allows for testing such scenarios.
    ///
    /// [RFC9113 3.4]: https://www.rfc-editor.org/rfc/rfc9113.html#name-http-2-connection-preface
    pub struct Server {
        addr: net::SocketAddr,
        shutdown_tx: Option<oneshot::Sender<()>>,
        server_terminated_rx: oneshot::Receiver<()>,
    }

    type Builder = hyper_util::server::conn::auto::Builder<hyper_util::rt::TokioExecutor>;

    impl Server {
        pub async fn new<F1, Fut, F2, Bu>(func: F1, apply_config: F2, delay: Duration) -> Self
        where
            F1: Fn(Request<hyper::body::Incoming>) -> Fut + Clone + Send + 'static,
            Fut: Future<Output = Response<reqwest::Body>> + Send + 'static,
            F2: FnOnce(&mut Builder) -> Bu + Send + 'static,
        {
            let (shutdown_tx, shutdown_rx) = oneshot::channel();
            let (server_terminated_tx, server_terminated_rx) = oneshot::channel();

            let tcp_listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
            let addr = tcp_listener.local_addr().unwrap();

            tokio::spawn(async move {
                let mut builder =
                    hyper_util::server::conn::auto::Builder::new(hyper_util::rt::TokioExecutor::new());
                apply_config(&mut builder);

                tokio::spawn(async move {
                    let builder = builder;
                    let (connection_shutdown_tx, connection_shutdown_rx) = oneshot::channel();
                    let connection_shutdown_rx = connection_shutdown_rx.shared();
                    let mut shutdown_rx = std::pin::pin!(shutdown_rx);

                    let mut handles = Vec::new();
                    loop {
                        select! {
                            _ = shutdown_rx.as_mut() => {
                                connection_shutdown_tx.send(()).unwrap();
                                break;
                            }
                            res = tcp_listener.accept() => {
                                let (stream, _) = res.unwrap();
                                let io = hyper_util::rt::TokioIo::new(stream);


                                let handle = tokio::spawn({
                                    let connection_shutdown_rx = connection_shutdown_rx.clone();
                                    let func = func.clone();
                                    let svc = service_fn(move |req| {
                                        let fut = func(req);
                                        async move {
                                        Ok::<_, Infallible>(fut.await)
                                    }});
                                    let builder = builder.clone();

                                    async move {
                                        let fut = builder.serve_connection_with_upgrades(io, svc);
                                        tokio::time::sleep(delay).await;

                                        let mut conn = std::pin::pin!(fut);

                                        select! {
                                            _ = conn.as_mut() => {}
                                            _ = connection_shutdown_rx => {
                                                conn.as_mut().graceful_shutdown();
                                                conn.await.unwrap();
                                            }
                                        }
                                    }
                                });

                                handles.push(handle);
                            }
                        }
                    }

                    futures_util::future::join_all(handles).await;
                    server_terminated_tx.send(()).unwrap();
                });
            });

            Self {
                addr,
                shutdown_tx: Some(shutdown_tx),
                server_terminated_rx,
            }
        }

        pub async fn shutdown(mut self) {
            if let Some(tx) = self.shutdown_tx.take() {
                let _ = tx.send(());
            }

            self.server_terminated_rx.await.unwrap();
        }

        pub fn addr(&self) -> net::SocketAddr {
            self.addr
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the server handle delayed responses after each TCP connection is established, and what system calls or APIs are used for this?
  codeQuestion3: What steps are taken to handle the shutdown process of the server, and what APIs or functions are involved in this process?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/support/server.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(not(target_arch = "wasm32"))]
    use std::convert::Infallible;
    use std::future::Future;
    use std::net;
    use std::sync::mpsc as std_mpsc;
    use std::thread;
    use std::time::Duration;

    use tokio::io::AsyncReadExt;
    use tokio::net::TcpStream;
    use tokio::runtime;
    use tokio::sync::oneshot;

    pub struct Server {
        addr: net::SocketAddr,
        panic_rx: std_mpsc::Receiver<()>,
        events_rx: std_mpsc::Receiver<Event>,
        shutdown_tx: Option<oneshot::Sender<()>>,
    }

    #[non_exhaustive]
    pub enum Event {
        ConnectionClosed,
    }

    impl Server {
        pub fn addr(&self) -> net::SocketAddr {
            self.addr
        }

        pub fn events(&mut self) -> Vec<Event> {
            let mut events = Vec::new();
            while let Ok(event) = self.events_rx.try_recv() {
                events.push(event);
            }
            events
        }
    }

    impl Drop for Server {
        fn drop(&mut self) {
            if let Some(tx) = self.shutdown_tx.take() {
                let _ = tx.send(());
            }

            if !::std::thread::panicking() {
                self.panic_rx
                    .recv_timeout(Duration::from_secs(3))
                    .expect("test server should not panic");
            }
        }
    }

    pub fn http<F, Fut>(func: F) -> Server
    where
        F: Fn(http::Request<hyper::body::Incoming>) -> Fut + Clone + Send + 'static,
        Fut: Future<Output = http::Response<reqwest::Body>> + Send + 'static,
    {
        http_with_config(func, |_builder| {})
    }

    type Builder = hyper_util::server::conn::auto::Builder<hyper_util::rt::TokioExecutor>;

    pub fn http_with_config<F1, Fut, F2, Bu>(func: F1, apply_config: F2) -> Server
    where
        F1: Fn(http::Request<hyper::body::Incoming>) -> Fut + Clone + Send + 'static,
        Fut: Future<Output = http::Response<reqwest::Body>> + Send + 'static,
        F2: FnOnce(&mut Builder) -> Bu + Send + 'static,
    {
        // Spawn new runtime in thread to prevent reactor execution context conflict
        let test_name = thread::current().name().unwrap_or("<unknown>").to_string();
        thread::spawn(move || {
            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let listener = rt.block_on(async move {
                tokio::net::TcpListener::bind(&std::net::SocketAddr::from(([127, 0, 0, 1], 0)))
                    .await
                    .unwrap()
            });
            let addr = listener.local_addr().unwrap();

            let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
            let (panic_tx, panic_rx) = std_mpsc::channel();
            let (events_tx, events_rx) = std_mpsc::channel();
            let tname = format!(
                "test({})-support-server",
                test_name,
            );
            thread::Builder::new()
                .name(tname)
                .spawn(move || {
                    rt.block_on(async move {
                        let mut builder =
                            hyper_util::server::conn::auto::Builder::new(hyper_util::rt::TokioExecutor::new());
                        apply_config(&mut builder);

                        loop {
                            tokio::select! {
                                _ = &mut shutdown_rx => {
                                    break;
                                }
                                accepted = listener.accept() => {
                                    let (io, _) = accepted.expect("accepted");
                                    let func = func.clone();
                                    let svc = hyper::service::service_fn(move |req| {
                                        let fut = func(req);
                                        async move { Ok::<_, Infallible>(fut.await) }
                                    });
                                    let builder = builder.clone();
                                    let events_tx = events_tx.clone();
                                    tokio::spawn(async move {
                                        let _ = builder.serve_connection_with_upgrades(hyper_util::rt::TokioIo::new(io), svc).await;
                                        let _ = events_tx.send(Event::ConnectionClosed);
                                    });
                                }
                            }
                        }
                        let _ = panic_tx.send(());
                    });
                })
                .expect("thread spawn");
            Server {
                addr,
                panic_rx,
                events_rx,
                shutdown_tx: Some(shutdown_tx),
            }
        })
        .join()
        .unwrap()
    }

    #[cfg(feature = "http3")]
    #[derive(Debug, Default)]
    pub struct Http3 {
        addr: Option<std::net::SocketAddr>,
    }

    #[cfg(feature = "http3")]
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `http` function create a server and handle incoming HTTP requests?
  codeQuestion3: What steps are involved in setting up the server's runtime and handling shutdown signals?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/support/server.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Http3 {
        pub fn new() -> Self {
            Self::default()
        }

        pub fn with_addr(mut self, addr: std::net::SocketAddr) -> Self {
            self.addr = Some(addr);
            self
        }

        pub fn build<F1, Fut>(self, func: F1) -> Server
        where
            F1: Fn(
                    http::Request<
                        http_body_util::combinators::BoxBody<bytes::Bytes, h3::error::StreamError>,
                    >,
                ) -> Fut
                + Clone
                + Send
                + 'static,
            Fut: Future<Output = http::Response<reqwest::Body>> + Send + 'static,
        {
            use bytes::Buf;
            use http_body_util::BodyExt;
            use quinn::crypto::rustls::QuicServerConfig;
            use std::sync::Arc;

            let addr = self.addr.unwrap_or_else(|| "[::1]:0".parse().unwrap());

            // Spawn new runtime in thread to prevent reactor execution context conflict
            let test_name = thread::current().name().unwrap_or("<unknown>").to_string();
            thread::spawn(move || {
                let rt = runtime::Builder::new_current_thread()
                    .enable_all()
                    .build()
                    .expect("new rt");

                let cert = std::fs::read("tests/support/server.cert").unwrap().into();
                let key = std::fs::read("tests/support/server.key").unwrap().try_into().unwrap();

                let mut tls_config = rustls::ServerConfig::builder()
                    .with_no_client_auth()
                    .with_single_cert(vec![cert], key)
                    .unwrap();
                tls_config.max_early_data_size = u32::MAX;
                tls_config.alpn_protocols = vec![b"h3".into()];

                let server_config = quinn::ServerConfig::with_crypto(Arc::new(QuicServerConfig::try_from(tls_config).unwrap()));
                let endpoint = rt.block_on(async move {
                    quinn::Endpoint::server(server_config, addr).unwrap()
                });
                let addr = endpoint.local_addr().unwrap();

                let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
                let (panic_tx, panic_rx) = std_mpsc::channel();
                let (events_tx, events_rx) = std_mpsc::channel();
                let tname = format!(
                    "test({})-support-server",
                    test_name,
                );
                thread::Builder::new()
                    .name(tname)
                    .spawn(move || {
                        rt.block_on(async move {

                            loop {
                                tokio::select! {
                                    _ = &mut shutdown_rx => {
                                        break;
                                    }
                                    Some(accepted) = endpoint.accept() => {
                                        let conn = accepted.await.expect("accepted");
                                        let mut h3_conn = h3::server::Connection::new(h3_quinn::Connection::new(conn)).await.unwrap();
                                        let events_tx = events_tx.clone();
                                        let func = func.clone();
                                        tokio::spawn(async move {
                                            while let Ok(Some(resolver)) = h3_conn.accept().await {
                                                let events_tx = events_tx.clone();
                                                let func = func.clone();
                                                tokio::spawn(async move {
                                                    if let Ok((req, stream)) = resolver.resolve_request().await {
                                                        let (mut tx, rx) = stream.split();
                                                        let body = futures_util::stream::unfold(rx, |mut rx| async move {
                                                            match rx.recv_data().await {
                                                                Ok(Some(mut buf)) => {
                                                                    Some((Ok(hyper::body::Frame::data(buf.copy_to_bytes(buf.remaining()))), rx))
                                                                },
                                                                Ok(None) => None,
                                                                Err(err) => {
                                                                    Some((Err(err), rx))
                                                                }
                                                            }
                                                        });
                                                        let body = BodyExt::boxed(http_body_util::StreamBody::new(body));
                                                        let resp = func(req.map(move |()| body)).await;
                                                        let (parts, mut body) = resp.into_parts();
                                                        let resp = http::Response::from_parts(parts, ());
                                                        tx.send_response(resp).await.unwrap();

                                                        while let Some(Ok(frame)) = body.frame().await {
                                                            if let Ok(data) = frame.into_data() {
                                                                tx.send_data(data).await.unwrap();
                                                            }
                                                        }
                                                        tx.finish().await.unwrap();
                                                        events_tx.send(Event::ConnectionClosed).unwrap();
                                                    }
                                                });
                                            }
                                        });
                                    }
                                }
                            }
                            let _ = panic_tx.send(());
                        });
                    })
                    .expect("thread spawn");
                Server {
                    addr,
                    panic_rx,
                    events_rx,
                    shutdown_tx: Some(shutdown_tx),
                }
            })
            .join()
            .unwrap()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle user input for a new game, and what APIs are used to process this input?
  codeQuestion3: What steps are taken to set up the HTTP/3 server with TLS and Quic protocols?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/support/server.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub fn low_level_with_response<F>(do_response: F) -> Server
    where
        for<'c> F: Fn(&'c [u8], &'c mut TcpStream) -> Box<dyn Future<Output = ()> + Send + 'c>
            + Clone
            + Send
            + 'static,
    {
        // Spawn new runtime in thread to prevent reactor execution context conflict
        let test_name = thread::current().name().unwrap_or("<unknown>").to_string();
        thread::spawn(move || {
            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let listener = rt.block_on(async move {
                tokio::net::TcpListener::bind(&std::net::SocketAddr::from(([127, 0, 0, 1], 0)))
                    .await
                    .unwrap()
            });
            let addr = listener.local_addr().unwrap();

            let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
            let (panic_tx, panic_rx) = std_mpsc::channel();
            let (events_tx, events_rx) = std_mpsc::channel();
            let tname = format!("test({})-support-server", test_name,);
            thread::Builder::new()
                .name(tname)
                .spawn(move || {
                    rt.block_on(async move {
                        loop {
                            tokio::select! {
                                _ = &mut shutdown_rx => {
                                    break;
                                }
                                accepted = listener.accept() => {
                                    let (io, _) = accepted.expect("accepted");
                                    let do_response = do_response.clone();
                                    let events_tx = events_tx.clone();
                                    tokio::spawn(async move {
                                        low_level_server_client(io, do_response).await;
                                        let _ = events_tx.send(Event::ConnectionClosed);
                                    });
                                }
                            }
                        }
                        let _ = panic_tx.send(());
                    });
                })
                .expect("thread spawn");
            Server {
                addr,
                panic_rx,
                events_rx,
                shutdown_tx: Some(shutdown_tx),
            }
        })
        .join()
        .unwrap()
    }

    async fn low_level_server_client<F>(mut client_socket: TcpStream, do_response: F)
    where
        for<'c> F: Fn(&'c [u8], &'c mut TcpStream) -> Box<dyn Future<Output = ()> + Send + 'c>,
    {
        loop {
            let request = low_level_read_http_request(&mut client_socket)
                .await
                .expect("read_http_request failed");
            if request.is_empty() {
                // connection closed by client
                break;
            }

            Box::into_pin(do_response(&request, &mut client_socket)).await;
        }
    }

    async fn low_level_read_http_request(
        client_socket: &mut TcpStream,
    ) -> core::result::Result<Vec<u8>, std::io::Error> {
        let mut buf = Vec::new();

        // Read until the delimiter "\r\n\r\n" is found
        loop {
            let mut temp_buffer = [0; 1024];
            let n = client_socket.read(&mut temp_buffer).await?;

            if n == 0 {
                break;
            }

            buf.extend_from_slice(&temp_buffer[..n]);

            if let Some(pos) = buf.windows(4).position(|window| window == b"\r\n\r\n") {
                return Ok(buf.drain(..pos + 4).collect());
            }
        }

        Ok(buf)
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the server handle incoming HTTP requests and what is the role of the `do_response` function in this context?
  codeQuestion3: What steps are taken to manage the server's lifecycle and handle shutdown or panic events?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/support/mod.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub mod delay_layer;
    pub mod delay_server;
    pub mod server;

    // TODO: remove once done converting to new support server?
    #[allow(unused)]
    pub static DEFAULT_USER_AGENT: &str =
        concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION"));
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle user agent string configuration for HTTP requests?
  codeQuestion3: What is the role of the 'delay_layer' and 'delay_server' modules in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/zstd.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod support;
    use support::server;
    use tokio::io::AsyncWriteExt;

    #[tokio::test]
    async fn zstd_response() {
        zstd_case(10_000, 4096).await;
    }

    #[tokio::test]
    async fn zstd_single_byte_chunks() {
        zstd_case(10, 1).await;
    }

    #[tokio::test]
    async fn test_zstd_empty_body() {
        let server = server::http(move |req| async move {
            assert_eq!(req.method(), "HEAD");

            http::Response::builder()
                .header("content-encoding", "zstd")
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::new();
        let res = client
            .head(&format!("http://{}/zstd", server.addr()))
            .send()
            .await
            .unwrap();

        let body = res.text().await.unwrap();

        assert_eq!(body, "");
    }

    #[tokio::test]
    async fn test_accept_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "application/json");
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("zstd"));
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept", server.addr()))
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn test_accept_encoding_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "*/*");
            assert_eq!(req.headers()["accept-encoding"], "identity");
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept-encoding", server.addr()))
            .header(
                reqwest::header::ACCEPT_ENCODING,
                reqwest::header::HeaderValue::from_static("identity"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    async fn zstd_case(response_size: usize, chunk_size: usize) {
        use futures_util::stream::StreamExt;

        let content: String = (0..response_size)
            .into_iter()
            .map(|i| format!("test {i}"))
            .collect();

        let zstded_content = zstd_crate::encode_all(content.as_bytes(), 3).unwrap();

        let mut response = format!(
            "\
             HTTP/1.1 200 OK\r\n\
             Server: test-accept\r\n\
             Content-Encoding: zstd\r\n\
             Content-Length: {}\r\n\
             \r\n",
            &zstded_content.len()
        )
        .into_bytes();
        response.extend(&zstded_content);

        let server = server::http(move |req| {
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("zstd"));

            let zstded = zstded_content.clone();
            async move {
                let len = zstded.len();
                let stream =
                    futures_util::stream::unfold((zstded, 0), move |(zstded, pos)| async move {
                        let chunk = zstded.chunks(chunk_size).nth(pos)?.to_vec();

                        Some((chunk, (zstded, pos + 1)))
                    });

                let body = reqwest::Body::wrap_stream(stream.map(Ok::<_, std::convert::Infallible>));

                http::Response::builder()
                    .header("content-encoding", "zstd")
                    .header("content-length", len)
                    .body(body)
                    .unwrap()
            }
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/zstd", server.addr()))
            .send()
            .await
            .expect("response");

        let body = res.text().await.expect("text");
        assert_eq!(body, content);
    }

    const COMPRESSED_RESPONSE_HEADERS: &[u8] = b"HTTP/1.1 200 OK\x0d\x0a\
                Content-Type: text/plain\x0d\x0a\
                Connection: keep-alive\x0d\x0a\
                Content-Encoding: zstd\x0d\x0a";

    const RESPONSE_CONTENT: &str = "some message here";

    fn zstd_compress(input: &[u8]) -> Vec<u8> {
        zstd_crate::encode_all(input, 3).unwrap()
    }

    #[tokio::test]
    async fn test_non_chunked_non_fragmented_response() {
        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let zstded_content = zstd_compress(RESPONSE_CONTENT.as_bytes());
                let content_length_header =
                    format!("Content-Length: {}\r\n\r\n", zstded_content.len()).into_bytes();
                let response = [
                    COMPRESSED_RESPONSE_HEADERS,
                    &content_length_header,
                    &zstded_content,
                ]
                .concat();

                client_socket
                    .write_all(response.as_slice())
                    .await
                    .expect("response write_all failed");
                client_socket.flush().await.expect("response flush failed");
            })
        });

        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `zstd_case` function handle large response data in chunks, and what system calls or APIs are used for this?
  codeQuestion3: What mechanisms are in place to handle and verify the correct compression and decompression of data between the server and client?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/zstd.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    // Big response can have multiple ZSTD frames in it
    #[tokio::test]
    async fn test_non_chunked_non_fragmented_multiple_frames_response() {
        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                // Split the content into two parts
                let content_bytes = RESPONSE_CONTENT.as_bytes();
                let mid = content_bytes.len() / 2;
                // Compress each part separately to create multiple ZSTD frames
                let compressed_part1 = zstd_crate::encode_all(&content_bytes[0..mid], 3).unwrap();
                let compressed_part2 = zstd_crate::encode_all(&content_bytes[mid..], 3).unwrap();
                // Concatenate the compressed frames
                let mut zstded_content = compressed_part1;
                zstded_content.extend_from_slice(&compressed_part2);
                // Set Content-Length to the total length of the concatenated frames
                let content_length_header =
                    format!("Content-Length: {}\r\n\r\n", zstded_content.len()).into_bytes();
                let response = [
                    COMPRESSED_RESPONSE_HEADERS,
                    &content_length_header,
                    &zstded_content,
                ]
                .concat();

                client_socket
                    .write_all(response.as_slice())
                    .await
                    .expect("response write_all failed");
                client_socket.flush().await.expect("response flush failed");
            })
        });

        let res = reqwest::Client::new()
            .get(format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_multiple_frames_in_one_chunk() {
        // Define constants for delay and timing margin
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000); // 1-second delay
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50); // Margin for timing assertions

        // Set up a low-level server
        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                // Split RESPONSE_CONTENT into two parts
                let mid = RESPONSE_CONTENT.len() / 2;
                let part1 = &RESPONSE_CONTENT[0..mid];
                let part2 = &RESPONSE_CONTENT[mid..];

                // Compress each part separately to create two ZSTD frames
                let compressed_part1 = zstd_compress(part1.as_bytes());
                let compressed_part2 = zstd_compress(part2.as_bytes());

                // Concatenate the frames into a single chunk's data
                let chunk_data = [compressed_part1.as_slice(), compressed_part2.as_slice()].concat();

                // Calculate the chunk size in bytes
                let chunk_size = chunk_data.len();

                // Prepare the initial response part: headers + chunk size
                let headers = [
                    COMPRESSED_RESPONSE_HEADERS, // e.g., "HTTP/1.1 200 OK\r\nContent-Encoding: zstd\r\n"
                    b"Transfer-Encoding: chunked\r\n\r\n", // Indicate chunked encoding
                    format!("{:x}\r\n", chunk_size).as_bytes(), // Chunk size in hex
                ]
                .concat();

                // Send headers + chunk size + chunk data
                client_socket
                    .write_all([headers.as_slice(), &chunk_data].concat().as_slice())
                    .await
                    .expect("write_all failed");
                client_socket.flush().await.expect("flush failed");

                // Introduce a delay to simulate fragmentation
                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                // Send chunk terminator + final chunk
                client_socket
                    .write_all(b"\r\n0\r\n\r\n")
                    .await
                    .expect("write_all failed");
                client_socket.flush().await.expect("flush failed");
            })
        });

        // Record the start time for delay verification
        let start = tokio::time::Instant::now();

        let res = reqwest::Client::new()
            .get(format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("Failed to get response");

        // Verify the decompressed response matches the original content
        assert_eq!(
            res.text().await.expect("Failed to read text"),
            RESPONSE_CONTENT
        );
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_connection_reuse_with_chunked_fragmented_multiple_frames_in_one_chunk() {
        // Define constants for delay and timing margin
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000); // 1-second delay
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50); // Margin for timing assertions

        // We will record the peer addresses of each client request here
        let peer_addrs = std::sync::Arc::new(std::sync::Mutex::new(Vec::<std::net::SocketAddr>::new()));
        let peer_addrs_clone = peer_addrs.clone();

        // Set up a low-level server (it will reuse existing client connection, executing callback for each client request)
        let server = server::low_level_with_response(move |_raw_request, client_socket| {
            let peer_addrs = peer_addrs_clone.clone();
            Box::new(async move {
                // Split RESPONSE_CONTENT into two parts
                let mid = RESPONSE_CONTENT.len() / 2;
                let part1 = &RESPONSE_CONTENT[0..mid];
                let part2 = &RESPONSE_CONTENT[mid..];

                // Compress each part separately to create two ZSTD frames
                let compressed_part1 = zstd_compress(part1.as_bytes());
                let compressed_part2 = zstd_compress(part2.as_bytes());

                // Concatenate the frames into a single chunk's data
                let chunk_data = [compressed_part1.as_slice(), compressed_part2.as_slice()].concat();

                // Calculate the chunk size in bytes
                let chunk_size = chunk_data.len();

                // Prepare the initial response part: headers + chunk size
                let headers = [
                    COMPRESSED_RESPONSE_HEADERS, // e.g., "HTTP/1.1 200 OK\r\nContent-Encoding: zstd\r\n"
                    b"Transfer-Encoding: chunked\r\n\r\n", // Indicate chunked encoding
                    format!("{:x}\r\n", chunk_size).as_bytes(), // Chunk size in hex
                ]
                .concat();

                // Send headers + chunk size + chunk data
                client_socket
                    .write_all([headers.as_slice(), &chunk_data].concat().as_slice())
                    .await
                    .expect("write_all failed");
                client_socket.flush().await.expect("flush failed");

                // Introduce a delay to simulate fragmentation
                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                peer_addrs
                    .lock()
                    .unwrap()
                    .push(client_socket.peer_addr().unwrap());

                // Send chunk terminator + final chunk
                client_socket
                    .write_all(b"\r\n0\r\n\r\n")
                    .await
                    .expect("write_all failed");
                client_socket.flush().await.expect("flush failed");
            })
        });

        let client = reqwest::Client::builder()
            .pool_idle_timeout(std::time::Duration::from_secs(30))
            .pool_max_idle_per_host(1)
            .build()
            .unwrap();

        const NUMBER_OF_REQUESTS: usize = 5;

        for _ in 0..NUMBER_OF_REQUESTS {
            // Record the start time for delay verification
            let start = tokio::time::Instant::now();

            let res = client
                .get(format!("http://{}/", server.addr()))
                .send()
                .await
                .expect("Failed to get response");

            // Verify the decompressed response matches the original content
            assert_eq!(
                res.text().await.expect("Failed to read text"),
                RESPONSE_CONTENT
            );
            assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
        }

        drop(client);

        // Check that all peer addresses are the same
        let peer_addrs = peer_addrs.lock().unwrap();
        assert_eq!(
            peer_addrs.len(),
            NUMBER_OF_REQUESTS,
            "Expected {} peer addresses, but got {}",
            NUMBER_OF_REQUESTS,
            peer_addrs.len()
        );
        let first_addr = peer_addrs[0];
        assert!(
            peer_addrs.iter().all(|addr| addr == &first_addr),
            "All peer addresses should be the same, but found differences: {:?}",
            peer_addrs
        );
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle sending a response with multiple ZSTD frames in a chunked transfer encoded HTTP response?
  codeQuestion3: What steps are taken to ensure connection reuse in a scenario where multiple requests are made with chunked transfer encoded responses?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/zstd.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn test_chunked_fragmented_response_1() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let zstded_content = zstd_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        zstded_content.len()
                    )
                    .as_bytes(),
                    &zstded_content,
                ]
                .concat();
                let response_second_part = b"\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_2() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let zstded_content = zstd_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        zstded_content.len()
                    )
                    .as_bytes(),
                    &zstded_content,
                    b"\r\n",
                ]
                .concat();
                let response_second_part = b"0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_with_extra_bytes() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let zstded_content = zstd_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        zstded_content.len()
                    )
                    .as_bytes(),
                    &zstded_content,
                ]
                .concat();
                let response_second_part = b"\r\n2ab\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        let err = res.text().await.expect_err("there must be an error");
        assert!(err.is_decode());
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `test_chunked_fragmented_response_1` function simulate a chunked response with Zstd compression, and what system calls are involved in handling the network communication?
  codeQuestion3: What steps are taken in `test_chunked_fragmented_response_with_extra_bytes` to handle invalid chunked response data, and how does the code verify that an error is correctly raised?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/blocking.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod support;

    use http::header::{CONTENT_LENGTH, CONTENT_TYPE, TRANSFER_ENCODING};
    use http_body_util::BodyExt;
    #[cfg(feature = "json")]
    use std::collections::HashMap;
    use support::server;

    #[test]
    fn test_response_text() {
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let url = format!("http://{}/text", server.addr());
        let res = reqwest::blocking::get(&url).unwrap();
        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        assert_eq!(res.content_length(), Some(5));

        let body = res.text().unwrap();
        assert_eq!(b"Hello", body.as_bytes());
    }

    #[test]
    fn donot_set_content_length_0_if_have_no_body() {
        let server = server::http(move |req| async move {
            let headers = req.headers();
            assert_eq!(headers.get(CONTENT_LENGTH), None);
            assert!(headers.get(CONTENT_TYPE).is_none());
            assert!(headers.get(TRANSFER_ENCODING).is_none());
            http::Response::default()
        });

        let url = format!("http://{}/content-length", server.addr());
        let res = reqwest::blocking::Client::builder()
            .no_proxy()
            .build()
            .expect("client builder")
            .get(&url)
            .send()
            .expect("request");

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[test]
    #[cfg(feature = "charset")]
    fn test_response_non_utf_8_text() {
        let server = server::http(move |_req| async {
            http::Response::builder()
                .header("content-type", "text/plain; charset=gbk")
                .body(b"\xc4\xe3\xba\xc3"[..].into())
                .unwrap()
        });

        let url = format!("http://{}/text", server.addr());
        let res = reqwest::blocking::get(&url).unwrap();
        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        assert_eq!(res.content_length(), Some(4));

        let body = res.text().unwrap();
        assert_eq!("", &body);
        assert_eq!(b"\xe4\xbd\xa0\xe5\xa5\xbd", body.as_bytes()); // Now it's utf-8
    }

    #[test]
    #[cfg(feature = "json")]
    fn test_response_json() {
        let server = server::http(move |_req| async { http::Response::new("\"Hello\"".into()) });

        let url = format!("http://{}/json", server.addr());
        let res = reqwest::blocking::get(&url).unwrap();
        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        assert_eq!(res.content_length(), Some(7));

        let body = res.json::<String>().unwrap();
        assert_eq!("Hello", body);
    }

    #[test]
    fn test_response_copy_to() {
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let url = format!("http://{}/1", server.addr());
        let mut res = reqwest::blocking::get(&url).unwrap();
        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);

        let mut dst = Vec::new();
        res.copy_to(&mut dst).unwrap();
        assert_eq!(dst, b"Hello");
    }

    #[test]
    fn test_get() {
        let server = server::http(move |_req| async { http::Response::default() });

        let url = format!("http://{}/1", server.addr());
        let res = reqwest::blocking::get(&url).unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        assert_eq!(res.remote_addr(), Some(server.addr()));

        assert_eq!(res.text().unwrap().len(), 0)
    }

    #[test]
    fn test_post() {
        let server = server::http(move |req| async move {
            assert_eq!(req.method(), "POST");
            assert_eq!(req.headers()["content-length"], "5");

            let data = req.into_body().collect().await.unwrap().to_bytes();
            assert_eq!(&*data, b"Hello");

            http::Response::default()
        });

        let url = format!("http://{}/2", server.addr());
        let res = reqwest::blocking::Client::new()
            .post(&url)
            .body("Hello")
            .send()
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[test]
    fn test_post_form() {
        let server = server::http(move |req| async move {
            assert_eq!(req.method(), "POST");
            assert_eq!(req.headers()["content-length"], "24");
            assert_eq!(
                req.headers()["content-type"],
                "application/x-www-form-urlencoded"
            );

            let data = req.into_body().collect().await.unwrap().to_bytes();
            assert_eq!(&*data, b"hello=world&sean=monstar");

            http::Response::default()
        });

        let form = &[("hello", "world"), ("sean", "monstar")];

        let url = format!("http://{}/form", server.addr());
        let res = reqwest::blocking::Client::new()
            .post(&url)
            .form(form)
            .send()
            .expect("request send");

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    /// Calling `Response::error_for_status`` on a response with status in 4xx
    /// returns an error.
    #[test]
    fn test_error_for_status_4xx() {
        let server = server::http(move |_req| async {
            http::Response::builder()
                .status(400)
                .body(Default::default())
                .unwrap()
        });

        let url = format!("http://{}/1", server.addr());
        let res = reqwest::blocking::get(&url).unwrap();

        let err = res.error_for_status().unwrap_err();
        assert!(err.is_status());
        assert_eq!(err.status(), Some(reqwest::StatusCode::BAD_REQUEST));
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user send a POST request with form data, and what system calls are involved in handling the input for this action?
  codeQuestion3: What steps are taken to handle terminal input and output settings for the game?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/blocking.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// Calling `Response::error_for_status`` on a response with status in 5xx
    /// returns an error.
    #[test]
    fn test_error_for_status_5xx() {
        let server = server::http(move |_req| async {
            http::Response::builder()
                .status(500)
                .body(Default::default())
                .unwrap()
        });

        let url = format!("http://{}/1", server.addr());
        let res = reqwest::blocking::get(&url).unwrap();

        let err = res.error_for_status().unwrap_err();
        assert!(err.is_status());
        assert_eq!(
            err.status(),
            Some(reqwest::StatusCode::INTERNAL_SERVER_ERROR)
        );
    }

    #[test]
    fn test_default_headers() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["reqwest-test"], "orly");
            http::Response::default()
        });

        let mut headers = http::HeaderMap::with_capacity(1);
        headers.insert("reqwest-test", "orly".parse().unwrap());
        let client = reqwest::blocking::Client::builder()
            .default_headers(headers)
            .build()
            .unwrap();

        let url = format!("http://{}/1", server.addr());
        let res = client.get(&url).send().unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[test]
    fn test_override_default_headers() {
        let server = server::http(move |req| {
            async move {
                // not 'iamatoken'
                assert_eq!(req.headers()[&http::header::AUTHORIZATION], "secret");
                http::Response::default()
            }
        });

        let mut headers = http::HeaderMap::with_capacity(1);
        headers.insert(
            http::header::AUTHORIZATION,
            http::header::HeaderValue::from_static("iamatoken"),
        );
        let client = reqwest::blocking::Client::builder()
            .default_headers(headers)
            .build()
            .unwrap();

        let url = format!("http://{}/3", server.addr());
        let res = client
            .get(&url)
            .header(
                http::header::AUTHORIZATION,
                http::header::HeaderValue::from_static("secret"),
            )
            .send()
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[test]
    fn test_appended_headers_not_overwritten() {
        let server = server::http(move |req| async move {
            let mut accepts = req.headers().get_all("accept").into_iter();
            assert_eq!(accepts.next().unwrap(), "application/json");
            assert_eq!(accepts.next().unwrap(), "application/json+hal");
            assert_eq!(accepts.next(), None);

            http::Response::default()
        });

        let client = reqwest::blocking::Client::new();

        let url = format!("http://{}/4", server.addr());
        let res = client
            .get(&url)
            .header(header::ACCEPT, "application/json")
            .header(header::ACCEPT, "application/json+hal")
            .send()
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);

        // make sure this also works with default headers
        use reqwest::header;
        let mut headers = header::HeaderMap::with_capacity(1);
        headers.insert(
            header::ACCEPT,
            header::HeaderValue::from_static("text/html"),
        );
        let client = reqwest::blocking::Client::builder()
            .default_headers(headers)
            .build()
            .unwrap();

        let url = format!("http://{}/4", server.addr());
        let res = client
            .get(&url)
            .header(header::ACCEPT, "application/json")
            .header(header::ACCEPT, "application/json+hal")
            .send()
            .unwrap();

        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[cfg_attr(not(debug_assertions), ignore)]
    #[test]
    #[should_panic]
    fn test_blocking_inside_a_runtime() {
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let url = format!("http://{}/text", server.addr());

        let rt = tokio::runtime::Builder::new_current_thread()
            .build()
            .expect("new rt");

        rt.block_on(async move {
            let _should_panic = reqwest::blocking::get(&url);
        });
    }

    #[cfg(feature = "default-tls")]
    #[test]
    fn test_allowed_methods_blocking() {
        let resp = reqwest::blocking::Client::builder()
            .https_only(true)
            .build()
            .expect("client builder")
            .get("https://google.com")
            .send();

        assert_eq!(resp.is_err(), false);

        let resp = reqwest::blocking::Client::builder()
            .https_only(true)
            .build()
            .expect("client builder")
            .get("http://google.com")
            .send();

        assert_eq!(resp.is_err(), true);
    }

    /// Test that a [`reqwest::blocking::Body`] can be created from [`bytes::Bytes`].
    #[test]
    fn test_body_from_bytes() {
        let body = "abc";
        // No external calls are needed. Only the request building is tested.
        let request = reqwest::blocking::Client::builder()
            .build()
            .expect("Could not build the client")
            .put("https://google.com")
            .body(bytes::Bytes::from(body))
            .build()
            .expect("Invalid body");

        assert_eq!(request.body().unwrap().as_bytes(), Some(body.as_bytes()));
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle setting default headers for a request, and what is an example of using it?
  codeQuestion3: What system calls or functions are used to handle the blocking nature of the requests in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/blocking.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[test]
    #[cfg(feature = "json")]
    fn blocking_add_json_default_content_type_if_not_set_manually() {
        use http::header::HeaderValue;

        let mut map = HashMap::new();
        map.insert("body", "json");
        let content_type = HeaderValue::from_static("application/vnd.api+json");
        let req = reqwest::blocking::Client::new()
            .post("https://google.com/")
            .header(CONTENT_TYPE, &content_type)
            .json(&map)
            .build()
            .expect("request is not valid");

        assert_eq!(content_type, req.headers().get(CONTENT_TYPE).unwrap());
    }

    #[test]
    #[cfg(feature = "json")]
    fn blocking_update_json_content_type_if_set_manually() {
        let mut map = HashMap::new();
        map.insert("body", "json");
        let req = reqwest::blocking::Client::new()
            .post("https://google.com/")
            .json(&map)
            .build()
            .expect("request is not valid");

        assert_eq!("application/json", req.headers().get(CONTENT_TYPE).unwrap());
    }

    #[test]
    #[cfg(feature = "__tls")]
    fn test_response_no_tls_info_for_http() {
        let server = server::http(move |_req| async { http::Response::new("Hello".into()) });

        let url = format!("http://{}/text", server.addr());

        let client = reqwest::blocking::Client::builder()
            .tls_info(true)
            .build()
            .unwrap();

        let res = client.get(&url).send().unwrap();
        assert_eq!(res.url().as_str(), &url);
        assert_eq!(res.status(), reqwest::StatusCode::OK);
        assert_eq!(res.content_length(), Some(5));
        let tls_info = res.extensions().get::<reqwest::tls::TlsInfo>();
        assert_eq!(tls_info.is_none(), true);

        let body = res.text().unwrap();
        assert_eq!(b"Hello", body.as_bytes());
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code ensure that the correct content type is set when sending JSON data in a blocking request?
  codeQuestion3: What steps are taken to handle TLS information when making an HTTP request with the reqwest library?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/brotli.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod support;
    use std::io::Read;
    use support::server;
    use tokio::io::AsyncWriteExt;

    #[tokio::test]
    async fn brotli_response() {
        brotli_case(10_000, 4096).await;
    }

    #[tokio::test]
    async fn brotli_single_byte_chunks() {
        brotli_case(10, 1).await;
    }

    #[tokio::test]
    async fn test_brotli_empty_body() {
        let server = server::http(move |req| async move {
            assert_eq!(req.method(), "HEAD");

            http::Response::builder()
                .header("content-encoding", "br")
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::new();
        let res = client
            .head(&format!("http://{}/brotli", server.addr()))
            .send()
            .await
            .unwrap();

        let body = res.text().await.unwrap();

        assert_eq!(body, "");
    }

    #[tokio::test]
    async fn test_accept_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "application/json");
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("br"));
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept", server.addr()))
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    #[tokio::test]
    async fn test_accept_encoding_header_is_not_changed_if_set() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers()["accept"], "*/*");
            assert_eq!(req.headers()["accept-encoding"], "identity");
            http::Response::default()
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/accept-encoding", server.addr()))
            .header(
                reqwest::header::ACCEPT_ENCODING,
                reqwest::header::HeaderValue::from_static("identity"),
            )
            .send()
            .await
            .unwrap();

        assert_eq!(res.status(), reqwest::StatusCode::OK);
    }

    async fn brotli_case(response_size: usize, chunk_size: usize) {
        use futures_util::stream::StreamExt;

        let content: String = (0..response_size)
            .into_iter()
            .map(|i| format!("test {i}"))
            .collect();

        let mut encoder = brotli_crate::CompressorReader::new(content.as_bytes(), 4096, 5, 20);
        let mut brotlied_content = Vec::new();
        encoder.read_to_end(&mut brotlied_content).unwrap();

        let mut response = format!(
            "\
             HTTP/1.1 200 OK\r\n\
             Server: test-accept\r\n\
             Content-Encoding: br\r\n\
             Content-Length: {}\r\n\
             \r\n",
            &brotlied_content.len()
        )
        .into_bytes();
        response.extend(&brotlied_content);

        let server = server::http(move |req| {
            assert!(req.headers()["accept-encoding"]
                .to_str()
                .unwrap()
                .contains("br"));

            let brotlied = brotlied_content.clone();
            async move {
                let len = brotlied.len();
                let stream =
                    futures_util::stream::unfold((brotlied, 0), move |(brotlied, pos)| async move {
                        let chunk = brotlied.chunks(chunk_size).nth(pos)?.to_vec();

                        Some((chunk, (brotlied, pos + 1)))
                    });

                let body = reqwest::Body::wrap_stream(stream.map(Ok::<_, std::convert::Infallible>));

                http::Response::builder()
                    .header("content-encoding", "br")
                    .header("content-length", len)
                    .body(body)
                    .unwrap()
            }
        });

        let client = reqwest::Client::new();

        let res = client
            .get(&format!("http://{}/brotli", server.addr()))
            .send()
            .await
            .expect("response");

        let body = res.text().await.expect("text");
        assert_eq!(body, content);
    }

    const COMPRESSED_RESPONSE_HEADERS: &[u8] = b"HTTP/1.1 200 OK\x0d\x0a\
                Content-Type: text/plain\x0d\x0a\
                Connection: keep-alive\x0d\x0a\
                Content-Encoding: br\x0d\x0a";

    const RESPONSE_CONTENT: &str = "some message here";

    fn brotli_compress(input: &[u8]) -> Vec<u8> {
        let mut encoder = brotli_crate::CompressorReader::new(input, 4096, 5, 20);
        let mut brotlied_content = Vec::new();
        encoder.read_to_end(&mut brotlied_content).unwrap();
        brotlied_content
    }

    #[tokio::test]
    async fn test_non_chunked_non_fragmented_response() {
        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let brotlied_content = brotli_compress(RESPONSE_CONTENT.as_bytes());
                let content_length_header =
                    format!("Content-Length: {}\r\n\r\n", brotlied_content.len()).into_bytes();
                let response = [
                    COMPRESSED_RESPONSE_HEADERS,
                    &content_length_header,
                    &brotlied_content,
                ]
                .concat();

                client_socket
                    .write_all(response.as_slice())
                    .await
                    .expect("response write_all failed");
                client_socket.flush().await.expect("response flush failed");
            })
        });

        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the code handle the compression and decompression of data in HTTP responses?
  codeQuestion3: What is the process for testing that the server correctly handles the 'Accept-Encoding' header and responds with compressed content?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/brotli.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn test_chunked_fragmented_response_1() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let brotlied_content = brotli_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        brotlied_content.len()
                    )
                    .as_bytes(),
                    &brotlied_content,
                ]
                .concat();
                let response_second_part = b"\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_2() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let brotlied_content = brotli_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        brotlied_content.len()
                    )
                    .as_bytes(),
                    &brotlied_content,
                    b"\r\n",
                ]
                .concat();
                let response_second_part = b"0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        assert_eq!(res.text().await.expect("text"), RESPONSE_CONTENT);
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }

    #[tokio::test]
    async fn test_chunked_fragmented_response_with_extra_bytes() {
        const DELAY_BETWEEN_RESPONSE_PARTS: tokio::time::Duration =
            tokio::time::Duration::from_millis(1000);
        const DELAY_MARGIN: tokio::time::Duration = tokio::time::Duration::from_millis(50);

        let server = server::low_level_with_response(|_raw_request, client_socket| {
            Box::new(async move {
                let brotlied_content = brotli_compress(RESPONSE_CONTENT.as_bytes());
                let response_first_part = [
                    COMPRESSED_RESPONSE_HEADERS,
                    format!(
                        "Transfer-Encoding: chunked\r\n\r\n{:x}\r\n",
                        brotlied_content.len()
                    )
                    .as_bytes(),
                    &brotlied_content,
                ]
                .concat();
                let response_second_part = b"\r\n2ab\r\n0\r\n\r\n";

                client_socket
                    .write_all(response_first_part.as_slice())
                    .await
                    .expect("response_first_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_first_part flush failed");

                tokio::time::sleep(DELAY_BETWEEN_RESPONSE_PARTS).await;

                client_socket
                    .write_all(response_second_part)
                    .await
                    .expect("response_second_part write_all failed");
                client_socket
                    .flush()
                    .await
                    .expect("response_second_part flush failed");
            })
        });

        let start = tokio::time::Instant::now();
        let res = reqwest::Client::new()
            .get(&format!("http://{}/", server.addr()))
            .send()
            .await
            .expect("response");

        let err = res.text().await.expect_err("there must be an error");
        assert!(err.is_decode());
        assert!(start.elapsed() >= DELAY_BETWEEN_RESPONSE_PARTS - DELAY_MARGIN);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle the scenario where extra bytes are present after the chunked response ends?
  codeQuestion3: What steps are taken to manage the delayed sending of parts of a response in the test cases?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/cookie.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod support;
    use support::server;

    #[tokio::test]
    async fn cookie_response_accessor() {
        let server = server::http(move |_req| async move {
            http::Response::builder()
                .header("Set-Cookie", "key=val")
                .header(
                    "Set-Cookie",
                    "expires=1; Expires=Wed, 21 Oct 2015 07:28:00 GMT",
                )
                .header("Set-Cookie", "path=1; Path=/the-path")
                .header("Set-Cookie", "maxage=1; Max-Age=100")
                .header("Set-Cookie", "domain=1; Domain=mydomain")
                .header("Set-Cookie", "secure=1; Secure")
                .header("Set-Cookie", "httponly=1; HttpOnly")
                .header("Set-Cookie", "samesitelax=1; SameSite=Lax")
                .header("Set-Cookie", "samesitestrict=1; SameSite=Strict")
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::new();

        let url = format!("http://{}/", server.addr());
        let res = client.get(&url).send().await.unwrap();

        let cookies = res.cookies().collect::<Vec<_>>();

        // key=val
        assert_eq!(cookies[0].name(), "key");
        assert_eq!(cookies[0].value(), "val");

        // expires
        assert_eq!(cookies[1].name(), "expires");
        assert_eq!(
            cookies[1].expires().unwrap(),
            std::time::SystemTime::UNIX_EPOCH + std::time::Duration::from_secs(1_445_412_480)
        );

        // path
        assert_eq!(cookies[2].name(), "path");
        assert_eq!(cookies[2].path().unwrap(), "/the-path");

        // max-age
        assert_eq!(cookies[3].name(), "maxage");
        assert_eq!(
            cookies[3].max_age().unwrap(),
            std::time::Duration::from_secs(100)
        );

        // domain
        assert_eq!(cookies[4].name(), "domain");
        assert_eq!(cookies[4].domain().unwrap(), "mydomain");

        // secure
        assert_eq!(cookies[5].name(), "secure");
        assert_eq!(cookies[5].secure(), true);

        // httponly
        assert_eq!(cookies[6].name(), "httponly");
        assert_eq!(cookies[6].http_only(), true);

        // samesitelax
        assert_eq!(cookies[7].name(), "samesitelax");
        assert!(cookies[7].same_site_lax());

        // samesitestrict
        assert_eq!(cookies[8].name(), "samesitestrict");
        assert!(cookies[8].same_site_strict());
    }

    #[tokio::test]
    async fn cookie_store_simple() {
        let server = server::http(move |req| async move {
            if req.uri() == "/2" {
                assert_eq!(req.headers()["cookie"], "key=val");
            }
            http::Response::builder()
                .header("Set-Cookie", "key=val; HttpOnly")
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::builder()
            .cookie_store(true)
            .build()
            .unwrap();

        let url = format!("http://{}/", server.addr());
        client.get(&url).send().await.unwrap();

        let url = format!("http://{}/2", server.addr());
        client.get(&url).send().await.unwrap();
    }

    #[tokio::test]
    async fn cookie_store_overwrite_existing() {
        let server = server::http(move |req| async move {
            if req.uri() == "/" {
                http::Response::builder()
                    .header("Set-Cookie", "key=val")
                    .body(Default::default())
                    .unwrap()
            } else if req.uri() == "/2" {
                assert_eq!(req.headers()["cookie"], "key=val");
                http::Response::builder()
                    .header("Set-Cookie", "key=val2")
                    .body(Default::default())
                    .unwrap()
            } else {
                assert_eq!(req.uri(), "/3");
                assert_eq!(req.headers()["cookie"], "key=val2");
                http::Response::default()
            }
        });

        let client = reqwest::Client::builder()
            .cookie_store(true)
            .build()
            .unwrap();

        let url = format!("http://{}/", server.addr());
        client.get(&url).send().await.unwrap();

        let url = format!("http://{}/2", server.addr());
        client.get(&url).send().await.unwrap();

        let url = format!("http://{}/3", server.addr());
        client.get(&url).send().await.unwrap();
    }

    #[tokio::test]
    async fn cookie_store_max_age() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers().get("cookie"), None);
            http::Response::builder()
                .header("Set-Cookie", "key=val; Max-Age=0")
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::builder()
            .cookie_store(true)
            .build()
            .unwrap();
        let url = format!("http://{}/", server.addr());
        client.get(&url).send().await.unwrap();
        client.get(&url).send().await.unwrap();
    }

    #[tokio::test]
    async fn cookie_store_expires() {
        let server = server::http(move |req| async move {
            assert_eq!(req.headers().get("cookie"), None);
            http::Response::builder()
                .header(
                    "Set-Cookie",
                    "key=val; Expires=Wed, 21 Oct 2015 07:28:00 GMT",
                )
                .body(Default::default())
                .unwrap()
        });

        let client = reqwest::Client::builder()
            .cookie_store(true)
            .build()
            .unwrap();

        let url = format!("http://{}/", server.addr());
        client.get(&url).send().await.unwrap();
        client.get(&url).send().await.unwrap();
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle setting and retrieving cookies in a client-server interaction, using the `reqwest` library?
  codeQuestion3: What steps are taken to ensure that cookies are stored and persisted across multiple requests in the same session?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/tests/cookie.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[tokio::test]
    async fn cookie_store_path() {
        let server = server::http(move |req| async move {
            if req.uri() == "/" {
                assert_eq!(req.headers().get("cookie"), None);
                http::Response::builder()
                    .header("Set-Cookie", "key=val; Path=/subpath")
                    .body(Default::default())
                    .unwrap()
            } else {
                assert_eq!(req.uri(), "/subpath");
                assert_eq!(req.headers()["cookie"], "key=val");
                http::Response::default()
            }
        });

        let client = reqwest::Client::builder()
            .cookie_store(true)
            .build()
            .unwrap();

        let url = format!("http://{}/", server.addr());
        client.get(&url).send().await.unwrap();
        client.get(&url).send().await.unwrap();

        let url = format!("http://{}/subpath", server.addr());
        client.get(&url).send().await.unwrap();
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the client handle cookies across different paths in the HTTP requests?
  codeQuestion3: What steps are taken to verify that cookies are correctly set and sent with subsequent requests?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/json_dynamic.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! This example illustrates the way to send and receive arbitrary JSON.
    //!
    //! This is useful for some ad-hoc experiments and situations when you don't
    //! really care about the structure of the JSON and just need to display it or
    //! process it at runtime.

    // This is using the `tokio` runtime. You'll need the following dependency:
    //
    // `tokio = { version = "1", features = ["full"] }`
    #[tokio::main]
    async fn main() -> Result<(), reqwest::Error> {
        let echo_json: serde_json::Value = reqwest::Client::new()
            .post("https://jsonplaceholder.typicode.com/posts")
            .json(&serde_json::json!({
                "title": "Reqwest.rs",
                "body": "https://docs.rs/reqwest",
                "userId": 1
            }))
            .send()
            .await?
            .json()
            .await?;

        println!("{echo_json:#?}");
        // Object(
        //     {
        //         "body": String(
        //             "https://docs.rs/reqwest"
        //         ),
        //         "id": Number(
        //             101
        //         ),
        //         "title": String(
        //             "Reqwest.rs"
        //         ),
        //         "userId": Number(
        //             1
        //         )
        //     }
        // )
        Ok(())
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle sending and receiving JSON data in an asynchronous context?
  codeQuestion3: What is the role of the `serde_json::json!` macro in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/json_typed.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! This example illustrates the way to send and receive statically typed JSON.
    //!
    //! In contrast to the arbitrary JSON example, this brings up the full power of
    //! Rust compile-time type system guaranties though it requires a little bit
    //! more code.

    // These require the `serde` dependency.
    use serde::{Deserialize, Serialize};

    #[derive(Debug, Serialize, Deserialize)]
    struct Post {
        id: Option<i32>,
        title: String,
        body: String,
        #[serde(rename = "userId")]
        user_id: i32,
    }

    // This is using the `tokio` runtime. You'll need the following dependency:
    //
    // `tokio = { version = "1", features = ["full"] }`
    #[tokio::main]
    async fn main() -> Result<(), reqwest::Error> {
        let new_post = Post {
            id: None,
            title: "Reqwest.rs".into(),
            body: "https://docs.rs/reqwest".into(),
            user_id: 1,
        };
        let new_post: Post = reqwest::Client::new()
            .post("https://jsonplaceholder.typicode.com/posts")
            .json(&new_post)
            .send()
            .await?
            .json()
            .await?;

        println!("{new_post:#?}");
        // Post {
        //     id: Some(
        //         101
        //     ),
        //     title: "Reqwest.rs",
        //     body: "https://docs.rs/reqwest",
        //     user_id: 1
        // }
        Ok(())
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code demonstrate the use of serde for JSON serialization and deserialization in Rust?
  codeQuestion3: What steps are involved in sending a POST request and handling the response to retrieve the deserialized JSON data?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/wasm_github_fetch/src/lib.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use serde::{Deserialize, Serialize};
    use wasm_bindgen::prelude::*;

    // NOTE: This test is a clone of https://github.com/rustwasm/wasm-bindgen/blob/master/examples/fetch/src/lib.rs
    // but uses Reqwest instead of the web_sys fetch api directly

    /// A struct to hold some data from the GitHub Branch API.
    ///
    /// Note how we don't have to define every member -- serde will ignore extra
    /// data when deserializing
    #[derive(Debug, Serialize, Deserialize)]
    pub struct Branch {
        pub name: String,
        pub commit: Commit,
    }

    #[derive(Debug, Serialize, Deserialize)]
    pub struct Commit {
        pub sha: String,
        pub commit: CommitDetails,
    }

    #[derive(Debug, Serialize, Deserialize)]
    pub struct CommitDetails {
        pub author: Signature,
        pub committer: Signature,
    }

    #[derive(Debug, Serialize, Deserialize)]
    pub struct Signature {
        pub name: String,
        pub email: String,
    }

    #[wasm_bindgen]
    pub async fn run() -> Result<JsValue, JsValue> {
        let res = reqwest::Client::new()
            .get("https://api.github.com/repos/rustwasm/wasm-bindgen/branches/master")
            .header("Accept", "application/vnd.github.v3+json")
            .send()
            .await?;

        let text = res.text().await?;
        let branch_info: Branch = serde_json::from_str(&text).unwrap();

        Ok(JsValue::from_serde(&branch_info).unwrap())
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle user input for a web-based application, and what system calls are involved in this process?
  codeQuestion3: What steps are taken to handle the deserialization of JSON data received from a web request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/connect_via_lower_priority_tokio_runtime.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![deny(warnings)]
    // This example demonstrates how to delegate the connect calls, which contain TLS handshakes,
    // to a secondary tokio runtime of lower OS thread priority using a custom tower layer.
    // This helps to ensure that long-running futures during handshake crypto operations don't block other I/O futures.
    //
    // This does introduce overhead of additional threads, channels, extra vtables, etc,
    // so it is best suited to services with large numbers of incoming connections or that
    // are otherwise very sensitive to any blocking futures.  Or, you might want fewer threads
    // and/or to use the current_thread runtime.
    //
    // This is using the `tokio` runtime and certain other dependencies:
    //
    // `tokio = { version = "1", features = ["full"] }`
    // `num_cpus = "1.0"`
    // `libc = "0"`
    // `pin-project-lite = "0.2"`
    // `tower = { version = "0.5", default-features = false}`

    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::main]
    async fn main() -> Result<(), reqwest::Error> {
        background_threadpool::init_background_runtime();
        tokio::time::sleep(std::time::Duration::from_millis(10)).await;

        let client = reqwest::Client::builder()
            .connector_layer(background_threadpool::BackgroundProcessorLayer::new())
            .build()
            .expect("should be able to build reqwest client");

        let url = if let Some(url) = std::env::args().nth(1) {
            url
        } else {
            println!("No CLI URL provided, using default.");
            "https://hyper.rs".into()
        };

        eprintln!("Fetching {url:?}...");

        let res = client.get(url).send().await?;

        eprintln!("Response: {:?} {}", res.version(), res.status());
        eprintln!("Headers: {:#?}\n", res.headers());

        let body = res.text().await?;

        println!("{body}");

        Ok(())
    }

    // separating out for convenience to avoid a million #[cfg(not(target_arch = "wasm32"))]
    #[cfg(not(target_arch = "wasm32"))]
    mod background_threadpool {
        use std::{
            future::Future,
            pin::Pin,
            sync::OnceLock,
            task::{Context, Poll},
        };

        use futures_util::TryFutureExt;
        use pin_project_lite::pin_project;
        use tokio::{runtime::Handle, select, sync::mpsc::error::TrySendError};
        use tower::{BoxError, Layer, Service};

        static CPU_HEAVY_THREAD_POOL: OnceLock<
            tokio::sync::mpsc::Sender<Pin<Box<dyn Future<Output = ()> + Send + 'static>>>,
        > = OnceLock::new();

        pub(crate) fn init_background_runtime() {
            std::thread::Builder::new()
                .name("cpu-heavy-background-threadpool".to_string())
                .spawn(move || {
                    let rt = tokio::runtime::Builder::new_multi_thread()
                        .thread_name("cpu-heavy-background-pool-thread")
                        .worker_threads(num_cpus::get() as usize)
                        // ref: https://github.com/tokio-rs/tokio/issues/4941
                        // consider uncommenting if seeing heavy task contention
                        // .disable_lifo_slot()
                        .on_thread_start(move || {
                            #[cfg(target_os = "linux")]
                            unsafe {
                                // Increase thread pool thread niceness, so they are lower priority
                                // than the foreground executor and don't interfere with I/O tasks
                                {
                                    *libc::__errno_location() = 0;
                                    if libc::nice(10) == -1 && *libc::__errno_location() != 0 {
                                        let error = std::io::Error::last_os_error();
                                        log::error!("failed to set threadpool niceness: {}", error);
                                    }
                                }
                            }
                        })
                        .enable_all()
                        .build()
                        .unwrap_or_else(|e| panic!("cpu heavy runtime failed_to_initialize: {}", e));
                    rt.block_on(async {
                        log::debug!("starting background cpu-heavy work");
                        process_cpu_work().await;
                    });
                })
                .unwrap_or_else(|e| panic!("cpu heavy thread failed_to_initialize: {}", e));
        }

        #[cfg(not(target_arch = "wasm32"))]
        async fn process_cpu_work() {
            // we only use this channel for routing work, it should move pretty quick, it can be small
            let (tx, mut rx) = tokio::sync::mpsc::channel(10);
            // share the handle to the background channel globally
            CPU_HEAVY_THREAD_POOL.set(tx).unwrap();

            while let Some(work) = rx.recv().await {
                tokio::task::spawn(work);
            }
        }

        // retrieve the sender to the background channel, and send the future over to it for execution
        fn send_to_background_runtime(future: impl Future<Output = ()> + Send + 'static) {
            let tx = CPU_HEAVY_THREAD_POOL.get().expect(
                "start up the secondary tokio runtime before sending to `CPU_HEAVY_THREAD_POOL`",
            );

            match tx.try_send(Box::pin(future)) {
                Ok(_) => (),
                Err(TrySendError::Closed(_)) => {
                    panic!("background cpu heavy runtime channel is closed")
                }
                Err(TrySendError::Full(msg)) => {
                    log::warn!(
                        "background cpu heavy runtime channel is full, task spawning loop delayed"
                    );
                    let tx = tx.clone();
                    Handle::current().spawn(async move {
                        tx.send(msg)
                            .await
                            .expect("background cpu heavy runtime channel is closed")
                    });
                }
            }
        }

        // This tower layer injects futures with a oneshot channel, and then sends them to the background runtime for processing.
        // We don't use the Buffer service because that is intended to process sequentially on a single task, whereas we want to
        // spawn a new task per call.
        #[derive(Copy, Clone)]
        pub struct BackgroundProcessorLayer {}
        impl BackgroundProcessorLayer {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl<S> Layer<S> for BackgroundProcessorLayer {
            type Service = BackgroundProcessor<S>;
            fn layer(&self, service: S) -> Self::Service {
                BackgroundProcessor::new(service)
            }
        }

        impl std::fmt::Debug for BackgroundProcessorLayer {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.debug_struct("BackgroundProcessorLayer").finish()
            }
        }

        // This tower service injects futures with a oneshot channel, and then sends them to the background runtime for processing.
        #[derive(Debug, Clone)]
        pub struct BackgroundProcessor<S> {
            inner: S,
        }

        impl<S> BackgroundProcessor<S> {
            pub fn new(inner: S) -> Self {
                BackgroundProcessor { inner }
            }
        }

        impl<S, Request> Service<Request> for BackgroundProcessor<S>
        where
            S: Service<Request>,
            S::Response: Send + 'static,
            S::Error: Into<BoxError> + Send,
            S::Future: Send + 'static,
        {
            type Response = S::Response;

            type Error = BoxError;

            type Future = BackgroundResponseFuture<S::Response>;

            fn poll_ready(
                &mut self,
                cx: &mut std::task::Context<'_>,
            ) -> std::task::Poll<Result<(), Self::Error>> {
                match self.inner.poll_ready(cx) {
                    Poll::Pending => Poll::Pending,
                    Poll::Ready(r) => Poll::Ready(r.map_err(Into::into)),
                }
            }

            fn call(&mut self, req: Request) -> Self::Future {
                let response = self.inner.call(req);

                // wrap our inner service's future with a future that writes to this oneshot channel
                let (mut tx, rx) = tokio::sync::oneshot::channel();
                let future = async move {
                    select!(
                        _ = tx.closed() => {
                            // receiver already dropped, don't need to do anything
                        }
                        result = response.map_err(|err| Into::<BoxError>::into(err)) => {
                            // if this fails, the receiver already dropped, so we don't need to do anything
                            let _ = tx.send(result);
                        }
                    )
                };
                // send the wrapped future to the background
                send_to_background_runtime(future);

                BackgroundResponseFuture::new(rx)
            }
        }

        // `BackgroundProcessor` response future
        pin_project! {
            #[derive(Debug)]
            pub struct BackgroundResponseFuture<S> {
                #[pin]
                rx: tokio::sync::oneshot::Receiver<Result<S, BoxError>>,
            }
        }

        impl<S> BackgroundResponseFuture<S> {
            pub(crate) fn new(rx: tokio::sync::oneshot::Receiver<Result<S, BoxError>>) -> Self {
                BackgroundResponseFuture { rx }
            }
        }

        impl<S> Future for BackgroundResponseFuture<S>
        where
            S: Send + 'static,
        {
            type Output = Result<S, BoxError>;

            fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
                let this = self.project();

                // now poll on the receiver end of the oneshot to get the result
                match this.rx.poll(cx) {
                    Poll::Ready(v) => match v {
                        Ok(v) => Poll::Ready(v.map_err(Into::into)),
                        Err(err) => Poll::Ready(Err(Box::new(err) as BoxError)),
                    },
                    Poll::Pending => Poll::Pending,
                }
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle user input for initiating a new game after losing, and what system calls are involved in this process?
  codeQuestion3: What steps are taken to set up the background thread pool for handling CPU-intensive tasks, and how does it interact with the main runtime?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/connect_via_lower_priority_tokio_runtime.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    // The [cfg(not(target_arch = "wasm32"))] above prevent building the tokio::main function
    // for wasm32 target, because tokio isn't compatible with wasm32.
    // If you aren't building for wasm32, you don't need that line.
    // The two lines below avoid the "'main' function not found" error when building for wasm32 target.
    #[cfg(any(target_arch = "wasm32"))]
    fn main() {}
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle the main function for different target architectures?
  codeQuestion3: 'What is the role of the #[cfg(not(target_arch = "wasm32"))] attribute in this code?'

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/h3_simple.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![deny(warnings)]

    // This is using the `tokio` runtime. You'll need the following dependency:
    //
    // `tokio = { version = "1", features = ["full"] }`
    #[cfg(feature = "http3")]
    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::main]
    async fn main() -> Result<(), reqwest::Error> {
        let client = reqwest::Client::builder().http3_prior_knowledge().build()?;

        // Some simple CLI args requirements...
        let url = match std::env::args().nth(1) {
            Some(url) => url,
            None => {
                println!("No CLI URL provided, using default.");
                "https://hyper.rs".into()
            }
        };

        eprintln!("Fetching {url:?}...");

        let res = client
            .get(url)
            .version(http::Version::HTTP_3)
            .send()
            .await?;

        eprintln!("Response: {:?} {}", res.version(), res.status());
        eprintln!("Headers: {:#?}\n", res.headers());

        let body = res.text().await?;

        println!("{body}");

        Ok(())
    }

    // The [cfg(not(target_arch = "wasm32"))] above prevent building the tokio::main function
    // for wasm32 target, because tokio isn't compatible with wasm32.
    // If you aren't building for wasm32, you don't need that line.
    // The two lines below avoid the "'main' function not found" error when building for wasm32 target.
    #[cfg(any(target_arch = "wasm32", not(feature = "http3")))]
    fn main() {}
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP/3 requests and what system calls are involved in establishing a connection?
  codeQuestion3: What steps are taken to configure the HTTP client for HTTP/3 and how is the response handled?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/simple.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![deny(warnings)]

    // This is using the `tokio` runtime. You'll need the following dependency:
    //
    // `tokio = { version = "1", features = ["full"] }`
    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::main]
    async fn main() -> Result<(), reqwest::Error> {
        // Some simple CLI args requirements...
        let url = if let Some(url) = std::env::args().nth(1) {
            url
        } else {
            println!("No CLI URL provided, using default.");
            "https://hyper.rs".into()
        };

        eprintln!("Fetching {url:?}...");

        // reqwest::get() is a convenience function.
        //
        // In most cases, you should create/build a reqwest::Client and reuse
        // it for all requests.
        let res = reqwest::get(url).await?;

        eprintln!("Response: {:?} {}", res.version(), res.status());
        eprintln!("Headers: {:#?}\n", res.headers());

        let body = res.text().await?;

        println!("{body}");

        Ok(())
    }

    // The [cfg(not(target_arch = "wasm32"))] above prevent building the tokio::main function
    // for wasm32 target, because tokio isn't compatible with wasm32.
    // If you aren't building for wasm32, you don't need that line.
    // The two lines below avoid the "'main' function not found" error when building for wasm32 target.
    #[cfg(target_arch = "wasm32")]
    fn main() {}
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle user input for the URL, and what is the default URL used if no command-line argument is provided?
  codeQuestion3: What system calls or APIs are used to fetch data from a URL, and how is the response handled in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/blocking.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! `cargo run --example blocking --features=blocking`
    #![deny(warnings)]

    fn main() -> Result<(), Box<dyn std::error::Error>> {
        env_logger::init();

        // Some simple CLI args requirements...
        let url = match std::env::args().nth(1) {
            Some(url) => url,
            None => {
                println!("No CLI URL provided, using default.");
                "https://hyper.rs".into()
            }
        };

        eprintln!("Fetching {url:?}...");

        // reqwest::blocking::get() is a convenience function.
        //
        // In most cases, you should create/build a reqwest::Client and reuse
        // it for all requests.
        let mut res = reqwest::blocking::get(url)?;

        eprintln!("Response: {:?} {}", res.version(), res.status());
        eprintln!("Headers: {:#?}\n", res.headers());

        // copy the response body directly to stdout
        res.copy_to(&mut std::io::stdout())?;

        Ok(())
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle command-line arguments and what is the default URL used if no argument is provided?
  codeQuestion3: What system calls or APIs are used to handle the HTTP request and response, and how is the response body streamed to stdout?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/tor_socks.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![deny(warnings)]

    // This is using the `tokio` runtime. You'll need the following dependency:
    //
    // `tokio = { version = "1", features = ["full"] }`
    #[tokio::main]
    async fn main() -> Result<(), reqwest::Error> {
        // Make sure you are running tor and this is your socks port
        let proxy = reqwest::Proxy::all("socks5h://127.0.0.1:9050").expect("tor proxy should be there");
        let client = reqwest::Client::builder()
            .proxy(proxy)
            .build()
            .expect("should be able to build reqwest client");

        let res = client.get("https://check.torproject.org").send().await?;
        println!("Status: {}", res.status());

        let text = res.text().await?;
        let is_tor = text.contains("Congratulations. This browser is configured to use Tor.");
        println!("Is Tor: {is_tor}");
        assert!(is_tor);

        Ok(())
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code configure the request to use a Tor proxy through the socks5h protocol?
  codeQuestion3: What steps are taken to handle the response from the Tor check endpoint and validate that the browser is correctly configured with Tor?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/examples/form.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    // Short example of a POST request with form data.
    //
    // This is using the `tokio` runtime. You'll need the following dependency:
    //
    // `tokio = { version = "1", features = ["full"] }`
    #[cfg(not(target_arch = "wasm32"))]
    #[tokio::main]
    async fn main() {
        let response = reqwest::Client::new()
            .post("http://www.baidu.com")
            .form(&[("one", "1")])
            .send()
            .await
            .expect("send");
        println!("Response status {}", response.status());
    }

    // The [cfg(not(target_arch = "wasm32"))] above prevent building the tokio::main function
    // for wasm32 target, because tokio isn't compatible with wasm32.
    // If you aren't building for wasm32, you don't need that line.
    // The two lines below avoid the "'main' function not found" error when building for wasm32 target.
    #[cfg(target_arch = "wasm32")]
    fn main() {}
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user submit form data to a server using the `reqwest` crate in Rust?
  codeQuestion3: What steps are taken to handle the `tokio` runtime in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use url::Url;

    #[derive(Debug, Clone, PartialEq)]
    pub(crate) struct ResponseUrl(pub Url);

    /// Extension trait for http::response::Builder objects
    ///
    /// Allows the user to add a `Url` to the http::Response
    pub trait ResponseBuilderExt {
        /// A builder method for the `http::response::Builder` type that allows the user to add a `Url`
        /// to the `http::Response`
        fn url(self, url: Url) -> Self;
    }

    impl ResponseBuilderExt for http::response::Builder {
        fn url(self, url: Url) -> Self {
            self.extension(ResponseUrl(url))
        }
    }

    #[cfg(test)]
    mod tests {
        use super::{ResponseBuilderExt, ResponseUrl};
        use http::response::Builder;
        use url::Url;

        #[test]
        fn test_response_builder_ext() {
            let url = Url::parse("http://example.com").unwrap();
            let response = Builder::new()
                .status(200)
                .url(url.clone())
                .body(())
                .unwrap();

            assert_eq!(
                response.extensions().get::<ResponseUrl>(),
                Some(&ResponseUrl(url))
            );
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `ResponseBuilderExt` trait enable setting a URL on an HTTP response in Hyper?
  codeQuestion3: What is the role of the `tests` module in verifying the functionality of the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/h3_client/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use crate::async_impl::h3_client::dns::resolve;
    use crate::dns::DynResolver;
    use crate::error::BoxError;
    use bytes::Bytes;
    use h3::client::SendRequest;
    use h3_quinn::{Connection, OpenStreams};
    use http::Uri;
    use hyper_util::client::legacy::connect::dns::Name;
    use quinn::crypto::rustls::QuicClientConfig;
    use quinn::{ClientConfig, Endpoint, TransportConfig};
    use std::net::{IpAddr, SocketAddr};
    use std::str::FromStr;
    use std::sync::Arc;

    type H3Connection = (
        h3::client::Connection<Connection, Bytes>,
        SendRequest<OpenStreams, Bytes>,
    );

    /// H3 Client Config
    #[derive(Clone)]
    pub(crate) struct H3ClientConfig {
        /// Set the maximum HTTP/3 header size this client is willing to accept.
        ///
        /// See [header size constraints] section of the specification for details.
        ///
        /// [header size constraints]: https://www.rfc-editor.org/rfc/rfc9114.html#name-header-size-constraints
        ///
        /// Please see docs in [`Builder`] in [`h3`].
        ///
        /// [`Builder`]: https://docs.rs/h3/latest/h3/client/struct.Builder.html#method.max_field_section_size
        pub(crate) max_field_section_size: Option<u64>,

        /// Enable whether to send HTTP/3 protocol grease on the connections.
        ///
        /// Just like in HTTP/2, HTTP/3 also uses the concept of "grease"
        ///
        /// to prevent potential interoperability issues in the future.
        /// In HTTP/3, the concept of grease is used to ensure that the protocol can evolve
        /// and accommodate future changes without breaking existing implementations.
        ///
        /// Please see docs in [`Builder`] in [`h3`].
        ///
        /// [`Builder`]: https://docs.rs/h3/latest/h3/client/struct.Builder.html#method.send_grease
        pub(crate) send_grease: Option<bool>,
    }

    impl Default for H3ClientConfig {
        fn default() -> Self {
            Self {
                max_field_section_size: None,
                send_grease: None,
            }
        }
    }

    #[derive(Clone)]
    pub(crate) struct H3Connector {
        resolver: DynResolver,
        endpoint: Endpoint,
        client_config: H3ClientConfig,
    }

    impl H3Connector {
        pub fn new(
            resolver: DynResolver,
            tls: rustls::ClientConfig,
            local_addr: Option<IpAddr>,
            transport_config: TransportConfig,
            client_config: H3ClientConfig,
        ) -> Result<H3Connector, BoxError> {
            let quic_client_config = Arc::new(QuicClientConfig::try_from(tls)?);
            let mut config = ClientConfig::new(quic_client_config);
            // FIXME: Replace this when there is a setter.
            config.transport_config(Arc::new(transport_config));

            let socket_addr = match local_addr {
                Some(ip) => SocketAddr::new(ip, 0),
                None => "[::]:0".parse::<SocketAddr>().unwrap(),
            };

            let mut endpoint = Endpoint::client(socket_addr)?;
            endpoint.set_default_client_config(config);

            Ok(Self {
                resolver,
                endpoint,
                client_config,
            })
        }

        pub async fn connect(&mut self, dest: Uri) -> Result<H3Connection, BoxError> {
            let host = dest
                .host()
                .ok_or("destination must have a host")?
                .trim_start_matches('[')
                .trim_end_matches(']');
            let port = dest.port_u16().unwrap_or(443);

            let addrs = if let Some(addr) = IpAddr::from_str(host).ok() {
                // If the host is already an IP address, skip resolving.
                vec![SocketAddr::new(addr, port)]
            } else {
                let addrs = resolve(&mut self.resolver, Name::from_str(host)?).await?;
                let addrs = addrs.map(|mut addr| {
                    addr.set_port(port);
                    addr
                });
                addrs.collect()
            };

            self.remote_connect(addrs, host).await
        }

        async fn remote_connect(
            &mut self,
            addrs: Vec<SocketAddr>,
            server_name: &str,
        ) -> Result<H3Connection, BoxError> {
            let mut err = None;
            for addr in addrs {
                match self.endpoint.connect(addr, server_name)?.await {
                    Ok(new_conn) => {
                        let quinn_conn = Connection::new(new_conn);
                        let mut h3_client_builder = h3::client::builder();
                        if let Some(max_field_section_size) = self.client_config.max_field_section_size
                        {
                            h3_client_builder.max_field_section_size(max_field_section_size);
                        }
                        if let Some(send_grease) = self.client_config.send_grease {
                            h3_client_builder.send_grease(send_grease);
                        }
                        return Ok(h3_client_builder.build(quinn_conn).await?);
                    }
                    Err(e) => err = Some(e),
                }
            }

            match err {
                Some(e) => Err(Box::new(e) as BoxError),
                None => Err("failed to establish connection for HTTP/3 request".into()),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `H3Connector` handle DNS resolution for a given destination?
  codeQuestion3: What steps are involved in establishing an HTTP/3 connection using the `H3Connector`?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/h3_client/dns.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use core::task;
    use hyper_util::client::legacy::connect::dns::Name;
    use std::future::Future;
    use std::net::SocketAddr;
    use std::task::Poll;
    use tower_service::Service;

    // Trait from hyper to implement DNS resolution for HTTP/3 client.
    pub trait Resolve {
        type Addrs: Iterator<Item = SocketAddr>;
        type Error: Into<Box<dyn std::error::Error + Send + Sync>>;
        type Future: Future<Output = Result<Self::Addrs, Self::Error>>;

        fn poll_ready(&mut self, cx: &mut task::Context<'_>) -> Poll<Result<(), Self::Error>>;
        fn resolve(&mut self, name: Name) -> Self::Future;
    }

    impl<S> Resolve for S
    where
        S: Service<Name>,
        S::Response: Iterator<Item = SocketAddr>,
        S::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        type Addrs = S::Response;
        type Error = S::Error;
        type Future = S::Future;

        fn poll_ready(&mut self, cx: &mut task::Context<'_>) -> Poll<Result<(), Self::Error>> {
            Service::poll_ready(self, cx)
        }

        fn resolve(&mut self, name: Name) -> Self::Future {
            Service::call(self, name)
        }
    }

    pub(super) async fn resolve<R>(resolver: &mut R, name: Name) -> Result<R::Addrs, R::Error>
    where
        R: Resolve,
    {
        std::future::poll_fn(|cx| resolver.poll_ready(cx)).await?;
        resolver.resolve(name).await
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `resolve` function utilize the `Resolve` trait to perform DNS resolution for an HTTP/3 client?
  codeQuestion3: What is the role of the `resolve` function marked as `async` and how does it interact with the `poll_fn` macro?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/h3_client/mod.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg(feature = "http3")]

    pub(crate) mod connect;
    pub(crate) mod dns;
    mod pool;

    use crate::async_impl::body::ResponseBody;
    use crate::async_impl::h3_client::pool::{Key, Pool, PoolClient};
    use crate::error::{BoxError, Error, Kind};
    use crate::{error, Body};
    use connect::H3Connector;
    use futures_util::future;
    use http::{Request, Response};
    use log::trace;
    use std::future::Future;
    use std::pin::Pin;
    use std::task::{Context, Poll};
    use std::time::Duration;

    #[derive(Clone)]
    pub(crate) struct H3Client {
        pool: Pool,
        connector: H3Connector,
    }

    impl H3Client {
        pub fn new(connector: H3Connector, pool_timeout: Option<Duration>) -> Self {
            H3Client {
                pool: Pool::new(pool_timeout),
                connector,
            }
        }

        async fn get_pooled_client(&mut self, key: Key) -> Result<PoolClient, BoxError> {
            if let Some(client) = self.pool.try_pool(&key) {
                trace!("getting client from pool with key {key:?}");
                return Ok(client);
            }

            trace!("did not find connection {key:?} in pool so connecting...");

            let dest = pool::domain_as_uri(key.clone());

            let lock = match self.pool.connecting(&key) {
                pool::Connecting::InProgress(waiter) => {
                    trace!("connecting to {key:?} is already in progress, subscribing...");

                    match waiter.receive().await {
                        Some(client) => return Ok(client),
                        None => return Err("failed to establish connection for HTTP/3 request".into()),
                    }
                }
                pool::Connecting::Acquired(lock) => lock,
            };
            trace!("connecting to {key:?}...");
            let (driver, tx) = self.connector.connect(dest).await?;
            trace!("saving new pooled connection to {key:?}");
            Ok(self.pool.new_connection(lock, driver, tx))
        }

        async fn send_request(
            mut self,
            key: Key,
            req: Request<Body>,
        ) -> Result<Response<ResponseBody>, Error> {
            let mut pooled = match self.get_pooled_client(key).await {
                Ok(client) => client,
                Err(e) => return Err(error::request(e)),
            };
            pooled
                .send_request(req)
                .await
                .map_err(|e| Error::new(Kind::Request, Some(e)))
        }

        pub fn request(&self, mut req: Request<Body>) -> H3ResponseFuture {
            let pool_key = match pool::extract_domain(req.uri_mut()) {
                Ok(s) => s,
                Err(e) => {
                    return H3ResponseFuture {
                        inner: Box::pin(future::err(e)),
                    }
                }
            };
            H3ResponseFuture {
                inner: Box::pin(self.clone().send_request(pool_key, req)),
            }
        }
    }

    pub(crate) struct H3ResponseFuture {
        inner: Pin<Box<dyn Future<Output = Result<Response<ResponseBody>, Error>> + Send>>,
    }

    impl Future for H3ResponseFuture {
        type Output = Result<Response<ResponseBody>, Error>;

        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            self.inner.as_mut().poll(cx)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle establishing and managing HTTP/3 connections with a pool of clients?
  codeQuestion3: What is the role of the `H3ResponseFuture` struct and how is it used in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/h3_client/pool.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use bytes::Bytes;
    use std::collections::HashMap;
    use std::future;
    use std::pin::Pin;
    use std::sync::mpsc::{Receiver, TryRecvError};
    use std::sync::{Arc, Mutex};
    use std::task::{Context, Poll};
    use std::time::Duration;
    use tokio::sync::watch;
    use tokio::time::Instant;

    use crate::async_impl::body::ResponseBody;
    use crate::error::{BoxError, Error, Kind};
    use crate::Body;
    use bytes::Buf;
    use h3::client::SendRequest;
    use h3_quinn::{Connection, OpenStreams};
    use http::uri::{Authority, Scheme};
    use http::{Request, Response, Uri};
    use log::trace;

    pub(super) type Key = (Scheme, Authority);

    #[derive(Clone)]
    pub struct Pool {
        inner: Arc<Mutex<PoolInner>>,
    }

    struct ConnectingLockInner {
        key: Key,
        pool: Arc<Mutex<PoolInner>>,
    }

    /// A lock that ensures only one HTTP/3 connection is established per host at a
    /// time. The lock is automatically released when dropped.
    pub struct ConnectingLock(Option<ConnectingLockInner>);

    /// A waiter that allows subscribers to receive updates when a new connection is
    /// established or when the connection attempt fails. For example, when
    /// connection lock is dropped due to an error.
    pub struct ConnectingWaiter {
        receiver: watch::Receiver<Option<PoolClient>>,
    }

    pub enum Connecting {
        /// A connection attempt is already in progress.
        /// You must subscribe to updates instead of initiating a new connection.
        InProgress(ConnectingWaiter),
        /// The connection lock has been acquired, allowing you to initiate a
        /// new connection.
        Acquired(ConnectingLock),
    }

    impl ConnectingLock {
        fn new(key: Key, pool: Arc<Mutex<PoolInner>>) -> Self {
            Self(Some(ConnectingLockInner { key, pool }))
        }

        /// Forget the lock and return corresponding Key
        fn forget(mut self) -> Key {
            // Unwrap is safe because the Option can be None only after dropping the
            // lock
            self.0.take().unwrap().key
        }
    }

    impl Drop for ConnectingLock {
        fn drop(&mut self) {
            if let Some(ConnectingLockInner { key, pool }) = self.0.take() {
                let mut pool = pool.lock().unwrap();
                pool.connecting.remove(&key);
                trace!("HTTP/3 connecting lock for {:?} is dropped", key);
            }
        }
    }

    impl ConnectingWaiter {
        pub async fn receive(mut self) -> Option<PoolClient> {
            match self.receiver.wait_for(Option::is_some).await {
                // unwrap because we already checked that option is Some
                Ok(ok) => Some(ok.as_ref().unwrap().to_owned()),
                Err(_) => None,
            }
        }
    }

    impl Pool {
        pub fn new(timeout: Option<Duration>) -> Self {
            Self {
                inner: Arc::new(Mutex::new(PoolInner {
                    connecting: HashMap::new(),
                    idle_conns: HashMap::new(),
                    timeout,
                })),
            }
        }

        /// Acquire a connecting lock. This is to ensure that we have only one HTTP3
        /// connection per host.
        pub fn connecting(&self, key: &Key) -> Connecting {
            let mut inner = self.inner.lock().unwrap();

            if let Some(sender) = inner.connecting.get(key) {
                Connecting::InProgress(ConnectingWaiter {
                    receiver: sender.subscribe(),
                })
            } else {
                let (tx, _) = watch::channel(None);
                inner.connecting.insert(key.clone(), tx);
                Connecting::Acquired(ConnectingLock::new(key.clone(), Arc::clone(&self.inner)))
            }
        }

        pub fn try_pool(&self, key: &Key) -> Option<PoolClient> {
            let mut inner = self.inner.lock().unwrap();
            let timeout = inner.timeout;
            if let Some(conn) = inner.idle_conns.get(&key) {
                // We check first if the connection still valid
                // and if not, we remove it from the pool.
                if conn.is_invalid() {
                    trace!("pooled HTTP/3 connection is invalid so removing it...");
                    inner.idle_conns.remove(&key);
                    return None;
                }

                if let Some(duration) = timeout {
                    if Instant::now().saturating_duration_since(conn.idle_timeout) > duration {
                        trace!("pooled connection expired");
                        return None;
                    }
                }
            }

            inner
                .idle_conns
                .get_mut(&key)
                .and_then(|conn| Some(conn.pool()))
        }

        pub fn new_connection(
            &mut self,
            lock: ConnectingLock,
            mut driver: h3::client::Connection<Connection, Bytes>,
            tx: SendRequest<OpenStreams, Bytes>,
        ) -> PoolClient {
            let (close_tx, close_rx) = std::sync::mpsc::channel();
            tokio::spawn(async move {
                let e = future::poll_fn(|cx| driver.poll_close(cx)).await;
                trace!("poll_close returned error {e:?}");
                close_tx.send(e).ok();
            });

            let mut inner = self.inner.lock().unwrap();

            // We clean up "connecting" here so we don't have to acquire the lock again.
            let key = lock.forget();
            let Some(notifier) = inner.connecting.remove(&key) else {
                unreachable!("there should be one connecting lock at a time");
            };
            let client = PoolClient::new(tx);

            // Send the client to all our awaiters
            let pool_client = if let Err(watch::error::SendError(Some(unsent_client))) =
                notifier.send(Some(client.clone()))
            {
                // If there are no awaiters, the client is returned to us. As a
                // micro optimisation, let's reuse it and avoid cloning.
                unsent_client
            } else {
                client.clone()
            };

            let conn = PoolConnection::new(pool_client, close_rx);
            inner.insert(key, conn);

            client
        }
    }
    ```
  codeQuestion1: What is the general purpose of this code?
  codeQuestion2: How does the code handle the initialization and management of HTTP/3 connections for different hosts?
  codeQuestion3: What mechanisms are used to manage and reuse existing HTTP/3 connections in the pool?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/h3_client/pool.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    struct PoolInner {
        connecting: HashMap<Key, watch::Sender<Option<PoolClient>>>,
        idle_conns: HashMap<Key, PoolConnection>,
        timeout: Option<Duration>,
    }

    impl PoolInner {
        fn insert(&mut self, key: Key, conn: PoolConnection) {
            if self.idle_conns.contains_key(&key) {
                trace!("connection already exists for key {key:?}");
            }

            self.idle_conns.insert(key, conn);
        }
    }

    #[derive(Clone)]
    pub struct PoolClient {
        inner: SendRequest<OpenStreams, Bytes>,
    }

    impl PoolClient {
        pub fn new(tx: SendRequest<OpenStreams, Bytes>) -> Self {
            Self { inner: tx }
        }

        pub async fn send_request(
            &mut self,
            req: Request<Body>,
        ) -> Result<Response<ResponseBody>, BoxError> {
            use hyper::body::Body as _;

            let (head, req_body) = req.into_parts();
            let mut req = Request::from_parts(head, ());

            if let Some(n) = req_body.size_hint().exact() {
                if n > 0 {
                    req.headers_mut()
                        .insert(http::header::CONTENT_LENGTH, n.into());
                }
            }

            let mut stream = self.inner.send_request(req).await?;

            match req_body.as_bytes() {
                Some(b) if !b.is_empty() => {
                    stream.send_data(Bytes::copy_from_slice(b)).await?;
                }
                _ => {}
            }

            stream.finish().await?;

            let resp = stream.recv_response().await?;

            let resp_body = crate::async_impl::body::boxed(Incoming::new(stream, resp.headers()));

            Ok(resp.map(|_| resp_body))
        }
    }

    pub struct PoolConnection {
        // This receives errors from polling h3 driver.
        close_rx: Receiver<h3::error::ConnectionError>,
        client: PoolClient,
        idle_timeout: Instant,
    }

    impl PoolConnection {
        pub fn new(client: PoolClient, close_rx: Receiver<h3::error::ConnectionError>) -> Self {
            Self {
                close_rx,
                client,
                idle_timeout: Instant::now(),
            }
        }

        pub fn pool(&mut self) -> PoolClient {
            self.idle_timeout = Instant::now();
            self.client.clone()
        }

        pub fn is_invalid(&self) -> bool {
            match self.close_rx.try_recv() {
                Err(TryRecvError::Empty) => false,
                Err(TryRecvError::Disconnected) => true,
                Ok(_) => true,
            }
        }
    }

    struct Incoming<S, B> {
        inner: h3::client::RequestStream<S, B>,
        content_length: Option<u64>,
    }

    impl<S, B> Incoming<S, B> {
        fn new(stream: h3::client::RequestStream<S, B>, headers: &http::header::HeaderMap) -> Self {
            Self {
                inner: stream,
                content_length: headers
                    .get(http::header::CONTENT_LENGTH)
                    .and_then(|h| h.to_str().ok())
                    .and_then(|v| v.parse().ok()),
            }
        }
    }

    impl<S, B> http_body::Body for Incoming<S, B>
    where
        S: h3::quic::RecvStream,
    {
        type Data = Bytes;
        type Error = crate::error::Error;

        fn poll_frame(
            mut self: Pin<&mut Self>,
            cx: &mut Context,
        ) -> Poll<Option<Result<hyper::body::Frame<Self::Data>, Self::Error>>> {
            match futures_core::ready!(self.inner.poll_recv_data(cx)) {
                Ok(Some(mut b)) => Poll::Ready(Some(Ok(hyper::body::Frame::data(
                    b.copy_to_bytes(b.remaining()),
                )))),
                Ok(None) => Poll::Ready(None),
                Err(e) => Poll::Ready(Some(Err(crate::error::body(e)))),
            }
        }

        fn size_hint(&self) -> hyper::body::SizeHint {
            if let Some(content_length) = self.content_length {
                hyper::body::SizeHint::with_exact(content_length)
            } else {
                hyper::body::SizeHint::default()
            }
        }
    }

    pub(crate) fn extract_domain(uri: &mut Uri) -> Result<Key, Error> {
        let uri_clone = uri.clone();
        match (uri_clone.scheme(), uri_clone.authority()) {
            (Some(scheme), Some(auth)) => Ok((scheme.clone(), auth.clone())),
            _ => Err(Error::new(Kind::Request, None::<Error>)),
        }
    }

    pub(crate) fn domain_as_uri((scheme, auth): Key) -> Uri {
        http::uri::Builder::new()
            .scheme(scheme)
            .authority(auth)
            .path_and_query("/")
            .build()
            .expect("domain is valid Uri")
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user manage and reuse HTTP connections efficiently in the Hyper project's h3 client pool?
  codeQuestion3: What steps are taken to handle the lifetime and invalidation of HTTP connections in the PoolConnection struct?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::fmt;
    use std::net::SocketAddr;
    use std::pin::Pin;
    use std::time::Duration;

    use bytes::Bytes;
    use http_body_util::BodyExt;
    use hyper::{HeaderMap, StatusCode, Version};
    use hyper_util::client::legacy::connect::HttpInfo;
    #[cfg(feature = "json")]
    use serde::de::DeserializeOwned;
    #[cfg(feature = "json")]
    use serde_json;
    use tokio::time::Sleep;
    use url::Url;

    use super::body::Body;
    use super::decoder::{Accepts, Decoder};
    use crate::async_impl::body::ResponseBody;
    #[cfg(feature = "cookies")]
    use crate::cookie;

    #[cfg(feature = "charset")]
    use encoding_rs::{Encoding, UTF_8};
    #[cfg(feature = "charset")]
    use mime::Mime;

    /// A Response to a submitted `Request`.
    pub struct Response {
        pub(super) res: hyper::Response<Decoder>,
        // Boxed to save space (11 words to 1 word), and it's not accessed
        // frequently internally.
        url: Box<Url>,
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Response` struct handle different character encodings, and what system calls are involved in handling the input for this action?
  codeQuestion3: What steps are taken to handle terminal input and output settings for the game?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Response
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle asynchronous HTTP requests and responses?
  codeQuestion3: What steps are taken to ensure the code is thread-safe for concurrent use?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        pub(super) fn new(
            res: hyper::Response<ResponseBody>,
            url: Url,
            accepts: Accepts,
            total_timeout: Option<Pin<Box<Sleep>>>,
            read_timeout: Option<Duration>,
        ) -> Response {
            let (mut parts, body) = res.into_parts();
            let decoder = Decoder::detect(
                &mut parts.headers,
                super::body::response(body, total_timeout, read_timeout),
                accepts,
            );
            let res = hyper::Response::from_parts(parts, decoder);

            Response {
                res,
                url: Box::new(url),
            }
        }

        /// Get the `StatusCode` of this `Response`.
        #[inline]
        pub fn status(&self) -> StatusCode {
            self.res.status()
        }

        /// Get the HTTP `Version` of this `Response`.
        #[inline]
        pub fn version(&self) -> Version {
            self.res.version()
        }

        /// Get the `Headers` of this `Response`.
        #[inline]
        pub fn headers(&self) -> &HeaderMap {
            self.res.headers()
        }

        /// Get a mutable reference to the `Headers` of this `Response`.
        #[inline]
        pub fn headers_mut(&mut self) -> &mut HeaderMap {
            self.res.headers_mut()
        }

        /// Get the content length of the response, if it is known.
        ///
        /// This value does not directly represents the value of the `Content-Length`
        /// header, but rather the size of the response's body. To read the header's
        /// value, please use the [`Response::headers`] method instead.
        ///
        /// Reasons it may not be known:
        ///
        /// - The response does not include a body (e.g. it responds to a `HEAD`
        ///   request).
        /// - The response is gzipped and automatically decoded (thus changing the
        ///   actual decoded length).
        pub fn content_length(&self) -> Option<u64> {
            use hyper::body::Body;

            Body::size_hint(self.res.body()).exact()
        }

        /// Retrieve the cookies contained in the response.
        ///
        /// Note that invalid 'Set-Cookie' headers will be ignored.
        ///
        /// # Optional
        ///
        /// This requires the optional `cookies` feature to be enabled.
        #[cfg(feature = "cookies")]
        #[cfg_attr(docsrs, doc(cfg(feature = "cookies")))]
        pub fn cookies<'a>(&'a self) -> impl Iterator<Item = cookie::Cookie<'a>> + 'a {
            cookie::extract_response_cookies(self.res.headers()).filter_map(Result::ok)
        }

        /// Get the final `Url` of this `Response`.
        #[inline]
        pub fn url(&self) -> &Url {
            &self.url
        }

        /// Get the remote address used to get this `Response`.
        pub fn remote_addr(&self) -> Option<SocketAddr> {
            self.res
                .extensions()
                .get::<HttpInfo>()
                .map(|info| info.remote_addr())
        }

        /// Returns a reference to the associated extensions.
        pub fn extensions(&self) -> &http::Extensions {
            self.res.extensions()
        }

        /// Returns a mutable reference to the associated extensions.
        pub fn extensions_mut(&mut self) -> &mut http::Extensions {
            self.res.extensions_mut()
        }

        // body methods

        /// Get the full response text.
        ///
        /// This method decodes the response body with BOM sniffing
        /// and with malformed sequences replaced with the
        /// [`char::REPLACEMENT_CHARACTER`].
        /// Encoding is determined from the `charset` parameter of `Content-Type` header,
        /// and defaults to `utf-8` if not presented.
        ///
        /// Note that the BOM is stripped from the returned String.
        ///
        /// # Note
        ///
        /// If the `charset` feature is disabled the method will only attempt to decode the
        /// response as UTF-8, regardless of the given `Content-Type`
        ///
        /// # Example
        ///
        /// ```
        /// # async fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let content = reqwest::get("http://httpbin.org/range/26")
        ///     .await?
        ///     .text()
        ///     .await?;
        ///
        /// println!("text: {content:?}");
        /// # Ok(())
        /// # }
        /// ```
        pub async fn text(self) -> crate::Result<String> {
            #[cfg(feature = "charset")]
            {
                self.text_with_charset("utf-8").await
            }

            #[cfg(not(feature = "charset"))]
            {
                let full = self.bytes().await?;
                let text = String::from_utf8_lossy(&full);
                Ok(text.into_owned())
            }
        }

        /// Get the full response text given a specific encoding.
        ///
        /// This method decodes the response body with BOM sniffing
        /// and with malformed sequences replaced with the [`char::REPLACEMENT_CHARACTER`].
        /// You can provide a default encoding for decoding the raw message, while the
        /// `charset` parameter of `Content-Type` header is still prioritized. For more information
        /// about the possible encoding name, please go to [`encoding_rs`] docs.
        ///
        /// Note that the BOM is stripped from the returned String.
        ///
        /// [`encoding_rs`]: https://docs.rs/encoding_rs/0.8/encoding_rs/#relationship-with-windows-code-pages
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer retrieve the cookies from an HTTP response, and what features are required for this functionality?
  codeQuestion3: What is the process for decoding the response body into a string, and what are the conditions under which different decoding methods are used?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///
        /// # Optional
        ///
        /// This requires the optional `encoding_rs` feature enabled.
        ///
        /// # Example
        ///
        /// ```
        /// # async fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let content = reqwest::get("http://httpbin.org/range/26")
        ///     .await?
        ///     .text_with_charset("utf-8")
        ///     .await?;
        ///
        /// println!("text: {content:?}");
        /// # Ok(())
        /// # }
        /// ```
        #[cfg(feature = "charset")]
        #[cfg_attr(docsrs, doc(cfg(feature = "charset")))]
        pub async fn text_with_charset(self, default_encoding: &str) -> crate::Result<String> {
            let content_type = self
                .headers()
                .get(crate::header::CONTENT_TYPE)
                .and_then(|value| value.to_str().ok())
                .and_then(|value| value.parse::<Mime>().ok());
            let encoding_name = content_type
                .as_ref()
                .and_then(|mime| mime.get_param("charset").map(|charset| charset.as_str()))
                .unwrap_or(default_encoding);
            let encoding = Encoding::for_label(encoding_name.as_bytes()).unwrap_or(UTF_8);

            let full = self.bytes().await?;

            let (text, _, _) = encoding.decode(&full);
            Ok(text.into_owned())
        }

        /// Try to deserialize the response body as JSON.
        ///
        /// # Optional
        ///
        /// This requires the optional `json` feature enabled.
        ///
        /// # Examples
        ///
        /// ```
        /// # extern crate reqwest;
        /// # extern crate serde;
        /// #
        /// # use reqwest::Error;
        /// # use serde::Deserialize;
        /// #
        /// // This `derive` requires the `serde` dependency.
        /// #[derive(Deserialize)]
        /// struct Ip {
        ///     origin: String,
        /// }
        ///
        /// # async fn run() -> Result<(), Error> {
        /// let ip = reqwest::get("http://httpbin.org/ip")
        ///     .await?
        ///     .json::<Ip>()
        ///     .await?;
        ///
        /// println!("ip: {}", ip.origin);
        /// # Ok(())
        /// # }
        /// #
        /// # fn main() { }
        /// ```
        ///
        /// # Errors
        ///
        /// This method fails whenever the response body is not in JSON format,
        /// or it cannot be properly deserialized to target type `T`. For more
        /// details please see [`serde_json::from_reader`].
        ///
        /// [`serde_json::from_reader`]: https://docs.serde.rs/serde_json/fn.from_reader.html
        #[cfg(feature = "json")]
        #[cfg_attr(docsrs, doc(cfg(feature = "json")))]
        pub async fn json<T: DeserializeOwned>(self) -> crate::Result<T> {
            let full = self.bytes().await?;

            serde_json::from_slice(&full).map_err(crate::error::decode)
        }

        /// Get the full response body as `Bytes`.
        ///
        /// # Example
        ///
        /// ```
        /// # async fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let bytes = reqwest::get("http://httpbin.org/ip")
        ///     .await?
        ///     .bytes()
        ///     .await?;
        ///
        /// println!("bytes: {bytes:?}");
        /// # Ok(())
        /// # }
        /// ```
        pub async fn bytes(self) -> crate::Result<Bytes> {
            use http_body_util::BodyExt;

            BodyExt::collect(self.res.into_body())
                .await
                .map(|buf| buf.to_bytes())
        }

        /// Stream a chunk of the response body.
        ///
        /// When the response body has been exhausted, this will return `None`.
        ///
        /// # Example
        ///
        /// ```
        /// # async fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut res = reqwest::get("https://hyper.rs").await?;
        ///
        /// while let Some(chunk) = res.chunk().await? {
        ///     println!("Chunk: {chunk:?}");
        /// }
        /// # Ok(())
        /// # }
        /// ```
        pub async fn chunk(&mut self) -> crate::Result<Option<Bytes>> {
            use http_body_util::BodyExt;

            // loop to ignore unrecognized frames
            loop {
                if let Some(res) = self.res.body_mut().frame().await {
                    let frame = res?;
                    if let Ok(buf) = frame.into_data() {
                        return Ok(Some(buf));
                    }
                    // else continue
                } else {
                    return Ok(None);
                }
            }
        }

        /// Convert the response into a `Stream` of `Bytes` from the body.
        ///
        /// # Example
        ///
        /// ```
        /// use futures_util::StreamExt;
        ///
        /// # async fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut stream = reqwest::get("http://httpbin.org/ip")
        ///     .await?
        ///     .bytes_stream();
        ///
        /// while let Some(item) = stream.next().await {
        ///     println!("Chunk: {:?}", item?);
        /// }
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the optional `stream` feature to be enabled.
        #[cfg(feature = "stream")]
        #[cfg_attr(docsrs, doc(cfg(feature = "stream")))]
        pub fn bytes_stream(self) -> impl futures_core::Stream<Item = crate::Result<Bytes>> {
            super::body::DataStream(self.res.into_body())
        }

        // util methods

        /// Turn a response into an error if the server returned an error.
        ///
        /// # Example
        ///
        /// ```
        /// # use reqwest::Response;
        /// fn on_response(res: Response) {
        ///     match res.error_for_status() {
        ///         Ok(_res) => (),
        ///         Err(err) => {
        ///             // asserting a 400 as an example
        ///             // it could be any status between 400...599
        ///             assert_eq!(
        ///                 err.status(),
        ///                 Some(reqwest::StatusCode::BAD_REQUEST)
        ///             );
        ///         }
        ///     }
        /// }
        /// # fn main() {}
        /// ```
        pub fn error_for_status(self) -> crate::Result<Self> {
            let status = self.status();
            if status.is_client_error() || status.is_server_error() {
                Err(crate::error::status_code(*self.url, status))
            } else {
                Ok(self)
            }
        }

        /// Turn a reference to a response into an error if the server returned an error.
        ///
        /// # Example
        ///
        /// ```
        /// # use reqwest::Response;
        /// fn on_response(res: &Response) {
        ///     match res.error_for_status_ref() {
        ///         Ok(_res) => (),
        ///         Err(err) => {
        ///             // asserting a 400 as an example
        ///             // it could be any status between 400...599
        ///             assert_eq!(
        ///                 err.status(),
        ///                 Some(reqwest::StatusCode::BAD_REQUEST)
        ///             );
        ///         }
        ///     }
        /// }
        /// # fn main() {}
        /// ```
        pub fn error_for_status_ref(&self) -> crate::Result<&Self> {
            let status = self.status();
            if status.is_client_error() || status.is_server_error() {
                Err(crate::error::status_code(*self.url.clone(), status))
            } else {
                Ok(self)
            }
        }

        // private

        // The Response's body is an implementation detail.
        // You no longer need to get a reference to it, there are async methods
        // on the `Response` itself.
        //
        // This method is just used by the blocking API.
        #[cfg(feature = "blocking")]
        pub(crate) fn body_mut(&mut self) -> &mut Decoder {
            self.res.body_mut()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user deserialize a JSON response from an HTTP request, and what system calls or API methods are involved in this process?
  codeQuestion3: What steps are taken to handle the response body as bytes and convert it into a string with specific character encoding?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Response {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Response")
                .field("url", &self.url().as_str())
                .field("status", &self.status())
                .field("headers", self.headers())
                .finish()
        }
    }

    /// A `Response` can be piped as the `Body` of another request.
    impl From<Response> for Body {
        fn from(r: Response) -> Body {
            Body::wrap(r.res.into_body())
        }
    }

    // I'm not sure this conversion is that useful... People should be encouraged
    // to use `http::Response`, not `reqwest::Response`.
    impl<T: Into<Body>> From<http::Response<T>> for Response {
        fn from(r: http::Response<T>) -> Response {
            use crate::response::ResponseUrl;

            let (mut parts, body) = r.into_parts();
            let body: crate::async_impl::body::Body = body.into();
            let decoder = Decoder::detect(
                &mut parts.headers,
                ResponseBody::new(body.map_err(Into::into)),
                Accepts::none(),
            );
            let url = parts
                .extensions
                .remove::<ResponseUrl>()
                .unwrap_or_else(|| ResponseUrl(Url::parse("http://no.url.provided.local").unwrap()));
            let url = url.0;
            let res = hyper::Response::from_parts(parts, decoder);
            Response {
                res,
                url: Box::new(url),
            }
        }
    }

    /// A `Response` can be converted into a `http::Response`.
    // It's supposed to be the inverse of the conversion above.
    impl From<Response> for http::Response<Body> {
        fn from(r: Response) -> http::Response<Body> {
            let (parts, body) = r.res.into_parts();
            let body = Body::wrap(body);
            http::Response::from_parts(parts, body)
        }
    }

    #[cfg(test)]
    mod tests {
        use super::Response;
        use crate::ResponseBuilderExt;
        use http::response::Builder;
        use url::Url;

        #[test]
        fn test_from_http_response() {
            let url = Url::parse("http://example.com").unwrap();
            let response = Builder::new()
                .status(200)
                .url(url.clone())
                .body("foo")
                .unwrap();
            let response = Response::from(response);

            assert_eq!(response.status(), 200);
            assert_eq!(*response.url(), url);
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user convert an `http::Response` to a `reqwest::Response` and what system calls are involved in this conversion?
  codeQuestion3: What steps are taken to handle URL parsing and response headers during the conversion between `http::Response` and `reqwest::Response`?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::convert::TryFrom;
    use std::fmt;
    use std::future::Future;
    use std::time::Duration;

    use serde::Serialize;
    #[cfg(feature = "json")]
    use serde_json;

    use super::body::Body;
    use super::client::{Client, Pending};
    #[cfg(feature = "multipart")]
    use super::multipart;
    use super::response::Response;
    use crate::config::{RequestConfig, RequestTimeout};
    #[cfg(feature = "multipart")]
    use crate::header::CONTENT_LENGTH;
    use crate::header::{HeaderMap, HeaderName, HeaderValue, CONTENT_TYPE};
    use crate::{Method, Url};
    use http::{request::Parts, Extensions, Request as HttpRequest, Version};

    /// A request which can be executed with `Client::execute()`.
    pub struct Request {
        method: Method,
        url: Url,
        headers: HeaderMap,
        body: Option<Body>,
        version: Version,
        extensions: Extensions,
    }

    /// A builder to construct the properties of a `Request`.
    ///
    /// To construct a `RequestBuilder`, refer to the `Client` documentation.
    #[must_use = "RequestBuilder does nothing until you 'send' it"]
    pub struct RequestBuilder {
        client: Client,
        request: crate::Result<Request>,
    }

    impl Request {
        /// Constructs a new request.
        #[inline]
        pub fn new(method: Method, url: Url) -> Self {
            Request {
                method,
                url,
                headers: HeaderMap::new(),
                body: None,
                version: Version::default(),
                extensions: Extensions::new(),
            }
        }

        /// Get the method.
        #[inline]
        pub fn method(&self) -> &Method {
            &self.method
        }

        /// Get a mutable reference to the method.
        #[inline]
        pub fn method_mut(&mut self) -> &mut Method {
            &mut self.method
        }

        /// Get the url.
        #[inline]
        pub fn url(&self) -> &Url {
            &self.url
        }

        /// Get a mutable reference to the url.
        #[inline]
        pub fn url_mut(&mut self) -> &mut Url {
            &mut self.url
        }

        /// Get the headers.
        #[inline]
        pub fn headers(&self) -> &HeaderMap {
            &self.headers
        }

        /// Get a mutable reference to the headers.
        #[inline]
        pub fn headers_mut(&mut self) -> &mut HeaderMap {
            &mut self.headers
        }

        /// Get the body.
        #[inline]
        pub fn body(&self) -> Option<&Body> {
            self.body.as_ref()
        }

        /// Get a mutable reference to the body.
        #[inline]
        pub fn body_mut(&mut self) -> &mut Option<Body> {
            &mut self.body
        }

        /// Get the extensions.
        #[inline]
        pub(crate) fn extensions(&self) -> &Extensions {
            &self.extensions
        }

        /// Get a mutable reference to the extensions.
        #[inline]
        pub(crate) fn extensions_mut(&mut self) -> &mut Extensions {
            &mut self.extensions
        }

        /// Get the timeout.
        #[inline]
        pub fn timeout(&self) -> Option<&Duration> {
            RequestConfig::<RequestTimeout>::get(&self.extensions)
        }

        /// Get a mutable reference to the timeout.
        #[inline]
        pub fn timeout_mut(&mut self) -> &mut Option<Duration> {
            RequestConfig::<RequestTimeout>::get_mut(&mut self.extensions)
        }

        /// Get the http version.
        #[inline]
        pub fn version(&self) -> Version {
            self.version
        }

        /// Get a mutable reference to the http version.
        #[inline]
        pub fn version_mut(&mut self) -> &mut Version {
            &mut self.version
        }

        /// Attempt to clone the request.
        ///
        /// `None` is returned if the request can not be cloned, i.e. if the body is a stream.
        pub fn try_clone(&self) -> Option<Request> {
            let body = match self.body.as_ref() {
                Some(body) => Some(body.try_clone()?),
                None => None,
            };
            let mut req = Request::new(self.method().clone(), self.url().clone());
            *req.timeout_mut() = self.timeout().copied();
            *req.headers_mut() = self.headers().clone();
            *req.version_mut() = self.version();
            *req.extensions_mut() = self.extensions().clone();
            req.body = body;
            Some(req)
        }

        pub(super) fn pieces(self) -> (Method, Url, HeaderMap, Option<Body>, Version, Extensions) {
            (
                self.method,
                self.url,
                self.headers,
                self.body,
                self.version,
                self.extensions,
            )
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Request` struct facilitate HTTP requests in the Hyper project, and what methods are available for modifying request properties?
  codeQuestion3: What is the role of the `try_clone` method in the `Request` struct, and how does it handle cloning a request with a body?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl RequestBuilder
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user send an HTTP GET request using the RequestBuilder API?
  codeQuestion3: What steps are taken to handle custom headers in a request using the RequestBuilder API?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        pub(super) fn new(client: Client, request: crate::Result<Request>) -> RequestBuilder {
            let mut builder = RequestBuilder { client, request };

            let auth = builder
                .request
                .as_mut()
                .ok()
                .and_then(|req| extract_authority(&mut req.url));

            if let Some((username, password)) = auth {
                builder.basic_auth(username, password)
            } else {
                builder
            }
        }

        /// Assemble a builder starting from an existing `Client` and a `Request`.
        pub fn from_parts(client: Client, request: Request) -> RequestBuilder {
            RequestBuilder {
                client,
                request: crate::Result::Ok(request),
            }
        }

        /// Add a `Header` to this Request.
        pub fn header<K, V>(self, key: K, value: V) -> RequestBuilder
        where
            HeaderName: TryFrom<K>,
            <HeaderName as TryFrom<K>>::Error: Into<http::Error>,
            HeaderValue: TryFrom<V>,
            <HeaderValue as TryFrom<V>>::Error: Into<http::Error>,
        {
            self.header_sensitive(key, value, false)
        }

        /// Add a `Header` to this Request with ability to define if `header_value` is sensitive.
        fn header_sensitive<K, V>(mut self, key: K, value: V, sensitive: bool) -> RequestBuilder
        where
            HeaderName: TryFrom<K>,
            <HeaderName as TryFrom<K>>::Error: Into<http::Error>,
            HeaderValue: TryFrom<V>,
            <HeaderValue as TryFrom<V>>::Error: Into<http::Error>,
        {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match <HeaderName as TryFrom<K>>::try_from(key) {
                    Ok(key) => match <HeaderValue as TryFrom<V>>::try_from(value) {
                        Ok(mut value) => {
                            // We want to potentially make an non-sensitive header
                            // to be sensitive, not the reverse. So, don't turn off
                            // a previously sensitive header.
                            if sensitive {
                                value.set_sensitive(true);
                            }
                            req.headers_mut().append(key, value);
                        }
                        Err(e) => error = Some(crate::error::builder(e.into())),
                    },
                    Err(e) => error = Some(crate::error::builder(e.into())),
                };
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Add a set of Headers to the existing ones on this Request.
        ///
        /// The headers will be merged in to any already set.
        pub fn headers(mut self, headers: crate::header::HeaderMap) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                crate::util::replace_headers(req.headers_mut(), headers);
            }
            self
        }

        /// Enable HTTP basic authentication.
        ///
        /// ```rust
        /// # use reqwest::Error;
        ///
        /// # async fn run() -> Result<(), Error> {
        /// let client = reqwest::Client::new();
        /// let resp = client.delete("http://httpbin.org/delete")
        ///     .basic_auth("admin", Some("good password"))
        ///     .send()
        ///     .await?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn basic_auth<U, P>(self, username: U, password: Option<P>) -> RequestBuilder
        where
            U: fmt::Display,
            P: fmt::Display,
        {
            let header_value = crate::util::basic_auth(username, password);
            self.header_sensitive(crate::header::AUTHORIZATION, header_value, true)
        }

        /// Enable HTTP bearer authentication.
        pub fn bearer_auth<T>(self, token: T) -> RequestBuilder
        where
            T: fmt::Display,
        {
            let header_value = format!("Bearer {token}");
            self.header_sensitive(crate::header::AUTHORIZATION, header_value, true)
        }

        /// Set the request body.
        pub fn body<T: Into<Body>>(mut self, body: T) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                *req.body_mut() = Some(body.into());
            }
            self
        }

        /// Enables a request timeout.
        ///
        /// The timeout is applied from when the request starts connecting until the
        /// response body has finished. It affects only this request and overrides
        /// the timeout configured using `ClientBuilder::timeout()`.
        pub fn timeout(mut self, timeout: Duration) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                *req.timeout_mut() = Some(timeout);
            }
            self
        }

        /// Sends a multipart/form-data body.
        ///
        /// ```
        /// # use reqwest::Error;
        ///
        /// # async fn run() -> Result<(), Error> {
        /// let client = reqwest::Client::new();
        /// let form = reqwest::multipart::Form::new()
        ///     .text("key3", "value3")
        ///     .text("key4", "value4");
        ///
        ///
        /// let response = client.post("your url")
        ///     .multipart(form)
        ///     .send()
        ///     .await?;
        /// # Ok(())
        /// # }
        /// ```
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user add custom headers to a request, and what is the process for handling sensitive header information?
  codeQuestion3: What steps are taken to handle HTTP basic authentication in the code, and how is it integrated with the request builder?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///
        /// In additional the request's body, the Content-Type and Content-Length fields are
        /// appropriately set.
        #[cfg(feature = "multipart")]
        #[cfg_attr(docsrs, doc(cfg(feature = "multipart")))]
        pub fn multipart(self, mut multipart: multipart::Form) -> RequestBuilder {
            let mut builder = self.header(
                CONTENT_TYPE,
                format!("multipart/form-data; boundary={}", multipart.boundary()).as_str(),
            );

            builder = match multipart.compute_length() {
                Some(length) => builder.header(CONTENT_LENGTH, length),
                None => builder,
            };

            if let Ok(ref mut req) = builder.request {
                *req.body_mut() = Some(multipart.stream())
            }
            builder
        }

        /// Modify the query string of the URL.
        ///
        /// Modifies the URL of this request, adding the parameters provided.
        /// This method appends and does not overwrite. This means that it can
        /// be called multiple times and that existing query parameters are not
        /// overwritten if the same key is used. The key will simply show up
        /// twice in the query string.
        /// Calling `.query(&[("foo", "a"), ("foo", "b")])` gives `"foo=a&foo=b"`.
        ///
        /// # Note
        /// This method does not support serializing a single key-value
        /// pair. Instead of using `.query(("key", "val"))`, use a sequence, such
        /// as `.query(&[("key", "val")])`. It's also possible to serialize structs
        /// and maps into a key-value pair.
        ///
        /// # Errors
        /// This method will fail if the object you provide cannot be serialized
        /// into a query string.
        pub fn query<T: Serialize + ?Sized>(mut self, query: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                let url = req.url_mut();
                let mut pairs = url.query_pairs_mut();
                let serializer = serde_urlencoded::Serializer::new(&mut pairs);

                if let Err(err) = query.serialize(serializer) {
                    error = Some(crate::error::builder(err));
                }
            }
            if let Ok(ref mut req) = self.request {
                if let Some("") = req.url().query() {
                    req.url_mut().set_query(None);
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Set HTTP version
        pub fn version(mut self, version: Version) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                req.version = version;
            }
            self
        }

        /// Send a form body.
        ///
        /// Sets the body to the url encoded serialization of the passed value,
        /// and also sets the `Content-Type: application/x-www-form-urlencoded`
        /// header.
        ///
        /// ```rust
        /// # use reqwest::Error;
        /// # use std::collections::HashMap;
        /// #
        /// # async fn run() -> Result<(), Error> {
        /// let mut params = HashMap::new();
        /// params.insert("lang", "rust");
        ///
        /// let client = reqwest::Client::new();
        /// let res = client.post("http://httpbin.org")
        ///     .form(&params)
        ///     .send()
        ///     .await?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Errors
        ///
        /// This method fails if the passed value cannot be serialized into
        /// url encoded format
        pub fn form<T: Serialize + ?Sized>(mut self, form: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match serde_urlencoded::to_string(form) {
                    Ok(body) => {
                        req.headers_mut()
                            .entry(CONTENT_TYPE)
                            .or_insert(HeaderValue::from_static(
                                "application/x-www-form-urlencoded",
                            ));
                        *req.body_mut() = Some(body.into());
                    }
                    Err(err) => error = Some(crate::error::builder(err)),
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Send a JSON body.
        ///
        /// # Optional
        ///
        /// This requires the optional `json` feature enabled.
        ///
        /// # Errors
        ///
        /// Serialization can fail if `T`'s implementation of `Serialize` decides to
        /// fail, or if `T` contains a map with non-string keys.
        #[cfg(feature = "json")]
        #[cfg_attr(docsrs, doc(cfg(feature = "json")))]
        pub fn json<T: Serialize + ?Sized>(mut self, json: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match serde_json::to_vec(json) {
                    Ok(body) => {
                        if !req.headers().contains_key(CONTENT_TYPE) {
                            req.headers_mut()
                                .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
                        }
                        *req.body_mut() = Some(body.into());
                    }
                    Err(err) => error = Some(crate::error::builder(err)),
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        // This was a shell only meant to help with rendered documentation.
        // However, docs.rs can now show the docs for the wasm platforms, so this
        // is no longer needed.
        //
        // You should not otherwise depend on this function. It's deprecation
        // is just to nudge people to reduce breakage. It may be removed in a
        // future patch version.
        #[doc(hidden)]
        #[cfg_attr(target_arch = "wasm32", deprecated)]
        pub fn fetch_mode_no_cors(self) -> RequestBuilder {
            self
        }

        /// Build a `Request`, which can be inspected, modified and executed with
        /// `Client::execute()`.
        pub fn build(self) -> crate::Result<Request> {
            self.request
        }

        /// Build a `Request`, which can be inspected, modified and executed with
        /// `Client::execute()`.
        ///
        /// This is similar to [`RequestBuilder::build()`], but also returns the
        /// embedded `Client`.
        pub fn build_split(self) -> (Client, crate::Result<Request>) {
            (self.client, self.request)
        }

        /// Constructs the Request and sends it to the target URL, returning a
        /// future Response.
        ///
        /// # Errors
        ///
        /// This method fails if there was an error while sending request,
        /// redirect loop was detected or redirect limit was exhausted.
        ///
        /// # Example
        ///
        /// ```no_run
        /// # use reqwest::Error;
        /// #
        /// # async fn run() -> Result<(), Error> {
        /// let response = reqwest::Client::new()
        ///     .get("https://hyper.rs")
        ///     .send()
        ///     .await?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn send(self) -> impl Future<Output = Result<Response, crate::Error>> {
            match self.request {
                Ok(req) => self.client.execute_request(req),
                Err(err) => Pending::new_err(err),
            }
        }

        /// Attempt to clone the RequestBuilder.
        ///
        /// `None` is returned if the RequestBuilder can not be cloned,
        /// i.e. if the request body is a stream.
        ///
        /// # Examples
        ///
        /// ```
        /// # use reqwest::Error;
        /// #
        /// # fn run() -> Result<(), Error> {
        /// let client = reqwest::Client::new();
        /// let builder = client.post("http://httpbin.org/post")
        ///     .body("from a &str!");
        /// let clone = builder.try_clone();
        /// assert!(clone.is_some());
        /// # Ok(())
        /// # }
        /// ```
        pub fn try_clone(&self) -> Option<RequestBuilder> {
            self.request
                .as_ref()
                .ok()
                .and_then(|req| req.try_clone())
                .map(|req| RequestBuilder {
                    client: self.client.clone(),
                    request: Ok(req),
                })
        }
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the `form` method handle serialization of a data structure into an HTTP request body?
  codeQuestion3: What is the role of the `query` method in modifying the URL parameters of a request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Request {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            fmt_request_fields(&mut f.debug_struct("Request"), self).finish()
        }
    }

    impl fmt::Debug for RequestBuilder {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut builder = f.debug_struct("RequestBuilder");
            match self.request {
                Ok(ref req) => fmt_request_fields(&mut builder, req).finish(),
                Err(ref err) => builder.field("error", err).finish(),
            }
        }
    }

    fn fmt_request_fields<'a, 'b>(
        f: &'a mut fmt::DebugStruct<'a, 'b>,
        req: &Request,
    ) -> &'a mut fmt::DebugStruct<'a, 'b> {
        f.field("method", &req.method)
            .field("url", &req.url)
            .field("headers", &req.headers)
    }

    /// Check the request URL for a "username:password" type authority, and if
    /// found, remove it from the URL and return it.
    pub(crate) fn extract_authority(url: &mut Url) -> Option<(String, Option<String>)> {
        use percent_encoding::percent_decode;

        if url.has_authority() {
            let username: String = percent_decode(url.username().as_bytes())
                .decode_utf8()
                .ok()?
                .into();
            let password = url.password().and_then(|pass| {
                percent_decode(pass.as_bytes())
                    .decode_utf8()
                    .ok()
                    .map(String::from)
            });
            if !username.is_empty() || password.is_some() {
                url.set_username("")
                    .expect("has_authority means set_username shouldn't fail");
                url.set_password(None)
                    .expect("has_authority means set_password shouldn't fail");
                return Some((username, password));
            }
        }

        None
    }

    impl<T> TryFrom<HttpRequest<T>> for Request
    where
        T: Into<Body>,
    {
        type Error = crate::Error;

        fn try_from(req: HttpRequest<T>) -> crate::Result<Self> {
            let (parts, body) = req.into_parts();
            let Parts {
                method,
                uri,
                headers,
                version,
                extensions,
                ..
            } = parts;
            let url = Url::parse(&uri.to_string()).map_err(crate::error::builder)?;
            Ok(Request {
                method,
                url,
                headers,
                body: Some(body.into()),
                version,
                extensions,
            })
        }
    }

    impl TryFrom<Request> for HttpRequest<Body> {
        type Error = crate::Error;

        fn try_from(req: Request) -> crate::Result<Self> {
            let Request {
                method,
                url,
                headers,
                body,
                version,
                extensions,
                ..
            } = req;

            let mut req = HttpRequest::builder()
                .version(version)
                .method(method)
                .uri(url.as_str())
                .body(body.unwrap_or_else(Body::empty))
                .map_err(crate::error::builder)?;

            *req.headers_mut() = headers;
            *req.extensions_mut() = extensions;
            Ok(req)
        }
    }

    #[cfg(test)]
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `extract_authority` function handle username and password extraction from a URL, and what is its return value?
  codeQuestion3: What is the process for converting an `HttpRequest<T>` into a `Request` object, and what error handling is involved?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod tests
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user initiate a new game after losing, and what system calls are involved in handling the input for this action?
  codeQuestion3: What steps are taken to handle terminal input and output settings for the game?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]

        use super::{Client, HttpRequest, Request, RequestBuilder, Version};
        use crate::Method;
        use serde::Serialize;
        use std::collections::BTreeMap;
        use std::convert::TryFrom;

        #[test]
        fn add_query_append() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.get(some_url);

            let r = r.query(&[("foo", "bar")]);
            let r = r.query(&[("qux", 3)]);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=bar&qux=3"));
        }

        #[test]
        fn add_query_append_same() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.get(some_url);

            let r = r.query(&[("foo", "a"), ("foo", "b")]);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=a&foo=b"));
        }

        #[test]
        fn add_query_struct() {
            #[derive(Serialize)]
            struct Params {
                foo: String,
                qux: i32,
            }

            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.get(some_url);

            let params = Params {
                foo: "bar".into(),
                qux: 3,
            };

            let r = r.query(&params);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=bar&qux=3"));
        }

        #[test]
        fn add_query_map() {
            let mut params = BTreeMap::new();
            params.insert("foo", "bar");
            params.insert("qux", "three");

            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.get(some_url);

            let r = r.query(&params);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=bar&qux=three"));
        }

        #[test]
        fn test_replace_headers() {
            use http::HeaderMap;

            let mut headers = HeaderMap::new();
            headers.insert("foo", "bar".parse().unwrap());
            headers.append("foo", "baz".parse().unwrap());

            let client = Client::new();
            let req = client
                .get("https://hyper.rs")
                .header("im-a", "keeper")
                .header("foo", "pop me")
                .headers(headers)
                .build()
                .expect("request build");

            assert_eq!(req.headers()["im-a"], "keeper");

            let foo = req.headers().get_all("foo").iter().collect::<Vec<_>>();
            assert_eq!(foo.len(), 2);
            assert_eq!(foo[0], "bar");
            assert_eq!(foo[1], "baz");
        }

        #[test]
        fn normalize_empty_query() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let empty_query: &[(&str, &str)] = &[];

            let req = client
                .get(some_url)
                .query(empty_query)
                .build()
                .expect("request build");

            assert_eq!(req.url().query(), None);
            assert_eq!(req.url().as_str(), "https://google.com/");
        }

        #[test]
        fn try_clone_reusable() {
            let client = Client::new();
            let builder = client
                .post("http://httpbin.org/post")
                .header("foo", "bar")
                .body("from a &str!");
            let req = builder
                .try_clone()
                .expect("clone successful")
                .build()
                .expect("request is valid");
            assert_eq!(req.url().as_str(), "http://httpbin.org/post");
            assert_eq!(req.method(), Method::POST);
            assert_eq!(req.headers()["foo"], "bar");
        }

        #[test]
        fn try_clone_no_body() {
            let client = Client::new();
            let builder = client.get("http://httpbin.org/get");
            let req = builder
                .try_clone()
                .expect("clone successful")
                .build()
                .expect("request is valid");
            assert_eq!(req.url().as_str(), "http://httpbin.org/get");
            assert_eq!(req.method(), Method::GET);
            assert!(req.body().is_none());
        }

        #[test]
        #[cfg(feature = "stream")]
        fn try_clone_stream() {
            let chunks: Vec<Result<_, ::std::io::Error>> = vec![Ok("hello"), Ok(" "), Ok("world")];
            let stream = futures_util::stream::iter(chunks);
            let client = Client::new();
            let builder = client
                .get("http://httpbin.org/get")
                .body(super::Body::wrap_stream(stream));
            let clone = builder.try_clone();
            assert!(clone.is_none());
        }

        #[test]
        fn convert_url_authority_into_basic_auth() {
            let client = Client::new();
            let some_url = "https://Aladdin:open sesame@localhost/";

            let req = client.get(some_url).build().expect("request build");

            assert_eq!(req.url().as_str(), "https://localhost/");
            assert_eq!(
                req.headers()["authorization"],
                "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
            );
        }

        #[test]
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle adding query parameters to a request, and what is an example of using `query` with different data types?
  codeQuestion3: What steps are taken to handle cloning a request builder and what is the difference between `try_clone` with and without a body?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    fn test_basic_auth_sensitive_header() {
            let client = Client::new();
            let some_url = "https://localhost/";

            let req = client
                .get(some_url)
                .basic_auth("Aladdin", Some("open sesame"))
                .build()
                .expect("request build");

            assert_eq!(req.url().as_str(), "https://localhost/");
            assert_eq!(
                req.headers()["authorization"],
                "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
            );
            assert!(req.headers()["authorization"].is_sensitive());
        }

        #[test]
        fn test_bearer_auth_sensitive_header() {
            let client = Client::new();
            let some_url = "https://localhost/";

            let req = client
                .get(some_url)
                .bearer_auth("Hold my bear")
                .build()
                .expect("request build");

            assert_eq!(req.url().as_str(), "https://localhost/");
            assert_eq!(req.headers()["authorization"], "Bearer Hold my bear");
            assert!(req.headers()["authorization"].is_sensitive());
        }

        #[test]
        fn test_explicit_sensitive_header() {
            let client = Client::new();
            let some_url = "https://localhost/";

            let mut header = http::HeaderValue::from_static("in plain sight");
            header.set_sensitive(true);

            let req = client
                .get(some_url)
                .header("hiding", header)
                .build()
                .expect("request build");

            assert_eq!(req.url().as_str(), "https://localhost/");
            assert_eq!(req.headers()["hiding"], "in plain sight");
            assert!(req.headers()["hiding"].is_sensitive());
        }

        #[test]
        fn convert_from_http_request() {
            let http_request = HttpRequest::builder()
                .method("GET")
                .uri("http://localhost/")
                .header("User-Agent", "my-awesome-agent/1.0")
                .body("test test test")
                .unwrap();
            let req: Request = Request::try_from(http_request).unwrap();
            assert!(req.body().is_some());
            let test_data = b"test test test";
            assert_eq!(req.body().unwrap().as_bytes(), Some(&test_data[..]));
            let headers = req.headers();
            assert_eq!(headers.get("User-Agent").unwrap(), "my-awesome-agent/1.0");
            assert_eq!(req.method(), Method::GET);
            assert_eq!(req.url().as_str(), "http://localhost/");
        }

        #[test]
        fn set_http_request_version() {
            let http_request = HttpRequest::builder()
                .method("GET")
                .uri("http://localhost/")
                .header("User-Agent", "my-awesome-agent/1.0")
                .version(Version::HTTP_11)
                .body("test test test")
                .unwrap();
            let req: Request = Request::try_from(http_request).unwrap();
            assert!(req.body().is_some());
            let test_data = b"test test test";
            assert_eq!(req.body().unwrap().as_bytes(), Some(&test_data[..]));
            let headers = req.headers();
            assert_eq!(headers.get("User-Agent").unwrap(), "my-awesome-agent/1.0");
            assert_eq!(req.method(), Method::GET);
            assert_eq!(req.url().as_str(), "http://localhost/");
            assert_eq!(req.version(), Version::HTTP_11);
        }

        #[test]
        fn builder_split_reassemble() {
            let builder = {
                let client = Client::new();
                client.get("http://example.com")
            };
            let (client, inner) = builder.build_split();
            let request = inner.unwrap();
            let builder = RequestBuilder::from_parts(client, request);
            builder.build().unwrap();
        }

        /*
        use {body, Method};
        use super::Client;
        use header::{Host, Headers, ContentType};
        use std::collections::HashMap;
        use serde_urlencoded;
        use serde_json;

        #[test]
        fn basic_get_request() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let r = client.get(some_url).unwrap().build();

            assert_eq!(r.method, Method::Get);
            assert_eq!(r.url.as_str(), some_url);
        }

        #[test]
        fn basic_head_request() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let r = client.head(some_url).unwrap().build();

            assert_eq!(r.method, Method::Head);
            assert_eq!(r.url.as_str(), some_url);
        }

        #[test]
        fn basic_post_request() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let r = client.post(some_url).unwrap().build();

            assert_eq!(r.method, Method::Post);
            assert_eq!(r.url.as_str(), some_url);
        }

        #[test]
        fn basic_put_request() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let r = client.put(some_url).unwrap().build();

            assert_eq!(r.method, Method::Put);
            assert_eq!(r.url.as_str(), some_url);
        }

        #[test]
        fn basic_patch_request() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let r = client.patch(some_url).unwrap().build();

            assert_eq!(r.method, Method::Patch);
            assert_eq!(r.url.as_str(), some_url);
        }

        #[test]
        fn basic_delete_request() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let r = client.delete(some_url).unwrap().build();

            assert_eq!(r.method, Method::Delete);
            assert_eq!(r.url.as_str(), some_url);
        }

        #[test]
        fn add_header() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let mut r = client.post(some_url).unwrap();

            let header = Host {
                hostname: "google.com".to_string(),
                port: None,
            };

            // Add a copy of the header to the request builder
            let r = r.header(header.clone()).build();

            // then check it was actually added
            assert_eq!(r.headers.get::<Host>(), Some(&header));
        }

        #[test]
        fn add_headers() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let mut r = client.post(some_url).unwrap();

            let header = Host {
                hostname: "google.com".to_string(),
                port: None,
            };

            let mut headers = Headers::new();
            headers.set(header);

            // Add a copy of the headers to the request builder
            let r = r.headers(headers.clone()).build();

            // then make sure they were added correctly
            assert_eq!(r.headers, headers);
        }

        #[test]
        fn add_headers_multi() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let mut r = client.post(some_url).unwrap();

            let header = Host {
                hostname: "google.com".to_string(),
                port: None,
            };

            let mut headers = Headers::new();
            headers.set(header);

            // Add a copy of the headers to the request builder
            let r = r.headers(headers.clone()).build();

            // then make sure they were added correctly
            assert_eq!(r.headers, headers);
        }

        #[test]
        fn add_body() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let mut r = client.post(some_url).unwrap();

            let body = "Some interesting content";

            let r = r.body(body).build();

            let buf = body::read_to_string(r.body.unwrap()).unwrap();

            assert_eq!(buf, body);
        }

        #[test]
        fn add_form() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let mut r = client.post(some_url).unwrap();

            let mut form_data = HashMap::new();
            form_data.insert("foo", "bar");

            let r = r.form(&form_data).unwrap().build();

            // Make sure the content type was set
            assert_eq!(r.headers.get::<ContentType>(),
                       Some(&ContentType::form_url_encoded()));

            let buf = body::read_to_string(r.body.unwrap()).unwrap();

            let body_should_be = serde_urlencoded::to_string(&form_data).unwrap();
            assert_eq!(buf, body_should_be);
        }

        #[test]
        fn add_json() {
            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let mut r = client.post(some_url).unwrap();

            let mut json_data = HashMap::new();
            json_data.insert("foo", "bar");

            let r = r.json(&json_data).unwrap().build();

            // Make sure the content type was set
            assert_eq!(r.headers.get::<ContentType>(), Some(&ContentType::json()));

            let buf = body::read_to_string(r.body.unwrap()).unwrap();

            let body_should_be = serde_json::to_string(&json_data).unwrap();
            assert_eq!(buf, body_should_be);
        }

        #[test]
        fn add_json_fail() {
            use serde::{Serialize, Serializer};
            use serde::ser::Error;
            struct MyStruct;
            impl Serialize for MyStruct {
                fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>
                    where S: Serializer
                    {
                        Err(S::Error::custom("nope"))
                    }
            }

            let client = Client::new().unwrap();
            let some_url = "https://google.com/";
            let mut r = client.post(some_url).unwrap();
            let json_data = MyStruct{};
            assert!(r.json(&json_data).unwrap_err().is_serialization());
        }
        */
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle setting and validating sensitive headers in HTTP requests, and what APIs are used for this?
  codeQuestion3: What steps are taken to convert an HTTP request into a Hyper Request object, and what APIs are involved in this process?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user initiate a new game after losing, and what system calls are involved in handling the input for this action?
  codeQuestion3: What steps are taken to handle terminal input and output settings for the game?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/upgrade.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::pin::Pin;
    use std::task::{self, Poll};
    use std::{fmt, io};

    use futures_util::TryFutureExt;
    use hyper_util::rt::TokioIo;
    use tokio::io::{AsyncRead, AsyncWrite, ReadBuf};

    /// An upgraded HTTP connection.
    pub struct Upgraded {
        inner: TokioIo<hyper::upgrade::Upgraded>,
    }

    impl AsyncRead for Upgraded {
        fn poll_read(
            mut self: Pin<&mut Self>,
            cx: &mut task::Context<'_>,
            buf: &mut ReadBuf<'_>,
        ) -> Poll<io::Result<()>> {
            Pin::new(&mut self.inner).poll_read(cx, buf)
        }
    }

    impl AsyncWrite for Upgraded {
        fn poll_write(
            mut self: Pin<&mut Self>,
            cx: &mut task::Context<'_>,
            buf: &[u8],
        ) -> Poll<io::Result<usize>> {
            Pin::new(&mut self.inner).poll_write(cx, buf)
        }

        fn poll_write_vectored(
            mut self: Pin<&mut Self>,
            cx: &mut task::Context<'_>,
            bufs: &[io::IoSlice<'_>],
        ) -> Poll<io::Result<usize>> {
            Pin::new(&mut self.inner).poll_write_vectored(cx, bufs)
        }

        fn poll_flush(mut self: Pin<&mut Self>, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
            Pin::new(&mut self.inner).poll_flush(cx)
        }

        fn poll_shutdown(mut self: Pin<&mut Self>, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
            Pin::new(&mut self.inner).poll_shutdown(cx)
        }

        fn is_write_vectored(&self) -> bool {
            self.inner.is_write_vectored()
        }
    }

    impl fmt::Debug for Upgraded {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Upgraded").finish()
        }
    }

    impl From<hyper::upgrade::Upgraded> for Upgraded {
        fn from(inner: hyper::upgrade::Upgraded) -> Self {
            Upgraded {
                inner: TokioIo::new(inner),
            }
        }
    }

    impl super::response::Response {
        /// Consumes the response and returns a future for a possible HTTP upgrade.
        pub async fn upgrade(self) -> crate::Result<Upgraded> {
            hyper::upgrade::on(self.res)
                .map_ok(Upgraded::from)
                .map_err(crate::error::upgrade)
                .await
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `upgrade` method in the `Response` struct handle HTTP upgrades, and what system calls or APIs are involved?
  codeQuestion3: What steps are taken to handle the upgraded connection and its underlying I/O operations?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(any(feature = "native-tls", feature = "__rustls",))]
    use std::any::Any;
    use std::future::Future;
    use std::net::IpAddr;
    use std::pin::Pin;
    use std::sync::Arc;
    use std::task::{Context, Poll};
    use std::time::Duration;
    use std::{collections::HashMap, convert::TryInto, net::SocketAddr};
    use std::{fmt, str};

    use super::decoder::Accepts;
    use super::request::{Request, RequestBuilder};
    use super::response::Response;
    use super::Body;
    #[cfg(feature = "http3")]
    use crate::async_impl::h3_client::connect::{H3ClientConfig, H3Connector};
    #[cfg(feature = "http3")]
    use crate::async_impl::h3_client::{H3Client, H3ResponseFuture};
    use crate::config::{RequestConfig, RequestTimeout};
    use crate::connect::{
        sealed::{Conn, Unnameable},
        BoxedConnectorLayer, BoxedConnectorService, Connector, ConnectorBuilder,
    };
    #[cfg(feature = "cookies")]
    use crate::cookie;
    #[cfg(feature = "hickory-dns")]
    use crate::dns::hickory::HickoryDnsResolver;
    use crate::dns::{gai::GaiResolver, DnsResolverWithOverrides, DynResolver, Resolve};
    use crate::error::{self, BoxError};
    use crate::into_url::try_uri;
    use crate::redirect::{self, remove_sensitive_headers};
    #[cfg(feature = "__rustls")]
    use crate::tls::CertificateRevocationList;
    #[cfg(feature = "__tls")]
    use crate::tls::{self, TlsBackend};
    #[cfg(feature = "__tls")]
    use crate::Certificate;
    #[cfg(any(feature = "native-tls", feature = "__rustls"))]
    use crate::Identity;
    use crate::{IntoUrl, Method, Proxy, StatusCode, Url};
    use bytes::Bytes;
    use http::header::{
        Entry, HeaderMap, HeaderValue, ACCEPT, ACCEPT_ENCODING, CONTENT_ENCODING, CONTENT_LENGTH,
        CONTENT_TYPE, LOCATION, PROXY_AUTHORIZATION, RANGE, REFERER, TRANSFER_ENCODING, USER_AGENT,
    };
    use http::uri::Scheme;
    use http::Uri;
    use hyper_util::client::legacy::connect::HttpConnector;
    use log::debug;
    #[cfg(feature = "default-tls")]
    use native_tls_crate::TlsConnector;
    use pin_project_lite::pin_project;
    #[cfg(feature = "http3")]
    use quinn::TransportConfig;
    #[cfg(feature = "http3")]
    use quinn::VarInt;
    use tokio::time::Sleep;
    use tower::util::BoxCloneSyncServiceLayer;
    use tower::{Layer, Service};

    type HyperResponseFuture = hyper_util::client::legacy::ResponseFuture;

    /// An asynchronous `Client` to make Requests with.
    ///
    /// The Client has various configuration values to tweak, but the defaults
    /// are set to what is usually the most commonly desired value. To configure a
    /// `Client`, use `Client::builder()`.
    ///
    /// The `Client` holds a connection pool internally, so it is advised that
    /// you create one and **reuse** it.
    ///
    /// You do **not** have to wrap the `Client` in an [`Rc`] or [`Arc`] to **reuse** it,
    /// because it already uses an [`Arc`] internally.
    ///
    /// [`Rc`]: std::rc::Rc
    #[derive(Clone)]
    pub struct Client {
        inner: Arc<ClientRef>,
    }

    /// A `ClientBuilder` can be used to create a `Client` with custom configuration.
    #[must_use]
    pub struct ClientBuilder {
        config: Config,
    }

    enum HttpVersionPref {
        Http1,
        #[cfg(feature = "http2")]
        Http2,
        #[cfg(feature = "http3")]
        Http3,
        All,
    }

    struct Config {
        // NOTE: When adding a new field, update `fmt::Debug for ClientBuilder`
        accepts: Accepts,
        headers: HeaderMap,
        #[cfg(feature = "__tls")]
        hostname_verification: bool,
        #[cfg(feature = "__tls")]
        certs_verification: bool,
        #[cfg(feature = "__tls")]
        tls_sni: bool,
        connect_timeout: Option<Duration>,
        connection_verbose: bool,
        pool_idle_timeout: Option<Duration>,
        pool_max_idle_per_host: usize,
        tcp_keepalive: Option<Duration>,
        #[cfg(any(feature = "native-tls", feature = "__rustls"))]
        identity: Option<Identity>,
        proxies: Vec<Proxy>,
        auto_sys_proxy: bool,
        redirect_policy: redirect::Policy,
        referer: bool,
        read_timeout: Option<Duration>,
        timeout: Option<Duration>,
        #[cfg(feature = "__tls")]
        root_certs: Vec<Certificate>,
        #[cfg(feature = "__tls")]
        tls_built_in_root_certs: bool,
        #[cfg(feature = "rustls-tls-webpki-roots-no-provider")]
        tls_built_in_certs_webpki: bool,
        #[cfg(feature = "rustls-tls-native-roots-no-provider")]
        tls_built_in_certs_native: bool,
        #[cfg(feature = "__rustls")]
        crls: Vec<CertificateRevocationList>,
        #[cfg(feature = "__tls")]
        min_tls_version: Option<tls::Version>,
        #[cfg(feature = "__tls")]
        max_tls_version: Option<tls::Version>,
        #[cfg(feature = "__tls")]
        tls_info: bool,
        #[cfg(feature = "__tls")]
        tls: TlsBackend,
        connector_layers: Vec<BoxedConnectorLayer>,
        http_version_pref: HttpVersionPref,
        http09_responses: bool,
        http1_title_case_headers: bool,
        http1_allow_obsolete_multiline_headers_in_responses: bool,
        http1_ignore_invalid_headers_in_responses: bool,
        http1_allow_spaces_after_header_name_in_responses: bool,
        #[cfg(feature = "http2")]
        http2_initial_stream_window_size: Option<u32>,
        #[cfg(feature = "http2")]
        http2_initial_connection_window_size: Option<u32>,
        #[cfg(feature = "http2")]
        http2_adaptive_window: bool,
        #[cfg(feature = "http2")]
        http2_max_frame_size: Option<u32>,
        #[cfg(feature = "http2")]
        http2_max_header_list_size: Option<u32>,
        #[cfg(feature = "http2")]
        http2_keep_alive_interval: Option<Duration>,
        #[cfg(feature = "http2")]
        http2_keep_alive_timeout: Option<Duration>,
        #[cfg(feature = "http2")]
        http2_keep_alive_while_idle: bool,
        local_address: Option<IpAddr>,
        #[cfg(any(
            target_os = "android",
            target_os = "fuchsia",
            target_os = "illumos",
            target_os = "ios",
            target_os = "linux",
            target_os = "macos",
            target_os = "solaris",
            target_os = "tvos",
            target_os = "visionos",
            target_os = "watchos",
        ))]
        interface: Option<String>,
        nodelay: bool,
        #[cfg(feature = "cookies")]
        cookie_store: Option<Arc<dyn cookie::CookieStore>>,
        hickory_dns: bool,
        error: Option<crate::Error>,
        https_only: bool,
        #[cfg(feature = "http3")]
        tls_enable_early_data: bool,
        #[cfg(feature = "http3")]
        quic_max_idle_timeout: Option<Duration>,
        #[cfg(feature = "http3")]
        quic_stream_receive_window: Option<VarInt>,
        #[cfg(feature = "http3")]
        quic_receive_window: Option<VarInt>,
        #[cfg(feature = "http3")]
        quic_send_window: Option<u64>,
        #[cfg(feature = "http3")]
        quic_congestion_bbr: bool,
        #[cfg(feature = "http3")]
        h3_max_field_section_size: Option<u64>,
        #[cfg(feature = "http3")]
        h3_send_grease: Option<bool>,
        dns_overrides: HashMap<String, Vec<SocketAddr>>,
        dns_resolver: Option<Arc<dyn Resolve>>,
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the client handle TLS connection setup, including certificate verification and handling of different TLS versions?
  codeQuestion3: What steps are taken to configure the HTTP version preferences (HTTP/1, HTTP/2, HTTP/3) and how are they applied to outgoing requests?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Default for ClientBuilder {
        fn default() -> Self {
            Self::new()
        }
    }

    impl ClientBuilder {
        /// Constructs a new `ClientBuilder`.
        ///
        /// This is the same as `Client::builder()`.
        pub fn new() -> Self {
            let mut headers: HeaderMap<HeaderValue> = HeaderMap::with_capacity(2);
            headers.insert(ACCEPT, HeaderValue::from_static("*/*"));

            ClientBuilder {
                config: Config {
                    error: None,
                    accepts: Accepts::default(),
                    headers,
                    #[cfg(feature = "__tls")]
                    hostname_verification: true,
                    #[cfg(feature = "__tls")]
                    certs_verification: true,
                    #[cfg(feature = "__tls")]
                    tls_sni: true,
                    connect_timeout: None,
                    connection_verbose: false,
                    pool_idle_timeout: Some(Duration::from_secs(90)),
                    pool_max_idle_per_host: usize::MAX,
                    // TODO: Re-enable default duration once hyper's HttpConnector is fixed
                    // to no longer error when an option fails.
                    tcp_keepalive: None, //Some(Duration::from_secs(60)),
                    proxies: Vec::new(),
                    auto_sys_proxy: true,
                    redirect_policy: redirect::Policy::default(),
                    referer: true,
                    read_timeout: None,
                    timeout: None,
                    #[cfg(feature = "__tls")]
                    root_certs: Vec::new(),
                    #[cfg(feature = "__tls")]
                    tls_built_in_root_certs: true,
                    #[cfg(feature = "rustls-tls-webpki-roots-no-provider")]
                    tls_built_in_certs_webpki: true,
                    #[cfg(feature = "rustls-tls-native-roots-no-provider")]
                    tls_built_in_certs_native: true,
                    #[cfg(any(feature = "native-tls", feature = "__rustls"))]
                    identity: None,
                    #[cfg(feature = "__rustls")]
                    crls: vec![],
                    #[cfg(feature = "__tls")]
                    min_tls_version: None,
                    #[cfg(feature = "__tls")]
                    max_tls_version: None,
                    #[cfg(feature = "__tls")]
                    tls_info: false,
                    #[cfg(feature = "__tls")]
                    tls: TlsBackend::default(),
                    connector_layers: Vec::new(),
                    http_version_pref: HttpVersionPref::All,
                    http09_responses: false,
                    http1_title_case_headers: false,
                    http1_allow_obsolete_multiline_headers_in_responses: false,
                    http1_ignore_invalid_headers_in_responses: false,
                    http1_allow_spaces_after_header_name_in_responses: false,
                    #[cfg(feature = "http2")]
                    http2_initial_stream_window_size: None,
                    #[cfg(feature = "http2")]
                    http2_initial_connection_window_size: None,
                    #[cfg(feature = "http2")]
                    http2_adaptive_window: false,
                    #[cfg(feature = "http2")]
                    http2_max_frame_size: None,
                    #[cfg(feature = "http2")]
                    http2_max_header_list_size: None,
                    #[cfg(feature = "http2")]
                    http2_keep_alive_interval: None,
                    #[cfg(feature = "http2")]
                    http2_keep_alive_timeout: None,
                    #[cfg(feature = "http2")]
                    http2_keep_alive_while_idle: false,
                    local_address: None,
                    #[cfg(any(
                        target_os = "android",
                        target_os = "fuchsia",
                        target_os = "illumos",
                        target_os = "ios",
                        target_os = "linux",
                        target_os = "macos",
                        target_os = "solaris",
                        target_os = "tvos",
                        target_os = "visionos",
                        target_os = "watchos",
                    ))]
                    interface: None,
                    nodelay: true,
                    hickory_dns: cfg!(feature = "hickory-dns"),
                    #[cfg(feature = "cookies")]
                    cookie_store: None,
                    https_only: false,
                    dns_overrides: HashMap::new(),
                    #[cfg(feature = "http3")]
                    tls_enable_early_data: false,
                    #[cfg(feature = "http3")]
                    quic_max_idle_timeout: None,
                    #[cfg(feature = "http3")]
                    quic_stream_receive_window: None,
                    #[cfg(feature = "http3")]
                    quic_receive_window: None,
                    #[cfg(feature = "http3")]
                    quic_send_window: None,
                    #[cfg(feature = "http3")]
                    quic_congestion_bbr: false,
                    #[cfg(feature = "http3")]
                    h3_max_field_section_size: None,
                    #[cfg(feature = "http3")]
                    h3_send_grease: None,
                    dns_resolver: None,
                },
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user customize the timeout settings for HTTP requests, and what API is used to achieve this?
  codeQuestion3: What steps are taken to initialize the default configuration for a client builder, and how is the `HeaderMap` utilized in this process?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl ClientBuilder
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user customize the HTTP client settings before making a request, and what API methods are used for this?
  codeQuestion3: What steps are taken to handle the HTTP client configuration and how is it applied when making a request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        /// Returns a `Client` that uses this `ClientBuilder` configuration.
        ///
        /// # Errors
        ///
        /// This method fails if a TLS backend cannot be initialized, or the resolver
        /// cannot load the system configuration.
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `ClientBuilder` handle TLS initialization errors, and what is the correct way to recover from such an error?
  codeQuestion3: What steps are taken to configure the resolver for the `Client` and how does it affect request handling?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub fn build(self) -> crate::Result<Client>
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `build` method handle error cases, and what is the role of the `crate::Result<Client>` return type?
  codeQuestion3: What is the expected behavior of the `build` method when it is called with invalid configuration parameters?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
            let config = self.config;

            if let Some(err) = config.error {
                return Err(err);
            }

            let mut proxies = config.proxies;
            if config.auto_sys_proxy {
                proxies.push(Proxy::system());
            }
            let proxies = Arc::new(proxies);

            #[allow(unused)]
            #[cfg(feature = "http3")]
            let mut h3_connector = None;
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle automatic system proxy configuration for HTTP requests?
  codeQuestion3: What is the role of the `Arc::new(proxies)` line in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    let mut connector_builder =
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle asynchronous HTTP requests using the reqwest library?
  codeQuestion3: What steps are taken to configure the connector for the HTTP client?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
                #[cfg(feature = "__tls")]
                fn user_agent(headers: &HeaderMap) -> Option<HeaderValue> {
                    headers.get(USER_AGENT).cloned()
                }

                let mut resolver: Arc<dyn Resolve> = match config.hickory_dns {
                    false => Arc::new(GaiResolver::new()),
                    #[cfg(feature = "hickory-dns")]
                    true => Arc::new(HickoryDnsResolver::default()),
                    #[cfg(not(feature = "hickory-dns"))]
                    true => unreachable!("hickory-dns shouldn't be enabled unless the feature is"),
                };
                if let Some(dns_resolver) = config.dns_resolver {
                    resolver = dns_resolver;
                }
                if !config.dns_overrides.is_empty() {
                    resolver = Arc::new(DnsResolverWithOverrides::new(
                        resolver,
                        config.dns_overrides,
                    ));
                }
                let mut http = HttpConnector::new_with_resolver(DynResolver::new(resolver.clone()));
                http.set_connect_timeout(config.connect_timeout);

                #[cfg(all(feature = "http3", feature = "__rustls"))]
                let build_h3_connector =
                    |resolver,
                     tls,
                     quic_max_idle_timeout: Option<Duration>,
                     quic_stream_receive_window,
                     quic_receive_window,
                     quic_send_window,
                     quic_congestion_bbr,
                     h3_max_field_section_size,
                     h3_send_grease,
                     local_address,
                     http_version_pref: &HttpVersionPref| {
                        let mut transport_config = TransportConfig::default();

                        if let Some(max_idle_timeout) = quic_max_idle_timeout {
                            transport_config.max_idle_timeout(Some(
                                max_idle_timeout.try_into().map_err(error::builder)?,
                            ));
                        }

                        if let Some(stream_receive_window) = quic_stream_receive_window {
                            transport_config.stream_receive_window(stream_receive_window);
                        }

                        if let Some(receive_window) = quic_receive_window {
                            transport_config.receive_window(receive_window);
                        }

                        if let Some(send_window) = quic_send_window {
                            transport_config.send_window(send_window);
                        }

                        if quic_congestion_bbr {
                            let factory = Arc::new(quinn::congestion::BbrConfig::default());
                            transport_config.congestion_controller_factory(factory);
                        }

                        let mut h3_client_config = H3ClientConfig::default();

                        if let Some(max_field_section_size) = h3_max_field_section_size {
                            h3_client_config.max_field_section_size = Some(max_field_section_size);
                        }

                        if let Some(send_grease) = h3_send_grease {
                            h3_client_config.send_grease = Some(send_grease);
                        }

                        let res = H3Connector::new(
                            DynResolver::new(resolver),
                            tls,
                            local_address,
                            transport_config,
                            h3_client_config,
                        );

                        match res {
                            Ok(connector) => Ok(Some(connector)),
                            Err(err) => {
                                if let HttpVersionPref::Http3 = http_version_pref {
                                    Err(error::builder(err))
                                } else {
                                    Ok(None)
                                }
                            }
                        }
                    };

                #[cfg(feature = "__tls")]
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle DNS resolution configuration for HTTP requests?
  codeQuestion3: What steps are taken to configure the HTTP connector with TLS and QUIC settings?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    match config.tls
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle TLS configuration for HTTP requests?
  codeQuestion3: What is the role of the `config.tls` field in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
                    #[cfg(feature = "default-tls")]
                    TlsBackend::Default => {
                        let mut tls = TlsConnector::builder();

                        #[cfg(all(feature = "native-tls-alpn", not(feature = "http3")))]
                        {
                            match config.http_version_pref {
                                HttpVersionPref::Http1 => {
                                    tls.request_alpns(&["http/1.1"]);
                                }
                                #[cfg(feature = "http2")]
                                HttpVersionPref::Http2 => {
                                    tls.request_alpns(&["h2"]);
                                }
                                HttpVersionPref::All => {
                                    tls.request_alpns(&["h2", "http/1.1"]);
                                }
                            }
                        }

                        tls.danger_accept_invalid_hostnames(!config.hostname_verification);

                        tls.danger_accept_invalid_certs(!config.certs_verification);

                        tls.use_sni(config.tls_sni);

                        tls.disable_built_in_roots(!config.tls_built_in_root_certs);

                        for cert in config.root_certs {
                            cert.add_to_native_tls(&mut tls);
                        }

                        #[cfg(feature = "native-tls")]
                        {
                            if let Some(id) = config.identity {
                                id.add_to_native_tls(&mut tls)?;
                            }
                        }
                        #[cfg(all(feature = "__rustls", not(feature = "native-tls")))]
                        {
                            // Default backend + rustls Identity doesn't work.
                            if let Some(_id) = config.identity {
                                return Err(crate::error::builder("incompatible TLS identity type"));
                            }
                        }

                        if let Some(min_tls_version) = config.min_tls_version {
                            let protocol = min_tls_version.to_native_tls().ok_or_else(|| {
                                // TLS v1.3. This would be entirely reasonable,
                                // native-tls just doesn't support it.
                                // https://github.com/sfackler/rust-native-tls/issues/140
                                crate::error::builder("invalid minimum TLS version for backend")
                            })?;
                            tls.min_protocol_version(Some(protocol));
                        }

                        if let Some(max_tls_version) = config.max_tls_version {
                            let protocol = max_tls_version.to_native_tls().ok_or_else(|| {
                                // TLS v1.3.
                                // We could arguably do max_protocol_version(None), given
                                // that 1.4 does not exist yet, but that'd get messy in the
                                // future.
                                crate::error::builder("invalid maximum TLS version for backend")
                            })?;
                            tls.max_protocol_version(Some(protocol));
                        }

                        ConnectorBuilder::new_default_tls(
                            http,
                            tls,
                            proxies.clone(),
                            user_agent(&config.headers),
                            config.local_address,
                            #[cfg(any(
                                target_os = "android",
                                target_os = "fuchsia",
                                target_os = "illumos",
                                target_os = "ios",
                                target_os = "linux",
                                target_os = "macos",
                                target_os = "solaris",
                                target_os = "tvos",
                                target_os = "visionos",
                                target_os = "watchos",
                            ))]
                            config.interface.as_deref(),
                            config.nodelay,
                            config.tls_info,
                        )?
                    }
                    #[cfg(feature = "native-tls")]
                    TlsBackend::BuiltNativeTls(conn) => ConnectorBuilder::from_built_default_tls(
                        http,
                        conn,
                        proxies.clone(),
                        user_agent(&config.headers),
                        config.local_address,
                        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
                        config.interface.as_deref(),
                        config.nodelay,
                        config.tls_info,
                    ),
                    #[cfg(feature = "__rustls")]
                    TlsBackend::BuiltRustls(conn) => {
                        #[cfg(feature = "http3")]
                        {
                            h3_connector = build_h3_connector(
                                resolver,
                                conn.clone(),
                                config.quic_max_idle_timeout,
                                config.quic_stream_receive_window,
                                config.quic_receive_window,
                                config.quic_send_window,
                                config.quic_congestion_bbr,
                                config.h3_max_field_section_size,
                                config.h3_send_grease,
                                config.local_address,
                                &config.http_version_pref,
                            )?;
                        }

                        ConnectorBuilder::new_rustls_tls(
                            http,
                            conn,
                            proxies.clone(),
                            user_agent(&config.headers),
                            config.local_address,
                            #[cfg(any(
                                target_os = "android",
                                target_os = "fuchsia",
                                target_os = "illumos",
                                target_os = "ios",
                                target_os = "linux",
                                target_os = "macos",
                                target_os = "solaris",
                                target_os = "tvos",
                                target_os = "visionos",
                                target_os = "watchos",
                            ))]
                            config.interface.as_deref(),
                            config.nodelay,
                            config.tls_info,
                        )
                    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle TLS configuration based on different backend features, and what are the key steps involved in setting up the TLS connector?
  codeQuestion3: What system calls or API functions are used to configure the terminal input and output for handling user interactions in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__rustls")]
                    TlsBackend::Rustls => {
                        use crate::tls::{IgnoreHostname, NoVerifier};

                        // Set root certificates.
                        let mut root_cert_store = rustls::RootCertStore::empty();
                        for cert in config.root_certs {
                            cert.add_to_rustls(&mut root_cert_store)?;
                        }

                        #[cfg(feature = "rustls-tls-webpki-roots-no-provider")]
                        if config.tls_built_in_certs_webpki {
                            root_cert_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());
                        }

                        #[cfg(feature = "rustls-tls-native-roots-no-provider")]
                        if config.tls_built_in_certs_native {
                            let mut valid_count = 0;
                            let mut invalid_count = 0;

                            let load_results = rustls_native_certs::load_native_certs();
                            for cert in load_results.certs {
                                // Continue on parsing errors, as native stores often include ancient or syntactically
                                // invalid certificates, like root certificates without any X509 extensions.
                                // Inspiration: https://github.com/rustls/rustls/blob/633bf4ba9d9521a95f68766d04c22e2b01e68318/rustls/src/anchors.rs#L105-L112
                                match root_cert_store.add(cert.into()) {
                                    Ok(_) => valid_count += 1,
                                    Err(err) => {
                                        invalid_count += 1;
                                        log::debug!("rustls failed to parse DER certificate: {err:?}");
                                    }
                                }
                            }
                            if valid_count == 0 && invalid_count > 0 {
                                let err = if load_results.errors.is_empty() {
                                    crate::error::builder(
                                        "zero valid certificates found in native root store",
                                    )
                                } else {
                                    use std::fmt::Write as _;
                                    let mut acc = String::new();
                                    for err in load_results.errors {
                                        let _ = writeln!(&mut acc, "{err}");
                                    }

                                    crate::error::builder(acc)
                                };

                                return Err(err);
                            }
                        }

                        // Set TLS versions.
                        let mut versions = rustls::ALL_VERSIONS.to_vec();

                        if let Some(min_tls_version) = config.min_tls_version {
                            versions.retain(|&supported_version| {
                                match tls::Version::from_rustls(supported_version.version) {
                                    Some(version) => version >= min_tls_version,
                                    // Assume it's so new we don't know about it, allow it
                                    // (as of writing this is unreachable)
                                    None => true,
                                }
                            });
                        }

                        if let Some(max_tls_version) = config.max_tls_version {
                            versions.retain(|&supported_version| {
                                match tls::Version::from_rustls(supported_version.version) {
                                    Some(version) => version <= max_tls_version,
                                    None => false,
                                }
                            });
                        }

                        if versions.is_empty() {
                            return Err(crate::error::builder("empty supported tls versions"));
                        }

                        // Allow user to have installed a runtime default.
                        // If not, we use ring.
                        let provider = rustls::crypto::CryptoProvider::get_default()
                            .map(|arc| arc.clone())
                            .unwrap_or_else(|| {
                                #[cfg(not(feature = "__rustls-ring"))]
                                panic!("No provider set");

                                #[cfg(feature = "__rustls-ring")]
                                Arc::new(rustls::crypto::ring::default_provider())
                            });

                        // Build TLS config
                        let signature_algorithms = provider.signature_verification_algorithms;
                        let config_builder =
                            rustls::ClientConfig::builder_with_provider(provider.clone())
                                .with_protocol_versions(&versions)
                                .map_err(|_| crate::error::builder("invalid TLS versions"))?;

                        let config_builder = if !config.certs_verification {
                            config_builder
                                .dangerous()
                                .with_custom_certificate_verifier(Arc::new(NoVerifier))
                        } else if !config.hostname_verification {
                            config_builder
                                .dangerous()
                                .with_custom_certificate_verifier(Arc::new(IgnoreHostname::new(
                                    root_cert_store,
                                    signature_algorithms,
                                )))
                        } else {
                            if config.crls.is_empty() {
                                config_builder.with_root_certificates(root_cert_store)
                            } else {
                                let crls = config
                                    .crls
                                    .iter()
                                    .map(|e| e.as_rustls_crl())
                                    .collect::<Vec<_>>();
                                let verifier =
                                    rustls::client::WebPkiServerVerifier::builder_with_provider(
                                        Arc::new(root_cert_store),
                                        provider,
                                    )
                                    .with_crls(crls)
                                    .build()
                                    .map_err(|_| {
                                        crate::error::builder("invalid TLS verification settings")
                                    })?;
                                config_builder.with_webpki_verifier(verifier)
                            }
                        };

                        // Finalize TLS config
                        let mut tls = if let Some(id) = config.identity {
                            id.add_to_rustls(config_builder)?
                        } else {
                            config_builder.with_no_client_auth()
                        };

                        tls.enable_sni = config.tls_sni;

                        // ALPN protocol
                        match config.http_version_pref {
                            HttpVersionPref::Http1 => {
                                tls.alpn_protocols = vec!["http/1.1".into()];
                            }
                            #[cfg(feature = "http2")]
                            HttpVersionPref::Http2 => {
                                tls.alpn_protocols = vec!["h2".into()];
                            }
                            #[cfg(feature = "http3")]
                            HttpVersionPref::Http3 => {
                                tls.alpn_protocols = vec!["h3".into()];
                            }
                            HttpVersionPref::All => {
                                tls.alpn_protocols = vec![
                                    #[cfg(feature = "http2")]
                                    "h2".into(),
                                    "http/1.1".into(),
                                ];
                            }
                        }

                        #[cfg(feature = "http3")]
                        {
                            tls.enable_early_data = config.tls_enable_early_data;

                            h3_connector = build_h3_connector(
                                resolver,
                                tls.clone(),
                                config.quic_max_idle_timeout,
                                config.quic_stream_receive_window,
                                config.quic_receive_window,
                                config.quic_send_window,
                                config.quic_congestion_bbr,
                                config.h3_max_field_section_size,
                                config.h3_send_grease,
                                config.local_address,
                                &config.http_version_pref,
                            )?;
                        }

                        ConnectorBuilder::new_rustls_tls(
                            http,
                            tls,
                            proxies.clone(),
                            user_agent(&config.headers),
                            config.local_address,
                            #[cfg(any(
                                target_os = "android",
                                target_os = "fuchsia",
                                target_os = "illumos",
                                target_os = "ios",
                                target_os = "linux",
                                target_os = "macos",
                                target_os = "solaris",
                                target_os = "tvos",
                                target_os = "visionos",
                                target_os = "watchos",
                            ))]
                            config.interface.as_deref(),
                            config.nodelay,
                            config.tls_info,
                        )
                    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle user input for initiating a new game after losing, and what system calls are involved in handling this action?
  codeQuestion3: What steps are taken to handle terminal input and output settings for the game?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(any(feature = "native-tls", feature = "__rustls",))]
                    TlsBackend::UnknownPreconfigured => {
                        return Err(crate::error::builder(
                            "Unknown TLS backend passed to `use_preconfigured_tls`",
                        ));
                    }
                }

                #[cfg(not(feature = "__tls"))]
                ConnectorBuilder::new(
                    http,
                    proxies.clone(),
                    config.local_address,
                    #[cfg(any(
                        target_os = "android",
                        target_os = "fuchsia",
                        target_os = "illumos",
                        target_os = "ios",
                        target_os = "linux",
                        target_os = "macos",
                        target_os = "solaris",
                        target_os = "tvos",
                        target_os = "visionos",
                        target_os = "watchos",
                    ))]
                    config.interface.as_deref(),
                    config.nodelay,
                )
            };

            connector_builder.set_timeout(config.connect_timeout);
            connector_builder.set_verbose(config.connection_verbose);
            connector_builder.set_keepalive(config.tcp_keepalive);

            let mut builder =
                hyper_util::client::legacy::Client::builder(hyper_util::rt::TokioExecutor::new());
            #[cfg(feature = "http2")]
            {
                if matches!(config.http_version_pref, HttpVersionPref::Http2) {
                    builder.http2_only(true);
                }

                if let Some(http2_initial_stream_window_size) = config.http2_initial_stream_window_size
                {
                    builder.http2_initial_stream_window_size(http2_initial_stream_window_size);
                }
                if let Some(http2_initial_connection_window_size) =
                    config.http2_initial_connection_window_size
                {
                    builder.http2_initial_connection_window_size(http2_initial_connection_window_size);
                }
                if config.http2_adaptive_window {
                    builder.http2_adaptive_window(true);
                }
                if let Some(http2_max_frame_size) = config.http2_max_frame_size {
                    builder.http2_max_frame_size(http2_max_frame_size);
                }
                if let Some(http2_max_header_list_size) = config.http2_max_header_list_size {
                    builder.http2_max_header_list_size(http2_max_header_list_size);
                }
                if let Some(http2_keep_alive_interval) = config.http2_keep_alive_interval {
                    builder.http2_keep_alive_interval(http2_keep_alive_interval);
                }
                if let Some(http2_keep_alive_timeout) = config.http2_keep_alive_timeout {
                    builder.http2_keep_alive_timeout(http2_keep_alive_timeout);
                }
                if config.http2_keep_alive_while_idle {
                    builder.http2_keep_alive_while_idle(true);
                }
            }

            builder.timer(hyper_util::rt::TokioTimer::new());
            builder.pool_timer(hyper_util::rt::TokioTimer::new());
            builder.pool_idle_timeout(config.pool_idle_timeout);
            builder.pool_max_idle_per_host(config.pool_max_idle_per_host);

            if config.http09_responses {
                builder.http09_responses(true);
            }

            if config.http1_title_case_headers {
                builder.http1_title_case_headers(true);
            }

            if config.http1_allow_obsolete_multiline_headers_in_responses {
                builder.http1_allow_obsolete_multiline_headers_in_responses(true);
            }

            if config.http1_ignore_invalid_headers_in_responses {
                builder.http1_ignore_invalid_headers_in_responses(true);
            }

            if config.http1_allow_spaces_after_header_name_in_responses {
                builder.http1_allow_spaces_after_header_name_in_responses(true);
            }

            let proxies_maybe_http_auth = proxies.iter().any(|p| p.maybe_has_http_auth());

            Ok(Client {
                inner: Arc::new(ClientRef {
                    accepts: config.accepts,
                    #[cfg(feature = "cookies")]
                    cookie_store: config.cookie_store,
                    // Use match instead of map since config is partially moved,
                    // and it cannot be used in closure
                    #[cfg(feature = "http3")]
                    h3_client: match h3_connector {
                        Some(h3_connector) => {
                            Some(H3Client::new(h3_connector, config.pool_idle_timeout))
                        }
                        None => None,
                    },
                    hyper: builder.build(connector_builder.build(config.connector_layers)),
                    headers: config.headers,
                    redirect_policy: config.redirect_policy,
                    referer: config.referer,
                    read_timeout: config.read_timeout,
                    request_timeout: RequestConfig::new(config.timeout),
                    proxies,
                    proxies_maybe_http_auth,
                    https_only: config.https_only,
                }),
            })
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle different TLS backends based on features?
  codeQuestion3: What steps are taken to configure the HTTP/2 settings for the client?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    // Higher-level options

        /// Sets the `User-Agent` header to be used by this client.
        ///
        /// # Example
        ///
        /// ```rust
        /// # async fn doc() -> Result<(), reqwest::Error> {
        /// // Name your user agent after your app?
        /// static APP_USER_AGENT: &str = concat!(
        ///     env!("CARGO_PKG_NAME"),
        ///     "/",
        ///     env!("CARGO_PKG_VERSION"),
        /// );
        ///
        /// let client = reqwest::Client::builder()
        ///     .user_agent(APP_USER_AGENT)
        ///     .build()?;
        /// let res = client.get("https://www.rust-lang.org").send().await?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn user_agent<V>(mut self, value: V) -> ClientBuilder
        where
            V: TryInto<HeaderValue>,
            V::Error: Into<http::Error>,
        {
            match value.try_into() {
                Ok(value) => {
                    self.config.headers.insert(USER_AGENT, value);
                }
                Err(e) => {
                    self.config.error = Some(crate::error::builder(e.into()));
                }
            };
            self
        }
        /// Sets the default headers for every request.
        ///
        /// # Example
        ///
        /// ```rust
        /// use reqwest::header;
        /// # async fn doc() -> Result<(), reqwest::Error> {
        /// let mut headers = header::HeaderMap::new();
        /// headers.insert("X-MY-HEADER", header::HeaderValue::from_static("value"));
        ///
        /// // Consider marking security-sensitive headers with `set_sensitive`.
        /// let mut auth_value = header::HeaderValue::from_static("secret");
        /// auth_value.set_sensitive(true);
        /// headers.insert(header::AUTHORIZATION, auth_value);
        ///
        /// // get a client builder
        /// let client = reqwest::Client::builder()
        ///     .default_headers(headers)
        ///     .build()?;
        /// let res = client.get("https://www.rust-lang.org").send().await?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn default_headers(mut self, headers: HeaderMap) -> ClientBuilder {
            for (key, value) in headers.iter() {
                self.config.headers.insert(key, value.clone());
            }
            self
        }

        /// Enable a persistent cookie store for the client.
        ///
        /// Cookies received in responses will be preserved and included in
        /// additional requests.
        ///
        /// By default, no cookie store is used. Enabling the cookie store
        /// with `cookie_store(true)` will set the store to a default implementation.
        /// It is **not** necessary to call [cookie_store(true)](crate::ClientBuilder::cookie_store) if [cookie_provider(my_cookie_store)](crate::ClientBuilder::cookie_provider)
        /// is used; calling [cookie_store(true)](crate::ClientBuilder::cookie_store) _after_ [cookie_provider(my_cookie_store)](crate::ClientBuilder::cookie_provider) will result
        /// in the provided `my_cookie_store` being **overridden** with a default implementation.
        ///
        /// # Optional
        ///
        /// This requires the optional `cookies` feature to be enabled.
        #[cfg(feature = "cookies")]
        #[cfg_attr(docsrs, doc(cfg(feature = "cookies")))]
        pub fn cookie_store(mut self, enable: bool) -> ClientBuilder {
            if enable {
                self.cookie_provider(Arc::new(cookie::Jar::default()))
            } else {
                self.config.cookie_store = None;
                self
            }
        }

        /// Set the persistent cookie store for the client.
        ///
        /// Cookies received in responses will be passed to this store, and
        /// additional requests will query this store for cookies.
        ///
        /// By default, no cookie store is used. It is **not** necessary to also call
        /// [cookie_store(true)](crate::ClientBuilder::cookie_store) if [cookie_provider(my_cookie_store)](crate::ClientBuilder::cookie_provider) is used; calling
        /// [cookie_store(true)](crate::ClientBuilder::cookie_store) _after_ [cookie_provider(my_cookie_store)](crate::ClientBuilder::cookie_provider) will result
        /// in the provided `my_cookie_store` being **overridden** with a default implementation.
        ///
        /// # Optional
        ///
        /// This requires the optional `cookies` feature to be enabled.
        #[cfg(feature = "cookies")]
        #[cfg_attr(docsrs, doc(cfg(feature = "cookies")))]
        pub fn cookie_provider<C: cookie::CookieStore + 'static>(
            mut self,
            cookie_store: Arc<C>,
        ) -> ClientBuilder {
            self.config.cookie_store = Some(cookie_store as _);
            self
        }

        /// Enable auto gzip decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto gzip decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `gzip`.
        ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if its headers contain a `Content-Encoding` value of
        ///   `gzip`, both `Content-Encoding` and `Content-Length` are removed from the
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer set custom headers for all requests made by the client, and what is an example of this usage?
  codeQuestion3: What steps are involved in enabling a persistent cookie store for the client, and how is it configured with a custom cookie store implementation?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `gzip` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `gzip` feature to be enabled
        #[cfg(feature = "gzip")]
        #[cfg_attr(docsrs, doc(cfg(feature = "gzip")))]
        pub fn gzip(mut self, enable: bool) -> ClientBuilder {
            self.config.accepts.gzip = enable;
            self
        }

        /// Enable auto brotli decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto brotli decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `br`.
        ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if its headers contain a `Content-Encoding` value of
        ///   `br`, both `Content-Encoding` and `Content-Length` are removed from the
        ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `brotli` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `brotli` feature to be enabled
        #[cfg(feature = "brotli")]
        #[cfg_attr(docsrs, doc(cfg(feature = "brotli")))]
        pub fn brotli(mut self, enable: bool) -> ClientBuilder {
            self.config.accepts.brotli = enable;
            self
        }

        /// Enable auto zstd decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto zstd decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `zstd`.
        ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if its headers contain a `Content-Encoding` value of
        ///   `zstd`, both `Content-Encoding` and `Content-Length` are removed from the
        ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `zstd` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `zstd` feature to be enabled
        #[cfg(feature = "zstd")]
        #[cfg_attr(docsrs, doc(cfg(feature = "zstd")))]
        pub fn zstd(mut self, enable: bool) -> ClientBuilder {
            self.config.accepts.zstd = enable;
            self
        }

        /// Enable auto deflate decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto deflate decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `deflate`.
        ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if it's headers contain a `Content-Encoding` value that
        ///   equals to `deflate`, both values `Content-Encoding` and `Content-Length` are removed from the
        ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `deflate` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `deflate` feature to be enabled
        #[cfg(feature = "deflate")]
        #[cfg_attr(docsrs, doc(cfg(feature = "deflate")))]
        pub fn deflate(mut self, enable: bool) -> ClientBuilder {
            self.config.accepts.deflate = enable;
            self
        }

        /// Disable auto response body gzip decompression.
        ///
        /// This method exists even if the optional `gzip` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use gzip decompression
        /// even if another dependency were to enable the optional `gzip` feature.
        pub fn no_gzip(self) -> ClientBuilder {
            #[cfg(feature = "gzip")]
            {
                self.gzip(false)
            }

            #[cfg(not(feature = "gzip"))]
            {
                self
            }
        }

        /// Disable auto response body brotli decompression.
        ///
        /// This method exists even if the optional `brotli` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use brotli decompression
        /// even if another dependency were to enable the optional `brotli` feature.
        pub fn no_brotli(self) -> ClientBuilder {
            #[cfg(feature = "brotli")]
            {
                self.brotli(false)
            }

            #[cfg(not(feature = "brotli"))]
            {
                self
            }
        }

        /// Disable auto response body zstd decompression.
        ///
        /// This method exists even if the optional `zstd` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use zstd decompression
        /// even if another dependency were to enable the optional `zstd` feature.
        pub fn no_zstd(self) -> ClientBuilder {
            #[cfg(feature = "zstd")]
            {
                self.zstd(false)
            }

            #[cfg(not(feature = "zstd"))]
            {
                self
            }
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `gzip` method work, and what is an example of its usage?
  codeQuestion3: What steps are taken to disable auto decompression for a specific encoding type, and how is this implemented?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// Disable auto response body deflate decompression.
        ///
        /// This method exists even if the optional `deflate` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use deflate decompression
        /// even if another dependency were to enable the optional `deflate` feature.
        pub fn no_deflate(self) -> ClientBuilder {
            #[cfg(feature = "deflate")]
            {
                self.deflate(false)
            }

            #[cfg(not(feature = "deflate"))]
            {
                self
            }
        }

        // Redirect options

        /// Set a `RedirectPolicy` for this client.
        ///
        /// Default will follow redirects up to a maximum of 10.
        pub fn redirect(mut self, policy: redirect::Policy) -> ClientBuilder {
            self.config.redirect_policy = policy;
            self
        }

        /// Enable or disable automatic setting of the `Referer` header.
        ///
        /// Default is `true`.
        pub fn referer(mut self, enable: bool) -> ClientBuilder {
            self.config.referer = enable;
            self
        }

        // Proxy options

        /// Add a `Proxy` to the list of proxies the `Client` will use.
        ///
        /// # Note
        ///
        /// Adding a proxy will disable the automatic usage of the "system" proxy.
        pub fn proxy(mut self, proxy: Proxy) -> ClientBuilder {
            self.config.proxies.push(proxy);
            self.config.auto_sys_proxy = false;
            self
        }

        /// Clear all `Proxies`, so `Client` will use no proxy anymore.
        ///
        /// # Note
        /// To add a proxy exclusion list, use [crate::proxy::Proxy::no_proxy()]
        /// on all desired proxies instead.
        ///
        /// This also disables the automatic usage of the "system" proxy.
        pub fn no_proxy(mut self) -> ClientBuilder {
            self.config.proxies.clear();
            self.config.auto_sys_proxy = false;
            self
        }

        // Timeout options

        /// Enables a total request timeout.
        ///
        /// The timeout is applied from when the request starts connecting until the
        /// response body has finished. Also considered a total deadline.
        ///
        /// Default is no timeout.
        pub fn timeout(mut self, timeout: Duration) -> ClientBuilder {
            self.config.timeout = Some(timeout);
            self
        }

        /// Enables a read timeout.
        ///
        /// The timeout applies to each read operation, and resets after a
        /// successful read. This is more appropriate for detecting stalled
        /// connections when the size isn't known beforehand.
        ///
        /// Default is no timeout.
        pub fn read_timeout(mut self, timeout: Duration) -> ClientBuilder {
            self.config.read_timeout = Some(timeout);
            self
        }

        /// Set a timeout for only the connect phase of a `Client`.
        ///
        /// Default is `None`.
        ///
        /// # Note
        ///
        /// This **requires** the futures be executed in a tokio runtime with
        /// a tokio timer enabled.
        pub fn connect_timeout(mut self, timeout: Duration) -> ClientBuilder {
            self.config.connect_timeout = Some(timeout);
            self
        }

        /// Set whether connections should emit verbose logs.
        ///
        /// Enabling this option will emit [log][] messages at the `TRACE` level
        /// for read and write operations on connections.
        ///
        /// [log]: https://crates.io/crates/log
        pub fn connection_verbose(mut self, verbose: bool) -> ClientBuilder {
            self.config.connection_verbose = verbose;
            self
        }

        // HTTP options

        /// Set an optional timeout for idle sockets being kept-alive.
        ///
        /// Pass `None` to disable timeout.
        ///
        /// Default is 90 seconds.
        pub fn pool_idle_timeout<D>(mut self, val: D) -> ClientBuilder
        where
            D: Into<Option<Duration>>,
        {
            self.config.pool_idle_timeout = val.into();
            self
        }

        /// Sets the maximum idle connection per host allowed in the pool.
        pub fn pool_max_idle_per_host(mut self, max: usize) -> ClientBuilder {
            self.config.pool_max_idle_per_host = max;
            self
        }

        /// Send headers as title case instead of lowercase.
        pub fn http1_title_case_headers(mut self) -> ClientBuilder {
            self.config.http1_title_case_headers = true;
            self
        }

        /// Set whether HTTP/1 connections will accept obsolete line folding for
        /// header values.
        ///
        /// Newline codepoints (`\r` and `\n`) will be transformed to spaces when
        /// parsing.
        pub fn http1_allow_obsolete_multiline_headers_in_responses(
            mut self,
            value: bool,
        ) -> ClientBuilder {
            self.config
                .http1_allow_obsolete_multiline_headers_in_responses = value;
            self
        }

        /// Sets whether invalid header lines should be silently ignored in HTTP/1 responses.
        pub fn http1_ignore_invalid_headers_in_responses(mut self, value: bool) -> ClientBuilder {
            self.config.http1_ignore_invalid_headers_in_responses = value;
            self
        }

        /// Set whether HTTP/1 connections will accept spaces between header
        /// names and the colon that follow them in responses.
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure the client to disable automatic deflate decompression and set a custom redirect policy?
  codeQuestion3: What steps are involved in setting up proxy settings and disabling the system proxy for the client?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///
        /// Newline codepoints (`\r` and `\n`) will be transformed to spaces when
        /// parsing.
        pub fn http1_allow_spaces_after_header_name_in_responses(
            mut self,
            value: bool,
        ) -> ClientBuilder {
            self.config
                .http1_allow_spaces_after_header_name_in_responses = value;
            self
        }

        /// Only use HTTP/1.
        pub fn http1_only(mut self) -> ClientBuilder {
            self.config.http_version_pref = HttpVersionPref::Http1;
            self
        }

        /// Allow HTTP/0.9 responses
        pub fn http09_responses(mut self) -> ClientBuilder {
            self.config.http09_responses = true;
            self
        }

        /// Only use HTTP/2.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_prior_knowledge(mut self) -> ClientBuilder {
            self.config.http_version_pref = HttpVersionPref::Http2;
            self
        }

        /// Only use HTTP/3.
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_prior_knowledge(mut self) -> ClientBuilder {
            self.config.http_version_pref = HttpVersionPref::Http3;
            self
        }

        /// Sets the `SETTINGS_INITIAL_WINDOW_SIZE` option for HTTP2 stream-level flow control.
        ///
        /// Default is currently 65,535 but may change internally to optimize for common uses.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_initial_stream_window_size(mut self, sz: impl Into<Option<u32>>) -> ClientBuilder {
            self.config.http2_initial_stream_window_size = sz.into();
            self
        }

        /// Sets the max connection-level flow control for HTTP2
        ///
        /// Default is currently 65,535 but may change internally to optimize for common uses.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_initial_connection_window_size(
            mut self,
            sz: impl Into<Option<u32>>,
        ) -> ClientBuilder {
            self.config.http2_initial_connection_window_size = sz.into();
            self
        }

        /// Sets whether to use an adaptive flow control.
        ///
        /// Enabling this will override the limits set in `http2_initial_stream_window_size` and
        /// `http2_initial_connection_window_size`.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_adaptive_window(mut self, enabled: bool) -> ClientBuilder {
            self.config.http2_adaptive_window = enabled;
            self
        }

        /// Sets the maximum frame size to use for HTTP2.
        ///
        /// Default is currently 16,384 but may change internally to optimize for common uses.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_max_frame_size(mut self, sz: impl Into<Option<u32>>) -> ClientBuilder {
            self.config.http2_max_frame_size = sz.into();
            self
        }

        /// Sets the maximum size of received header frames for HTTP2.
        ///
        /// Default is currently 16KB, but can change.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_max_header_list_size(mut self, max_header_size_bytes: u32) -> ClientBuilder {
            self.config.http2_max_header_list_size = Some(max_header_size_bytes);
            self
        }

        /// Sets an interval for HTTP2 Ping frames should be sent to keep a connection alive.
        ///
        /// Pass `None` to disable HTTP2 keep-alive.
        /// Default is currently disabled.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_keep_alive_interval(
            mut self,
            interval: impl Into<Option<Duration>>,
        ) -> ClientBuilder {
            self.config.http2_keep_alive_interval = interval.into();
            self
        }

        /// Sets a timeout for receiving an acknowledgement of the keep-alive ping.
        ///
        /// If the ping is not acknowledged within the timeout, the connection will be closed.
        /// Does nothing if `http2_keep_alive_interval` is disabled.
        /// Default is currently disabled.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_keep_alive_timeout(mut self, timeout: Duration) -> ClientBuilder {
            self.config.http2_keep_alive_timeout = Some(timeout);
            self
        }

        /// Sets whether HTTP2 keep-alive should apply while the connection is idle.
        ///
        /// If disabled, keep-alive pings are only sent while there are open request/responses streams.
        /// If enabled, pings are also sent when no streams are active.
        /// Does nothing if `http2_keep_alive_interval` is disabled.
        /// Default is `false`.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_keep_alive_while_idle(mut self, enabled: bool) -> ClientBuilder {
            self.config.http2_keep_alive_while_idle = enabled;
            self
        }

        // TCP options

        /// Set whether sockets have `TCP_NODELAY` enabled.
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer configure the HTTP/2 settings for flow control and connection management in this code?
  codeQuestion3: What system calls or APIs are used to set TCP options for sockets in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///
        /// Default is `true`.
        pub fn tcp_nodelay(mut self, enabled: bool) -> ClientBuilder {
            self.config.nodelay = enabled;
            self
        }

        /// Bind to a local IP Address.
        ///
        /// # Example
        ///
        /// ```
        /// # #[cfg(all(feature = "__rustls", not(feature = "__rustls-ring")))]
        /// # let _ = rustls::crypto::ring::default_provider().install_default();
        /// use std::net::IpAddr;
        /// let local_addr = IpAddr::from([12, 4, 1, 8]);
        /// let client = reqwest::Client::builder()
        ///     .local_address(local_addr)
        ///     .build().unwrap();
        /// ```
        pub fn local_address<T>(mut self, addr: T) -> ClientBuilder
        where
            T: Into<Option<IpAddr>>,
        {
            self.config.local_address = addr.into();
            self
        }

        /// Bind connections only on the specified network interface.
        ///
        /// This option is only available on the following operating systems:
        ///
        /// - Android
        /// - Fuchsia
        /// - Linux,
        /// - macOS and macOS-like systems (iOS, tvOS, watchOS and visionOS)
        /// - Solaris and illumos
        ///
        /// On Android, Linux, and Fuchsia, this uses the
        /// [`SO_BINDTODEVICE`][man-7-socket] socket option. On macOS and macOS-like
        /// systems, Solaris, and illumos, this instead uses the [`IP_BOUND_IF` and
        /// `IPV6_BOUND_IF`][man-7p-ip] socket options (as appropriate).
        ///
        /// Note that connections will fail if the provided interface name is not a
        /// network interface that currently exists when a connection is established.
        ///
        /// # Example
        ///
        /// ```
        /// # #[cfg(all(feature = "__rustls", not(feature = "__rustls-ring")))]
        /// # let _ = rustls::crypto::ring::default_provider().install_default();
        /// let interface = "lo";
        /// let client = reqwest::Client::builder()
        ///     .interface(interface)
        ///     .build().unwrap();
        /// ```
        ///
        /// [man-7-socket]: https://man7.org/linux/man-pages/man7/socket.7.html
        /// [man-7p-ip]: https://docs.oracle.com/cd/E86824_01/html/E54777/ip-7p.html
        #[cfg(any(
            target_os = "android",
            target_os = "fuchsia",
            target_os = "illumos",
            target_os = "ios",
            target_os = "linux",
            target_os = "macos",
            target_os = "solaris",
            target_os = "tvos",
            target_os = "visionos",
            target_os = "watchos",
        ))]
        pub fn interface(mut self, interface: &str) -> ClientBuilder {
            self.config.interface = Some(interface.to_string());
            self
        }

        /// Set that all sockets have `SO_KEEPALIVE` set with the supplied duration.
        ///
        /// If `None`, the option will not be set.
        pub fn tcp_keepalive<D>(mut self, val: D) -> ClientBuilder
        where
            D: Into<Option<Duration>>,
        {
            self.config.tcp_keepalive = val.into();
            self
        }

        // TLS options

        /// Add a custom root certificate.
        ///
        /// This can be used to connect to a server that has a self-signed
        /// certificate for example.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn add_root_certificate(mut self, cert: Certificate) -> ClientBuilder {
            self.config.root_certs.push(cert);
            self
        }

        /// Add a certificate revocation list.
        ///
        ///
        /// # Optional
        ///
        /// This requires the `rustls-tls(-...)` Cargo feature enabled.
        #[cfg(feature = "__rustls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls")))]
        pub fn add_crl(mut self, crl: CertificateRevocationList) -> ClientBuilder {
            self.config.crls.push(crl);
            self
        }

        /// Add multiple certificate revocation lists.
        ///
        ///
        /// # Optional
        ///
        /// This requires the `rustls-tls(-...)` Cargo feature enabled.
        #[cfg(feature = "__rustls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls")))]
        pub fn add_crls(
            mut self,
            crls: impl IntoIterator<Item = CertificateRevocationList>,
        ) -> ClientBuilder {
            self.config.crls.extend(crls);
            self
        }

        /// Controls the use of built-in/preloaded certificates during certificate validation.
        ///
        /// Defaults to `true` -- built-in system certs will be used.
        ///
        /// # Bulk Option
        ///
        /// If this value is `true`, _all_ enabled system certs configured with Cargo
        /// features will be loaded.
        ///
        /// You can set this to `false`, and enable only a specific source with
        /// individual methods. Do that will prevent other sources from being loaded
        /// even if their feature Cargo feature is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer configure a custom root certificate for TLS connections in this code, and what are the necessary dependencies?
  codeQuestion3: What system calls or socket options are used when binding to a specific network interface, and how do they vary across different operating systems?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn tls_built_in_root_certs(mut self, tls_built_in_root_certs: bool) -> ClientBuilder {
            self.config.tls_built_in_root_certs = tls_built_in_root_certs;

            #[cfg(feature = "rustls-tls-webpki-roots-no-provider")]
            {
                self.config.tls_built_in_certs_webpki = tls_built_in_root_certs;
            }

            #[cfg(feature = "rustls-tls-native-roots-no-provider")]
            {
                self.config.tls_built_in_certs_native = tls_built_in_root_certs;
            }

            self
        }

        /// Sets whether to load webpki root certs with rustls.
        ///
        /// If the feature is enabled, this value is `true` by default.
        #[cfg(feature = "rustls-tls-webpki-roots-no-provider")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls-webpki-roots-no-provider")))]
        pub fn tls_built_in_webpki_certs(mut self, enabled: bool) -> ClientBuilder {
            self.config.tls_built_in_certs_webpki = enabled;
            self
        }

        /// Sets whether to load native root certs with rustls.
        ///
        /// If the feature is enabled, this value is `true` by default.
        #[cfg(feature = "rustls-tls-native-roots-no-provider")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls-native-roots-no-provider")))]
        pub fn tls_built_in_native_certs(mut self, enabled: bool) -> ClientBuilder {
            self.config.tls_built_in_certs_native = enabled;
            self
        }

        /// Sets the identity to be used for client certificate authentication.
        ///
        /// # Optional
        ///
        /// This requires the optional `native-tls` or `rustls-tls(-...)` feature to be
        /// enabled.
        #[cfg(any(feature = "native-tls", feature = "__rustls"))]
        #[cfg_attr(docsrs, doc(cfg(any(feature = "native-tls", feature = "rustls-tls"))))]
        pub fn identity(mut self, identity: Identity) -> ClientBuilder {
            self.config.identity = Some(identity);
            self
        }

        /// Controls the use of hostname verification.
        ///
        /// Defaults to `false`.
        ///
        /// # Warning
        ///
        /// You should think very carefully before you use this method. If
        /// hostname verification is not used, any valid certificate for any
        /// site will be trusted for use from any other. This introduces a
        /// significant vulnerability to man-in-the-middle attacks.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn danger_accept_invalid_hostnames(
            mut self,
            accept_invalid_hostname: bool,
        ) -> ClientBuilder {
            self.config.hostname_verification = !accept_invalid_hostname;
            self
        }

        /// Controls the use of certificate validation.
        ///
        /// Defaults to `false`.
        ///
        /// # Warning
        ///
        /// You should think very carefully before using this method. If
        /// invalid certificates are trusted, *any* certificate for *any* site
        /// will be trusted for use. This includes expired certificates. This
        /// introduces significant vulnerabilities, and should only be used
        /// as a last resort.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn danger_accept_invalid_certs(mut self, accept_invalid_certs: bool) -> ClientBuilder {
            self.config.certs_verification = !accept_invalid_certs;
            self
        }

        /// Controls the use of TLS server name indication.
        ///
        /// Defaults to `true`.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn tls_sni(mut self, tls_sni: bool) -> ClientBuilder {
            self.config.tls_sni = tls_sni;
            self
        }

        /// Set the minimum required TLS version for connections.
        ///
        /// By default, the TLS backend's own default is used.
        ///
        /// # Errors
        ///
        /// A value of `tls::Version::TLS_1_3` will cause an error with the
        /// `native-tls`/`default-tls` backend. This does not mean the version
        /// isn't supported, just that it can't be set as a minimum due to
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer configure the client to accept invalid certificates and disable hostname verification for testing purposes?
  codeQuestion3: What steps are involved in setting up a custom identity certificate for client authentication using the Hyper library?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// technical limitations.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn min_tls_version(mut self, version: tls::Version) -> ClientBuilder {
            self.config.min_tls_version = Some(version);
            self
        }

        /// Set the maximum allowed TLS version for connections.
        ///
        /// By default, there's no maximum.
        ///
        /// # Errors
        ///
        /// A value of `tls::Version::TLS_1_3` will cause an error with the
        /// `native-tls`/`default-tls` backend. This does not mean the version
        /// isn't supported, just that it can't be set as a maximum due to
        /// technical limitations.
        ///
        /// Cannot set a maximum outside the protocol versions supported by
        /// `rustls` with the `rustls-tls` backend.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn max_tls_version(mut self, version: tls::Version) -> ClientBuilder {
            self.config.max_tls_version = Some(version);
            self
        }

        /// Force using the native TLS backend.
        ///
        /// Since multiple TLS backends can be optionally enabled, this option will
        /// force the `native-tls` backend to be used for this `Client`.
        ///
        /// # Optional
        ///
        /// This requires the optional `native-tls` feature to be enabled.
        #[cfg(feature = "native-tls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "native-tls")))]
        pub fn use_native_tls(mut self) -> ClientBuilder {
            self.config.tls = TlsBackend::Default;
            self
        }

        /// Force using the Rustls TLS backend.
        ///
        /// Since multiple TLS backends can be optionally enabled, this option will
        /// force the `rustls` backend to be used for this `Client`.
        ///
        /// # Optional
        ///
        /// This requires the optional `rustls-tls(-...)` feature to be enabled.
        #[cfg(feature = "__rustls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls")))]
        pub fn use_rustls_tls(mut self) -> ClientBuilder {
            self.config.tls = TlsBackend::Rustls;
            self
        }

        /// Use a preconfigured TLS backend.
        ///
        /// If the passed `Any` argument is not a TLS backend that reqwest
        /// understands, the `ClientBuilder` will error when calling `build`.
        ///
        /// # Advanced
        ///
        /// This is an advanced option, and can be somewhat brittle. Usage requires
        /// keeping the preconfigured TLS argument version in sync with reqwest,
        /// since version mismatches will result in an "unknown" TLS backend.
        ///
        /// If possible, it's preferable to use the methods on `ClientBuilder`
        /// to configure reqwest's TLS.
        ///
        /// # Optional
        ///
        /// This requires one of the optional features `native-tls` or
        /// `rustls-tls(-...)` to be enabled.
        #[cfg(any(feature = "native-tls", feature = "__rustls",))]
        #[cfg_attr(docsrs, doc(cfg(any(feature = "native-tls", feature = "rustls-tls"))))]
        pub fn use_preconfigured_tls(mut self, tls: impl Any) -> ClientBuilder {
            let mut tls = Some(tls);
            #[cfg(feature = "native-tls")]
            {
                if let Some(conn) = (&mut tls as &mut dyn Any).downcast_mut::<Option<TlsConnector>>() {
                    let tls = conn.take().expect("is definitely Some");
                    let tls = crate::tls::TlsBackend::BuiltNativeTls(tls);
                    self.config.tls = tls;
                    return self;
                }
            }
            #[cfg(feature = "__rustls")]
            {
                if let Some(conn) =
                    (&mut tls as &mut dyn Any).downcast_mut::<Option<rustls::ClientConfig>>()
                {
                    let tls = conn.take().expect("is definitely Some");
                    let tls = crate::tls::TlsBackend::BuiltRustls(tls);
                    self.config.tls = tls;
                    return self;
                }
            }

            // Otherwise, we don't recognize the TLS backend!
            self.config.tls = crate::tls::TlsBackend::UnknownPreconfigured;
            self
        }

        /// Add TLS information as `TlsInfo` extension to responses.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn tls_info(mut self, tls_info: bool) -> ClientBuilder {
            self.config.tls_info = tls_info;
            self
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer configure the minimum and maximum TLS versions for a client connection, and what are the associated API calls?
  codeQuestion3: What is the process for forcing a specific TLS backend (e.g., native-tls or rustls-tls) and how is it implemented in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// Restrict the Client to be used with HTTPS only requests.
        ///
        /// Defaults to false.
        pub fn https_only(mut self, enabled: bool) -> ClientBuilder {
            self.config.https_only = enabled;
            self
        }

        #[doc(hidden)]
        #[cfg(feature = "hickory-dns")]
        #[cfg_attr(docsrs, doc(cfg(feature = "hickory-dns")))]
        #[deprecated(note = "use `hickory_dns` instead")]
        pub fn trust_dns(mut self, enable: bool) -> ClientBuilder {
            self.config.hickory_dns = enable;
            self
        }

        /// Enables the [hickory-dns](hickory_resolver) async resolver instead of a default threadpool
        /// using `getaddrinfo`.
        ///
        /// If the `hickory-dns` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `hickory-dns` feature to be enabled
        ///
        /// # Warning
        ///
        /// The hickory resolver does not work exactly the same, or on all the platforms
        /// that the default resolver does
        #[cfg(feature = "hickory-dns")]
        #[cfg_attr(docsrs, doc(cfg(feature = "hickory-dns")))]
        pub fn hickory_dns(mut self, enable: bool) -> ClientBuilder {
            self.config.hickory_dns = enable;
            self
        }

        #[doc(hidden)]
        #[deprecated(note = "use `no_hickory_dns` instead")]
        pub fn no_trust_dns(self) -> ClientBuilder {
            self.no_hickory_dns()
        }

        /// Disables the hickory-dns async resolver.
        ///
        /// This method exists even if the optional `hickory-dns` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use the hickory-dns async resolver
        /// even if another dependency were to enable the optional `hickory-dns` feature.
        pub fn no_hickory_dns(self) -> ClientBuilder {
            #[cfg(feature = "hickory-dns")]
            {
                self.hickory_dns(false)
            }

            #[cfg(not(feature = "hickory-dns"))]
            {
                self
            }
        }

        /// Override DNS resolution for specific domains to a particular IP address.
        ///
        /// Set the port to `0` to use the conventional port for the given scheme (e.g. 80 for http).
        /// Ports in the URL itself will always be used instead of the port in the overridden addr.
        pub fn resolve(self, domain: &str, addr: SocketAddr) -> ClientBuilder {
            self.resolve_to_addrs(domain, &[addr])
        }

        /// Override DNS resolution for specific domains to particular IP addresses.
        ///
        /// Set the port to `0` to use the conventional port for the given scheme (e.g. 80 for http).
        /// Ports in the URL itself will always be used instead of the port in the overridden addr.
        pub fn resolve_to_addrs(mut self, domain: &str, addrs: &[SocketAddr]) -> ClientBuilder {
            self.config
                .dns_overrides
                .insert(domain.to_ascii_lowercase(), addrs.to_vec());
            self
        }

        /// Override the DNS resolver implementation.
        ///
        /// Pass an `Arc` wrapping a trait object implementing `Resolve`.
        /// Overrides for specific names passed to `resolve` and `resolve_to_addrs` will
        /// still be applied on top of this resolver.
        pub fn dns_resolver<R: Resolve + 'static>(mut self, resolver: Arc<R>) -> ClientBuilder {
            self.config.dns_resolver = Some(resolver as _);
            self
        }

        /// Whether to send data on the first flight ("early data") in TLS 1.3 handshakes
        /// for HTTP/3 connections.
        ///
        /// The default is false.
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn tls_early_data(mut self, enabled: bool) -> ClientBuilder {
            self.config.tls_enable_early_data = enabled;
            self
        }

        /// Maximum duration of inactivity to accept before timing out the QUIC connection.
        ///
        /// Please see docs in [`TransportConfig`] in [`quinn`].
        ///
        /// [`TransportConfig`]: https://docs.rs/quinn/latest/quinn/struct.TransportConfig.html
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_max_idle_timeout(mut self, value: Duration) -> ClientBuilder {
            self.config.quic_max_idle_timeout = Some(value);
            self
        }

        /// Maximum number of bytes the peer may transmit without acknowledgement on any one stream
        /// before becoming blocked.
        ///
        /// Please see docs in [`TransportConfig`] in [`quinn`].
        ///
        /// [`TransportConfig`]: https://docs.rs/quinn/latest/quinn/struct.TransportConfig.html
        ///
        /// # Panics
        ///
        /// Panics if the value is over 2^62.
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_stream_receive_window(mut self, value: u64) -> ClientBuilder {
            self.config.quic_stream_receive_window = Some(value.try_into().unwrap());
            self
        }

        /// Maximum number of bytes the peer may transmit across all streams of a connection before
        /// becoming blocked.
        ///
        /// Please see docs in [`TransportConfig`] in [`quinn`].
        ///
        /// [`TransportConfig`]: https://docs.rs/quinn/latest/quinn/struct.TransportConfig.html
        ///
        /// # Panics
        ///
        /// Panics if the value is over 2^62.
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_conn_receive_window(mut self, value: u64) -> ClientBuilder {
            self.config.quic_receive_window = Some(value.try_into().unwrap());
            self
        }

        /// Maximum number of bytes to transmit to a peer without acknowledgment
        ///
        /// Please see docs in [`TransportConfig`] in [`quinn`].
        ///
        /// [`TransportConfig`]: https://docs.rs/quinn/latest/quinn/struct.TransportConfig.html
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_send_window(mut self, value: u64) -> ClientBuilder {
            self.config.quic_send_window = Some(value);
            self
        }

        /// Override the default congestion control algorithm to use [BBR]
        ///
        /// The current default congestion control algorithm is [CUBIC]. This method overrides the
        /// default.
        ///
        /// [BBR]: https://datatracker.ietf.org/doc/html/draft-ietf-ccwg-bbr
        /// [CUBIC]: https://datatracker.ietf.org/doc/html/rfc8312
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_congestion_bbr(mut self) -> ClientBuilder {
            self.config.quic_congestion_bbr = true;
            self
        }

        /// Set the maximum HTTP/3 header size this client is willing to accept.
        ///
        /// See [header size constraints] section of the specification for details.
        ///
        /// [header size constraints]: https://www.rfc-editor.org/rfc/rfc9114.html#name-header-size-constraints
        ///
        /// Please see docs in [`Builder`] in [`h3`].
        ///
        /// [`Builder`]: https://docs.rs/h3/latest/h3/client/struct.Builder.html#method.max_field_section_size
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_max_field_section_size(mut self, value: u64) -> ClientBuilder {
            self.config.h3_max_field_section_size = Some(value.try_into().unwrap());
            self
        }

        /// Enable whether to send HTTP/3 protocol grease on the connections.
        ///
        /// HTTP/3 uses the concept of "grease"
        ///
        /// to prevent potential interoperability issues in the future.
        /// In HTTP/3, the concept of grease is used to ensure that the protocol can evolve
        /// and accommodate future changes without breaking existing implementations.
        ///
        /// Please see docs in [`Builder`] in [`h3`].
        ///
        /// [`Builder`]: https://docs.rs/h3/latest/h3/client/struct.Builder.html#method.send_grease
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(all(reqwest_unstable, feature = "http3",))))]
        pub fn http3_send_grease(mut self, enabled: bool) -> ClientBuilder {
            self.config.h3_send_grease = Some(enabled);
            self
        }

        /// Adds a new Tower [`Layer`](https://docs.rs/tower/latest/tower/trait.Layer.html) to the
        /// base connector [`Service`](https://docs.rs/tower/latest/tower/trait.Service.html) which
        /// is responsible for connection establishment.
        ///
        /// Each subsequent invocation of this function will wrap previous layers.
        ///
        /// If configured, the `connect_timeout` will be the outermost layer.
        ///
        /// Example usage:
        /// ```
        /// use std::time::Duration;
        ///
        /// # #[cfg(not(feature = "rustls-tls-no-provider"))]
        /// let client = reqwest::Client::builder()
        ///                      // resolved to outermost layer, meaning while we are waiting on concurrency limit
        ///                      .connect_timeout(Duration::from_millis(200))
        ///                      // underneath the concurrency check, so only after concurrency limit lets us through
        ///                      .connector_layer(tower::timeout::TimeoutLayer::new(Duration::from_millis(50)))
        ///                      .connector_layer(tower::limit::concurrency::ConcurrencyLimitLayer::new(2))
        ///                      .build()
        ///                      .unwrap();
        /// ```
        ///
        pub fn connector_layer<L>(mut self, layer: L) -> ClientBuilder
        where
            L: Layer<BoxedConnectorService> + Clone + Send + Sync + 'static,
            L::Service:
                Service<Unnameable, Response = Conn, Error = BoxError> + Clone + Send + Sync + 'static,
            <L::Service as Service<Unnameable>>::Future: Send + 'static,
        {
            let layer = BoxCloneSyncServiceLayer::new(layer);

            self.config.connector_layers.push(layer);

            self
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer configure the client to use a custom DNS resolver with specific override settings for certain domains?
  codeQuestion3: What steps are involved in setting up HTTP/3 connection parameters such as congestion control and send window size?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    type HyperClient = hyper_util::client::legacy::Client<Connector, super::Body>;

    impl Default for Client {
        fn default() -> Self {
            Self::new()
        }
    }

    impl Client {
        /// Constructs a new `Client`.
        ///
        /// # Panics
        ///
        /// This method panics if a TLS backend cannot be initialized, or the resolver
        /// cannot load the system configuration.
        ///
        /// Use `Client::builder()` if you wish to handle the failure as an `Error`
        /// instead of panicking.
        pub fn new() -> Client {
            ClientBuilder::new().build().expect("Client::new()")
        }

        /// Creates a `ClientBuilder` to configure a `Client`.
        ///
        /// This is the same as `ClientBuilder::new()`.
        pub fn builder() -> ClientBuilder {
            ClientBuilder::new()
        }

        /// Convenience method to make a `GET` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever the supplied `Url` cannot be parsed.
        pub fn get<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::GET, url)
        }

        /// Convenience method to make a `POST` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever the supplied `Url` cannot be parsed.
        pub fn post<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::POST, url)
        }

        /// Convenience method to make a `PUT` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever the supplied `Url` cannot be parsed.
        pub fn put<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::PUT, url)
        }

        /// Convenience method to make a `PATCH` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever the supplied `Url` cannot be parsed.
        pub fn patch<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::PATCH, url)
        }

        /// Convenience method to make a `DELETE` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever the supplied `Url` cannot be parsed.
        pub fn delete<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::DELETE, url)
        }

        /// Convenience method to make a `HEAD` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever the supplied `Url` cannot be parsed.
        pub fn head<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::HEAD, url)
        }

        /// Start building a `Request` with the `Method` and `Url`.
        ///
        /// Returns a `RequestBuilder`, which will allow setting headers and
        /// the request body before sending.
        ///
        /// # Errors
        ///
        /// This method fails whenever the supplied `Url` cannot be parsed.
        pub fn request<U: IntoUrl>(&self, method: Method, url: U) -> RequestBuilder {
            let req = url.into_url().map(move |url| Request::new(method, url));
            RequestBuilder::new(self.clone(), req)
        }

        /// Executes a `Request`.
        ///
        /// A `Request` can be built manually with `Request::new()` or obtained
        /// from a RequestBuilder with `RequestBuilder::build()`.
        ///
        /// You should prefer to use the `RequestBuilder` and
        /// `RequestBuilder::send()`.
        ///
        /// # Errors
        ///
        /// This method fails if there was an error while sending request,
        /// redirect loop was detected or redirect limit was exhausted.
        pub fn execute(
            &self,
            request: Request,
        ) -> impl Future<Output = Result<Response, crate::Error>> {
            self.execute_request(request)
        }

        pub(super) fn execute_request(&self, req: Request) -> Pending {
            let (method, url, mut headers, body, version, extensions) = req.pieces();
            if url.scheme() != "http" && url.scheme() != "https" {
                return Pending::new_err(error::url_bad_scheme(url));
            }

            // check if we're in https_only mode and check the scheme of the current URL
            if self.inner.https_only && url.scheme() != "https" {
                return Pending::new_err(error::url_bad_scheme(url));
            }

            // insert default headers in the request headers
            // without overwriting already appended headers.
            for (key, value) in &self.inner.headers {
                if let Entry::Vacant(entry) = headers.entry(key) {
                    entry.insert(value.clone());
                }
            }

            // Add cookies from the cookie store.
            #[cfg(feature = "cookies")]
            {
                if let Some(cookie_store) = self.inner.cookie_store.as_ref() {
                    if headers.get(crate::header::COOKIE).is_none() {
                        add_cookie_header(&mut headers, &**cookie_store, &url);
                    }
                }
            }

            let accept_encoding = self.inner.accepts.as_str();

            if let Some(accept_encoding) = accept_encoding {
                if !headers.contains_key(ACCEPT_ENCODING) && !headers.contains_key(RANGE) {
                    headers.insert(ACCEPT_ENCODING, HeaderValue::from_static(accept_encoding));
                }
            }

            let uri = match try_uri(&url) {
                Ok(uri) => uri,
                _ => return Pending::new_err(error::url_invalid_uri(url)),
            };

            let (reusable, body) = match body {
                Some(body) => {
                    let (reusable, body) = body.try_reuse();
                    (Some(reusable), body)
                }
                None => (None, Body::empty()),
            };

            self.proxy_auth(&uri, &mut headers);

            let builder = hyper::Request::builder()
                .method(method.clone())
                .uri(uri)
                .version(version);

            let in_flight = match version {
                #[cfg(feature = "http3")]
                http::Version::HTTP_3 if self.inner.h3_client.is_some() => {
                    let mut req = builder.body(body).expect("valid request parts");
                    *req.headers_mut() = headers.clone();
                    ResponseFuture::H3(self.inner.h3_client.as_ref().unwrap().request(req))
                }
                _ => {
                    let mut req = builder.body(body).expect("valid request parts");
                    *req.headers_mut() = headers.clone();
                    ResponseFuture::Default(self.inner.hyper.request(req))
                }
            };

            let total_timeout = self
                .inner
                .request_timeout
                .fetch(&extensions)
                .copied()
                .map(tokio::time::sleep)
                .map(Box::pin);

            let read_timeout_fut = self
                .inner
                .read_timeout
                .map(tokio::time::sleep)
                .map(Box::pin);

            Pending {
                inner: PendingInner::Request(PendingRequest {
                    method,
                    url,
                    headers,
                    body: reusable,

                    urls: Vec::new(),

                    retry_count: 0,

                    client: self.inner.clone(),

                    in_flight,
                    total_timeout,
                    read_timeout_fut,
                    read_timeout: self.inner.read_timeout,
                }),
            }
        }

        fn proxy_auth(&self, dst: &Uri, headers: &mut HeaderMap) {
            if !self.inner.proxies_maybe_http_auth {
                return;
            }

            // Only set the header here if the destination scheme is 'http',
            // since otherwise, the header will be included in the CONNECT tunnel
            // request instead.
            if dst.scheme() != Some(&Scheme::HTTP) {
                return;
            }

            if headers.contains_key(PROXY_AUTHORIZATION) {
                return;
            }

            for proxy in self.inner.proxies.iter() {
                if proxy.is_match(dst) {
                    if let Some(header) = proxy.http_basic_auth(dst) {
                        headers.insert(PROXY_AUTHORIZATION, header);
                    }

                    break;
                }
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user make a GET request to a specific URL using the `Client` struct, and what system calls or API methods are involved in this process?
  codeQuestion3: What steps are taken to handle HTTP request headers and authentication when making a request through the `Client` struct?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Client {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut builder = f.debug_struct("Client");
            self.inner.fmt_fields(&mut builder);
            builder.finish()
        }
    }

    impl tower_service::Service<Request> for Client {
        type Response = Response;
        type Error = crate::Error;
        type Future = Pending;

        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }

        fn call(&mut self, req: Request) -> Self::Future {
            self.execute_request(req)
        }
    }

    impl tower_service::Service<Request> for &'_ Client {
        type Response = Response;
        type Error = crate::Error;
        type Future = Pending;

        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }

        fn call(&mut self, req: Request) -> Self::Future {
            self.execute_request(req)
        }
    }

    impl fmt::Debug for ClientBuilder {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut builder = f.debug_struct("ClientBuilder");
            self.config.fmt_fields(&mut builder);
            builder.finish()
        }
    }

    impl Config {
        fn fmt_fields(&self, f: &mut fmt::DebugStruct<'_, '_>) {
            // Instead of deriving Debug, only print fields when their output
            // would provide relevant or interesting data.

            #[cfg(feature = "cookies")]
            {
                if let Some(_) = self.cookie_store {
                    f.field("cookie_store", &true);
                }
            }

            f.field("accepts", &self.accepts);

            if !self.proxies.is_empty() {
                f.field("proxies", &self.proxies);
            }

            if !self.redirect_policy.is_default() {
                f.field("redirect_policy", &self.redirect_policy);
            }

            if self.referer {
                f.field("referer", &true);
            }

            f.field("default_headers", &self.headers);

            if self.http1_title_case_headers {
                f.field("http1_title_case_headers", &true);
            }

            if self.http1_allow_obsolete_multiline_headers_in_responses {
                f.field("http1_allow_obsolete_multiline_headers_in_responses", &true);
            }

            if self.http1_ignore_invalid_headers_in_responses {
                f.field("http1_ignore_invalid_headers_in_responses", &true);
            }

            if self.http1_allow_spaces_after_header_name_in_responses {
                f.field("http1_allow_spaces_after_header_name_in_responses", &true);
            }

            if matches!(self.http_version_pref, HttpVersionPref::Http1) {
                f.field("http1_only", &true);
            }

            #[cfg(feature = "http2")]
            if matches!(self.http_version_pref, HttpVersionPref::Http2) {
                f.field("http2_prior_knowledge", &true);
            }

            if let Some(ref d) = self.connect_timeout {
                f.field("connect_timeout", d);
            }

            if let Some(ref d) = self.timeout {
                f.field("timeout", d);
            }

            if let Some(ref v) = self.local_address {
                f.field("local_address", v);
            }

            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            if let Some(ref v) = self.interface {
                f.field("interface", v);
            }

            if self.nodelay {
                f.field("tcp_nodelay", &true);
            }

            #[cfg(feature = "__tls")]
            {
                if !self.hostname_verification {
                    f.field("danger_accept_invalid_hostnames", &true);
                }
            }

            #[cfg(feature = "__tls")]
            {
                if !self.certs_verification {
                    f.field("danger_accept_invalid_certs", &true);
                }

                if let Some(ref min_tls_version) = self.min_tls_version {
                    f.field("min_tls_version", min_tls_version);
                }

                if let Some(ref max_tls_version) = self.max_tls_version {
                    f.field("max_tls_version", max_tls_version);
                }

                f.field("tls_sni", &self.tls_sni);

                f.field("tls_info", &self.tls_info);
            }

            #[cfg(all(feature = "default-tls", feature = "__rustls"))]
            {
                f.field("tls_backend", &self.tls);
            }

            if !self.dns_overrides.is_empty() {
                f.field("dns_overrides", &self.dns_overrides);
            }

            #[cfg(feature = "http3")]
            {
                if self.tls_enable_early_data {
                    f.field("tls_enable_early_data", &true);
                }
            }
        }
    }

    struct ClientRef {
        accepts: Accepts,
        #[cfg(feature = "cookies")]
        cookie_store: Option<Arc<dyn cookie::CookieStore>>,
        headers: HeaderMap,
        hyper: HyperClient,
        #[cfg(feature = "http3")]
        h3_client: Option<H3Client>,
        redirect_policy: redirect::Policy,
        referer: bool,
        request_timeout: RequestConfig<RequestTimeout>,
        read_timeout: Option<Duration>,
        proxies: Arc<Vec<Proxy>>,
        proxies_maybe_http_auth: bool,
        https_only: bool,
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Client` struct handle HTTP requests and what system calls or APIs are involved in its functionality?
  codeQuestion3: What steps are taken to configure and initialize the `ClientBuilder` for a new HTTP client instance?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl ClientRef {
        fn fmt_fields(&self, f: &mut fmt::DebugStruct<'_, '_>) {
            // Instead of deriving Debug, only print fields when their output
            // would provide relevant or interesting data.

            #[cfg(feature = "cookies")]
            {
                if let Some(_) = self.cookie_store {
                    f.field("cookie_store", &true);
                }
            }

            f.field("accepts", &self.accepts);

            if !self.proxies.is_empty() {
                f.field("proxies", &self.proxies);
            }

            if !self.redirect_policy.is_default() {
                f.field("redirect_policy", &self.redirect_policy);
            }

            if self.referer {
                f.field("referer", &true);
            }

            f.field("default_headers", &self.headers);

            self.request_timeout.fmt_as_field(f);

            if let Some(ref d) = self.read_timeout {
                f.field("read_timeout", d);
            }
        }
    }

    pin_project! {
        pub struct Pending {
            #[pin]
            inner: PendingInner,
        }
    }

    enum PendingInner {
        Request(PendingRequest),
        Error(Option<crate::Error>),
    }

    pin_project! {
        struct PendingRequest {
            method: Method,
            url: Url,
            headers: HeaderMap,
            body: Option<Option<Bytes>>,

            urls: Vec<Url>,

            retry_count: usize,

            client: Arc<ClientRef>,

            #[pin]
            in_flight: ResponseFuture,
            #[pin]
            total_timeout: Option<Pin<Box<Sleep>>>,
            #[pin]
            read_timeout_fut: Option<Pin<Box<Sleep>>>,
            read_timeout: Option<Duration>,
        }
    }

    enum ResponseFuture {
        Default(HyperResponseFuture),
        #[cfg(feature = "http3")]
        H3(H3ResponseFuture),
    }

    impl PendingRequest {
        fn in_flight(self: Pin<&mut Self>) -> Pin<&mut ResponseFuture> {
            self.project().in_flight
        }

        fn total_timeout(self: Pin<&mut Self>) -> Pin<&mut Option<Pin<Box<Sleep>>>> {
            self.project().total_timeout
        }

        fn read_timeout(self: Pin<&mut Self>) -> Pin<&mut Option<Pin<Box<Sleep>>>> {
            self.project().read_timeout_fut
        }

        fn urls(self: Pin<&mut Self>) -> &mut Vec<Url> {
            self.project().urls
        }

        fn headers(self: Pin<&mut Self>) -> &mut HeaderMap {
            self.project().headers
        }

        #[cfg(any(feature = "http2", feature = "http3"))]
        fn retry_error(mut self: Pin<&mut Self>, err: &(dyn std::error::Error + 'static)) -> bool {
            use log::trace;

            if !is_retryable_error(err) {
                return false;
            }

            trace!("can retry {err:?}");

            let body = match self.body {
                Some(Some(ref body)) => Body::reusable(body.clone()),
                Some(None) => {
                    debug!("error was retryable, but body not reusable");
                    return false;
                }
                None => Body::empty(),
            };

            if self.retry_count >= 2 {
                trace!("retry count too high");
                return false;
            }
            self.retry_count += 1;

            // If it parsed once, it should parse again
            let uri = try_uri(&self.url).expect("URL was already validated as URI");

            *self.as_mut().in_flight().get_mut() = match *self.as_mut().in_flight().as_ref() {
                #[cfg(feature = "http3")]
                ResponseFuture::H3(_) => {
                    let mut req = hyper::Request::builder()
                        .method(self.method.clone())
                        .uri(uri)
                        .body(body)
                        .expect("valid request parts");
                    *req.headers_mut() = self.headers.clone();
                    ResponseFuture::H3(
                        self.client
                            .h3_client
                            .as_ref()
                            .expect("H3 client must exists, otherwise we can't have a h3 request here")
                            .request(req),
                    )
                }
                _ => {
                    let mut req = hyper::Request::builder()
                        .method(self.method.clone())
                        .uri(uri)
                        .body(body)
                        .expect("valid request parts");
                    *req.headers_mut() = self.headers.clone();
                    ResponseFuture::Default(self.client.hyper.request(req))
                }
            };

            true
        }
    }

    #[cfg(any(feature = "http2", feature = "http3"))]
    fn is_retryable_error(err: &(dyn std::error::Error + 'static)) -> bool {
        // pop the legacy::Error
        let err = if let Some(err) = err.source() {
            err
        } else {
            return false;
        };

        #[cfg(feature = "http3")]
        if let Some(cause) = err.source() {
            if let Some(err) = cause.downcast_ref::<h3::error::ConnectionError>() {
                debug!("determining if HTTP/3 error {err} can be retried");
                // TODO: Does h3 provide an API for checking the error?
                return err.to_string().as_str() == "timeout";
            }
        }

        #[cfg(feature = "http2")]
        if let Some(cause) = err.source() {
            if let Some(err) = cause.downcast_ref::<h2::Error>() {
                // They sent us a graceful shutdown, try with a new connection!
                if err.is_go_away() && err.is_remote() && err.reason() == Some(h2::Reason::NO_ERROR) {
                    return true;
                }

                // REFUSED_STREAM was sent from the server, which is safe to retry.
                // https://www.rfc-editor.org/rfc/rfc9113.html#section-8.7-3.2
                if err.is_reset() && err.is_remote() && err.reason() == Some(h2::Reason::REFUSED_STREAM)
                {
                    return true;
                }
            }
        }
        false
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `PendingRequest` struct handle retryable errors in HTTP/2 or HTTP/3 protocols?
  codeQuestion3: What is the role of the `fmt_fields` method in the `ClientRef` struct and how does it contribute to debugging?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Pending {
        pub(super) fn new_err(err: crate::Error) -> Pending {
            Pending {
                inner: PendingInner::Error(Some(err)),
            }
        }

        fn inner(self: Pin<&mut Self>) -> Pin<&mut PendingInner> {
            self.project().inner
        }
    }

    impl Future for Pending {
        type Output = Result<Response, crate::Error>;

        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            let inner = self.inner();
            match inner.get_mut() {
                PendingInner::Request(ref mut req) => Pin::new(req).poll(cx),
                PendingInner::Error(ref mut err) => Poll::Ready(Err(err
                    .take()
                    .expect("Pending error polled more than once"))),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Pending` struct handle errors when a request fails during polling?
  codeQuestion3: What is the role of the `inner` method in the `Pending` struct and how does it contribute to the overall functionality?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Future for PendingRequest {
        type Output = Result<Response, crate::Error>;

        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            if let Some(delay) = self.as_mut().total_timeout().as_mut().as_pin_mut() {
                if let Poll::Ready(()) = delay.poll(cx) {
                    return Poll::Ready(Err(
                        crate::error::request(crate::error::TimedOut).with_url(self.url.clone())
                    ));
                }
            }

            if let Some(delay) = self.as_mut().read_timeout().as_mut().as_pin_mut() {
                if let Poll::Ready(()) = delay.poll(cx) {
                    return Poll::Ready(Err(
                        crate::error::request(crate::error::TimedOut).with_url(self.url.clone())
                    ));
                }
            }

            loop {
                let res = match self.as_mut().in_flight().get_mut() {
                    ResponseFuture::Default(r) => match Pin::new(r).poll(cx) {
                        Poll::Ready(Err(e)) => {
                            #[cfg(feature = "http2")]
                            if self.as_mut().retry_error(&e) {
                                continue;
                            }
                            return Poll::Ready(Err(
                                crate::error::request(e).with_url(self.url.clone())
                            ));
                        }
                        Poll::Ready(Ok(res)) => res.map(super::body::boxed),
                        Poll::Pending => return Poll::Pending,
                    },
                    #[cfg(feature = "http3")]
                    ResponseFuture::H3(r) => match Pin::new(r).poll(cx) {
                        Poll::Ready(Err(e)) => {
                            if self.as_mut().retry_error(&e) {
                                continue;
                            }
                            return Poll::Ready(Err(
                                crate::error::request(e).with_url(self.url.clone())
                            ));
                        }
                        Poll::Ready(Ok(res)) => res,
                        Poll::Pending => return Poll::Pending,
                    },
                };

                #[cfg(feature = "cookies")]
                {
                    if let Some(ref cookie_store) = self.client.cookie_store {
                        let mut cookies =
                            cookie::extract_response_cookie_headers(&res.headers()).peekable();
                        if cookies.peek().is_some() {
                            cookie_store.set_cookies(&mut cookies, &self.url);
                        }
                    }
                }
                let should_redirect = match res.status() {
                    StatusCode::MOVED_PERMANENTLY | StatusCode::FOUND | StatusCode::SEE_OTHER => {
                        self.body = None;
                        for header in &[
                            TRANSFER_ENCODING,
                            CONTENT_ENCODING,
                            CONTENT_TYPE,
                            CONTENT_LENGTH,
                        ] {
                            self.headers.remove(header);
                        }

                        match self.method {
                            Method::GET | Method::HEAD => {}
                            _ => {
                                self.method = Method::GET;
                            }
                        }
                        true
                    }
                    StatusCode::TEMPORARY_REDIRECT | StatusCode::PERMANENT_REDIRECT => {
                        match self.body {
                            Some(Some(_)) | None => true,
                            Some(None) => false,
                        }
                    }
                    _ => false,
                };
                if should_redirect {
                    let loc = res.headers().get(LOCATION).and_then(|val| {
                        let loc = (|| -> Option<Url> {
                            // Some sites may send a UTF-8 Location header,
                            // even though we're supposed to treat those bytes
                            // as opaque, we'll check specifically for utf8.
                            self.url.join(str::from_utf8(val.as_bytes()).ok()?).ok()
                        })();

                        // Check that the `url` is also a valid `http::Uri`.
                        //
                        // If not, just log it and skip the redirect.
                        let loc = loc.and_then(|url| {
                            if try_uri(&url).is_ok() {
                                Some(url)
                            } else {
                                None
                            }
                        });

                        if loc.is_none() {
                            debug!("Location header had invalid URI: {val:?}");
                        }
                        loc
                    });
                    if let Some(loc) = loc {
                        if self.client.referer {
                            if let Some(referer) = make_referer(&loc, &self.url) {
                                self.headers.insert(REFERER, referer);
                            }
                        }
                        let url = self.url.clone();
                        self.as_mut().urls().push(url);
                        let action = self
                            .client
                            .redirect_policy
                            .check(res.status(), &loc, &self.urls);

                        match action {
                            redirect::ActionKind::Follow => {
                                debug!("redirecting '{}' to '{}'", self.url, loc);

                                if loc.scheme() != "http" && loc.scheme() != "https" {
                                    return Poll::Ready(Err(error::url_bad_scheme(loc)));
                                }

                                if self.client.https_only && loc.scheme() != "https" {
                                    return Poll::Ready(Err(error::redirect(
                                        error::url_bad_scheme(loc.clone()),
                                        loc,
                                    )));
                                }

                                self.url = loc;
                                let mut headers =
                                    std::mem::replace(self.as_mut().headers(), HeaderMap::new());

                                remove_sensitive_headers(&mut headers, &self.url, &self.urls);
                                let uri = try_uri(&self.url)?;
                                let body = match self.body {
                                    Some(Some(ref body)) => Body::reusable(body.clone()),
                                    _ => Body::empty(),
                                };

                                // Add cookies from the cookie store.
                                #[cfg(feature = "cookies")]
                                {
                                    if let Some(ref cookie_store) = self.client.cookie_store {
                                        add_cookie_header(&mut headers, &**cookie_store, &self.url);
                                    }
                                }

                                *self.as_mut().in_flight().get_mut() =
                                    match *self.as_mut().in_flight().as_ref() {
                                        #[cfg(feature = "http3")]
                                        ResponseFuture::H3(_) => {
                                            let mut req = hyper::Request::builder()
                                                .method(self.method.clone())
                                                .uri(uri.clone())
                                                .body(body)
                                                .expect("valid request parts");
                                            *req.headers_mut() = headers.clone();
                                            std::mem::swap(self.as_mut().headers(), &mut headers);
                                            ResponseFuture::H3(self.client.h3_client
                            .as_ref()
                            .expect("H3 client must exists, otherwise we can't have a h3 request here")
                                                .request(req))
                                        }
                                        _ => {
                                            let mut req = hyper::Request::builder()
                                                .method(self.method.clone())
                                                .uri(uri.clone())
                                                .body(body)
                                                .expect("valid request parts");
                                            *req.headers_mut() = headers.clone();
                                            std::mem::swap(self.as_mut().headers(), &mut headers);
                                            ResponseFuture::Default(self.client.hyper.request(req))
                                        }
                                    };

                                continue;
                            }
                            redirect::ActionKind::Stop => {
                                debug!("redirect policy disallowed redirection to '{loc}'");
                            }
                            redirect::ActionKind::Error(err) => {
                                return Poll::Ready(Err(crate::error::redirect(err, self.url.clone())));
                            }
                        }
                    }
                }

                let res = Response::new(
                    res,
                    self.url.clone(),
                    self.client.accepts,
                    self.total_timeout.take(),
                    self.read_timeout,
                );
                return Poll::Ready(Ok(res));
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle response redirections when a 301 or 302 status code is received?
  codeQuestion3: What steps are taken to manage timeouts for both the request and response in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Pending {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self.inner {
                PendingInner::Request(ref req) => f
                    .debug_struct("Pending")
                    .field("method", &req.method)
                    .field("url", &req.url)
                    .finish(),
                PendingInner::Error(ref err) => f.debug_struct("Pending").field("error", err).finish(),
            }
        }
    }

    fn make_referer(next: &Url, previous: &Url) -> Option<HeaderValue> {
        if next.scheme() == "http" && previous.scheme() == "https" {
            return None;
        }

        let mut referer = previous.clone();
        let _ = referer.set_username("");
        let _ = referer.set_password(None);
        referer.set_fragment(None);
        referer.as_str().parse().ok()
    }

    #[cfg(feature = "cookies")]
    fn add_cookie_header(headers: &mut HeaderMap, cookie_store: &dyn cookie::CookieStore, url: &Url) {
        if let Some(header) = cookie_store.cookies(url) {
            headers.insert(crate::header::COOKIE, header);
        }
    }

    #[cfg(test)]
    mod tests {
        #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]

        #[tokio::test]
        async fn execute_request_rejects_invalid_urls() {
            let url_str = "hxxps://www.rust-lang.org/";
            let url = url::Url::parse(url_str).unwrap();
            let result = crate::get(url.clone()).await;

            assert!(result.is_err());
            let err = result.err().unwrap();
            assert!(err.is_builder());
            assert_eq!(url_str, err.url().unwrap().as_str());
        }

        /// https://github.com/seanmonstar/reqwest/issues/668
        #[tokio::test]
        async fn execute_request_rejects_invalid_hostname() {
            let url_str = "https://{{hostname}}/";
            let url = url::Url::parse(url_str).unwrap();
            let result = crate::get(url.clone()).await;

            assert!(result.is_err());
            let err = result.err().unwrap();
            assert!(err.is_builder());
            assert_eq!(url_str, err.url().unwrap().as_str());
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `make_referer` function determine when to omit the Referer header in HTTP requests?
  codeQuestion3: What steps are taken in the `add_cookie_header` function to include cookies in HTTP headers?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/body.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::fmt;
    use std::future::Future;
    use std::pin::Pin;
    use std::task::{ready, Context, Poll};
    use std::time::Duration;

    use bytes::Bytes;
    use http_body::Body as HttpBody;
    use http_body_util::combinators::BoxBody;
    //use sync_wrapper::SyncWrapper;
    use pin_project_lite::pin_project;
    #[cfg(feature = "stream")]
    use tokio::fs::File;
    use tokio::time::Sleep;
    #[cfg(feature = "stream")]
    use tokio_util::io::ReaderStream;

    /// An asynchronous request body.
    pub struct Body {
        inner: Inner,
    }

    enum Inner {
        Reusable(Bytes),
        Streaming(BoxBody<Bytes, Box<dyn std::error::Error + Send + Sync>>),
    }

    pin_project! {
        /// A body with a total timeout.
        ///
        /// The timeout does not reset upon each chunk, but rather requires the whole
        /// body be streamed before the deadline is reached.
        pub(crate) struct TotalTimeoutBody<B> {
            #[pin]
            inner: B,
            timeout: Pin<Box<Sleep>>,
        }
    }

    pin_project! {
        pub(crate) struct ReadTimeoutBody<B> {
            #[pin]
            inner: B,
            #[pin]
            sleep: Option<Sleep>,
            timeout: Duration,
        }
    }

    /// Converts any `impl Body` into a `impl Stream` of just its DATA frames.
    #[cfg(any(feature = "stream", feature = "multipart",))]
    pub(crate) struct DataStream<B>(pub(crate) B);

    impl Body {
        /// Returns a reference to the internal data of the `Body`.
        ///
        /// `None` is returned, if the underlying data is a stream.
        pub fn as_bytes(&self) -> Option<&[u8]> {
            match &self.inner {
                Inner::Reusable(bytes) => Some(bytes.as_ref()),
                Inner::Streaming(..) => None,
            }
        }

        /// Wrap a futures `Stream` in a box inside `Body`.
        ///
        /// # Example
        ///
        /// ```
        /// # use reqwest::Body;
        /// # use futures_util;
        /// # fn main() {
        /// let chunks: Vec<Result<_, ::std::io::Error>> = vec![
        ///     Ok("hello"),
        ///     Ok(" "),
        ///     Ok("world"),
        /// ];
        ///
        /// let stream = futures_util::stream::iter(chunks);
        ///
        /// let body = Body::wrap_stream(stream);
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the `stream` feature to be enabled.
        #[cfg(feature = "stream")]
        #[cfg_attr(docsrs, doc(cfg(feature = "stream")))]
        pub fn wrap_stream<S>(stream: S) -> Body
        where
            S: futures_core::stream::TryStream + Send + 'static,
            S::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
            Bytes: From<S::Ok>,
        {
            Body::stream(stream)
        }

        #[cfg(any(feature = "stream", feature = "multipart", feature = "blocking"))]
        pub(crate) fn stream<S>(stream: S) -> Body
        where
            S: futures_core::stream::TryStream + Send + 'static,
            S::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
            Bytes: From<S::Ok>,
        {
            use futures_util::TryStreamExt;
            use http_body::Frame;
            use http_body_util::StreamBody;

            let body = http_body_util::BodyExt::boxed(StreamBody::new(sync_wrapper::SyncStream::new(
                stream
                    .map_ok(|d| Frame::data(Bytes::from(d)))
                    .map_err(Into::into),
            )));
            Body {
                inner: Inner::Streaming(body),
            }
        }

        pub(crate) fn empty() -> Body {
            Body::reusable(Bytes::new())
        }

        pub(crate) fn reusable(chunk: Bytes) -> Body {
            Body {
                inner: Inner::Reusable(chunk),
            }
        }

        /// Wrap a [`HttpBody`] in a box inside `Body`.
        ///
        /// # Example
        ///
        /// ```
        /// # use reqwest::Body;
        /// # use futures_util;
        /// # fn main() {
        /// let content = "hello,world!".to_string();
        ///
        /// let body = Body::wrap(content);
        /// # }
        /// ```
        pub fn wrap<B>(inner: B) -> Body
        where
            B: HttpBody + Send + Sync + 'static,
            B::Data: Into<Bytes>,
            B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
        {
            use http_body_util::BodyExt;

            let boxed = IntoBytesBody { inner }.map_err(Into::into).boxed();

            Body {
                inner: Inner::Streaming(boxed),
            }
        }

        pub(crate) fn try_reuse(self) -> (Option<Bytes>, Self) {
            let reuse = match self.inner {
                Inner::Reusable(ref chunk) => Some(chunk.clone()),
                Inner::Streaming { .. } => None,
            };

            (reuse, self)
        }

        pub(crate) fn try_clone(&self) -> Option<Body> {
            match self.inner {
                Inner::Reusable(ref chunk) => Some(Body::reusable(chunk.clone())),
                Inner::Streaming { .. } => None,
            }
        }

        #[cfg(feature = "multipart")]
        pub(crate) fn into_stream(self) -> DataStream<Body> {
            DataStream(self)
        }

        #[cfg(feature = "multipart")]
        pub(crate) fn content_length(&self) -> Option<u64> {
            match self.inner {
                Inner::Reusable(ref bytes) => Some(bytes.len() as u64),
                Inner::Streaming(ref body) => body.size_hint().exact(),
            }
        }
    }

    impl Default for Body {
        #[inline]
        fn default() -> Body {
            Body::empty()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer create a custom HTTP body that streams data with a read timeout, and what system calls or API methods are involved in this process?
  codeQuestion3: What steps are taken to convert a synchronous stream into an asynchronous HTTP body, and what API methods or system calls are used in this conversion?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/body.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /*
    impl From<hyper::Body> for Body {
        #[inline]
        fn from(body: hyper::Body) -> Body {
            Self {
                inner: Inner::Streaming {
                    body: Box::pin(WrapHyper(body)),
                },
            }
        }
    }
    */

    impl From<Bytes> for Body {
        #[inline]
        fn from(bytes: Bytes) -> Body {
            Body::reusable(bytes)
        }
    }

    impl From<Vec<u8>> for Body {
        #[inline]
        fn from(vec: Vec<u8>) -> Body {
            Body::reusable(vec.into())
        }
    }

    impl From<&'static [u8]> for Body {
        #[inline]
        fn from(s: &'static [u8]) -> Body {
            Body::reusable(Bytes::from_static(s))
        }
    }

    impl From<String> for Body {
        #[inline]
        fn from(s: String) -> Body {
            Body::reusable(s.into())
        }
    }

    impl From<&'static str> for Body {
        #[inline]
        fn from(s: &'static str) -> Body {
            s.as_bytes().into()
        }
    }

    #[cfg(feature = "stream")]
    #[cfg_attr(docsrs, doc(cfg(feature = "stream")))]
    impl From<File> for Body {
        #[inline]
        fn from(file: File) -> Body {
            Body::wrap_stream(ReaderStream::new(file))
        }
    }

    impl fmt::Debug for Body {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Body").finish()
        }
    }

    impl HttpBody for Body {
        type Data = Bytes;
        type Error = crate::Error;

        fn poll_frame(
            mut self: Pin<&mut Self>,
            cx: &mut Context,
        ) -> Poll<Option<Result<hyper::body::Frame<Self::Data>, Self::Error>>> {
            match self.inner {
                Inner::Reusable(ref mut bytes) => {
                    let out = bytes.split_off(0);
                    if out.is_empty() {
                        Poll::Ready(None)
                    } else {
                        Poll::Ready(Some(Ok(hyper::body::Frame::data(out))))
                    }
                }
                Inner::Streaming(ref mut body) => Poll::Ready(
                    ready!(Pin::new(body).poll_frame(cx))
                        .map(|opt_chunk| opt_chunk.map_err(crate::error::body)),
                ),
            }
        }

        fn size_hint(&self) -> http_body::SizeHint {
            match self.inner {
                Inner::Reusable(ref bytes) => http_body::SizeHint::with_exact(bytes.len() as u64),
                Inner::Streaming(ref body) => body.size_hint(),
            }
        }

        fn is_end_stream(&self) -> bool {
            match self.inner {
                Inner::Reusable(ref bytes) => bytes.is_empty(),
                Inner::Streaming(ref body) => body.is_end_stream(),
            }
        }
    }

    // ===== impl TotalTimeoutBody =====

    pub(crate) fn total_timeout<B>(body: B, timeout: Pin<Box<Sleep>>) -> TotalTimeoutBody<B> {
        TotalTimeoutBody {
            inner: body,
            timeout,
        }
    }

    pub(crate) fn with_read_timeout<B>(body: B, timeout: Duration) -> ReadTimeoutBody<B> {
        ReadTimeoutBody {
            inner: body,
            sleep: None,
            timeout,
        }
    }

    impl<B> hyper::body::Body for TotalTimeoutBody<B>
    where
        B: hyper::body::Body,
        B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        type Data = B::Data;
        type Error = crate::Error;

        fn poll_frame(
            self: Pin<&mut Self>,
            cx: &mut Context,
        ) -> Poll<Option<Result<hyper::body::Frame<Self::Data>, Self::Error>>> {
            let this = self.project();
            if let Poll::Ready(()) = this.timeout.as_mut().poll(cx) {
                return Poll::Ready(Some(Err(crate::error::body(crate::error::TimedOut))));
            }
            Poll::Ready(
                ready!(this.inner.poll_frame(cx))
                    .map(|opt_chunk| opt_chunk.map_err(crate::error::body)),
            )
        }

        #[inline]
        fn size_hint(&self) -> http_body::SizeHint {
            self.inner.size_hint()
        }

        #[inline]
        fn is_end_stream(&self) -> bool {
            self.inner.is_end_stream()
        }
    }

    impl<B> hyper::body::Body for ReadTimeoutBody<B>
    where
        B: hyper::body::Body,
        B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        type Data = B::Data;
        type Error = crate::Error;

        fn poll_frame(
            self: Pin<&mut Self>,
            cx: &mut Context,
        ) -> Poll<Option<Result<hyper::body::Frame<Self::Data>, Self::Error>>> {
            let mut this = self.project();

            // Start the `Sleep` if not active.
            let sleep_pinned = if let Some(some) = this.sleep.as_mut().as_pin_mut() {
                some
            } else {
                this.sleep.set(Some(tokio::time::sleep(*this.timeout)));
                this.sleep.as_mut().as_pin_mut().unwrap()
            };

            // Error if the timeout has expired.
            if let Poll::Ready(()) = sleep_pinned.poll(cx) {
                return Poll::Ready(Some(Err(crate::error::body(crate::error::TimedOut))));
            }

            let item = ready!(this.inner.poll_frame(cx))
                .map(|opt_chunk| opt_chunk.map_err(crate::error::body));
            // a ready frame means timeout is reset
            this.sleep.set(None);
            Poll::Ready(item)
        }

        #[inline]
        fn size_hint(&self) -> http_body::SizeHint {
            self.inner.size_hint()
        }

        #[inline]
        fn is_end_stream(&self) -> bool {
            self.inner.is_end_stream()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user create a body from a file stream, and what system calls or API methods are involved in this process?
  codeQuestion3: What steps are taken to handle timeouts when sending data over a network using this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/body.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub(crate) type ResponseBody =
        http_body_util::combinators::BoxBody<Bytes, Box<dyn std::error::Error + Send + Sync>>;

    pub(crate) fn boxed<B>(body: B) -> ResponseBody
    where
        B: hyper::body::Body<Data = Bytes> + Send + Sync + 'static,
        B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        use http_body_util::BodyExt;

        body.map_err(box_err).boxed()
    }

    pub(crate) fn response<B>(
        body: B,
        deadline: Option<Pin<Box<Sleep>>>,
        read_timeout: Option<Duration>,
    ) -> ResponseBody
    where
        B: hyper::body::Body<Data = Bytes> + Send + Sync + 'static,
        B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        use http_body_util::BodyExt;

        match (deadline, read_timeout) {
            (Some(total), Some(read)) => {
                let body = with_read_timeout(body, read).map_err(box_err);
                total_timeout(body, total).map_err(box_err).boxed()
            }
            (Some(total), None) => total_timeout(body, total).map_err(box_err).boxed(),
            (None, Some(read)) => with_read_timeout(body, read).map_err(box_err).boxed(),
            (None, None) => body.map_err(box_err).boxed(),
        }
    }

    fn box_err<E>(err: E) -> Box<dyn std::error::Error + Send + Sync>
    where
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        err.into()
    }

    // ===== impl DataStream =====

    #[cfg(any(feature = "stream", feature = "multipart",))]
    impl<B> futures_core::Stream for DataStream<B>
    where
        B: HttpBody<Data = Bytes> + Unpin,
    {
        type Item = Result<Bytes, B::Error>;

        fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Option<Self::Item>> {
            loop {
                return match ready!(Pin::new(&mut self.0).poll_frame(cx)) {
                    Some(Ok(frame)) => {
                        // skip non-data frames
                        if let Ok(buf) = frame.into_data() {
                            Poll::Ready(Some(Ok(buf)))
                        } else {
                            continue;
                        }
                    }
                    Some(Err(err)) => Poll::Ready(Some(Err(err))),
                    None => Poll::Ready(None),
                };
            }
        }
    }

    // ===== impl IntoBytesBody =====

    pin_project! {
        struct IntoBytesBody<B> {
            #[pin]
            inner: B,
        }
    }

    // We can't use `map_frame()` because that loses the hint data (for good reason).
    // But we aren't transforming the data.
    impl<B> hyper::body::Body for IntoBytesBody<B>
    where
        B: hyper::body::Body,
        B::Data: Into<Bytes>,
    {
        type Data = Bytes;
        type Error = B::Error;

        fn poll_frame(
            self: Pin<&mut Self>,
            cx: &mut Context,
        ) -> Poll<Option<Result<hyper::body::Frame<Self::Data>, Self::Error>>> {
            match ready!(self.project().inner.poll_frame(cx)) {
                Some(Ok(f)) => Poll::Ready(Some(Ok(f.map_data(Into::into)))),
                Some(Err(e)) => Poll::Ready(Some(Err(e))),
                None => Poll::Ready(None),
            }
        }

        #[inline]
        fn size_hint(&self) -> http_body::SizeHint {
            self.inner.size_hint()
        }

        #[inline]
        fn is_end_stream(&self) -> bool {
            self.inner.is_end_stream()
        }
    }

    #[cfg(test)]
    mod tests {
        use http_body::Body as _;

        use super::Body;

        #[test]
        fn test_as_bytes() {
            let test_data = b"Test body";
            let body = Body::from(&test_data[..]);
            assert_eq!(body.as_bytes(), Some(&test_data[..]));
        }

        #[test]
        fn body_exact_length() {
            let empty_body = Body::empty();
            assert!(empty_body.is_end_stream());
            assert_eq!(empty_body.size_hint().exact(), Some(0));

            let bytes_body = Body::reusable("abc".into());
            assert!(!bytes_body.is_end_stream());
            assert_eq!(bytes_body.size_hint().exact(), Some(3));

            // can delegate even when wrapped
            let stream_body = Body::wrap(empty_body);
            assert!(stream_body.is_end_stream());
            assert_eq!(stream_body.size_hint().exact(), Some(0));
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer use the `response` function to handle HTTP requests with specific timeouts, and what parameters are required?
  codeQuestion3: What is the role of the `IntoBytesBody` implementation, and how does it convert different body types into a byte-based format?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! multipart/form-data
    use std::borrow::Cow;
    use std::fmt;
    use std::pin::Pin;

    #[cfg(feature = "stream")]
    use std::io;
    #[cfg(feature = "stream")]
    use std::path::Path;

    use bytes::Bytes;
    use mime_guess::Mime;
    use percent_encoding::{self, AsciiSet, NON_ALPHANUMERIC};
    #[cfg(feature = "stream")]
    use tokio::fs::File;

    use futures_core::Stream;
    use futures_util::{future, stream, StreamExt};

    use super::Body;
    use crate::header::HeaderMap;

    /// An async multipart/form-data request.
    pub struct Form {
        inner: FormParts<Part>,
    }

    /// A field in a multipart form.
    pub struct Part {
        meta: PartMetadata,
        value: Body,
        body_length: Option<u64>,
    }

    pub(crate) struct FormParts<P> {
        pub(crate) boundary: String,
        pub(crate) computed_headers: Vec<Vec<u8>>,
        pub(crate) fields: Vec<(Cow<'static, str>, P)>,
        pub(crate) percent_encoding: PercentEncoding,
    }

    pub(crate) struct PartMetadata {
        mime: Option<Mime>,
        file_name: Option<Cow<'static, str>>,
        pub(crate) headers: HeaderMap,
    }

    pub(crate) trait PartProps {
        fn value_len(&self) -> Option<u64>;
        fn metadata(&self) -> &PartMetadata;
    }

    // ===== impl Form =====

    impl Default for Form {
        fn default() -> Self {
            Self::new()
        }
    }

    impl Form {
        /// Creates a new async Form without any content.
        pub fn new() -> Form {
            Form {
                inner: FormParts::new(),
            }
        }

        /// Get the boundary that this form will use.
        #[inline]
        pub fn boundary(&self) -> &str {
            self.inner.boundary()
        }

        /// Add a data field with supplied name and value.
        ///
        /// # Examples
        ///
        /// ```
        /// let form = reqwest::multipart::Form::new()
        ///     .text("username", "seanmonstar")
        ///     .text("password", "secret");
        /// ```
        pub fn text<T, U>(self, name: T, value: U) -> Form
        where
            T: Into<Cow<'static, str>>,
            U: Into<Cow<'static, str>>,
        {
            self.part(name, Part::text(value))
        }

        /// Adds a file field.
        ///
        /// The path will be used to try to guess the filename and mime.
        ///
        /// # Examples
        ///
        /// ```no_run
        /// # async fn run() -> std::io::Result<()> {
        /// let form = reqwest::multipart::Form::new()
        ///     .file("key", "/path/to/file").await?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Errors
        ///
        /// Errors when the file cannot be opened.
        #[cfg(feature = "stream")]
        #[cfg_attr(docsrs, doc(cfg(feature = "stream")))]
        pub async fn file<T, U>(self, name: T, path: U) -> io::Result<Form>
        where
            T: Into<Cow<'static, str>>,
            U: AsRef<Path>,
        {
            Ok(self.part(name, Part::file(path).await?))
        }

        /// Adds a customized Part.
        pub fn part<T>(self, name: T, part: Part) -> Form
        where
            T: Into<Cow<'static, str>>,
        {
            self.with_inner(move |inner| inner.part(name, part))
        }

        /// Configure this `Form` to percent-encode using the `path-segment` rules.
        pub fn percent_encode_path_segment(self) -> Form {
            self.with_inner(|inner| inner.percent_encode_path_segment())
        }

        /// Configure this `Form` to percent-encode using the `attr-char` rules.
        pub fn percent_encode_attr_chars(self) -> Form {
            self.with_inner(|inner| inner.percent_encode_attr_chars())
        }

        /// Configure this `Form` to skip percent-encoding
        pub fn percent_encode_noop(self) -> Form {
            self.with_inner(|inner| inner.percent_encode_noop())
        }

        /// Consume this instance and transform into an instance of Body for use in a request.
        pub(crate) fn stream(self) -> Body {
            if self.inner.fields.is_empty() {
                return Body::empty();
            }

            Body::stream(self.into_stream())
        }

        /// Produce a stream of the bytes in this `Form`, consuming it.
        pub fn into_stream(mut self) -> impl Stream<Item = Result<Bytes, crate::Error>> + Send + Sync {
            if self.inner.fields.is_empty() {
                let empty_stream: Pin<
                    Box<dyn Stream<Item = Result<Bytes, crate::Error>> + Send + Sync>,
                > = Box::pin(futures_util::stream::empty());
                return empty_stream;
            }

            // create initial part to init reduce chain
            let (name, part) = self.inner.fields.remove(0);
            let start = Box::pin(self.part_stream(name, part))
                as Pin<Box<dyn Stream<Item = crate::Result<Bytes>> + Send + Sync>>;

            let fields = self.inner.take_fields();
            // for each field, chain an additional stream
            let stream = fields.into_iter().fold(start, |memo, (name, part)| {
                let part_stream = self.part_stream(name, part);
                Box::pin(memo.chain(part_stream))
                    as Pin<Box<dyn Stream<Item = crate::Result<Bytes>> + Send + Sync>>
            });
            // append special ending boundary
            let last = stream::once(future::ready(Ok(
                format!("--{}--\r\n", self.boundary()).into()
            )));
            Box::pin(stream.chain(last))
        }

        /// Generate a hyper::Body stream for a single Part instance of a Form request.
        pub(crate) fn part_stream<T>(
            &mut self,
            name: T,
            part: Part,
        ) -> impl Stream<Item = Result<Bytes, crate::Error>>
        where
            T: Into<Cow<'static, str>>,
        {
            // start with boundary
            let boundary = stream::once(future::ready(Ok(
                format!("--{}\r\n", self.boundary()).into()
            )));
            // append headers
            let header = stream::once(future::ready(Ok({
                let mut h = self
                    .inner
                    .percent_encoding
                    .encode_headers(&name.into(), &part.meta);
                h.extend_from_slice(b"\r\n\r\n");
                h.into()
            })));
            // then append form data followed by terminating CRLF
            boundary
                .chain(header)
                .chain(part.value.into_stream())
                .chain(stream::once(future::ready(Ok("\r\n".into()))))
        }

        pub(crate) fn compute_length(&mut self) -> Option<u64> {
            self.inner.compute_length()
        }

        fn with_inner<F>(self, func: F) -> Self
        where
            F: FnOnce(FormParts<Part>) -> FormParts<Part>,
        {
            Form {
                inner: func(self.inner),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user add a file field to the form and what system calls are involved in handling file I/O for this action?
  codeQuestion3: What steps are taken to handle the percent-encoding of form data and how is it applied when generating the multipart request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Form {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.inner.fmt_fields("Form", f)
        }
    }

    // ===== impl Part =====

    impl Part {
        /// Makes a text parameter.
        pub fn text<T>(value: T) -> Part
        where
            T: Into<Cow<'static, str>>,
        {
            let body = match value.into() {
                Cow::Borrowed(slice) => Body::from(slice),
                Cow::Owned(string) => Body::from(string),
            };
            Part::new(body, None)
        }

        /// Makes a new parameter from arbitrary bytes.
        pub fn bytes<T>(value: T) -> Part
        where
            T: Into<Cow<'static, [u8]>>,
        {
            let body = match value.into() {
                Cow::Borrowed(slice) => Body::from(slice),
                Cow::Owned(vec) => Body::from(vec),
            };
            Part::new(body, None)
        }

        /// Makes a new parameter from an arbitrary stream.
        pub fn stream<T: Into<Body>>(value: T) -> Part {
            Part::new(value.into(), None)
        }

        /// Makes a new parameter from an arbitrary stream with a known length. This is particularly
        /// useful when adding something like file contents as a stream, where you can know the content
        /// length beforehand.
        pub fn stream_with_length<T: Into<Body>>(value: T, length: u64) -> Part {
            Part::new(value.into(), Some(length))
        }

        /// Makes a file parameter.
        ///
        /// # Errors
        ///
        /// Errors when the file cannot be opened.
        #[cfg(feature = "stream")]
        #[cfg_attr(docsrs, doc(cfg(feature = "stream")))]
        pub async fn file<T: AsRef<Path>>(path: T) -> io::Result<Part> {
            let path = path.as_ref();
            let file_name = path
                .file_name()
                .map(|filename| filename.to_string_lossy().into_owned());
            let ext = path.extension().and_then(|ext| ext.to_str()).unwrap_or("");
            let mime = mime_guess::from_ext(ext).first_or_octet_stream();
            let file = File::open(path).await?;
            let len = file.metadata().await.map(|m| m.len()).ok();
            let field = match len {
                Some(len) => Part::stream_with_length(file, len),
                None => Part::stream(file),
            }
            .mime(mime);

            Ok(if let Some(file_name) = file_name {
                field.file_name(file_name)
            } else {
                field
            })
        }

        fn new(value: Body, body_length: Option<u64>) -> Part {
            Part {
                meta: PartMetadata::new(),
                value,
                body_length,
            }
        }

        /// Tries to set the mime of this part.
        pub fn mime_str(self, mime: &str) -> crate::Result<Part> {
            Ok(self.mime(mime.parse().map_err(crate::error::builder)?))
        }

        // Re-export when mime 0.4 is available, with split MediaType/MediaRange.
        fn mime(self, mime: Mime) -> Part {
            self.with_inner(move |inner| inner.mime(mime))
        }

        /// Sets the filename, builder style.
        pub fn file_name<T>(self, filename: T) -> Part
        where
            T: Into<Cow<'static, str>>,
        {
            self.with_inner(move |inner| inner.file_name(filename))
        }

        /// Sets custom headers for the part.
        pub fn headers(self, headers: HeaderMap) -> Part {
            self.with_inner(move |inner| inner.headers(headers))
        }

        fn with_inner<F>(self, func: F) -> Self
        where
            F: FnOnce(PartMetadata) -> PartMetadata,
        {
            Part {
                meta: func(self.meta),
                ..self
            }
        }
    }

    impl fmt::Debug for Part {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut dbg = f.debug_struct("Part");
            dbg.field("value", &self.value);
            self.meta.fmt_fields(&mut dbg);
            dbg.finish()
        }
    }

    impl PartProps for Part {
        fn value_len(&self) -> Option<u64> {
            if self.body_length.is_some() {
                self.body_length
            } else {
                self.value.content_length()
            }
        }

        fn metadata(&self) -> &PartMetadata {
            &self.meta
        }
    }

    // ===== impl FormParts =====

    impl<P: PartProps> FormParts<P> {
        pub(crate) fn new() -> Self {
            FormParts {
                boundary: gen_boundary(),
                computed_headers: Vec::new(),
                fields: Vec::new(),
                percent_encoding: PercentEncoding::PathSegment,
            }
        }

        pub(crate) fn boundary(&self) -> &str {
            &self.boundary
        }

        /// Adds a customized Part.
        pub(crate) fn part<T>(mut self, name: T, part: P) -> Self
        where
            T: Into<Cow<'static, str>>,
        {
            self.fields.push((name.into(), part));
            self
        }

        /// Configure this `Form` to percent-encode using the `path-segment` rules.
        pub(crate) fn percent_encode_path_segment(mut self) -> Self {
            self.percent_encoding = PercentEncoding::PathSegment;
            self
        }

        /// Configure this `Form` to percent-encode using the `attr-char` rules.
        pub(crate) fn percent_encode_attr_chars(mut self) -> Self {
            self.percent_encoding = PercentEncoding::AttrChar;
            self
        }

        /// Configure this `Form` to skip percent-encoding
        pub(crate) fn percent_encode_noop(mut self) -> Self {
            self.percent_encoding = PercentEncoding::NoOp;
            self
        }

        // If predictable, computes the length the request will have
        // The length should be preditable if only String and file fields have been added,
        // but not if a generic reader has been added;
        pub(crate) fn compute_length(&mut self) -> Option<u64> {
            let mut length = 0u64;
            for &(ref name, ref field) in self.fields.iter() {
                match field.value_len() {
                    Some(value_length) => {
                        // We are constructing the header just to get its length. To not have to
                        // construct it again when the request is sent we cache these headers.
                        let header = self.percent_encoding.encode_headers(name, field.metadata());
                        let header_length = header.len();
                        self.computed_headers.push(header);
                        // The additions mimic the format string out of which the field is constructed
                        // in Reader. Not the cleanest solution because if that format string is
                        // ever changed then this formula needs to be changed too which is not an
                        // obvious dependency in the code.
                        length += 2
                            + self.boundary().len() as u64
                            + 2
                            + header_length as u64
                            + 4
                            + value_length
                            + 2
                    }
                    _ => return None,
                }
            }
            // If there is at least one field there is a special boundary for the very last field.
            if !self.fields.is_empty() {
                length += 2 + self.boundary().len() as u64 + 4
            }
            Some(length)
        }

        /// Take the fields vector of this instance, replacing with an empty vector.
        fn take_fields(&mut self) -> Vec<(Cow<'static, str>, P)> {
            std::mem::replace(&mut self.fields, Vec::new())
        }
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How can a user create a multipart form with text and file fields, and what APIs are used for that?
  codeQuestion3: What steps are taken in the `compute_length` method to determine the expected request length for a multipart form submission?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl<P: fmt::Debug> FormParts<P> {
        pub(crate) fn fmt_fields(&self, ty_name: &'static str, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct(ty_name)
                .field("boundary", &self.boundary)
                .field("parts", &self.fields)
                .finish()
        }
    }

    // ===== impl PartMetadata =====

    impl PartMetadata {
        pub(crate) fn new() -> Self {
            PartMetadata {
                mime: None,
                file_name: None,
                headers: HeaderMap::default(),
            }
        }

        pub(crate) fn mime(mut self, mime: Mime) -> Self {
            self.mime = Some(mime);
            self
        }

        pub(crate) fn file_name<T>(mut self, filename: T) -> Self
        where
            T: Into<Cow<'static, str>>,
        {
            self.file_name = Some(filename.into());
            self
        }

        pub(crate) fn headers<T>(mut self, headers: T) -> Self
        where
            T: Into<HeaderMap>,
        {
            self.headers = headers.into();
            self
        }
    }

    impl PartMetadata {
        pub(crate) fn fmt_fields<'f, 'fa, 'fb>(
            &self,
            debug_struct: &'f mut fmt::DebugStruct<'fa, 'fb>,
        ) -> &'f mut fmt::DebugStruct<'fa, 'fb> {
            debug_struct
                .field("mime", &self.mime)
                .field("file_name", &self.file_name)
                .field("headers", &self.headers)
        }
    }

    // https://url.spec.whatwg.org/#fragment-percent-encode-set
    const FRAGMENT_ENCODE_SET: &AsciiSet = &percent_encoding::CONTROLS
        .add(b' ')
        .add(b'"')
        .add(b'<')
        .add(b'>')
        .add(b'`');

    // https://url.spec.whatwg.org/#path-percent-encode-set
    const PATH_ENCODE_SET: &AsciiSet = &FRAGMENT_ENCODE_SET.add(b'#').add(b'?').add(b'{').add(b'}');

    const PATH_SEGMENT_ENCODE_SET: &AsciiSet = &PATH_ENCODE_SET.add(b'/').add(b'%');

    // https://tools.ietf.org/html/rfc8187#section-3.2.1
    const ATTR_CHAR_ENCODE_SET: &AsciiSet = &NON_ALPHANUMERIC
        .remove(b'!')
        .remove(b'#')
        .remove(b'$')
        .remove(b'&')
        .remove(b'+')
        .remove(b'-')
        .remove(b'.')
        .remove(b'^')
        .remove(b'_')
        .remove(b'`')
        .remove(b'|')
        .remove(b'~');

    pub(crate) enum PercentEncoding {
        PathSegment,
        AttrChar,
        NoOp,
    }

    impl PercentEncoding {
        pub(crate) fn encode_headers(&self, name: &str, field: &PartMetadata) -> Vec<u8> {
            let mut buf = Vec::new();
            buf.extend_from_slice(b"Content-Disposition: form-data; ");

            match self.percent_encode(name) {
                Cow::Borrowed(value) => {
                    // nothing has been percent encoded
                    buf.extend_from_slice(b"name=\"");
                    buf.extend_from_slice(value.as_bytes());
                    buf.extend_from_slice(b"\"");
                }
                Cow::Owned(value) => {
                    // something has been percent encoded
                    buf.extend_from_slice(b"name*=utf-8''");
                    buf.extend_from_slice(value.as_bytes());
                }
            }

            // According to RFC7578 Section 4.2, `filename*=` syntax is invalid.
            // See https://github.com/seanmonstar/reqwest/issues/419.
            if let Some(filename) = &field.file_name {
                buf.extend_from_slice(b"; filename=\"");
                let legal_filename = filename
                    .replace('\\', "\\\\")
                    .replace('"', "\\\"")
                    .replace('\r', "\\\r")
                    .replace('\n', "\\\n");
                buf.extend_from_slice(legal_filename.as_bytes());
                buf.extend_from_slice(b"\"");
            }

            if let Some(mime) = &field.mime {
                buf.extend_from_slice(b"\r\nContent-Type: ");
                buf.extend_from_slice(mime.as_ref().as_bytes());
            }

            for (k, v) in field.headers.iter() {
                buf.extend_from_slice(b"\r\n");
                buf.extend_from_slice(k.as_str().as_bytes());
                buf.extend_from_slice(b": ");
                buf.extend_from_slice(v.as_bytes());
            }
            buf
        }

        fn percent_encode<'a>(&self, value: &'a str) -> Cow<'a, str> {
            use percent_encoding::utf8_percent_encode as percent_encode;

            match self {
                Self::PathSegment => percent_encode(value, PATH_SEGMENT_ENCODE_SET).into(),
                Self::AttrChar => percent_encode(value, ATTR_CHAR_ENCODE_SET).into(),
                Self::NoOp => value.into(),
            }
        }
    }

    fn gen_boundary() -> String {
        use crate::util::fast_random as random;

        let a = random();
        let b = random();
        let c = random();
        let d = random();

        format!("{a:016x}-{b:016x}-{c:016x}-{d:016x}")
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use futures_util::TryStreamExt;
        use futures_util::{future, stream};
        use tokio::{self, runtime};

        #[test]
        fn form_empty() {
            let form = Form::new();

            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let body = form.stream().into_stream();
            let s = body.map_ok(|try_c| try_c.to_vec()).try_concat();

            let out = rt.block_on(s);
            assert!(out.unwrap().is_empty());
        }

        #[test]
        fn stream_to_end() {
            let mut form = Form::new()
                .part(
                    "reader1",
                    Part::stream(Body::stream(stream::once(future::ready::<
                        Result<String, crate::Error>,
                    >(Ok(
                        "part1".to_owned()
                    ))))),
                )
                .part("key1", Part::text("value1"))
                .part("key2", Part::text("value2").mime(mime::IMAGE_BMP))
                .part(
                    "reader2",
                    Part::stream(Body::stream(stream::once(future::ready::<
                        Result<String, crate::Error>,
                    >(Ok(
                        "part2".to_owned()
                    ))))),
                )
                .part("key3", Part::text("value3").file_name("filename"));
            form.inner.boundary = "boundary".to_string();
            let expected = "--boundary\r\n\
                 Content-Disposition: form-data; name=\"reader1\"\r\n\r\n\
                 part1\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key1\"\r\n\r\n\
                 value1\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key2\"\r\n\
                 Content-Type: image/bmp\r\n\r\n\
                 value2\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"reader2\"\r\n\r\n\
                 part2\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key3\"; filename=\"filename\"\r\n\r\n\
                 value3\r\n--boundary--\r\n";
            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let body = form.stream().into_stream();
            let s = body.map(|try_c| try_c.map(|r| r.to_vec())).try_concat();

            let out = rt.block_on(s).unwrap();
            // These prints are for debug purposes in case the test fails
            println!(
                "START REAL\n{}\nEND REAL",
                std::str::from_utf8(&out).unwrap()
            );
            println!("START EXPECTED\n{expected}\nEND EXPECTED");
            assert_eq!(std::str::from_utf8(&out).unwrap(), expected);
        }

        #[test]
        fn stream_to_end_with_header() {
            let mut part = Part::text("value2").mime(mime::IMAGE_BMP);
            let mut headers = HeaderMap::new();
            headers.insert("Hdr3", "/a/b/c".parse().unwrap());
            part = part.headers(headers);
            let mut form = Form::new().part("key2", part);
            form.inner.boundary = "boundary".to_string();
            let expected = "--boundary\r\n\
                            Content-Disposition: form-data; name=\"key2\"\r\n\
                            Content-Type: image/bmp\r\n\
                            hdr3: /a/b/c\r\n\
                            \r\n\
                            value2\r\n\
                            --boundary--\r\n";
            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let body = form.stream().into_stream();
            let s = body.map(|try_c| try_c.map(|r| r.to_vec())).try_concat();

            let out = rt.block_on(s).unwrap();
            // These prints are for debug purposes in case the test fails
            println!(
                "START REAL\n{}\nEND REAL",
                std::str::from_utf8(&out).unwrap()
            );
            println!("START EXPECTED\n{expected}\nEND EXPECTED");
            assert_eq!(std::str::from_utf8(&out).unwrap(), expected);
        }

        #[test]
        fn correct_content_length() {
            // Setup an arbitrary data stream
            let stream_data = b"just some stream data";
            let stream_len = stream_data.len();
            let stream_data = stream_data
                .chunks(3)
                .map(|c| Ok::<_, std::io::Error>(Bytes::from(c)));
            let the_stream = futures_util::stream::iter(stream_data);

            let bytes_data = b"some bytes data".to_vec();
            let bytes_len = bytes_data.len();

            let stream_part = Part::stream_with_length(Body::stream(the_stream), stream_len as u64);
            let body_part = Part::bytes(bytes_data);

            // A simple check to make sure we get the configured body length
            assert_eq!(stream_part.value_len().unwrap(), stream_len as u64);

            // Make sure it delegates to the underlying body if length is not specified
            assert_eq!(body_part.value_len().unwrap(), bytes_len as u64);
        }

        #[test]
        fn header_percent_encoding() {
            let name = "start%'\"\r\nend";
            let field = Part::text("");

            assert_eq!(
                PercentEncoding::PathSegment.encode_headers(name, &field.meta),
                &b"Content-Disposition: form-data; name*=utf-8''start%25'%22%0D%0A%C3%9Fend"[..]
            );

            assert_eq!(
                PercentEncoding::AttrChar.encode_headers(name, &field.meta),
                &b"Content-Disposition: form-data; name*=utf-8''start%25%27%22%0D%0A%C3%9Fend"[..]
            );
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `PercentEncoding` enum handle encoding of headers in a multipart/form-data request, and what are the differences between `PathSegment`, `AttrChar`, and `NoOp` encoding modes?
  codeQuestion3: What steps are taken in the `form_empty` test to verify that a form with no parts produces an empty body?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/decoder.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::fmt;
    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    use std::future::Future;
    use std::pin::Pin;
    use std::task::{ready, Context, Poll};

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    use futures_util::stream::Fuse;

    #[cfg(feature = "gzip")]
    use async_compression::tokio::bufread::GzipDecoder;

    #[cfg(feature = "brotli")]
    use async_compression::tokio::bufread::BrotliDecoder;

    #[cfg(feature = "zstd")]
    use async_compression::tokio::bufread::ZstdDecoder;

    #[cfg(feature = "deflate")]
    use async_compression::tokio::bufread::ZlibDecoder;

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate",
        feature = "blocking",
    ))]
    use futures_core::Stream;

    use bytes::Bytes;
    use http::HeaderMap;
    use hyper::body::Body as HttpBody;
    use hyper::body::Frame;

    #[cfg(any(
        feature = "gzip",
        feature = "brotli",
        feature = "zstd",
        feature = "deflate"
    ))]
    use tokio_util::codec::{BytesCodec, FramedRead};
    #[cfg(any(
        feature = "gzip",
        feature = "brotli",
        feature = "zstd",
        feature = "deflate"
    ))]
    use tokio_util::io::StreamReader;

    use super::body::ResponseBody;

    #[derive(Clone, Copy, Debug)]
    pub(super) struct Accepts {
        #[cfg(feature = "gzip")]
        pub(super) gzip: bool,
        #[cfg(feature = "brotli")]
        pub(super) brotli: bool,
        #[cfg(feature = "zstd")]
        pub(super) zstd: bool,
        #[cfg(feature = "deflate")]
        pub(super) deflate: bool,
    }

    impl Accepts {
        pub fn none() -> Self {
            Self {
                #[cfg(feature = "gzip")]
                gzip: false,
                #[cfg(feature = "brotli")]
                brotli: false,
                #[cfg(feature = "zstd")]
                zstd: false,
                #[cfg(feature = "deflate")]
                deflate: false,
            }
        }
    }

    /// A response decompressor over a non-blocking stream of chunks.
    ///
    /// The inner decoder may be constructed asynchronously.
    pub(crate) struct Decoder {
        inner: Inner,
    }

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    type PeekableIoStream = futures_util::stream::Peekable<IoStream>;

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    type PeekableIoStreamReader = StreamReader<PeekableIoStream, Bytes>;

    enum Inner {
        /// A `PlainText` decoder just returns the response content as is.
        PlainText(ResponseBody),

        /// A `Gzip` decoder will uncompress the gzipped response content before returning it.
        #[cfg(feature = "gzip")]
        Gzip(Pin<Box<Fuse<FramedRead<GzipDecoder<PeekableIoStreamReader>, BytesCodec>>>>),

        /// A `Brotli` decoder will uncompress the brotlied response content before returning it.
        #[cfg(feature = "brotli")]
        Brotli(Pin<Box<Fuse<FramedRead<BrotliDecoder<PeekableIoStreamReader>, BytesCodec>>>>),

        /// A `Zstd` decoder will uncompress the zstd compressed response content before returning it.
        #[cfg(feature = "zstd")]
        Zstd(Pin<Box<Fuse<FramedRead<ZstdDecoder<PeekableIoStreamReader>, BytesCodec>>>>),

        /// A `Deflate` decoder will uncompress the deflated response content before returning it.
        #[cfg(feature = "deflate")]
        Deflate(Pin<Box<Fuse<FramedRead<ZlibDecoder<PeekableIoStreamReader>, BytesCodec>>>>),

        /// A decoder that doesn't have a value yet.
        #[cfg(any(
            feature = "brotli",
            feature = "zstd",
            feature = "gzip",
            feature = "deflate"
        ))]
        Pending(Pin<Box<Pending>>),
    }

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    /// A future attempt to poll the response body for EOF so we know whether to use gzip or not.
    struct Pending(PeekableIoStream, DecoderType);

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate",
        feature = "blocking",
    ))]
    pub(crate) struct IoStream<B = ResponseBody>(B);

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    enum DecoderType {
        #[cfg(feature = "gzip")]
        Gzip,
        #[cfg(feature = "brotli")]
        Brotli,
        #[cfg(feature = "zstd")]
        Zstd,
        #[cfg(feature = "deflate")]
        Deflate,
    }

    impl fmt::Debug for Decoder {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Decoder").finish()
        }
    }

    impl Decoder {
        #[cfg(feature = "blocking")]
        pub(crate) fn empty() -> Decoder {
            Decoder {
                inner: Inner::PlainText(empty()),
            }
        }

        #[cfg(feature = "blocking")]
        pub(crate) fn into_stream(self) -> IoStream<Self> {
            IoStream(self)
        }

        /// A plain text decoder.
        ///
        /// This decoder will emit the underlying chunks as-is.
        fn plain_text(body: ResponseBody) -> Decoder {
            Decoder {
                inner: Inner::PlainText(body),
            }
        }

        /// A gzip decoder.
        ///
        /// This decoder will buffer and decompress chunks that are gzipped.
        #[cfg(feature = "gzip")]
        fn gzip(body: ResponseBody) -> Decoder {
            use futures_util::StreamExt;

            Decoder {
                inner: Inner::Pending(Box::pin(Pending(
                    IoStream(body).peekable(),
                    DecoderType::Gzip,
                ))),
            }
        }

        /// A brotli decoder.
        ///
        /// This decoder will buffer and decompress chunks that are brotlied.
        #[cfg(feature = "brotli")]
        fn brotli(body: ResponseBody) -> Decoder {
            use futures_util::StreamExt;

            Decoder {
                inner: Inner::Pending(Box::pin(Pending(
                    IoStream(body).peekable(),
                    DecoderType::Brotli,
                ))),
            }
        }

        /// A zstd decoder.
        ///
        /// This decoder will buffer and decompress chunks that are zstd compressed.
        #[cfg(feature = "zstd")]
        fn zstd(body: ResponseBody) -> Decoder {
            use futures_util::StreamExt;

            Decoder {
                inner: Inner::Pending(Box::pin(Pending(
                    IoStream(body).peekable(),
                    DecoderType::Zstd,
                ))),
            }
        }

        /// A deflate decoder.
        ///
        /// This decoder will buffer and decompress chunks that are deflated.
        #[cfg(feature = "deflate")]
        fn deflate(body: ResponseBody) -> Decoder {
            use futures_util::StreamExt;

            Decoder {
                inner: Inner::Pending(Box::pin(Pending(
                    IoStream(body).peekable(),
                    DecoderType::Deflate,
                ))),
            }
        }

        #[cfg(any(
            feature = "brotli",
            feature = "zstd",
            feature = "gzip",
            feature = "deflate"
        ))]
        fn detect_encoding(headers: &mut HeaderMap, encoding_str: &str) -> bool {
            use http::header::{CONTENT_ENCODING, CONTENT_LENGTH, TRANSFER_ENCODING};
            use log::warn;

            let mut is_content_encoded = {
                headers
                    .get_all(CONTENT_ENCODING)
                    .iter()
                    .any(|enc| enc == encoding_str)
                    || headers
                        .get_all(TRANSFER_ENCODING)
                        .iter()
                        .any(|enc| enc == encoding_str)
            };
            if is_content_encoded {
                if let Some(content_length) = headers.get(CONTENT_LENGTH) {
                    if content_length == "0" {
                        warn!("{encoding_str} response with content-length of 0");
                        is_content_encoded = false;
                    }
                }
            }
            if is_content_encoded {
                headers.remove(CONTENT_ENCODING);
                headers.remove(CONTENT_LENGTH);
            }
            is_content_encoded
        }

        /// Constructs a Decoder from a hyper request.
        ///
        /// A decoder is just a wrapper around the hyper request that knows
        /// how to decode the content body of the request.
        ///
        /// Uses the correct variant by inspecting the Content-Encoding header.
        pub(super) fn detect(
            _headers: &mut HeaderMap,
            body: ResponseBody,
            _accepts: Accepts,
        ) -> Decoder {
            #[cfg(feature = "gzip")]
            {
                if _accepts.gzip && Decoder::detect_encoding(_headers, "gzip") {
                    return Decoder::gzip(body);
                }
            }

            #[cfg(feature = "brotli")]
            {
                if _accepts.brotli && Decoder::detect_encoding(_headers, "br") {
                    return Decoder::brotli(body);
                }
            }

            #[cfg(feature = "zstd")]
            {
                if _accepts.zstd && Decoder::detect_encoding(_headers, "zstd") {
                    return Decoder::zstd(body);
                }
            }

            #[cfg(feature = "deflate")]
            {
                if _accepts.deflate && Decoder::detect_encoding(_headers, "deflate") {
                    return Decoder::deflate(body);
                }
            }

            Decoder::plain_text(body)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle different types of compressed content (e.g., gzip, brotli) in a HTTP response body?
  codeQuestion3: What is the role of the `detect` function and how does it determine which decoder to use?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/decoder.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl HttpBody for Decoder {
        type Data = Bytes;
        type Error = crate::Error;

        fn poll_frame(
            mut self: Pin<&mut Self>,
            cx: &mut Context,
        ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
            match self.inner {
                #[cfg(any(
                    feature = "brotli",
                    feature = "zstd",
                    feature = "gzip",
                    feature = "deflate"
                ))]
                Inner::Pending(ref mut future) => match Pin::new(future).poll(cx) {
                    Poll::Ready(Ok(inner)) => {
                        self.inner = inner;
                        self.poll_frame(cx)
                    }
                    Poll::Ready(Err(e)) => Poll::Ready(Some(Err(crate::error::decode_io(e)))),
                    Poll::Pending => Poll::Pending,
                },
                Inner::PlainText(ref mut body) => match ready!(Pin::new(body).poll_frame(cx)) {
                    Some(Ok(frame)) => Poll::Ready(Some(Ok(frame))),
                    Some(Err(err)) => Poll::Ready(Some(Err(crate::error::decode(err)))),
                    None => Poll::Ready(None),
                },
                #[cfg(feature = "gzip")]
                Inner::Gzip(ref mut decoder) => {
                    match ready!(Pin::new(&mut *decoder).poll_next(cx)) {
                        Some(Ok(bytes)) => Poll::Ready(Some(Ok(Frame::data(bytes.freeze())))),
                        Some(Err(err)) => Poll::Ready(Some(Err(crate::error::decode_io(err)))),
                        None => {
                            // poll inner connection until EOF after gzip stream is finished
                            poll_inner_should_be_empty(
                                decoder.get_mut().get_mut().get_mut().get_mut(),
                                cx,
                            )
                        }
                    }
                }
                #[cfg(feature = "brotli")]
                Inner::Brotli(ref mut decoder) => {
                    match ready!(Pin::new(&mut *decoder).poll_next(cx)) {
                        Some(Ok(bytes)) => Poll::Ready(Some(Ok(Frame::data(bytes.freeze())))),
                        Some(Err(err)) => Poll::Ready(Some(Err(crate::error::decode_io(err)))),
                        None => {
                            // poll inner connection until EOF after brotli stream is finished
                            poll_inner_should_be_empty(
                                decoder.get_mut().get_mut().get_mut().get_mut(),
                                cx,
                            )
                        }
                    }
                }
                #[cfg(feature = "zstd")]
                Inner::Zstd(ref mut decoder) => {
                    match ready!(Pin::new(&mut *decoder).poll_next(cx)) {
                        Some(Ok(bytes)) => Poll::Ready(Some(Ok(Frame::data(bytes.freeze())))),
                        Some(Err(err)) => Poll::Ready(Some(Err(crate::error::decode_io(err)))),
                        None => {
                            // poll inner connection until EOF after zstd stream is finished
                            poll_inner_should_be_empty(
                                decoder.get_mut().get_mut().get_mut().get_mut(),
                                cx,
                            )
                        }
                    }
                }
                #[cfg(feature = "deflate")]
                Inner::Deflate(ref mut decoder) => {
                    match ready!(Pin::new(&mut *decoder).poll_next(cx)) {
                        Some(Ok(bytes)) => Poll::Ready(Some(Ok(Frame::data(bytes.freeze())))),
                        Some(Err(err)) => Poll::Ready(Some(Err(crate::error::decode_io(err)))),
                        None => {
                            // poll inner connection until EOF after deflate stream is finished
                            poll_inner_should_be_empty(
                                decoder.get_mut().get_mut().get_mut().get_mut(),
                                cx,
                            )
                        }
                    }
                }
            }
        }

        fn size_hint(&self) -> http_body::SizeHint {
            match self.inner {
                Inner::PlainText(ref body) => HttpBody::size_hint(body),
                // the rest are "unknown", so default
                #[cfg(any(
                    feature = "brotli",
                    feature = "zstd",
                    feature = "gzip",
                    feature = "deflate"
                ))]
                _ => http_body::SizeHint::default(),
            }
        }
    }

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    fn poll_inner_should_be_empty(
        inner: &mut PeekableIoStream,
        cx: &mut Context,
    ) -> Poll<Option<Result<Frame<Bytes>, crate::Error>>> {
        // poll inner connection until EOF after deflate stream is finished
        // loop in case of empty frames
        let mut inner = Pin::new(inner);
        loop {
            match ready!(inner.as_mut().poll_next(cx)) {
                // ignore any empty frames
                Some(Ok(bytes)) if bytes.is_empty() => continue,
                Some(Ok(_)) => {
                    return Poll::Ready(Some(Err(crate::error::decode(
                        "there are extra bytes after body has been decompressed",
                    ))))
                }
                Some(Err(err)) => return Poll::Ready(Some(Err(crate::error::decode_io(err)))),
                None => return Poll::Ready(None),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle different compression algorithms like GZIP, Brotli, and Deflate?
  codeQuestion3: What is the role of the `poll_inner_should_be_empty` function in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/decoder.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate",
        feature = "blocking",
    ))]
    fn empty() -> ResponseBody {
        use http_body_util::{combinators::BoxBody, BodyExt, Empty};
        BoxBody::new(Empty::new().map_err(|never| match never {}))
    }

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate"
    ))]
    impl Future for Pending {
        type Output = Result<Inner, std::io::Error>;

        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            use futures_util::StreamExt;

            match ready!(Pin::new(&mut self.0).poll_peek(cx)) {
                Some(Ok(_)) => {
                    // fallthrough
                }
                Some(Err(_e)) => {
                    // error was just a ref, so we need to really poll to move it
                    return Poll::Ready(Err(ready!(Pin::new(&mut self.0).poll_next(cx))
                        .expect("just peeked Some")
                        .unwrap_err()));
                }
                None => return Poll::Ready(Ok(Inner::PlainText(empty()))),
            };

            let _body = std::mem::replace(&mut self.0, IoStream(empty()).peekable());

            match self.1 {
                #[cfg(feature = "brotli")]
                DecoderType::Brotli => Poll::Ready(Ok(Inner::Brotli(Box::pin(
                    FramedRead::new(
                        BrotliDecoder::new(StreamReader::new(_body)),
                        BytesCodec::new(),
                    )
                    .fuse(),
                )))),
                #[cfg(feature = "zstd")]
                DecoderType::Zstd => Poll::Ready(Ok(Inner::Zstd(Box::pin(
                    FramedRead::new(
                        {
                            let mut d = ZstdDecoder::new(StreamReader::new(_body));
                            d.multiple_members(true);
                            d
                        },
                        BytesCodec::new(),
                    )
                    .fuse(),
                )))),
                #[cfg(feature = "gzip")]
                DecoderType::Gzip => Poll::Ready(Ok(Inner::Gzip(Box::pin(
                    FramedRead::new(
                        GzipDecoder::new(StreamReader::new(_body)),
                        BytesCodec::new(),
                    )
                    .fuse(),
                )))),
                #[cfg(feature = "deflate")]
                DecoderType::Deflate => Poll::Ready(Ok(Inner::Deflate(Box::pin(
                    FramedRead::new(
                        ZlibDecoder::new(StreamReader::new(_body)),
                        BytesCodec::new(),
                    )
                    .fuse(),
                )))),
            }
        }
    }

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate",
        feature = "blocking",
    ))]
    impl<B> Stream for IoStream<B>
    where
        B: HttpBody<Data = Bytes> + Unpin,
        B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        type Item = Result<Bytes, std::io::Error>;

        fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Option<Self::Item>> {
            loop {
                return match ready!(Pin::new(&mut self.0).poll_frame(cx)) {
                    Some(Ok(frame)) => {
                        // skip non-data frames
                        if let Ok(buf) = frame.into_data() {
                            Poll::Ready(Some(Ok(buf)))
                        } else {
                            continue;
                        }
                    }
                    Some(Err(err)) => Poll::Ready(Some(Err(crate::error::into_io(err.into())))),
                    None => Poll::Ready(None),
                };
            }
        }
    }

    // ===== impl Accepts =====

    impl Accepts {
        /*
        pub(super) fn none() -> Self {
            Accepts {
                #[cfg(feature = "gzip")]
                gzip: false,
                #[cfg(feature = "brotli")]
                brotli: false,
                #[cfg(feature = "zstd")]
                zstd: false,
                #[cfg(feature = "deflate")]
                deflate: false,
            }
        }
        */

        pub(super) const fn as_str(&self) -> Option<&'static str> {
            match (
                self.is_gzip(),
                self.is_brotli(),
                self.is_zstd(),
                self.is_deflate(),
            ) {
                (true, true, true, true) => Some("gzip, br, zstd, deflate"),
                (true, true, false, true) => Some("gzip, br, deflate"),
                (true, true, true, false) => Some("gzip, br, zstd"),
                (true, true, false, false) => Some("gzip, br"),
                (true, false, true, true) => Some("gzip, zstd, deflate"),
                (true, false, false, true) => Some("gzip, deflate"),
                (false, true, true, true) => Some("br, zstd, deflate"),
                (false, true, false, true) => Some("br, deflate"),
                (true, false, true, false) => Some("gzip, zstd"),
                (true, false, false, false) => Some("gzip"),
                (false, true, true, false) => Some("br, zstd"),
                (false, true, false, false) => Some("br"),
                (false, false, true, true) => Some("zstd, deflate"),
                (false, false, true, false) => Some("zstd"),
                (false, false, false, true) => Some("deflate"),
                (false, false, false, false) => None,
            }
        }

        const fn is_gzip(&self) -> bool {
            #[cfg(feature = "gzip")]
            {
                self.gzip
            }

            #[cfg(not(feature = "gzip"))]
            {
                false
            }
        }

        const fn is_brotli(&self) -> bool {
            #[cfg(feature = "brotli")]
            {
                self.brotli
            }

            #[cfg(not(feature = "brotli"))]
            {
                false
            }
        }

        const fn is_zstd(&self) -> bool {
            #[cfg(feature = "zstd")]
            {
                self.zstd
            }

            #[cfg(not(feature = "zstd"))]
            {
                false
            }
        }

        const fn is_deflate(&self) -> bool {
            #[cfg(feature = "deflate")]
            {
                self.deflate
            }

            #[cfg(not(feature = "deflate"))]
            {
                false
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle different compression algorithms like gzip, zstd, and brotli?
  codeQuestion3: What is the role of the `as_str` method in the `Accepts` struct and how does it determine the supported compression types?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/decoder.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Default for Accepts {
        fn default() -> Accepts {
            Accepts {
                #[cfg(feature = "gzip")]
                gzip: true,
                #[cfg(feature = "brotli")]
                brotli: true,
                #[cfg(feature = "zstd")]
                zstd: true,
                #[cfg(feature = "deflate")]
                deflate: true,
            }
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn accepts_as_str() {
            fn format_accept_encoding(accepts: &Accepts) -> String {
                let mut encodings = vec![];
                if accepts.is_gzip() {
                    encodings.push("gzip");
                }
                if accepts.is_brotli() {
                    encodings.push("br");
                }
                if accepts.is_zstd() {
                    encodings.push("zstd");
                }
                if accepts.is_deflate() {
                    encodings.push("deflate");
                }
                encodings.join(", ")
            }

            let state = [true, false];
            let mut permutations = Vec::new();

            #[allow(unused_variables)]
            for gzip in state {
                for brotli in state {
                    for zstd in state {
                        for deflate in state {
                            permutations.push(Accepts {
                                #[cfg(feature = "gzip")]
                                gzip,
                                #[cfg(feature = "brotli")]
                                brotli,
                                #[cfg(feature = "zstd")]
                                zstd,
                                #[cfg(feature = "deflate")]
                                deflate,
                            });
                        }
                    }
                }
            }

            for accepts in permutations {
                let expected = format_accept_encoding(&accepts);
                let got = accepts.as_str().unwrap_or("");
                assert_eq!(got, expected.as_str());
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle different compression algorithms based on feature flags, and can you provide an example of how to customize the Accepts struct?
  codeQuestion3: What is the role of the test function 'accepts_as_str' and how does it verify the correctness of the Accepts struct's as_str method?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/async_impl/mod.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub use self::body::Body;
    pub use self::client::{Client, ClientBuilder};
    pub use self::request::{Request, RequestBuilder};
    pub use self::response::Response;
    pub use self::upgrade::Upgraded;

    #[cfg(feature = "blocking")]
    pub(crate) use self::decoder::Decoder;

    pub mod body;
    pub mod client;
    pub mod decoder;
    pub mod h3_client;
    #[cfg(feature = "multipart")]
    pub mod multipart;
    pub(crate) mod request;
    mod response;
    mod upgrade;
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user make an HTTP request using the features provided in this module?
  codeQuestion3: What is the role of the `Decoder` module when the `blocking` feature is enabled?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::fmt;
    #[cfg(feature = "socks")]
    use std::net::SocketAddr;
    use std::sync::Arc;

    use crate::into_url::{IntoUrl, IntoUrlSealed};
    use crate::Url;
    use http::{header::HeaderValue, Uri};
    use ipnet::IpNet;
    use percent_encoding::percent_decode;
    use std::collections::HashMap;
    use std::env;
    use std::error::Error;
    use std::net::IpAddr;
    #[cfg(all(target_os = "macos", feature = "macos-system-configuration"))]
    use system_configuration::{
        core_foundation::{
            base::CFType,
            dictionary::CFDictionary,
            number::CFNumber,
            string::{CFString, CFStringRef},
        },
        dynamic_store::SCDynamicStoreBuilder,
        sys::schema_definitions::kSCPropNetProxiesHTTPEnable,
        sys::schema_definitions::kSCPropNetProxiesHTTPPort,
        sys::schema_definitions::kSCPropNetProxiesHTTPProxy,
        sys::schema_definitions::kSCPropNetProxiesHTTPSEnable,
        sys::schema_definitions::kSCPropNetProxiesHTTPSPort,
        sys::schema_definitions::kSCPropNetProxiesHTTPSProxy,
    };

    #[cfg(target_os = "windows")]
    use windows_registry::CURRENT_USER;

    /// Configuration of a proxy that a `Client` should pass requests to.
    ///
    /// A `Proxy` has a couple pieces to it:
    ///
    /// - a URL of how to talk to the proxy
    /// - rules on what `Client` requests should be directed to the proxy
    ///
    /// For instance, let's look at `Proxy::http`:
    ///
    /// ```rust
    /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
    /// let proxy = reqwest::Proxy::http("https://secure.example")?;
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// This proxy will intercept all HTTP requests, and make use of the proxy
    /// at `https://secure.example`. A request to `http://hyper.rs` will talk
    /// to your proxy. A request to `https://hyper.rs` will not.
    ///
    /// Multiple `Proxy` rules can be configured for a `Client`. The `Client` will
    /// check each `Proxy` in the order it was added. This could mean that a
    /// `Proxy` added first with eager intercept rules, such as `Proxy::all`,
    /// would prevent a `Proxy` later in the list from ever working, so take care.
    ///
    /// By enabling the `"socks"` feature it is possible to use a socks proxy:
    /// ```rust
    /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
    /// let proxy = reqwest::Proxy::http("socks5://192.168.1.1:9000")?;
    /// # Ok(())
    /// # }
    /// ```
    #[derive(Clone)]
    pub struct Proxy {
        intercept: Intercept,
        no_proxy: Option<NoProxy>,
    }

    /// Represents a possible matching entry for an IP address
    #[derive(Clone, Debug)]
    enum Ip {
        Address(IpAddr),
        Network(IpNet),
    }

    /// A wrapper around a list of IP cidr blocks or addresses with a [IpMatcher::contains] method for
    /// checking if an IP address is contained within the matcher
    #[derive(Clone, Debug, Default)]
    struct IpMatcher(Vec<Ip>);

    /// A wrapper around a list of domains with a [DomainMatcher::contains] method for checking if a
    /// domain is contained within the matcher
    #[derive(Clone, Debug, Default)]
    struct DomainMatcher(Vec<String>);

    /// A configuration for filtering out requests that shouldn't be proxied
    #[derive(Clone, Debug, Default)]
    pub struct NoProxy {
        ips: IpMatcher,
        domains: DomainMatcher,
    }

    /// A particular scheme used for proxying requests.
    ///
    /// For example, HTTP vs SOCKS5
    #[derive(Clone)]
    pub enum ProxyScheme {
        Http {
            auth: Option<HeaderValue>,
            host: http::uri::Authority,
        },
        Https {
            auth: Option<HeaderValue>,
            host: http::uri::Authority,
        },
        #[cfg(feature = "socks")]
        Socks4 { addr: SocketAddr, remote_dns: bool },
        #[cfg(feature = "socks")]
        Socks5 {
            addr: SocketAddr,
            auth: Option<(String, String)>,
            remote_dns: bool,
        },
    }

    impl ProxyScheme {
        fn maybe_http_auth(&self) -> Option<&HeaderValue> {
            match self {
                ProxyScheme::Http { auth, .. } | ProxyScheme::Https { auth, .. } => auth.as_ref(),
                #[cfg(feature = "socks")]
                _ => None,
            }
        }
    }

    /// Trait used for converting into a proxy scheme. This trait supports
    /// parsing from a URL-like type, whilst also supporting proxy schemes
    /// built directly using the factory methods.
    pub trait IntoProxyScheme {
        fn into_proxy_scheme(self) -> crate::Result<ProxyScheme>;
    }

    impl<S: IntoUrl> IntoProxyScheme for S {
        fn into_proxy_scheme(self) -> crate::Result<ProxyScheme> {
            // validate the URL
            let url = match self.as_str().into_url() {
                Ok(ok) => ok,
                Err(e) => {
                    let mut presumed_to_have_scheme = true;
                    let mut source = e.source();
                    while let Some(err) = source {
                        if let Some(parse_error) = err.downcast_ref::<url::ParseError>() {
                            if *parse_error == url::ParseError::RelativeUrlWithoutBase {
                                presumed_to_have_scheme = false;
                                break;
                            }
                        } else if err.downcast_ref::<crate::error::BadScheme>().is_some() {
                            presumed_to_have_scheme = false;
                            break;
                        }
                        source = err.source();
                    }
                    if presumed_to_have_scheme {
                        return Err(crate::error::builder(e));
                    }
                    // the issue could have been caused by a missing scheme, so we try adding http://
                    let try_this = format!("http://{}", self.as_str());
                    try_this.into_url().map_err(|_| {
                        // return the original error
                        crate::error::builder(e)
                    })?
                }
            };
            ProxyScheme::parse(url)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Proxy` struct handle different types of proxy schemes, such as HTTP and SOCKS?
  codeQuestion3: What is the process for converting a string into a proxy scheme, and what error handling is in place during this conversion?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    // These bounds are accidentally leaked by the blanket impl of IntoProxyScheme
    // for all types that implement IntoUrl. So, this function exists to detect
    // if we were to break those bounds for a user.
    fn _implied_bounds() {
        fn prox<T: IntoProxyScheme>(_t: T) {}

        fn url<T: IntoUrl>(t: T) {
            prox(t);
        }
    }

    impl IntoProxyScheme for ProxyScheme {
        fn into_proxy_scheme(self) -> crate::Result<ProxyScheme> {
            Ok(self)
        }
    }

    impl Proxy {
        /// Proxy all HTTP traffic to the passed URL.
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::Client::builder()
        ///     .proxy(reqwest::Proxy::http("https://my.prox")?)
        ///     .build()?;
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn http<U: IntoProxyScheme>(proxy_scheme: U) -> crate::Result<Proxy> {
            Ok(Proxy::new(Intercept::Http(
                proxy_scheme.into_proxy_scheme()?,
            )))
        }

        /// Proxy all HTTPS traffic to the passed URL.
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::Client::builder()
        ///     .proxy(reqwest::Proxy::https("https://example.prox:4545")?)
        ///     .build()?;
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn https<U: IntoProxyScheme>(proxy_scheme: U) -> crate::Result<Proxy> {
            Ok(Proxy::new(Intercept::Https(
                proxy_scheme.into_proxy_scheme()?,
            )))
        }

        /// Proxy **all** traffic to the passed URL.
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::Client::builder()
        ///     .proxy(reqwest::Proxy::all("http://pro.xy")?)
        ///     .build()?;
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn all<U: IntoProxyScheme>(proxy_scheme: U) -> crate::Result<Proxy> {
            Ok(Proxy::new(Intercept::All(
                proxy_scheme.into_proxy_scheme()?,
            )))
        }

        /// Provide a custom function to determine what traffic to proxy to where.
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let target = reqwest::Url::parse("https://my.prox")?;
        /// let client = reqwest::Client::builder()
        ///     .proxy(reqwest::Proxy::custom(move |url| {
        ///         if url.host_str() == Some("hyper.rs") {
        ///             Some(target.clone())
        ///         } else {
        ///             None
        ///         }
        ///     }))
        ///     .build()?;
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn custom<F, U: IntoProxyScheme>(fun: F) -> Proxy
        where
            F: Fn(&Url) -> Option<U> + Send + Sync + 'static,
        {
            Proxy::new(Intercept::Custom(Custom {
                auth: None,
                func: Arc::new(move |url| fun(url).map(IntoProxyScheme::into_proxy_scheme)),
            }))
        }

        pub(crate) fn system() -> Proxy {
            let mut proxy = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(
                get_from_platform(),
            ))));
            proxy.no_proxy = NoProxy::from_env();

            #[cfg(target_os = "windows")]
            {
                // Only read from windows registry proxy settings if not available from an environment
                // variable. This is in line with the stated behavior of both dotnot and nuget on
                // windows. <https://github.com/seanmonstar/reqwest/issues/2599>
                if proxy.no_proxy.is_none() {
                    let win_exceptions: String = get_windows_proxy_exceptions();
                    proxy.no_proxy = NoProxy::from_string(&win_exceptions);
                }
            }

            proxy
        }

        fn new(intercept: Intercept) -> Proxy {
            Proxy {
                intercept,
                no_proxy: None,
            }
        }

        /// Set the `Proxy-Authorization` header using Basic auth.
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let proxy = reqwest::Proxy::https("http://localhost:1234")?
        ///     .basic_auth("Aladdin", "open sesame");
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn basic_auth(mut self, username: &str, password: &str) -> Proxy {
            self.intercept.set_basic_auth(username, password);
            self
        }

        /// Set the `Proxy-Authorization` header to a specified value.
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate reqwest;
        /// # use reqwest::header::*;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let proxy = reqwest::Proxy::https("http://localhost:1234")?
        ///     .custom_http_auth(HeaderValue::from_static("justletmeinalreadyplease"));
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn custom_http_auth(mut self, header_value: HeaderValue) -> Proxy {
            self.intercept.set_custom_http_auth(header_value);
            self
        }

        /// Adds a `No Proxy` exclusion list to this Proxy
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let proxy = reqwest::Proxy::https("http://localhost:1234")?
        ///     .no_proxy(reqwest::NoProxy::from_string("direct.tld, sub.direct2.tld"));
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn no_proxy(mut self, no_proxy: Option<NoProxy>) -> Proxy {
            self.no_proxy = no_proxy;
            self
        }

        pub(crate) fn maybe_has_http_auth(&self) -> bool {
            match &self.intercept {
                Intercept::All(p) | Intercept::Http(p) => p.maybe_http_auth().is_some(),
                // Custom *may* match 'http', so assume so.
                Intercept::Custom(_) => true,
                Intercept::System(system) => system
                    .get("http")
                    .and_then(|s| s.maybe_http_auth())
                    .is_some(),
                Intercept::Https(_) => false,
            }
        }

        pub(crate) fn http_basic_auth<D: Dst>(&self, uri: &D) -> Option<HeaderValue> {
            match &self.intercept {
                Intercept::All(p) | Intercept::Http(p) => p.maybe_http_auth().cloned(),
                Intercept::System(system) => system
                    .get("http")
                    .and_then(|s| s.maybe_http_auth().cloned()),
                Intercept::Custom(custom) => {
                    custom.call(uri).and_then(|s| s.maybe_http_auth().cloned())
                }
                Intercept::Https(_) => None,
            }
        }

        pub(crate) fn intercept<D: Dst>(&self, uri: &D) -> Option<ProxyScheme> {
            let in_no_proxy = self
                .no_proxy
                .as_ref()
                .map_or(false, |np| np.contains(uri.host()));
            match self.intercept {
                Intercept::All(ref u) => {
                    if !in_no_proxy {
                        Some(u.clone())
                    } else {
                        None
                    }
                }
                Intercept::Http(ref u) => {
                    if !in_no_proxy && uri.scheme() == "http" {
                        Some(u.clone())
                    } else {
                        None
                    }
                }
                Intercept::Https(ref u) => {
                    if !in_no_proxy && uri.scheme() == "https" {
                        Some(u.clone())
                    } else {
                        None
                    }
                }
                Intercept::System(ref map) => {
                    if in_no_proxy {
                        None
                    } else {
                        map.get(uri.scheme()).cloned()
                    }
                }
                Intercept::Custom(ref custom) => {
                    if !in_no_proxy {
                        custom.call(uri)
                    } else {
                        None
                    }
                }
            }
        }

        pub(crate) fn is_match<D: Dst>(&self, uri: &D) -> bool {
            match self.intercept {
                Intercept::All(_) => true,
                Intercept::Http(_) => uri.scheme() == "http",
                Intercept::Https(_) => uri.scheme() == "https",
                Intercept::System(ref map) => map.contains_key(uri.scheme()),
                Intercept::Custom(ref custom) => custom.call(uri).is_some(),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Proxy::custom` method handle custom proxy routing rules, and can you provide an example of its usage?
  codeQuestion3: What is the role of the `system()` method in this code, and how does it retrieve proxy settings from the operating system?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Proxy {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_tuple("Proxy")
                .field(&self.intercept)
                .field(&self.no_proxy)
                .finish()
        }
    }

    impl NoProxy {
        /// Returns a new no-proxy configuration based on environment variables (or `None` if no variables are set)
        /// see [self::NoProxy::from_string()] for the string format
        pub fn from_env() -> Option<NoProxy> {
            let raw = env::var("NO_PROXY")
                .or_else(|_| env::var("no_proxy"))
                .ok()?;

            // Per the docs, this returns `None` if no environment variable is set. We can only reach
            // here if an env var is set, so we return `Some(NoProxy::default)` if `from_string`
            // returns None, which occurs with an empty string.
            Some(Self::from_string(&raw).unwrap_or_default())
        }

        /// Returns a new no-proxy configuration based on a `no_proxy` string (or `None` if no variables
        /// are set)
        /// The rules are as follows:
        /// * The environment variable `NO_PROXY` is checked, if it is not set, `no_proxy` is checked
        /// * If neither environment variable is set, `None` is returned
        /// * Entries are expected to be comma-separated (whitespace between entries is ignored)
        /// * IP addresses (both IPv4 and IPv6) are allowed, as are optional subnet masks (by adding /size,
        ///   for example "`192.168.1.0/24`").
        /// * An entry "`*`" matches all hostnames (this is the only wildcard allowed)
        /// * Any other entry is considered a domain name (and may contain a leading dot, for example `google.com`
        ///   and `.google.com` are equivalent) and would match both that domain AND all subdomains.
        ///
        /// For example, if `"NO_PROXY=google.com, 192.168.1.0/24"` was set, all the following would match
        /// (and therefore would bypass the proxy):
        /// * `http://google.com/`
        /// * `http://www.google.com/`
        /// * `http://192.168.1.42/`
        ///
        /// The URL `http://notgoogle.com/` would not match.
        pub fn from_string(no_proxy_list: &str) -> Option<Self> {
            if no_proxy_list.is_empty() {
                return None;
            }
            let mut ips = Vec::new();
            let mut domains = Vec::new();
            let parts = no_proxy_list.split(',').map(str::trim);
            for part in parts {
                match part.parse::<IpNet>() {
                    // If we can parse an IP net or address, then use it, otherwise, assume it is a domain
                    Ok(ip) => ips.push(Ip::Network(ip)),
                    Err(_) => match part.parse::<IpAddr>() {
                        Ok(addr) => ips.push(Ip::Address(addr)),
                        Err(_) => domains.push(part.to_owned()),
                    },
                }
            }
            Some(NoProxy {
                ips: IpMatcher(ips),
                domains: DomainMatcher(domains),
            })
        }

        fn contains(&self, host: &str) -> bool {
            // According to RFC3986, raw IPv6 hosts will be wrapped in []. So we need to strip those off
            // the end in order to parse correctly
            let host = if host.starts_with('[') {
                let x: &[_] = &['[', ']'];
                host.trim_matches(x)
            } else {
                host
            };
            match host.parse::<IpAddr>() {
                // If we can parse an IP addr, then use it, otherwise, assume it is a domain
                Ok(ip) => self.ips.contains(ip),
                Err(_) => self.domains.contains(host),
            }
        }
    }

    impl IpMatcher {
        fn contains(&self, addr: IpAddr) -> bool {
            for ip in &self.0 {
                match ip {
                    Ip::Address(address) => {
                        if &addr == address {
                            return true;
                        }
                    }
                    Ip::Network(net) => {
                        if net.contains(&addr) {
                            return true;
                        }
                    }
                }
            }
            false
        }
    }

    impl DomainMatcher {
        // The following links may be useful to understand the origin of these rules:
        // * https://curl.se/libcurl/c/CURLOPT_NOPROXY.html
        // * https://github.com/curl/curl/issues/1208
        fn contains(&self, domain: &str) -> bool {
            let domain_len = domain.len();
            for d in &self.0 {
                if d == domain || d.strip_prefix('.') == Some(domain) {
                    return true;
                } else if domain.ends_with(d) {
                    if d.starts_with('.') {
                        // If the first character of d is a dot, that means the first character of domain
                        // must also be a dot, so we are looking at a subdomain of d and that matches
                        return true;
                    } else if domain.as_bytes().get(domain_len - d.len() - 1) == Some(&b'.') {
                        // Given that d is a prefix of domain, if the prior character in domain is a dot
                        // then that means we must be matching a subdomain of d, and that matches
                        return true;
                    }
                } else if d == "*" {
                    return true;
                }
            }
            false
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `from_env()` method handle environment variables for no-proxy settings, and what is an example of its usage?
  codeQuestion3: What steps are taken in the `contains()` method to determine if a given host should bypass the proxy, and how do IP addresses and domain names differ in their matching logic?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl ProxyScheme {
        // To start conservative, keep builders private for now.

        /// Proxy traffic via the specified URL over HTTP
        fn http(host: &str) -> crate::Result<Self> {
            Ok(ProxyScheme::Http {
                auth: None,
                host: host.parse().map_err(crate::error::builder)?,
            })
        }

        /// Proxy traffic via the specified URL over HTTPS
        fn https(host: &str) -> crate::Result<Self> {
            Ok(ProxyScheme::Https {
                auth: None,
                host: host.parse().map_err(crate::error::builder)?,
            })
        }

        /// Proxy traffic via the specified socket address over SOCKS4
        ///
        /// # Note
        ///
        /// Current SOCKS4 support is provided via blocking IO.
        #[cfg(feature = "socks")]
        fn socks4(addr: SocketAddr) -> crate::Result<Self> {
            Ok(ProxyScheme::Socks4 {
                addr,
                remote_dns: false,
            })
        }

        /// Proxy traffic via the specified socket address over SOCKS4A
        ///
        /// This differs from SOCKS4 in that DNS resolution is also performed via the proxy.
        ///
        /// # Note
        ///
        /// Current SOCKS4 support is provided via blocking IO.
        #[cfg(feature = "socks")]
        fn socks4a(addr: SocketAddr) -> crate::Result<Self> {
            Ok(ProxyScheme::Socks4 {
                addr,
                remote_dns: true,
            })
        }

        /// Proxy traffic via the specified socket address over SOCKS5
        ///
        /// # Note
        ///
        /// Current SOCKS5 support is provided via blocking IO.
        #[cfg(feature = "socks")]
        fn socks5(addr: SocketAddr) -> crate::Result<Self> {
            Ok(ProxyScheme::Socks5 {
                addr,
                auth: None,
                remote_dns: false,
            })
        }

        /// Proxy traffic via the specified socket address over SOCKS5H
        ///
        /// This differs from SOCKS5 in that DNS resolution is also performed via the proxy.
        ///
        /// # Note
        ///
        /// Current SOCKS5 support is provided via blocking IO.
        #[cfg(feature = "socks")]
        fn socks5h(addr: SocketAddr) -> crate::Result<Self> {
            Ok(ProxyScheme::Socks5 {
                addr,
                auth: None,
                remote_dns: true,
            })
        }

        /// Use a username and password when connecting to the proxy server
        fn with_basic_auth<T: Into<String>, U: Into<String>>(
            mut self,
            username: T,
            password: U,
        ) -> Self {
            self.set_basic_auth(username, password);
            self
        }

        fn set_basic_auth<T: Into<String>, U: Into<String>>(&mut self, username: T, password: U) {
            match *self {
                ProxyScheme::Http { ref mut auth, .. } => {
                    let header = encode_basic_auth(&username.into(), &password.into());
                    *auth = Some(header);
                }
                ProxyScheme::Https { ref mut auth, .. } => {
                    let header = encode_basic_auth(&username.into(), &password.into());
                    *auth = Some(header);
                }
                #[cfg(feature = "socks")]
                ProxyScheme::Socks4 { .. } => {
                    panic!("Socks4 is not supported for this method")
                }
                #[cfg(feature = "socks")]
                ProxyScheme::Socks5 { ref mut auth, .. } => {
                    *auth = Some((username.into(), password.into()));
                }
            }
        }

        fn set_custom_http_auth(&mut self, header_value: HeaderValue) {
            match *self {
                ProxyScheme::Http { ref mut auth, .. } => {
                    *auth = Some(header_value);
                }
                ProxyScheme::Https { ref mut auth, .. } => {
                    *auth = Some(header_value);
                }
                #[cfg(feature = "socks")]
                ProxyScheme::Socks4 { .. } => {
                    panic!("Socks4 is not supported for this method")
                }
                #[cfg(feature = "socks")]
                ProxyScheme::Socks5 { .. } => {
                    panic!("Socks5 is not supported for this method")
                }
            }
        }

        fn if_no_auth(mut self, update: &Option<HeaderValue>) -> Self {
            match self {
                ProxyScheme::Http { ref mut auth, .. } => {
                    if auth.is_none() {
                        *auth = update.clone();
                    }
                }
                ProxyScheme::Https { ref mut auth, .. } => {
                    if auth.is_none() {
                        *auth = update.clone();
                    }
                }
                #[cfg(feature = "socks")]
                ProxyScheme::Socks4 { .. } => {}
                #[cfg(feature = "socks")]
                ProxyScheme::Socks5 { .. } => {}
            }

            self
        }

        /// Convert a URL into a proxy scheme
        ///
        /// Supported schemes: HTTP, HTTPS, (SOCKS4, SOCKS5, SOCKS5H if `socks` feature is enabled).
        // Private for now...
        fn parse(url: Url) -> crate::Result<Self> {
            use url::Position;

            // Resolve URL to a host and port
            #[cfg(feature = "socks")]
            let to_addr = || {
                let addrs = url
                    .socket_addrs(|| match url.scheme() {
                        "socks4" | "socks4a" | "socks5" | "socks5h" => Some(1080),
                        _ => None,
                    })
                    .map_err(crate::error::builder)?;
                addrs
                    .into_iter()
                    .next()
                    .ok_or_else(|| crate::error::builder("unknown proxy scheme"))
            };

            let mut scheme = match url.scheme() {
                "http" => Self::http(&url[Position::BeforeHost..Position::AfterPort])?,
                "https" => Self::https(&url[Position::BeforeHost..Position::AfterPort])?,
                #[cfg(feature = "socks")]
                "socks4" => Self::socks4(to_addr()?)?,
                #[cfg(feature = "socks")]
                "socks4a" => Self::socks4a(to_addr()?)?,
                #[cfg(feature = "socks")]
                "socks5" => Self::socks5(to_addr()?)?,
                #[cfg(feature = "socks")]
                "socks5h" => Self::socks5h(to_addr()?)?,
                _ => return Err(crate::error::builder("unknown proxy scheme")),
            };

            if let Some(pwd) = url.password() {
                let decoded_username = percent_decode(url.username().as_bytes()).decode_utf8_lossy();
                let decoded_password = percent_decode(pwd.as_bytes()).decode_utf8_lossy();
                scheme = scheme.with_basic_auth(decoded_username, decoded_password);
            }

            Ok(scheme)
        }

        #[cfg(test)]
        fn scheme(&self) -> &str {
            match self {
                ProxyScheme::Http { .. } => "http",
                ProxyScheme::Https { .. } => "https",
                #[cfg(feature = "socks")]
                ProxyScheme::Socks4 { .. } => "socks4",
                #[cfg(feature = "socks")]
                ProxyScheme::Socks5 { .. } => "socks5",
            }
        }

        #[cfg(test)]
        fn host(&self) -> &str {
            match self {
                ProxyScheme::Http { host, .. } => host.as_str(),
                ProxyScheme::Https { host, .. } => host.as_str(),
                #[cfg(feature = "socks")]
                ProxyScheme::Socks4 { .. } => panic!("socks4"),
                #[cfg(feature = "socks")]
                ProxyScheme::Socks5 { .. } => panic!("socks5"),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `parse` method handle different proxy schemes like HTTP, HTTPS, and SOCKS?
  codeQuestion3: What is the process for setting up basic authentication for HTTP and HTTPS proxies, and how does it differ from SOCKS protocols?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for ProxyScheme {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                ProxyScheme::Http { auth: _auth, host } => write!(f, "http://{host}"),
                ProxyScheme::Https { auth: _auth, host } => write!(f, "https://{host}"),
                #[cfg(feature = "socks")]
                ProxyScheme::Socks4 { addr, remote_dns } => {
                    let h = if *remote_dns { "a" } else { "" };
                    write!(f, "socks4{}://{}", h, addr)
                }
                #[cfg(feature = "socks")]
                ProxyScheme::Socks5 {
                    addr,
                    auth: _auth,
                    remote_dns,
                } => {
                    let h = if *remote_dns { "h" } else { "" };
                    write!(f, "socks5{h}://{addr}")
                }
            }
        }
    }

    type SystemProxyMap = HashMap<String, ProxyScheme>;

    #[derive(Clone, Debug)]
    enum Intercept {
        All(ProxyScheme),
        Http(ProxyScheme),
        Https(ProxyScheme),
        System(Arc<SystemProxyMap>),
        Custom(Custom),
    }

    impl Intercept {
        fn set_basic_auth(&mut self, username: &str, password: &str) {
            match self {
                Intercept::All(ref mut s)
                | Intercept::Http(ref mut s)
                | Intercept::Https(ref mut s) => s.set_basic_auth(username, password),
                Intercept::System(_) => unimplemented!(),
                Intercept::Custom(ref mut custom) => {
                    let header = encode_basic_auth(username, password);
                    custom.auth = Some(header);
                }
            }
        }

        fn set_custom_http_auth(&mut self, header_value: HeaderValue) {
            match self {
                Intercept::All(ref mut s)
                | Intercept::Http(ref mut s)
                | Intercept::Https(ref mut s) => s.set_custom_http_auth(header_value),
                Intercept::System(_) => unimplemented!(),
                Intercept::Custom(ref mut custom) => {
                    custom.auth = Some(header_value);
                }
            }
        }
    }

    #[derive(Clone)]
    struct Custom {
        // This auth only applies if the returned ProxyScheme doesn't have an auth...
        auth: Option<HeaderValue>,
        func: Arc<dyn Fn(&Url) -> Option<crate::Result<ProxyScheme>> + Send + Sync + 'static>,
    }

    impl Custom {
        fn call<D: Dst>(&self, uri: &D) -> Option<ProxyScheme> {
            let url = format!(
                "{}://{}{}{}",
                uri.scheme(),
                uri.host(),
                uri.port().map_or("", |_| ":"),
                uri.port().map_or(String::new(), |p| p.to_string())
            )
            .parse()
            .expect("should be valid Url");

            (self.func)(&url)
                .and_then(|result| result.ok())
                .map(|scheme| scheme.if_no_auth(&self.auth))
        }
    }

    impl fmt::Debug for Custom {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_str("_")
        }
    }

    pub(crate) fn encode_basic_auth(username: &str, password: &str) -> HeaderValue {
        crate::util::basic_auth(username, Some(password))
    }

    /// A helper trait to allow testing `Proxy::intercept` without having to
    /// construct `hyper::client::connect::Destination`s.
    pub(crate) trait Dst {
        fn scheme(&self) -> &str;
        fn host(&self) -> &str;
        fn port(&self) -> Option<u16>;
    }

    #[doc(hidden)]
    impl Dst for Uri {
        fn scheme(&self) -> &str {
            self.scheme().expect("Uri should have a scheme").as_str()
        }

        fn host(&self) -> &str {
            Uri::host(self).expect("<Uri as Dst>::host should have a str")
        }

        fn port(&self) -> Option<u16> {
            self.port().map(|p| p.as_u16())
        }
    }

    /// Get system proxies information.
    ///
    /// All platforms will check for proxy settings via environment variables.
    /// If those aren't set, platform-wide proxy settings will be looked up on
    /// Windows and macOS platforms instead. Errors encountered while discovering
    /// these settings are ignored.
    ///
    /// Returns:
    ///     System proxies information as a hashmap like
    ///     {"http": Url::parse("http://127.0.0.1:80"), "https": Url::parse("https://127.0.0.1:80")}
    fn get_sys_proxies(
        #[cfg_attr(
            not(any(target_os = "windows", target_os = "macos")),
            allow(unused_variables)
        )]
        platform_proxies: Option<String>,
    ) -> SystemProxyMap {
        let proxies = get_from_environment();

        #[cfg(any(target_os = "windows", target_os = "macos"))]
        if proxies.is_empty() {
            // if there are errors in acquiring the platform proxies,
            // we'll just return an empty HashMap
            if let Some(platform_proxies) = platform_proxies {
                return parse_platform_values(platform_proxies);
            }
        }

        proxies
    }

    fn insert_proxy(proxies: &mut SystemProxyMap, scheme: impl Into<String>, addr: String) -> bool {
        if addr.trim().is_empty() {
            // do not accept empty or whitespace proxy address
            false
        } else if let Ok(valid_addr) = addr.into_proxy_scheme() {
            proxies.insert(scheme.into(), valid_addr);
            true
        } else {
            false
        }
    }

    fn get_from_environment() -> SystemProxyMap {
        let mut proxies = HashMap::new();

        if !(insert_from_env(&mut proxies, "http", "ALL_PROXY")
            && insert_from_env(&mut proxies, "https", "ALL_PROXY"))
        {
            insert_from_env(&mut proxies, "http", "all_proxy");
            insert_from_env(&mut proxies, "https", "all_proxy");
        }

        if is_cgi() {
            if log::log_enabled!(log::Level::Warn) && env::var_os("HTTP_PROXY").is_some() {
                log::warn!("HTTP_PROXY environment variable ignored in CGI");
            }
        } else if !insert_from_env(&mut proxies, "http", "HTTP_PROXY") {
            insert_from_env(&mut proxies, "http", "http_proxy");
        }

        if !insert_from_env(&mut proxies, "https", "HTTPS_PROXY") {
            insert_from_env(&mut proxies, "https", "https_proxy");
        }

        proxies
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Intercept` enum handle setting custom HTTP authentication headers, and what is an example of how this would be used in practice?
  codeQuestion3: What steps are taken to retrieve system proxy settings, and how does the code handle cases where environment variables are not set?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    fn insert_from_env(proxies: &mut SystemProxyMap, scheme: &str, var: &str) -> bool {
        if let Ok(val) = env::var(var) {
            insert_proxy(proxies, scheme, val)
        } else {
            false
        }
    }

    /// Check if we are being executed in a CGI context.
    ///
    /// If so, a malicious client can send the `Proxy:` header, and it will
    /// be in the `HTTP_PROXY` env var. So we don't use it :)
    fn is_cgi() -> bool {
        env::var_os("REQUEST_METHOD").is_some()
    }

    #[cfg(target_os = "windows")]
    fn get_from_platform_impl() -> Result<Option<String>, Box<dyn Error>> {
        let internet_setting = windows_registry::CURRENT_USER
            .open("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")?;
        // ensure the proxy is enabled, if the value doesn't exist, an error will be returned.
        let proxy_enable = internet_setting.get_u32("ProxyEnable")?;
        let proxy_server = internet_setting.get_string("ProxyServer")?;

        Ok((proxy_enable == 1).then_some(proxy_server))
    }

    #[cfg(all(target_os = "macos", feature = "macos-system-configuration"))]
    fn parse_setting_from_dynamic_store(
        proxies_map: &CFDictionary<CFString, CFType>,
        enabled_key: CFStringRef,
        host_key: CFStringRef,
        port_key: CFStringRef,
        scheme: &str,
    ) -> Option<String> {
        let proxy_enabled = proxies_map
            .find(enabled_key)
            .and_then(|flag| flag.downcast::<CFNumber>())
            .and_then(|flag| flag.to_i32())
            .unwrap_or(0)
            == 1;

        if proxy_enabled {
            let proxy_host = proxies_map
                .find(host_key)
                .and_then(|host| host.downcast::<CFString>())
                .map(|host| host.to_string());
            let proxy_port = proxies_map
                .find(port_key)
                .and_then(|port| port.downcast::<CFNumber>())
                .and_then(|port| port.to_i32());

            return match (proxy_host, proxy_port) {
                (Some(proxy_host), Some(proxy_port)) => {
                    Some(format!("{scheme}={proxy_host}:{proxy_port}"))
                }
                (Some(proxy_host), None) => Some(format!("{scheme}={proxy_host}")),
                (None, Some(_)) => None,
                (None, None) => None,
            };
        }

        None
    }

    #[cfg(all(target_os = "macos", feature = "macos-system-configuration"))]
    fn get_from_platform_impl() -> Result<Option<String>, Box<dyn Error>> {
        let store = SCDynamicStoreBuilder::new("reqwest").build();

        let proxies_map = if let Some(proxies_map) = store.get_proxies() {
            proxies_map
        } else {
            return Ok(None);
        };

        let http_proxy_config = parse_setting_from_dynamic_store(
            &proxies_map,
            unsafe { kSCPropNetProxiesHTTPEnable },
            unsafe { kSCPropNetProxiesHTTPProxy },
            unsafe { kSCPropNetProxiesHTTPPort },
            "http",
        );
        let https_proxy_config = parse_setting_from_dynamic_store(
            &proxies_map,
            unsafe { kSCPropNetProxiesHTTPSEnable },
            unsafe { kSCPropNetProxiesHTTPSProxy },
            unsafe { kSCPropNetProxiesHTTPSPort },
            "https",
        );

        match http_proxy_config.as_ref().zip(https_proxy_config.as_ref()) {
            Some((http_config, https_config)) => Ok(Some(format!("{http_config};{https_config}"))),
            None => Ok(http_proxy_config.or(https_proxy_config)),
        }
    }

    #[cfg(any(
        target_os = "windows",
        all(target_os = "macos", feature = "macos-system-configuration")
    ))]
    fn get_from_platform() -> Option<String> {
        get_from_platform_impl().ok().flatten()
    }

    #[cfg(not(any(
        target_os = "windows",
        all(target_os = "macos", feature = "macos-system-configuration")
    )))]
    fn get_from_platform() -> Option<String> {
        None
    }

    #[cfg(any(target_os = "windows", target_os = "macos"))]
    fn parse_platform_values_impl(platform_values: String) -> SystemProxyMap {
        let mut proxies = HashMap::new();
        if platform_values.contains("=") {
            // per-protocol settings.
            for p in platform_values.split(";") {
                let protocol_parts: Vec<&str> = p.split("=").collect();
                match protocol_parts.as_slice() {
                    [protocol, address] => {
                        // If address doesn't specify an explicit protocol as protocol://address
                        // then default to HTTP
                        let address = if extract_type_prefix(*address).is_some() {
                            String::from(*address)
                        } else {
                            format!("http://{address}")
                        };

                        insert_proxy(&mut proxies, *protocol, address);
                    }
                    _ => {
                        // Contains invalid protocol setting, just break the loop
                        // And make proxies to be empty.
                        proxies.clear();
                        break;
                    }
                }
            }
        } else {
            if let Some(scheme) = extract_type_prefix(&platform_values) {
                // Explicit protocol has been specified
                insert_proxy(&mut proxies, scheme, platform_values.to_owned());
            } else {
                // No explicit protocol has been specified, default to HTTP
                insert_proxy(&mut proxies, "http", format!("http://{platform_values}"));
                insert_proxy(&mut proxies, "https", format!("http://{platform_values}"));
            }
        }
        proxies
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle system-specific proxy settings on Windows and macOS, and what is an example of retrieving these settings?
  codeQuestion3: What steps are taken to parse and insert platform-specific proxy values into the system proxy map?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// Extract the protocol from the given address, if present
    /// For example, "https://example.com" will return Some("https")
    #[cfg(any(target_os = "windows", target_os = "macos"))]
    fn extract_type_prefix(address: &str) -> Option<&str> {
        if let Some(indice) = address.find("://") {
            if indice == 0 {
                None
            } else {
                let prefix = &address[..indice];
                let contains_banned = prefix.contains(|c| c == ':' || c == '/');

                if !contains_banned {
                    Some(prefix)
                } else {
                    None
                }
            }
        } else {
            None
        }
    }

    #[cfg(any(target_os = "windows", target_os = "macos"))]
    fn parse_platform_values(platform_values: String) -> SystemProxyMap {
        parse_platform_values_impl(platform_values)
    }

    #[cfg(target_os = "windows")]
    fn get_windows_proxy_exceptions() -> String {
        let mut exceptions = String::new();
        if let Ok(key) =
            CURRENT_USER.create(r"Software\Microsoft\Windows\CurrentVersion\Internet Settings")
        {
            if let Ok(value) = key.get_string("ProxyOverride") {
                exceptions = value
                    .split(';')
                    .map(|s| s.trim())
                    .collect::<Vec<&str>>()
                    .join(",")
                    .replace("*.", "");
            }
        }
        exceptions
    }

    #[cfg(test)]
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `extract_type_prefix` function determine the protocol of a given URL?
  codeQuestion3: What system calls or functions are used to retrieve proxy exceptions on Windows, and how are they processed?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod tests
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP requests and responses in a proxy scenario?
  codeQuestion3: What are the key components or modules involved in processing requests through the proxy?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        use super::*;
        use once_cell::sync::Lazy;
        use std::sync::Mutex;

        impl Dst for Url {
            fn scheme(&self) -> &str {
                Url::scheme(self)
            }

            fn host(&self) -> &str {
                Url::host_str(self).expect("<Url as Dst>::host should have a str")
            }

            fn port(&self) -> Option<u16> {
                Url::port(self)
            }
        }

        fn url(s: &str) -> Url {
            s.parse().unwrap()
        }

        fn intercepted_uri(p: &Proxy, s: &str) -> Uri {
            let (scheme, host) = match p.intercept(&url(s)).unwrap() {
                ProxyScheme::Http { host, .. } => ("http", host),
                ProxyScheme::Https { host, .. } => ("https", host),
                #[cfg(feature = "socks")]
                _ => panic!("intercepted as socks"),
            };
            http::Uri::builder()
                .scheme(scheme)
                .authority(host)
                .path_and_query("/")
                .build()
                .expect("intercepted_uri")
        }

        #[test]
        fn test_http() {
            let target = "http://example.domain/";
            let p = Proxy::http(target).unwrap();

            let http = "http://hyper.rs";
            let other = "https://hyper.rs";

            assert_eq!(intercepted_uri(&p, http), target);
            assert!(p.intercept(&url(other)).is_none());
        }

        #[test]
        fn test_https() {
            let target = "http://example.domain/";
            let p = Proxy::https(target).unwrap();

            let http = "http://hyper.rs";
            let other = "https://hyper.rs";

            assert!(p.intercept(&url(http)).is_none());
            assert_eq!(intercepted_uri(&p, other), target);
        }

        #[test]
        fn test_all() {
            let target = "http://example.domain/";
            let p = Proxy::all(target).unwrap();

            let http = "http://hyper.rs";
            let https = "https://hyper.rs";
            let other = "x-youve-never-heard-of-me-mr-proxy://hyper.rs";

            assert_eq!(intercepted_uri(&p, http), target);
            assert_eq!(intercepted_uri(&p, https), target);
            assert_eq!(intercepted_uri(&p, other), target);
        }

        #[test]
        fn test_custom() {
            let target1 = "http://example.domain/";
            let target2 = "https://example.domain/";
            let p = Proxy::custom(move |url| {
                if url.host_str() == Some("hyper.rs") {
                    target1.parse().ok()
                } else if url.scheme() == "http" {
                    target2.parse().ok()
                } else {
                    None::<Url>
                }
            });

            let http = "http://seanmonstar.com";
            let https = "https://hyper.rs";
            let other = "x-youve-never-heard-of-me-mr-proxy://seanmonstar.com";

            assert_eq!(intercepted_uri(&p, http), target2);
            assert_eq!(intercepted_uri(&p, https), target1);
            assert!(p.intercept(&url(other)).is_none());
        }

        #[test]
        fn test_proxy_scheme_parse() {
            let ps = "http://foo:bar@localhost:1239".into_proxy_scheme().unwrap();

            match ps {
                ProxyScheme::Http { auth, host } => {
                    assert_eq!(auth.unwrap(), encode_basic_auth("foo", "bar"));
                    assert_eq!(host, "localhost:1239");
                }
                other => panic!("unexpected: {other:?}"),
            }
        }

        #[test]
        fn test_proxy_scheme_ip_address_default_http() {
            let ps = "192.168.1.1:8888".into_proxy_scheme().unwrap();

            match ps {
                ProxyScheme::Http { auth, host } => {
                    assert!(auth.is_none());
                    assert_eq!(host, "192.168.1.1:8888");
                }
                other => panic!("unexpected: {other:?}"),
            }
        }

        #[test]
        fn test_proxy_scheme_parse_default_http_with_auth() {
            // this should fail because `foo` is interpreted as the scheme and no host can be found
            let ps = "foo:bar@localhost:1239".into_proxy_scheme().unwrap();

            match ps {
                ProxyScheme::Http { auth, host } => {
                    assert_eq!(auth.unwrap(), encode_basic_auth("foo", "bar"));
                    assert_eq!(host, "localhost:1239");
                }
                other => panic!("unexpected: {other:?}"),
            }
        }

        #[test]
        fn test_domain_matcher() {
            let domains = vec![".foo.bar".into(), "bar.foo".into()];
            let matcher = DomainMatcher(domains);

            // domains match with leading `.`
            assert!(matcher.contains("foo.bar"));
            // subdomains match with leading `.`
            assert!(matcher.contains("www.foo.bar"));

            // domains match with no leading `.`
            assert!(matcher.contains("bar.foo"));
            // subdomains match with no leading `.`
            assert!(matcher.contains("www.bar.foo"));

            // non-subdomain string prefixes don't match
            assert!(!matcher.contains("notfoo.bar"));
            assert!(!matcher.contains("notbar.foo"));
        }

        // Smallest possible content for a mutex
        struct MutexInner;

        static ENVLOCK: Lazy<Mutex<MutexInner>> = Lazy::new(|| Mutex::new(MutexInner));

        #[test]
        fn test_get_sys_proxies_parsing() {
            // Stop other threads from modifying process-global ENV while we are.
            let _lock = ENVLOCK.lock();
            // save system setting first.
            let _g1 = env_guard("HTTP_PROXY");
            let _g2 = env_guard("http_proxy");
            let _g3 = env_guard("ALL_PROXY");

            // Mock ENV, get the results, before doing assertions
            // to avoid assert! -> panic! -> Mutex Poisoned.
            let baseline_proxies = get_sys_proxies(None);
            // the system proxy setting url is invalid.
            env::set_var("http_proxy", "file://123465");
            let invalid_proxies = get_sys_proxies(None);
            // set valid proxy
            env::set_var("http_proxy", "127.0.0.1/");
            let valid_proxies = get_sys_proxies(None);
            // set valid ALL_PROXY
            env::set_var("ALL_PROXY", "127.0.0.2/");
            let all_proxies = get_sys_proxies(None);

            // reset user setting when guards drop
            drop(_g1);
            drop(_g2);
            // Let other threads run now
            drop(_lock);

            assert!(!baseline_proxies.contains_key("http"));
            assert!(!invalid_proxies.contains_key("http"));

            let p = &valid_proxies["http"];
            assert_eq!(p.scheme(), "http");
            assert_eq!(p.host(), "127.0.0.1");

            assert_eq!(all_proxies.len(), 2);
            // Set by ALL_PROXY
            assert_eq!(all_proxies["https"].host(), "127.0.0.2");
            // Overwritten by the more specific HTTP_PROXY
            assert_eq!(all_proxies["http"].host(), "127.0.0.1");
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `intercepted_uri` function handle different proxy schemes and what is an example of its usage?
  codeQuestion3: What steps are taken to manage environment variables when retrieving system proxies, and how does the code ensure thread safety during this process?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(any(target_os = "windows", target_os = "macos"))]
        #[test]
        fn test_get_sys_proxies_registry_parsing() {
            // Stop other threads from modifying process-global ENV while we are.
            let _lock = ENVLOCK.lock();
            // save system setting first.
            let _g1 = env_guard("HTTP_PROXY");
            let _g2 = env_guard("http_proxy");

            // Mock ENV, get the results, before doing assertions
            // to avoid assert! -> panic! -> Mutex Poisoned.
            let baseline_proxies = get_sys_proxies(None);
            // set valid proxy
            let valid_proxies = get_sys_proxies(Some(String::from("http://127.0.0.1/")));
            let valid_proxies_no_scheme = get_sys_proxies(Some(String::from("127.0.0.1")));
            let valid_proxies_explicit_https =
                get_sys_proxies(Some(String::from("https://127.0.0.1/")));
            let multiple_proxies = get_sys_proxies(Some(String::from(
                "http=127.0.0.1:8888;https=127.0.0.2:8888",
            )));
            let multiple_proxies_explicit_scheme = get_sys_proxies(Some(String::from(
                "http=http://127.0.0.1:8888;https=https://127.0.0.2:8888",
            )));

            // reset user setting when guards drop
            drop(_g1);
            drop(_g2);
            // Let other threads run now
            drop(_lock);

            assert_eq!(baseline_proxies.contains_key("http"), false);

            let p = &valid_proxies["http"];
            assert_eq!(p.scheme(), "http");
            assert_eq!(p.host(), "127.0.0.1");

            let p = &valid_proxies_no_scheme["http"];
            assert_eq!(p.scheme(), "http");
            assert_eq!(p.host(), "127.0.0.1");

            let p = &valid_proxies_no_scheme["https"];
            assert_eq!(p.scheme(), "http");
            assert_eq!(p.host(), "127.0.0.1");

            let p = &valid_proxies_explicit_https["https"];
            assert_eq!(p.scheme(), "https");
            assert_eq!(p.host(), "127.0.0.1");

            let p = &multiple_proxies["http"];
            assert_eq!(p.scheme(), "http");
            assert_eq!(p.host(), "127.0.0.1:8888");

            let p = &multiple_proxies["https"];
            assert_eq!(p.scheme(), "http");
            assert_eq!(p.host(), "127.0.0.2:8888");

            let p = &multiple_proxies_explicit_scheme["http"];
            assert_eq!(p.scheme(), "http");
            assert_eq!(p.host(), "127.0.0.1:8888");

            let p = &multiple_proxies_explicit_scheme["https"];
            assert_eq!(p.scheme(), "https");
            assert_eq!(p.host(), "127.0.0.2:8888");
        }

        #[test]
        fn test_get_sys_proxies_in_cgi() {
            // Stop other threads from modifying process-global ENV while we are.
            let _lock = ENVLOCK.lock();
            // save system setting first.
            let _g1 = env_guard("REQUEST_METHOD");
            let _g2 = env_guard("HTTP_PROXY");

            // Mock ENV, get the results, before doing assertions
            // to avoid assert! -> panic! -> Mutex Poisoned.
            env::set_var("HTTP_PROXY", "http://evil/");

            let baseline_proxies = get_sys_proxies(None);
            // set like we're in CGI
            env::set_var("REQUEST_METHOD", "GET");

            let cgi_proxies = get_sys_proxies(None);

            // reset user setting when guards drop
            drop(_g1);
            drop(_g2);
            // Let other threads run now
            drop(_lock);

            // not in CGI yet
            assert_eq!(baseline_proxies["http"].host(), "evil");
            // In CGI
            assert!(!cgi_proxies.contains_key("http"));
        }

        #[test]
        fn test_sys_no_proxy() {
            // Stop other threads from modifying process-global ENV while we are.
            let _lock = ENVLOCK.lock();
            // save system setting first.
            let _g1 = env_guard("HTTP_PROXY");
            let _g2 = env_guard("NO_PROXY");

            let target = "http://example.domain/";
            env::set_var("HTTP_PROXY", target);

            env::set_var(
                "NO_PROXY",
                ".foo.bar, bar.baz,10.42.1.1/24,::1,10.124.7.8,2001::/17",
            );

            // Manually construct this so we aren't use the cache
            let mut p = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(None))));
            p.no_proxy = NoProxy::from_env();

            // random url, not in no_proxy
            assert_eq!(intercepted_uri(&p, "http://hyper.rs"), target);
            // make sure that random non-subdomain string prefixes don't match
            assert_eq!(intercepted_uri(&p, "http://notfoo.bar"), target);
            // make sure that random non-subdomain string prefixes don't match
            assert_eq!(intercepted_uri(&p, "http://notbar.baz"), target);
            // ipv4 address out of range
            assert_eq!(intercepted_uri(&p, "http://10.43.1.1"), target);
            // ipv4 address out of range
            assert_eq!(intercepted_uri(&p, "http://10.124.7.7"), target);
            // ipv6 address out of range
            assert_eq!(intercepted_uri(&p, "http://[ffff:db8:a0b:12f0::1]"), target);
            // ipv6 address out of range
            assert_eq!(intercepted_uri(&p, "http://[2005:db8:a0b:12f0::1]"), target);

            // make sure subdomains (with leading .) match
            assert!(p.intercept(&url("http://hello.foo.bar")).is_none());
            // make sure exact matches (without leading .) match (also makes sure spaces between entries work)
            assert!(p.intercept(&url("http://bar.baz")).is_none());
            // check case sensitivity
            assert!(p.intercept(&url("http://BAR.baz")).is_none());
            // make sure subdomains (without leading . in no_proxy) match
            assert!(p.intercept(&url("http://foo.bar.baz")).is_none());
            // make sure subdomains (without leading . in no_proxy) match - this differs from cURL
            assert!(p.intercept(&url("http://foo.bar")).is_none());
            // ipv4 address match within range
            assert!(p.intercept(&url("http://10.42.1.100")).is_none());
            // ipv6 address exact match
            assert!(p.intercept(&url("http://[::1]")).is_none());
            // ipv6 address match within range
            assert!(p.intercept(&url("http://[2001:db8:a0b:12f0::1]")).is_none());
            // ipv4 address exact match
            assert!(p.intercept(&url("http://10.124.7.8")).is_none());

            // reset user setting when guards drop
            drop(_g1);
            drop(_g2);
            // Let other threads run now
            drop(_lock);
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle different proxy configurations, and what API is used to parse them?
  codeQuestion3: What steps are taken to ensure that no proxy settings are applied for specific domains or IP addresses?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[test]
        fn test_proxy_no_proxy_interception_for_proxy_types() {
            let proxy_url = "http://example.domain/";
            let no_proxy = ".no.proxy.tld";

            // test all proxy interception
            let p = Proxy::all(proxy_url)
                .unwrap()
                .no_proxy(NoProxy::from_string(no_proxy));

            // random url, not in no_proxy
            assert_eq!(intercepted_uri(&p, "http://hyper.rs"), proxy_url);

            // positive match for no proxy
            assert!(p.intercept(&url("https://hello.no.proxy.tld")).is_none());

            // test http proxy interception
            let p = Proxy::http(proxy_url)
                .unwrap()
                .no_proxy(NoProxy::from_string(no_proxy));

            // random url, not in no_proxy
            assert_eq!(intercepted_uri(&p, "http://hyper.rs"), proxy_url);

            // positive match for no proxy
            assert!(p.intercept(&url("http://hello.no.proxy.tld")).is_none());

            // should not be intercepted due to scheme
            assert!(p.intercept(&url("https://hyper.rs")).is_none());

            // test https proxy interception
            let p = Proxy::https(proxy_url)
                .unwrap()
                .no_proxy(NoProxy::from_string(no_proxy));

            // random url, not in no_proxy
            assert_eq!(intercepted_uri(&p, "https://hyper.rs"), proxy_url);

            // positive match for no proxy
            assert!(p.intercept(&url("https://hello.no.proxy.tld")).is_none());

            // should not be intercepted due to scheme
            assert!(p.intercept(&url("http://hyper.rs")).is_none());

            // test custom proxy interception
            let p = Proxy::custom(move |_url| Some(proxy_url)).no_proxy(NoProxy::from_string(no_proxy));

            // random url, not in no_proxy
            assert_eq!(intercepted_uri(&p, "https://hyper.rs"), proxy_url);

            // positive match for no proxy
            assert!(p.intercept(&url("https://hello.no.proxy.tld")).is_none());
            assert!(p.intercept(&url("http://hello.no.proxy.tld")).is_none());
        }

        #[test]
        fn test_wildcard_sys_no_proxy() {
            // Stop other threads from modifying process-global ENV while we are.
            let _lock = ENVLOCK.lock();
            // save system setting first.
            let _g1 = env_guard("HTTP_PROXY");
            let _g2 = env_guard("NO_PROXY");

            let target = "http://example.domain/";
            env::set_var("HTTP_PROXY", target);

            env::set_var("NO_PROXY", "*");

            // Manually construct this so we aren't use the cache
            let mut p = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(None))));
            p.no_proxy = NoProxy::from_env();

            assert!(p.intercept(&url("http://foo.bar")).is_none());

            // reset user setting when guards drop
            drop(_g1);
            drop(_g2);
            // Let other threads run now
            drop(_lock);
        }

        #[test]
        fn test_empty_sys_no_proxy() {
            // Stop other threads from modifying process-global ENV while we are.
            let _lock = ENVLOCK.lock();
            // save system setting first.
            let _g1 = env_guard("HTTP_PROXY");
            let _g2 = env_guard("NO_PROXY");

            let target = "http://example.domain/";
            env::set_var("HTTP_PROXY", target);

            env::set_var("NO_PROXY", ",");

            // Manually construct this so we aren't use the cache
            let mut p = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(None))));
            p.no_proxy = NoProxy::from_env();

            // everything should go through proxy, "effectively" nothing is in no_proxy
            assert_eq!(intercepted_uri(&p, "http://hyper.rs"), target);

            // Also test the behavior of `NO_PROXY` being an empty string.
            env::set_var("NO_PROXY", "");

            // Manually construct this so we aren't use the cache
            let mut p = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(None))));
            p.no_proxy = NoProxy::from_env();
            // In the case of an empty string `NoProxy::from_env()` should return `Some(..)`
            assert!(p.no_proxy.is_some());

            // everything should go through proxy, "effectively" nothing is in no_proxy
            assert_eq!(intercepted_uri(&p, "http://hyper.rs"), target);

            // reset user setting when guards drop
            drop(_g1);
            drop(_g2);
            // Let other threads run now
            drop(_lock);
        }

        #[test]
        fn test_no_proxy_load() {
            // Stop other threads from modifying process-global ENV while we are.
            let _lock = ENVLOCK.lock();

            let _g1 = env_guard("no_proxy");
            let domain = "lower.case";
            env::set_var("no_proxy", domain);
            // Manually construct this so we aren't use the cache
            let mut p = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(None))));
            p.no_proxy = NoProxy::from_env();
            assert_eq!(
                p.no_proxy.expect("should have a no proxy set").domains.0[0],
                domain
            );

            env::remove_var("no_proxy");
            let _g2 = env_guard("NO_PROXY");
            let domain = "upper.case";
            env::set_var("NO_PROXY", domain);
            // Manually construct this so we aren't use the cache
            let mut p = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(None))));
            p.no_proxy = NoProxy::from_env();
            assert_eq!(
                p.no_proxy.expect("should have a no proxy set").domains.0[0],
                domain
            );

            let _g3 = env_guard("HTTP_PROXY");
            env::remove_var("NO_PROXY");
            env::remove_var("no_proxy");
            let target = "http://example.domain/";
            env::set_var("HTTP_PROXY", target);

            // Manually construct this so we aren't use the cache
            let mut p = Proxy::new(Intercept::System(Arc::new(get_sys_proxies(None))));
            p.no_proxy = NoProxy::from_env();
            assert!(p.no_proxy.is_none(), "NoProxy shouldn't have been created");

            assert_eq!(intercepted_uri(&p, "http://hyper.rs"), target);

            // reset user setting when guards drop
            drop(_g1);
            drop(_g2);
            drop(_g3);
            // Let other threads run now
            drop(_lock);
        }
    ```
  codeQuestion1: What is the primary purpose of this Rust code?
  codeQuestion2: How does the code handle the scenario where a URL should be excluded from proxy interception based on environment variables?
  codeQuestion3: What is the role of the `NoProxy::from_env()` method in the code, and how is it used in different test cases?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(any(target_os = "windows", target_os = "macos"))]
        #[test]
        fn test_type_prefix_extraction() {
            assert!(extract_type_prefix("test").is_none());
            assert!(extract_type_prefix("://test").is_none());
            assert!(extract_type_prefix("some:prefix://test").is_none());
            assert!(extract_type_prefix("some/prefix://test").is_none());

            assert_eq!(extract_type_prefix("http://test").unwrap(), "http");
            assert_eq!(extract_type_prefix("a://test").unwrap(), "a");
        }

        /// Guard an environment variable, resetting it to the original value
        /// when dropped.
        fn env_guard(name: impl Into<String>) -> EnvGuard {
            let name = name.into();
            let orig_val = env::var(&name).ok();
            env::remove_var(&name);
            EnvGuard { name, orig_val }
        }

        struct EnvGuard {
            name: String,
            orig_val: Option<String>,
        }

        impl Drop for EnvGuard {
            fn drop(&mut self) {
                if let Some(val) = self.orig_val.take() {
                    env::set_var(&self.name, val);
                } else {
                    env::remove_var(&self.name);
                }
            }
        }

        #[test]
        fn test_has_http_auth() {
            let http_proxy_with_auth = Proxy {
                intercept: Intercept::Http(ProxyScheme::Http {
                    auth: Some(HeaderValue::from_static("auth1")),
                    host: http::uri::Authority::from_static("authority"),
                }),
                no_proxy: None,
            };
            assert!(http_proxy_with_auth.maybe_has_http_auth());
            assert_eq!(
                http_proxy_with_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                Some(HeaderValue::from_static("auth1"))
            );

            let http_proxy_without_auth = Proxy {
                intercept: Intercept::Http(ProxyScheme::Http {
                    auth: None,
                    host: http::uri::Authority::from_static("authority"),
                }),
                no_proxy: None,
            };
            assert!(!http_proxy_without_auth.maybe_has_http_auth());
            assert_eq!(
                http_proxy_without_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                None
            );

            let https_proxy_with_auth = Proxy {
                intercept: Intercept::Http(ProxyScheme::Https {
                    auth: Some(HeaderValue::from_static("auth2")),
                    host: http::uri::Authority::from_static("authority"),
                }),
                no_proxy: None,
            };
            assert!(https_proxy_with_auth.maybe_has_http_auth());
            assert_eq!(
                https_proxy_with_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                Some(HeaderValue::from_static("auth2"))
            );

            let all_http_proxy_with_auth = Proxy {
                intercept: Intercept::All(ProxyScheme::Http {
                    auth: Some(HeaderValue::from_static("auth3")),
                    host: http::uri::Authority::from_static("authority"),
                }),
                no_proxy: None,
            };
            assert!(all_http_proxy_with_auth.maybe_has_http_auth());
            assert_eq!(
                all_http_proxy_with_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                Some(HeaderValue::from_static("auth3"))
            );

            let all_https_proxy_with_auth = Proxy {
                intercept: Intercept::All(ProxyScheme::Https {
                    auth: Some(HeaderValue::from_static("auth4")),
                    host: http::uri::Authority::from_static("authority"),
                }),
                no_proxy: None,
            };
            assert!(all_https_proxy_with_auth.maybe_has_http_auth());
            assert_eq!(
                all_https_proxy_with_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                Some(HeaderValue::from_static("auth4"))
            );

            let all_https_proxy_without_auth = Proxy {
                intercept: Intercept::All(ProxyScheme::Https {
                    auth: None,
                    host: http::uri::Authority::from_static("authority"),
                }),
                no_proxy: None,
            };
            assert!(!all_https_proxy_without_auth.maybe_has_http_auth());
            assert_eq!(
                all_https_proxy_without_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                None
            );

            let system_http_proxy_with_auth = Proxy {
                intercept: Intercept::System(Arc::new({
                    let mut m = HashMap::new();
                    m.insert(
                        "http".into(),
                        ProxyScheme::Http {
                            auth: Some(HeaderValue::from_static("auth5")),
                            host: http::uri::Authority::from_static("authority"),
                        },
                    );
                    m
                })),
                no_proxy: None,
            };
            assert!(system_http_proxy_with_auth.maybe_has_http_auth());
            assert_eq!(
                system_http_proxy_with_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                Some(HeaderValue::from_static("auth5"))
            );

            let system_https_proxy_with_auth = Proxy {
                intercept: Intercept::System(Arc::new({
                    let mut m = HashMap::new();
                    m.insert(
                        "https".into(),
                        ProxyScheme::Https {
                            auth: Some(HeaderValue::from_static("auth6")),
                            host: http::uri::Authority::from_static("authority"),
                        },
                    );
                    m
                })),
                no_proxy: None,
            };
            assert!(!system_https_proxy_with_auth.maybe_has_http_auth());
            assert_eq!(
                system_https_proxy_with_auth.http_basic_auth(&Uri::from_static("http://example.com")),
                None
            );
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `env_guard` function ensure that environment variables are properly restored after use?
  codeQuestion3: What is the behavior of the `maybe_has_http_auth` method when dealing with different proxy schemes, and how is this demonstrated in the test cases?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/proxy.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(test)]
    mod test {
        mod into_proxy_scheme {
            use crate::Proxy;
            use std::error::Error;
            use std::mem::discriminant;

            fn includes(haystack: &crate::error::Error, needle: url::ParseError) -> bool {
                let mut source = haystack.source();
                while let Some(error) = source {
                    if let Some(parse_error) = error.downcast_ref::<url::ParseError>() {
                        if discriminant(parse_error) == discriminant(&needle) {
                            return true;
                        }
                    }
                    source = error.source();
                }
                false
            }

            fn check_parse_error(url: &str, needle: url::ParseError) {
                let error = Proxy::http(url).unwrap_err();
                if !includes(&error, needle) {
                    panic!("{needle:?} expected; {error:?}, {error} found");
                }
            }

            mod when_scheme_missing {
                mod and_url_is_valid {
                    use crate::Proxy;

                    #[test]
                    fn lookback_works() {
                        let _ = Proxy::http("127.0.0.1").unwrap();
                    }

                    #[test]
                    fn loopback_port_works() {
                        let _ = Proxy::http("127.0.0.1:8080").unwrap();
                    }

                    #[test]
                    fn loopback_username_works() {
                        let _ = Proxy::http("username@127.0.0.1").unwrap();
                    }

                    #[test]
                    fn loopback_username_password_works() {
                        let _ = Proxy::http("username:password@127.0.0.1").unwrap();
                    }

                    #[test]
                    fn loopback_username_password_port_works() {
                        let _ = Proxy::http("ldap%5Cgremlin:pass%3Bword@127.0.0.1:8080").unwrap();
                    }

                    #[test]
                    fn domain_works() {
                        let _ = Proxy::http("proxy.example.com").unwrap();
                    }

                    #[test]
                    fn domain_port_works() {
                        let _ = Proxy::http("proxy.example.com:8080").unwrap();
                    }

                    #[test]
                    fn domain_username_works() {
                        let _ = Proxy::http("username@proxy.example.com").unwrap();
                    }

                    #[test]
                    fn domain_username_password_works() {
                        let _ = Proxy::http("username:password@proxy.example.com").unwrap();
                    }

                    #[test]
                    fn domain_username_password_port_works() {
                        let _ =
                            Proxy::http("ldap%5Cgremlin:pass%3Bword@proxy.example.com:8080").unwrap();
                    }
                }
                mod and_url_has_bad {
                    use super::super::check_parse_error;

                    #[test]
                    fn host() {
                        check_parse_error("username@", url::ParseError::RelativeUrlWithoutBase);
                    }

                    #[test]
                    fn idna_encoding() {
                        check_parse_error("xn---", url::ParseError::RelativeUrlWithoutBase);
                    }

                    #[test]
                    fn port() {
                        check_parse_error("127.0.0.1:808080", url::ParseError::RelativeUrlWithoutBase);
                    }

                    #[test]
                    fn ip_v4_address() {
                        check_parse_error("421.627.718.469", url::ParseError::RelativeUrlWithoutBase);
                    }

                    #[test]
                    fn ip_v6_address() {
                        check_parse_error(
                            "[56FE::2159:5BBC::6594]",
                            url::ParseError::RelativeUrlWithoutBase,
                        );
                    }

                    #[test]
                    fn invalid_domain_character() {
                        check_parse_error("abc 123", url::ParseError::RelativeUrlWithoutBase);
                    }
                }
            }

            mod when_scheme_present {
                mod and_url_is_valid {
                    use crate::Proxy;

                    #[test]
                    fn loopback_works() {
                        let _ = Proxy::http("http://127.0.0.1").unwrap();
                    }

                    #[test]
                    fn loopback_port_works() {
                        let _ = Proxy::http("https://127.0.0.1:8080").unwrap();
                    }

                    #[test]
                    fn loopback_username_works() {
                        let _ = Proxy::http("http://username@127.0.0.1").unwrap();
                    }

                    #[test]
                    fn loopback_username_password_works() {
                        let _ = Proxy::http("https://username:password@127.0.0.1").unwrap();
                    }

                    #[test]
                    fn loopback_username_password_port_works() {
                        let _ =
                            Proxy::http("http://ldap%5Cgremlin:pass%3Bword@127.0.0.1:8080").unwrap();
                    }

                    #[test]
                    fn domain_works() {
                        let _ = Proxy::http("https://proxy.example.com").unwrap();
                    }

                    #[test]
                    fn domain_port_works() {
                        let _ = Proxy::http("http://proxy.example.com:8080").unwrap();
                    }

                    #[test]
                    fn domain_username_works() {
                        let _ = Proxy::http("https://username@proxy.example.com").unwrap();
                    }

                    #[test]
                    fn domain_username_password_works() {
                        let _ = Proxy::http("http://username:password@proxy.example.com").unwrap();
                    }

                    #[test]
                    fn domain_username_password_port_works() {
                        let _ =
                            Proxy::http("https://ldap%5Cgremlin:pass%3Bword@proxy.example.com:8080")
                                .unwrap();
                    }
                }
                mod and_url_has_bad {
                    use super::super::check_parse_error;

                    #[test]
                    fn host() {
                        check_parse_error("http://username@", url::ParseError::EmptyHost);
                    }

                    #[test]
                    fn idna_encoding() {
                        check_parse_error("http://xn---", url::ParseError::IdnaError);
                    }

                    #[test]
                    fn port() {
                        check_parse_error("http://127.0.0.1:808080", url::ParseError::InvalidPort);
                    }

                    #[test]
                    fn ip_v4_address() {
                        check_parse_error(
                            "http://421.627.718.469",
                            url::ParseError::InvalidIpv4Address,
                        );
                    }

                    #[test]
                    fn ip_v6_address() {
                        check_parse_error(
                            "http://[56FE::2159:5BBC::6594]",
                            url::ParseError::InvalidIpv6Address,
                        );
                    }
                }
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle invalid URLs when the scheme is present and the URL has bad formatting?
  codeQuestion3: What system calls or APIs are used to validate and process the proxy URLs in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/redirect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! Redirect Handling
    //!
    //! By default, a `Client` will automatically handle HTTP redirects, having a
    //! maximum redirect chain of 10 hops. To customize this behavior, a
    //! `redirect::Policy` can be used with a `ClientBuilder`.

    use std::error::Error as StdError;
    use std::fmt;

    use crate::header::{HeaderMap, AUTHORIZATION, COOKIE, PROXY_AUTHORIZATION, WWW_AUTHENTICATE};
    use hyper::StatusCode;

    use crate::Url;

    /// A type that controls the policy on how to handle the following of redirects.
    ///
    /// The default value will catch redirect loops, and has a maximum of 10
    /// redirects it will follow in a chain before returning an error.
    ///
    /// - `limited` can be used have the same as the default behavior, but adjust
    ///   the allowed maximum redirect hops in a chain.
    /// - `none` can be used to disable all redirect behavior.
    /// - `custom` can be used to create a customized policy.
    pub struct Policy {
        inner: PolicyKind,
    }

    /// A type that holds information on the next request and previous requests
    /// in redirect chain.
    #[derive(Debug)]
    pub struct Attempt<'a> {
        status: StatusCode,
        next: &'a Url,
        previous: &'a [Url],
    }

    /// An action to perform when a redirect status code is found.
    #[derive(Debug)]
    pub struct Action {
        inner: ActionKind,
    }

    impl Policy {
        /// Create a `Policy` with a maximum number of redirects.
        ///
        /// An `Error` will be returned if the max is reached.
        pub fn limited(max: usize) -> Self {
            Self {
                inner: PolicyKind::Limit(max),
            }
        }

        /// Create a `Policy` that does not follow any redirect.
        pub fn none() -> Self {
            Self {
                inner: PolicyKind::None,
            }
        }

        /// Create a custom `Policy` using the passed function.
        ///
        /// # Note
        ///
        /// The default `Policy` handles a maximum loop
        /// chain, but the custom variant does not do that for you automatically.
        /// The custom policy should have some way of handling those.
        ///
        /// Information on the next request and previous requests can be found
        /// on the [`Attempt`] argument passed to the closure.
        ///
        /// Actions can be conveniently created from methods on the
        /// [`Attempt`].
        ///
        /// # Example
        ///
        /// ```rust
        /// # use reqwest::{Error, redirect};
        /// #
        /// # fn run() -> Result<(), Error> {
        /// let custom = redirect::Policy::custom(|attempt| {
        ///     if attempt.previous().len() > 5 {
        ///         attempt.error("too many redirects")
        ///     } else if attempt.url().host_str() == Some("example.domain") {
        ///         // prevent redirects to 'example.domain'
        ///         attempt.stop()
        ///     } else {
        ///         attempt.follow()
        ///     }
        /// });
        /// let client = reqwest::Client::builder()
        ///     .redirect(custom)
        ///     .build()?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// [`Attempt`]: struct.Attempt.html
        pub fn custom<T>(policy: T) -> Self
        where
            T: Fn(Attempt) -> Action + Send + Sync + 'static,
        {
            Self {
                inner: PolicyKind::Custom(Box::new(policy)),
            }
        }

        /// Apply this policy to a given [`Attempt`] to produce a [`Action`].
        ///
        /// # Note
        ///
        /// This method can be used together with `Policy::custom()`
        /// to construct one `Policy` that wraps another.
        ///
        /// # Example
        ///
        /// ```rust
        /// # use reqwest::{Error, redirect};
        /// #
        /// # fn run() -> Result<(), Error> {
        /// let custom = redirect::Policy::custom(|attempt| {
        ///     eprintln!("{}, Location: {:?}", attempt.status(), attempt.url());
        ///     redirect::Policy::default().redirect(attempt)
        /// });
        /// # Ok(())
        /// # }
        /// ```
        pub fn redirect(&self, attempt: Attempt) -> Action {
            match self.inner {
                PolicyKind::Custom(ref custom) => custom(attempt),
                PolicyKind::Limit(max) => {
                    // The first URL in the previous is the initial URL and not a redirection. It needs to be excluded.
                    if attempt.previous.len() > max {
                        attempt.error(TooManyRedirects)
                    } else {
                        attempt.follow()
                    }
                }
                PolicyKind::None => attempt.stop(),
            }
        }

        pub(crate) fn check(&self, status: StatusCode, next: &Url, previous: &[Url]) -> ActionKind {
            self.redirect(Attempt {
                status,
                next,
                previous,
            })
            .inner
        }

        pub(crate) fn is_default(&self) -> bool {
            matches!(self.inner, PolicyKind::Limit(10))
        }
    }

    impl Default for Policy {
        fn default() -> Policy {
            // Keep `is_default` in sync
            Policy::limited(10)
        }
    }

    impl<'a> Attempt<'a> {
        /// Get the type of redirect.
        pub fn status(&self) -> StatusCode {
            self.status
        }

        /// Get the next URL to redirect to.
        pub fn url(&self) -> &Url {
            self.next
        }

        /// Get the list of previous URLs that have already been requested in this chain.
        pub fn previous(&self) -> &[Url] {
            self.previous
        }
        /// Returns an action meaning reqwest should follow the next URL.
        pub fn follow(self) -> Action {
            Action {
                inner: ActionKind::Follow,
            }
        }

        /// Returns an action meaning reqwest should not follow the next URL.
        ///
        /// The 30x response will be returned as the `Ok` result.
        pub fn stop(self) -> Action {
            Action {
                inner: ActionKind::Stop,
            }
        }

        /// Returns an action failing the redirect with an error.
        ///
        /// The `Error` will be returned for the result of the sent request.
        pub fn error<E: Into<Box<dyn StdError + Send + Sync>>>(self, error: E) -> Action {
            Action {
                inner: ActionKind::Error(error.into()),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a custom redirect policy be implemented, and what is an example of such a policy?
  codeQuestion3: What steps are involved in checking and applying a redirect policy when handling a response?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/redirect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    enum PolicyKind {
        Custom(Box<dyn Fn(Attempt) -> Action + Send + Sync + 'static>),
        Limit(usize),
        None,
    }

    impl fmt::Debug for Policy {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_tuple("Policy").field(&self.inner).finish()
        }
    }

    impl fmt::Debug for PolicyKind {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                PolicyKind::Custom(..) => f.pad("Custom"),
                PolicyKind::Limit(max) => f.debug_tuple("Limit").field(&max).finish(),
                PolicyKind::None => f.pad("None"),
            }
        }
    }

    // pub(crate)

    #[derive(Debug)]
    pub(crate) enum ActionKind {
        Follow,
        Stop,
        Error(Box<dyn StdError + Send + Sync>),
    }

    pub(crate) fn remove_sensitive_headers(headers: &mut HeaderMap, next: &Url, previous: &[Url]) {
        if let Some(previous) = previous.last() {
            let cross_host = next.host_str() != previous.host_str()
                || next.port_or_known_default() != previous.port_or_known_default();
            if cross_host {
                headers.remove(AUTHORIZATION);
                headers.remove(COOKIE);
                headers.remove("cookie2");
                headers.remove(PROXY_AUTHORIZATION);
                headers.remove(WWW_AUTHENTICATE);
            }
        }
    }

    #[derive(Debug)]
    struct TooManyRedirects;

    impl fmt::Display for TooManyRedirects {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_str("too many redirects")
        }
    }

    impl StdError for TooManyRedirects {}

    #[test]
    fn test_redirect_policy_limit() {
        let policy = Policy::default();
        let next = Url::parse("http://x.y/z").unwrap();
        let mut previous = (0..=9)
            .map(|i| Url::parse(&format!("http://a.b/c/{i}")).unwrap())
            .collect::<Vec<_>>();

        match policy.check(StatusCode::FOUND, &next, &previous) {
            ActionKind::Follow => (),
            other => panic!("unexpected {other:?}"),
        }

        previous.push(Url::parse("http://a.b.d/e/33").unwrap());

        match policy.check(StatusCode::FOUND, &next, &previous) {
            ActionKind::Error(err) if err.is::<TooManyRedirects>() => (),
            other => panic!("unexpected {other:?}"),
        }
    }

    #[test]
    fn test_redirect_policy_limit_to_0() {
        let policy = Policy::limited(0);
        let next = Url::parse("http://x.y/z").unwrap();
        let previous = vec![Url::parse("http://a.b/c").unwrap()];

        match policy.check(StatusCode::FOUND, &next, &previous) {
            ActionKind::Error(err) if err.is::<TooManyRedirects>() => (),
            other => panic!("unexpected {other:?}"),
        }
    }

    #[test]
    fn test_redirect_policy_custom() {
        let policy = Policy::custom(|attempt| {
            if attempt.url().host_str() == Some("foo") {
                attempt.stop()
            } else {
                attempt.follow()
            }
        });

        let next = Url::parse("http://bar/baz").unwrap();
        match policy.check(StatusCode::FOUND, &next, &[]) {
            ActionKind::Follow => (),
            other => panic!("unexpected {other:?}"),
        }

        let next = Url::parse("http://foo/baz").unwrap();
        match policy.check(StatusCode::FOUND, &next, &[]) {
            ActionKind::Stop => (),
            other => panic!("unexpected {other:?}"),
        }
    }

    #[test]
    fn test_remove_sensitive_headers() {
        use hyper::header::{HeaderValue, ACCEPT, AUTHORIZATION, COOKIE};

        let mut headers = HeaderMap::new();
        headers.insert(ACCEPT, HeaderValue::from_static("*/*"));
        headers.insert(AUTHORIZATION, HeaderValue::from_static("let me in"));
        headers.insert(COOKIE, HeaderValue::from_static("foo=bar"));

        let next = Url::parse("http://initial-domain.com/path").unwrap();
        let mut prev = vec![Url::parse("http://initial-domain.com/new_path").unwrap()];
        let mut filtered_headers = headers.clone();

        remove_sensitive_headers(&mut headers, &next, &prev);
        assert_eq!(headers, filtered_headers);

        prev.push(Url::parse("http://new-domain.com/path").unwrap());
        filtered_headers.remove(AUTHORIZATION);
        filtered_headers.remove(COOKIE);

        remove_sensitive_headers(&mut headers, &next, &prev);
        assert_eq!(headers, filtered_headers);
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the custom redirect policy in the test_redirect_policy_custom function handle different URLs, and what is the expected behavior when the URL host is 'foo'?
  codeQuestion3: What steps are taken in the remove_sensitive_headers function to remove specific headers when a redirect occurs between different domains?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/util.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use crate::header::{Entry, HeaderMap, HeaderValue, OccupiedEntry};

    pub fn basic_auth<U, P>(username: U, password: Option<P>) -> HeaderValue
    where
        U: std::fmt::Display,
        P: std::fmt::Display,
    {
        use base64::prelude::BASE64_STANDARD;
        use base64::write::EncoderWriter;
        use std::io::Write;

        let mut buf = b"Basic ".to_vec();
        {
            let mut encoder = EncoderWriter::new(&mut buf, &BASE64_STANDARD);
            let _ = write!(encoder, "{username}:");
            if let Some(password) = password {
                let _ = write!(encoder, "{password}");
            }
        }
        let mut header = HeaderValue::from_bytes(&buf).expect("base64 is always valid HeaderValue");
        header.set_sensitive(true);
        header
    }

    // xor-shift
    #[cfg(not(target_arch = "wasm32"))]
    pub(crate) fn fast_random() -> u64 {
        use std::cell::Cell;
        use std::collections::hash_map::RandomState;
        use std::hash::{BuildHasher, Hasher};
        use std::num::Wrapping;

        thread_local! {
            static RNG: Cell<Wrapping<u64>> = Cell::new(Wrapping(seed()));
        }

        fn seed() -> u64 {
            let seed = RandomState::new();

            let mut out = 0;
            let mut cnt = 0;
            while out == 0 {
                cnt += 1;
                let mut hasher = seed.build_hasher();
                hasher.write_usize(cnt);
                out = hasher.finish();
            }
            out
        }

        RNG.with(|rng| {
            let mut n = rng.get();
            debug_assert_ne!(n.0, 0);
            n ^= n >> 12;
            n ^= n << 25;
            n ^= n >> 27;
            rng.set(n);
            n.0.wrapping_mul(0x2545_f491_4f6c_dd1d)
        })
    }

    pub(crate) fn replace_headers(dst: &mut HeaderMap, src: HeaderMap) {
        // IntoIter of HeaderMap yields (Option<HeaderName>, HeaderValue).
        // The first time a name is yielded, it will be Some(name), and if
        // there are more values with the same name, the next yield will be
        // None.

        let mut prev_entry: Option<OccupiedEntry<_>> = None;
        for (key, value) in src {
            match key {
                Some(key) => match dst.entry(key) {
                    Entry::Occupied(mut e) => {
                        e.insert(value);
                        prev_entry = Some(e);
                    }
                    Entry::Vacant(e) => {
                        let e = e.insert_entry(value);
                        prev_entry = Some(e);
                    }
                },
                None => match prev_entry {
                    Some(ref mut entry) => {
                        entry.append(value);
                    }
                    None => unreachable!("HeaderMap::into_iter yielded None first"),
                },
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `basic_auth` function generate and encode a Basic Authentication header?
  codeQuestion3: What is the role of the `replace_headers` function in handling HTTP headers?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::fmt;
    use std::io::{self, Read};
    use std::mem;
    use std::net::SocketAddr;
    use std::pin::Pin;
    use std::time::Duration;

    use bytes::Bytes;
    use http;
    use hyper::header::HeaderMap;
    #[cfg(feature = "json")]
    use serde::de::DeserializeOwned;

    use super::client::KeepCoreThreadAlive;
    use super::wait;
    #[cfg(feature = "cookies")]
    use crate::cookie;
    use crate::{async_impl, StatusCode, Url, Version};

    /// A Response to a submitted `Request`.
    pub struct Response {
        inner: async_impl::Response,
        body: Option<Pin<Box<dyn futures_util::io::AsyncRead + Send + Sync>>>,
        timeout: Option<Duration>,
        _thread_handle: KeepCoreThreadAlive,
    }

    impl fmt::Debug for Response {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            fmt::Debug::fmt(&self.inner, f)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Response` struct handle asynchronous reading of data from a network request?
  codeQuestion3: What mechanisms are in place to ensure the core thread remains alive during asynchronous operations?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Response
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP response headers when a request is made to an endpoint?
  codeQuestion3: What steps are taken to handle errors in the response handling process?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        pub(crate) fn new(
            res: async_impl::Response,
            timeout: Option<Duration>,
            thread: KeepCoreThreadAlive,
        ) -> Response {
            Response {
                inner: res,
                body: None,
                timeout,
                _thread_handle: thread,
            }
        }

        /// Get the `StatusCode` of this `Response`.
        ///
        /// # Examples
        ///
        /// Checking for general status class:
        ///
        /// ```rust
        /// # #[cfg(feature = "json")]
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let resp = reqwest::blocking::get("http://httpbin.org/get")?;
        /// if resp.status().is_success() {
        ///     println!("success!");
        /// } else if resp.status().is_server_error() {
        ///     println!("server error!");
        /// } else {
        ///     println!("Something else happened. Status: {:?}", resp.status());
        /// }
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// Checking for specific status codes:
        ///
        /// ```rust
        /// use reqwest::blocking::Client;
        /// use reqwest::StatusCode;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = Client::new();
        ///
        /// let resp = client.post("http://httpbin.org/post")
        ///     .body("possibly too large")
        ///     .send()?;
        ///
        /// match resp.status() {
        ///     StatusCode::OK => println!("success!"),
        ///     StatusCode::PAYLOAD_TOO_LARGE => {
        ///         println!("Request payload is too large!");
        ///     }
        ///     s => println!("Received response status: {s:?}"),
        /// };
        /// # Ok(())
        /// # }
        /// ```
        #[inline]
        pub fn status(&self) -> StatusCode {
            self.inner.status()
        }

        /// Get the `Headers` of this `Response`.
        ///
        /// # Example
        ///
        /// Saving an etag when caching a file:
        ///
        /// ```
        /// use reqwest::blocking::Client;
        /// use reqwest::header::ETAG;
        ///
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = Client::new();
        ///
        /// let mut resp = client.get("http://httpbin.org/cache").send()?;
        /// if resp.status().is_success() {
        ///     if let Some(etag) = resp.headers().get(ETAG) {
        ///         std::fs::write("etag", etag.as_bytes());
        ///     }
        ///     let mut file = std::fs::File::create("file")?;
        ///     resp.copy_to(&mut file)?;
        /// }
        /// # Ok(())
        /// # }
        /// ```
        #[inline]
        pub fn headers(&self) -> &HeaderMap {
            self.inner.headers()
        }

        /// Get a mutable reference to the `Headers` of this `Response`.
        #[inline]
        pub fn headers_mut(&mut self) -> &mut HeaderMap {
            self.inner.headers_mut()
        }

        /// Retrieve the cookies contained in the response.
        ///
        /// Note that invalid 'Set-Cookie' headers will be ignored.
        ///
        /// # Optional
        ///
        /// This requires the optional `cookies` feature to be enabled.
        #[cfg(feature = "cookies")]
        #[cfg_attr(docsrs, doc(cfg(feature = "cookies")))]
        pub fn cookies<'a>(&'a self) -> impl Iterator<Item = cookie::Cookie<'a>> + 'a {
            cookie::extract_response_cookies(self.headers()).filter_map(Result::ok)
        }

        /// Get the HTTP `Version` of this `Response`.
        #[inline]
        pub fn version(&self) -> Version {
            self.inner.version()
        }

        /// Get the final `Url` of this `Response`.
        ///
        /// # Example
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let resp = reqwest::blocking::get("http://httpbin.org/redirect/1")?;
        /// assert_eq!(resp.url().as_str(), "http://httpbin.org/get");
        /// # Ok(())
        /// # }
        /// ```
        #[inline]
        pub fn url(&self) -> &Url {
            self.inner.url()
        }

        /// Get the remote address used to get this `Response`.
        ///
        /// # Example
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let resp = reqwest::blocking::get("http://httpbin.org/redirect/1")?;
        /// println!("httpbin.org address: {:?}", resp.remote_addr());
        /// # Ok(())
        /// # }
        /// ```
        pub fn remote_addr(&self) -> Option<SocketAddr> {
            self.inner.remote_addr()
        }

        /// Returns a reference to the associated extensions.
        pub fn extensions(&self) -> &http::Extensions {
            self.inner.extensions()
        }

        /// Returns a mutable reference to the associated extensions.
        pub fn extensions_mut(&mut self) -> &mut http::Extensions {
            self.inner.extensions_mut()
        }

        /// Get the content length of the response, if it is known.
        ///
        ///
        /// This value does not directly represents the value of the `Content-Length`
        /// header, but rather the size of the response's body. To read the header's
        /// value, please use the [`Response::headers`] method instead.
        ///
        /// Reasons it may not be known:
        ///
        /// - The response does not include a body (e.g. it responds to a `HEAD`
        ///   request).
        /// - The response is gzipped and automatically decoded (thus changing the
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user retrieve specific headers from the response and what API is used for that?
  codeQuestion3: What steps are taken to handle the response's content length and how is it accessed in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///   actual decoded length).
        pub fn content_length(&self) -> Option<u64> {
            self.inner.content_length()
        }

        /// Try and deserialize the response body as JSON using `serde`.
        ///
        /// # Optional
        ///
        /// This requires the optional `json` feature enabled.
        ///
        /// # Examples
        ///
        /// ```rust
        /// # extern crate reqwest;
        /// # extern crate serde;
        /// #
        /// # use reqwest::Error;
        /// # use serde::Deserialize;
        /// #
        /// // This `derive` requires the `serde` dependency.
        /// #[derive(Deserialize)]
        /// struct Ip {
        ///     origin: String,
        /// }
        ///
        /// # fn run() -> Result<(), Error> {
        /// let json: Ip = reqwest::blocking::get("http://httpbin.org/ip")?.json()?;
        /// # Ok(())
        /// # }
        /// #
        /// # fn main() { }
        /// ```
        ///
        /// # Errors
        ///
        /// This method fails whenever the response body is not in JSON format,
        /// or it cannot be properly deserialized to target type `T`. For more
        /// details please see [`serde_json::from_reader`].
        ///
        /// [`serde_json::from_reader`]: https://docs.serde.rs/serde_json/fn.from_reader.html
        #[cfg(feature = "json")]
        #[cfg_attr(docsrs, doc(cfg(feature = "json")))]
        pub fn json<T: DeserializeOwned>(self) -> crate::Result<T> {
            wait::timeout(self.inner.json(), self.timeout).map_err(|e| match e {
                wait::Waited::TimedOut(e) => crate::error::decode(e),
                wait::Waited::Inner(e) => e,
            })
        }

        /// Get the full response body as `Bytes`.
        ///
        /// # Example
        ///
        /// ```
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let bytes = reqwest::blocking::get("http://httpbin.org/ip")?.bytes()?;
        ///
        /// println!("bytes: {bytes:?}");
        /// # Ok(())
        /// # }
        /// ```
        pub fn bytes(self) -> crate::Result<Bytes> {
            wait::timeout(self.inner.bytes(), self.timeout).map_err(|e| match e {
                wait::Waited::TimedOut(e) => crate::error::decode(e),
                wait::Waited::Inner(e) => e,
            })
        }

        /// Get the response text.
        ///
        /// This method decodes the response body with BOM sniffing
        /// and with malformed sequences replaced with the [`char::REPLACEMENT_CHARACTER`].
        /// Encoding is determined from the `charset` parameter of `Content-Type` header,
        /// and defaults to `utf-8` if not presented.
        ///
        /// # Note
        ///
        /// If the `charset` feature is disabled the method will only attempt to decode the
        /// response as UTF-8, regardless of the given `Content-Type`
        ///
        /// # Example
        ///
        /// ```rust
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let content = reqwest::blocking::get("http://httpbin.org/range/26")?.text()?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn text(self) -> crate::Result<String> {
            wait::timeout(self.inner.text(), self.timeout).map_err(|e| match e {
                wait::Waited::TimedOut(e) => crate::error::decode(e),
                wait::Waited::Inner(e) => e,
            })
        }

        /// Get the response text given a specific encoding.
        ///
        /// This method decodes the response body with BOM sniffing
        /// and with malformed sequences replaced with the [`char::REPLACEMENT_CHARACTER`].
        /// You can provide a default encoding for decoding the raw message, while the
        /// `charset` parameter of `Content-Type` header is still prioritized. For more information
        /// about the possible encoding name, please go to [`encoding_rs`] docs.
        ///
        /// [`encoding_rs`]: https://docs.rs/encoding_rs/0.8/encoding_rs/#relationship-with-windows-code-pages
        ///
        /// # Optional
        ///
        /// This requires the optional `charset` feature enabled.
        ///
        /// # Example
        ///
        /// ```rust
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let content = reqwest::blocking::get("http://httpbin.org/range/26")?
        ///     .text_with_charset("utf-8")?;
        /// # Ok(())
        /// # }
        /// ```
        #[cfg(feature = "charset")]
        #[cfg_attr(docsrs, doc(cfg(feature = "charset")))]
        pub fn text_with_charset(self, default_encoding: &str) -> crate::Result<String> {
            wait::timeout(self.inner.text_with_charset(default_encoding), self.timeout).map_err(|e| {
                match e {
                    wait::Waited::TimedOut(e) => crate::error::decode(e),
                    wait::Waited::Inner(e) => e,
                }
            })
        }

        /// Copy the response body into a writer.
        ///
        /// This function internally uses [`std::io::copy`] and hence will continuously read data from
        /// the body and then write it into writer in a streaming fashion until EOF is met.
        ///
        /// On success, the total number of bytes that were copied to `writer` is returned.
        ///
        /// [`std::io::copy`]: https://doc.rust-lang.org/std/io/fn.copy.html
        ///
        /// # Example
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut resp = reqwest::blocking::get("http://httpbin.org/range/5")?;
        /// let mut buf: Vec<u8> = vec![];
        /// resp.copy_to(&mut buf)?;
        /// assert_eq!(b"abcde", buf.as_slice());
        /// # Ok(())
        /// # }
        /// ```
        pub fn copy_to<W: ?Sized>(&mut self, w: &mut W) -> crate::Result<u64>
        where
            W: io::Write,
        {
            io::copy(self, w).map_err(crate::error::decode_io)
        }

        /// Turn a response into an error if the server returned an error.
        ///
        /// # Example
        ///
        /// ```rust,no_run
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let res = reqwest::blocking::get("http://httpbin.org/status/400")?
        ///     .error_for_status();
        /// if let Err(err) = res {
        ///     assert_eq!(err.status(), Some(reqwest::StatusCode::BAD_REQUEST));
        /// }
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn error_for_status(self) -> crate::Result<Self> {
            let Response {
                body,
                inner,
                timeout,
                _thread_handle,
            } = self;
            inner.error_for_status().map(move |inner| Response {
                inner,
                body,
                timeout,
                _thread_handle,
            })
        }

        /// Turn a reference to a response into an error if the server returned an error.
        ///
        /// # Example
        ///
        /// ```rust,no_run
        /// # extern crate reqwest;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let res = reqwest::blocking::get("http://httpbin.org/status/400")?;
        /// let res = res.error_for_status_ref();
        /// if let Err(err) = res {
        ///     assert_eq!(err.status(), Some(reqwest::StatusCode::BAD_REQUEST));
        /// }
        /// # Ok(())
        /// # }
        /// # fn main() {}
        /// ```
        pub fn error_for_status_ref(&self) -> crate::Result<&Self> {
            self.inner.error_for_status_ref().and_then(|_| Ok(self))
        }

        // private

        fn body_mut(&mut self) -> Pin<&mut dyn futures_util::io::AsyncRead> {
            use futures_util::TryStreamExt;
            if self.body.is_none() {
                let body = mem::replace(self.inner.body_mut(), async_impl::Decoder::empty());

                let body = body.into_stream().into_async_read();

                self.body = Some(Box::pin(body));
            }
            self.body.as_mut().expect("body was init").as_mut()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `json()` method deserialize a JSON response into a Rust struct, and what are the necessary dependencies?
  codeQuestion3: What steps does the `text()` method take to decode the response body into a string, and how is it affected by the `charset` feature?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Read for Response {
        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
            use futures_util::io::AsyncReadExt;

            let timeout = self.timeout;
            wait::timeout(self.body_mut().read(buf), timeout).map_err(|e| match e {
                wait::Waited::TimedOut(e) => crate::error::decode(e).into_io(),
                wait::Waited::Inner(e) => e,
            })
        }
    }

    impl<T: Into<async_impl::body::Body>> From<http::Response<T>> for Response {
        fn from(r: http::Response<T>) -> Response {
            let response = async_impl::Response::from(r);
            Response::new(response, None, KeepCoreThreadAlive::empty())
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle asynchronous reading from a HTTP response body with a timeout?
  codeQuestion3: What is the role of the `From` implementation for converting an HTTP response into a `Response` type?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::convert::TryFrom;
    use std::fmt;
    use std::time::Duration;

    use http::{request::Parts, Request as HttpRequest, Version};
    use serde::Serialize;
    #[cfg(feature = "json")]
    use serde_json;
    use serde_urlencoded;

    use super::body::{self, Body};
    #[cfg(feature = "multipart")]
    use super::multipart;
    use super::Client;
    use crate::header::{HeaderMap, HeaderName, HeaderValue, CONTENT_TYPE};
    use crate::{async_impl, Method, Url};

    /// A request which can be executed with `Client::execute()`.
    pub struct Request {
        body: Option<Body>,
        inner: async_impl::Request,
    }

    /// A builder to construct the properties of a `Request`.
    ///
    /// To construct a `RequestBuilder`, refer to the `Client` documentation.
    #[derive(Debug)]
    #[must_use = "RequestBuilder does nothing until you 'send' it"]
    pub struct RequestBuilder {
        client: Client,
        request: crate::Result<Request>,
    }

    impl Request {
        /// Constructs a new request.
        #[inline]
        pub fn new(method: Method, url: Url) -> Self {
            Request {
                body: None,
                inner: async_impl::Request::new(method, url),
            }
        }

        /// Get the method.
        #[inline]
        pub fn method(&self) -> &Method {
            self.inner.method()
        }

        /// Get a mutable reference to the method.
        #[inline]
        pub fn method_mut(&mut self) -> &mut Method {
            self.inner.method_mut()
        }

        /// Get the url.
        #[inline]
        pub fn url(&self) -> &Url {
            self.inner.url()
        }

        /// Get a mutable reference to the url.
        #[inline]
        pub fn url_mut(&mut self) -> &mut Url {
            self.inner.url_mut()
        }

        /// Get the headers.
        #[inline]
        pub fn headers(&self) -> &HeaderMap {
            self.inner.headers()
        }

        /// Get a mutable reference to the headers.
        #[inline]
        pub fn headers_mut(&mut self) -> &mut HeaderMap {
            self.inner.headers_mut()
        }

        /// Get the http version.
        #[inline]
        pub fn version(&self) -> Version {
            self.inner.version()
        }

        /// Get a mutable reference to the http version.
        #[inline]
        pub fn version_mut(&mut self) -> &mut Version {
            self.inner.version_mut()
        }

        /// Get the body.
        #[inline]
        pub fn body(&self) -> Option<&Body> {
            self.body.as_ref()
        }

        /// Get a mutable reference to the body.
        #[inline]
        pub fn body_mut(&mut self) -> &mut Option<Body> {
            &mut self.body
        }

        /// Get the timeout.
        #[inline]
        pub fn timeout(&self) -> Option<&Duration> {
            self.inner.timeout()
        }

        /// Get a mutable reference to the timeout.
        #[inline]
        pub fn timeout_mut(&mut self) -> &mut Option<Duration> {
            self.inner.timeout_mut()
        }

        /// Attempts to clone the `Request`.
        ///
        /// None is returned if a body is which can not be cloned. This can be because the body is a
        /// stream.
        pub fn try_clone(&self) -> Option<Request> {
            let body = if let Some(ref body) = self.body.as_ref() {
                if let Some(body) = body.try_clone() {
                    Some(body)
                } else {
                    return None;
                }
            } else {
                None
            };
            let mut req = Request::new(self.method().clone(), self.url().clone());
            *req.timeout_mut() = self.timeout().copied();
            *req.headers_mut() = self.headers().clone();
            *req.version_mut() = self.version().clone();
            req.body = body;
            Some(req)
        }

        pub(crate) fn into_async(self) -> (async_impl::Request, Option<body::Sender>) {
            use crate::header::CONTENT_LENGTH;

            let mut req_async = self.inner;
            let body = self.body.and_then(|body| {
                let (tx, body, len) = body.into_async();
                if let Some(len) = len {
                    req_async.headers_mut().insert(CONTENT_LENGTH, len.into());
                }
                *req_async.body_mut() = Some(body);
                tx
            });
            (req_async, body)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer set a custom header for a request, and what are the steps involved in doing so?
  codeQuestion3: What is the process for handling the body of a request, especially when dealing with streaming data?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl RequestBuilder
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle making a HTTP request with custom headers?
  codeQuestion3: What steps are taken to handle the response from an HTTP request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        pub(crate) fn new(client: Client, request: crate::Result<Request>) -> RequestBuilder {
            let mut builder = RequestBuilder { client, request };

            let auth = builder
                .request
                .as_mut()
                .ok()
                .and_then(|req| async_impl::request::extract_authority(req.url_mut()));

            if let Some((username, password)) = auth {
                builder.basic_auth(username, password)
            } else {
                builder
            }
        }

        /// Assemble a builder starting from an existing `Client` and a `Request`.
        pub fn from_parts(client: Client, request: Request) -> RequestBuilder {
            RequestBuilder {
                client,
                request: crate::Result::Ok(request),
            }
        }

        /// Add a `Header` to this Request.
        ///
        /// ```rust
        /// use reqwest::header::USER_AGENT;
        ///
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.get("https://www.rust-lang.org")
        ///     .header(USER_AGENT, "foo")
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn header<K, V>(self, key: K, value: V) -> RequestBuilder
        where
            HeaderName: TryFrom<K>,
            HeaderValue: TryFrom<V>,
            <HeaderName as TryFrom<K>>::Error: Into<http::Error>,
            <HeaderValue as TryFrom<V>>::Error: Into<http::Error>,
        {
            self.header_sensitive(key, value, false)
        }

        /// Add a `Header` to this Request with ability to define if header_value is sensitive.
        fn header_sensitive<K, V>(mut self, key: K, value: V, sensitive: bool) -> RequestBuilder
        where
            HeaderName: TryFrom<K>,
            HeaderValue: TryFrom<V>,
            <HeaderName as TryFrom<K>>::Error: Into<http::Error>,
            <HeaderValue as TryFrom<V>>::Error: Into<http::Error>,
        {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match <HeaderName as TryFrom<K>>::try_from(key) {
                    Ok(key) => match <HeaderValue as TryFrom<V>>::try_from(value) {
                        Ok(mut value) => {
                            // We want to potentially make an unsensitive header
                            // to be sensitive, not the reverse. So, don't turn off
                            // a previously sensitive header.
                            if sensitive {
                                value.set_sensitive(true);
                            }
                            req.headers_mut().append(key, value);
                        }
                        Err(e) => error = Some(crate::error::builder(e.into())),
                    },
                    Err(e) => error = Some(crate::error::builder(e.into())),
                };
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Add a set of Headers to the existing ones on this Request.
        ///
        /// The headers will be merged in to any already set.
        ///
        /// ```rust
        /// use reqwest::header::{HeaderMap, HeaderValue, USER_AGENT, CONTENT_TYPE};
        /// # use std::fs;
        ///
        /// fn construct_headers() -> HeaderMap {
        ///     let mut headers = HeaderMap::new();
        ///     headers.insert(USER_AGENT, HeaderValue::from_static("reqwest"));
        ///     headers.insert(CONTENT_TYPE, HeaderValue::from_static("image/png"));
        ///     headers
        /// }
        ///
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let file = fs::File::open("much_beauty.png")?;
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.post("http://httpbin.org/post")
        ///     .headers(construct_headers())
        ///     .body(file)
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn headers(mut self, headers: crate::header::HeaderMap) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                crate::util::replace_headers(req.headers_mut(), headers);
            }
            self
        }

        /// Enable HTTP basic authentication.
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let resp = client.delete("http://httpbin.org/delete")
        ///     .basic_auth("admin", Some("good password"))
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn basic_auth<U, P>(self, username: U, password: Option<P>) -> RequestBuilder
        where
            U: fmt::Display,
            P: fmt::Display,
        {
            let header_value = crate::util::basic_auth(username, password);
            self.header_sensitive(crate::header::AUTHORIZATION, header_value, true)
        }

        /// Enable HTTP bearer authentication.
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let resp = client.delete("http://httpbin.org/delete")
        ///     .bearer_auth("token")
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the `basic_auth` method set up HTTP basic authentication, and what system calls are involved in handling the input for this action?
  codeQuestion3: What steps are taken to handle header settings and authentication in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub fn bearer_auth<T>(self, token: T) -> RequestBuilder
        where
            T: fmt::Display,
        {
            let header_value = format!("Bearer {token}");
            self.header_sensitive(crate::header::AUTHORIZATION, &*header_value, true)
        }

        /// Set the request body.
        ///
        /// # Examples
        ///
        /// Using a string:
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.post("http://httpbin.org/post")
        ///     .body("from a &str!")
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// Using a `File`:
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let file = std::fs::File::open("from_a_file.txt")?;
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.post("http://httpbin.org/post")
        ///     .body(file)
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// Using arbitrary bytes:
        ///
        /// ```rust
        /// # use std::fs;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// // from bytes!
        /// let bytes: Vec<u8> = vec![1, 10, 100];
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.post("http://httpbin.org/post")
        ///     .body(bytes)
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn body<T: Into<Body>>(mut self, body: T) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                *req.body_mut() = Some(body.into());
            }
            self
        }

        /// Enables a request timeout.
        ///
        /// The timeout is applied from when the request starts connecting until the
        /// response body has finished. It affects only this request and overrides
        /// the timeout configured using `ClientBuilder::timeout()`.
        pub fn timeout(mut self, timeout: Duration) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                *req.timeout_mut() = Some(timeout);
            }
            self
        }

        /// Modify the query string of the URL.
        ///
        /// Modifies the URL of this request, adding the parameters provided.
        /// This method appends and does not overwrite. This means that it can
        /// be called multiple times and that existing query parameters are not
        /// overwritten if the same key is used. The key will simply show up
        /// twice in the query string.
        /// Calling `.query(&[("foo", "a"), ("foo", "b")])` gives `"foo=a&foo=b"`.
        ///
        /// ```rust
        /// # use reqwest::Error;
        /// #
        /// # fn run() -> Result<(), Error> {
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.get("http://httpbin.org")
        ///     .query(&[("lang", "rust")])
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Note
        /// This method does not support serializing a single key-value
        /// pair. Instead of using `.query(("key", "val"))`, use a sequence, such
        /// as `.query(&[("key", "val")])`. It's also possible to serialize structs
        /// and maps into a key-value pair.
        ///
        /// # Errors
        /// This method will fail if the object you provide cannot be serialized
        /// into a query string.
        pub fn query<T: Serialize + ?Sized>(mut self, query: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                let url = req.url_mut();
                let mut pairs = url.query_pairs_mut();
                let serializer = serde_urlencoded::Serializer::new(&mut pairs);

                if let Err(err) = query.serialize(serializer) {
                    error = Some(crate::error::builder(err));
                }
            }
            if let Ok(ref mut req) = self.request {
                if let Some("") = req.url().query() {
                    req.url_mut().set_query(None);
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Set HTTP version
        pub fn version(mut self, version: Version) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                *req.version_mut() = version;
            }
            self
        }

        /// Send a form body.
        ///
        /// Sets the body to the url encoded serialization of the passed value,
        /// and also sets the `Content-Type: application/x-www-form-urlencoded`
        /// header.
        ///
        /// ```rust
        /// # use reqwest::Error;
        /// # use std::collections::HashMap;
        /// #
        /// # fn run() -> Result<(), Error> {
        /// let mut params = HashMap::new();
        /// params.insert("lang", "rust");
        ///
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.post("http://httpbin.org")
        ///     .form(&params)
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Errors
        ///
        /// This method fails if the passed value cannot be serialized into
        /// url encoded format
        pub fn form<T: Serialize + ?Sized>(mut self, form: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match serde_urlencoded::to_string(form) {
                    Ok(body) => {
                        req.headers_mut()
                            .entry(CONTENT_TYPE)
                            .or_insert(HeaderValue::from_static(
                                "application/x-www-form-urlencoded",
                            ));
                        *req.body_mut() = Some(body.into());
                    }
                    Err(err) => error = Some(crate::error::builder(err)),
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user set an HTTP request body with different types of data, such as a string, file, or byte vector, and what APIs are used for this?
  codeQuestion3: What steps are involved in modifying the query string of a URL in this code, and how is serialization handled?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// Send a JSON body.
        ///
        /// Sets the body to the JSON serialization of the passed value, and
        /// also sets the `Content-Type: application/json` header.
        ///
        /// # Optional
        ///
        /// This requires the optional `json` feature enabled.
        ///
        /// # Examples
        ///
        /// ```rust
        /// # use reqwest::Error;
        /// # use std::collections::HashMap;
        /// #
        /// # fn run() -> Result<(), Error> {
        /// let mut map = HashMap::new();
        /// map.insert("lang", "rust");
        ///
        /// let client = reqwest::blocking::Client::new();
        /// let res = client.post("http://httpbin.org")
        ///     .json(&map)
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Errors
        ///
        /// Serialization can fail if `T`'s implementation of `Serialize` decides to
        /// fail, or if `T` contains a map with non-string keys.
        #[cfg(feature = "json")]
        #[cfg_attr(docsrs, doc(cfg(feature = "json")))]
        pub fn json<T: Serialize + ?Sized>(mut self, json: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match serde_json::to_vec(json) {
                    Ok(body) => {
                        if !req.headers().contains_key(CONTENT_TYPE) {
                            req.headers_mut()
                                .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
                        }
                        *req.body_mut() = Some(body.into());
                    }
                    Err(err) => error = Some(crate::error::builder(err)),
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Sends a multipart/form-data body.
        ///
        /// ```
        /// # use reqwest::Error;
        ///
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let form = reqwest::blocking::multipart::Form::new()
        ///     .text("key3", "value3")
        ///     .file("file", "/path/to/field")?;
        ///
        /// let response = client.post("your url")
        ///     .multipart(form)
        ///     .send()?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// See [`multipart`](multipart/) for more examples.
        #[cfg(feature = "multipart")]
        #[cfg_attr(docsrs, doc(cfg(feature = "multipart")))]
        pub fn multipart(self, mut multipart: multipart::Form) -> RequestBuilder {
            let mut builder = self.header(
                CONTENT_TYPE,
                format!("multipart/form-data; boundary={}", multipart.boundary()).as_str(),
            );
            if let Ok(ref mut req) = builder.request {
                *req.body_mut() = Some(match multipart.compute_length() {
                    Some(length) => Body::sized(multipart.reader(), length),
                    None => Body::new(multipart.reader()),
                })
            }
            builder
        }

        /// Build a `Request`, which can be inspected, modified and executed with
        /// `Client::execute()`.
        pub fn build(self) -> crate::Result<Request> {
            self.request
        }

        /// Build a `Request`, which can be inspected, modified and executed with
        /// `Client::execute()`.
        ///
        /// This is similar to [`RequestBuilder::build()`], but also returns the
        /// embedded `Client`.
        pub fn build_split(self) -> (Client, crate::Result<Request>) {
            (self.client, self.request)
        }

        /// Constructs the Request and sends it the target URL, returning a Response.
        ///
        /// # Errors
        ///
        /// This method fails if there was an error while sending request,
        /// redirect loop was detected or redirect limit was exhausted.
        pub fn send(self) -> crate::Result<super::Response> {
            self.client.execute(self.request?)
        }

        /// Attempts to clone the `RequestBuilder`.
        ///
        /// None is returned if a body is which can not be cloned. This can be because the body is a
        /// stream.
        ///
        /// # Examples
        ///
        /// With a static body
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let builder = client.post("http://httpbin.org/post")
        ///     .body("from a &str!");
        /// let clone = builder.try_clone();
        /// assert!(clone.is_some());
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// Without a body
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let builder = client.get("http://httpbin.org/get");
        /// let clone = builder.try_clone();
        /// assert!(clone.is_some());
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// With a non-cloneable body
        ///
        /// ```rust
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let client = reqwest::blocking::Client::new();
        /// let builder = client.get("http://httpbin.org/get")
        ///     .body(reqwest::blocking::Body::new(std::io::empty()));
        /// let clone = builder.try_clone();
        /// assert!(clone.is_none());
        /// # Ok(())
        /// # }
        /// ```
        pub fn try_clone(&self) -> Option<RequestBuilder> {
            self.request
                .as_ref()
                .ok()
                .and_then(|req| req.try_clone())
                .map(|req| RequestBuilder {
                    client: self.client.clone(),
                    request: Ok(req),
                })
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user send a JSON payload in a POST request using the `json` method, and what are the necessary steps to set up the request?
  codeQuestion3: What is the process for handling multipart/form-data requests, and how does the `multipart` method in this code facilitate that?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl<T> TryFrom<HttpRequest<T>> for Request
    where
        T: Into<Body>,
    {
        type Error = crate::Error;

        fn try_from(req: HttpRequest<T>) -> crate::Result<Self> {
            let (parts, body) = req.into_parts();
            let Parts {
                method,
                uri,
                headers,
                ..
            } = parts;
            let url = Url::parse(&uri.to_string()).map_err(crate::error::builder)?;
            let mut inner = async_impl::Request::new(method, url);
            crate::util::replace_headers(inner.headers_mut(), headers);
            Ok(Request {
                body: Some(body.into()),
                inner,
            })
        }
    }

    impl fmt::Debug for Request {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            fmt_request_fields(&mut f.debug_struct("Request"), self).finish()
        }
    }

    fn fmt_request_fields<'a, 'b>(
        f: &'a mut fmt::DebugStruct<'a, 'b>,
        req: &Request,
    ) -> &'a mut fmt::DebugStruct<'a, 'b> {
        f.field("method", req.method())
            .field("url", req.url())
            .field("headers", req.headers())
    }

    #[cfg(test)]
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `try_from` implementation convert an `HttpRequest<T>` into a `Request` object, and what steps are taken to handle the headers?
  codeQuestion3: What is the role of the `fmt::Debug` implementation for the `Request` struct, and how does it format the request details?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod tests
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP request errors and what is the proper way to use the `Result` type in this context?
  codeQuestion3: What is the role of the `tests` module in this code, and how would you structure a test for a function that makes an HTTP request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        use super::super::{body, Client};
        use super::{HttpRequest, Request, Version};
        use crate::header::{HeaderMap, HeaderValue, ACCEPT, CONTENT_TYPE, HOST};
        use crate::Method;
        use serde::Serialize;
        #[cfg(feature = "json")]
        use serde_json;
        use serde_urlencoded;
        use std::collections::{BTreeMap, HashMap};
        use std::time::Duration;

        #[test]
        fn basic_get_request() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.get(some_url).build().unwrap();

            assert_eq!(r.method(), &Method::GET);
            assert_eq!(r.url().as_str(), some_url);
        }

        #[test]
        fn basic_head_request() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.head(some_url).build().unwrap();

            assert_eq!(r.method(), &Method::HEAD);
            assert_eq!(r.url().as_str(), some_url);
        }

        #[test]
        fn basic_post_request() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url).build().unwrap();

            assert_eq!(r.method(), &Method::POST);
            assert_eq!(r.url().as_str(), some_url);
        }

        #[test]
        fn basic_put_request() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.put(some_url).build().unwrap();

            assert_eq!(r.method(), &Method::PUT);
            assert_eq!(r.url().as_str(), some_url);
        }

        #[test]
        fn basic_patch_request() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.patch(some_url).build().unwrap();

            assert_eq!(r.method(), &Method::PATCH);
            assert_eq!(r.url().as_str(), some_url);
        }

        #[test]
        fn basic_delete_request() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.delete(some_url).build().unwrap();

            assert_eq!(r.method(), &Method::DELETE);
            assert_eq!(r.url().as_str(), some_url);
        }

        #[test]
        fn add_header() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url);

            let header = HeaderValue::from_static("google.com");

            // Add a copy of the header to the request builder
            let r = r.header(HOST, header.clone()).build().unwrap();

            // then check it was actually added
            assert_eq!(r.headers().get(HOST), Some(&header));
        }

        #[test]
        fn add_headers() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url);

            let header = HeaderValue::from_static("google.com");

            let mut headers = HeaderMap::new();
            headers.insert(HOST, header);

            // Add a copy of the headers to the request builder
            let r = r.headers(headers.clone()).build().unwrap();

            // then make sure they were added correctly
            assert_eq!(r.headers(), &headers);
        }

        #[test]
        fn add_headers_multi() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url);

            let header_json = HeaderValue::from_static("application/json");
            let header_xml = HeaderValue::from_static("application/xml");

            let mut headers = HeaderMap::new();
            headers.append(ACCEPT, header_json);
            headers.append(ACCEPT, header_xml);

            // Add a copy of the headers to the request builder
            let r = r.headers(headers.clone()).build().unwrap();

            // then make sure they were added correctly
            assert_eq!(r.headers(), &headers);
            let mut all_values = r.headers().get_all(ACCEPT).iter();
            assert_eq!(all_values.next().unwrap(), &"application/json");
            assert_eq!(all_values.next().unwrap(), &"application/xml");
            assert_eq!(all_values.next(), None);
        }

        #[test]
        fn add_body() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url);

            let body = "Some interesting content";

            let mut r = r.body(body).build().unwrap();

            let buf = body::read_to_string(r.body_mut().take().unwrap()).unwrap();

            assert_eq!(buf, body);
        }

        #[test]
        fn add_query_append() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let mut r = client.get(some_url);

            r = r.query(&[("foo", "bar")]);
            r = r.query(&[("qux", 3)]);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=bar&qux=3"));
        }

        #[test]
        fn add_query_append_same() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let mut r = client.get(some_url);

            r = r.query(&[("foo", "a"), ("foo", "b")]);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=a&foo=b"));
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer add custom headers to an HTTP request and what APIs are used for this?
  codeQuestion3: What is the process for adding query parameters to an HTTP request URL and how are they handled in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[test]
        fn add_query_struct() {
            #[derive(Serialize)]
            struct Params {
                foo: String,
                qux: i32,
            }

            let client = Client::new();
            let some_url = "https://google.com/";
            let mut r = client.get(some_url);

            let params = Params {
                foo: "bar".into(),
                qux: 3,
            };

            r = r.query(&params);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=bar&qux=3"));
        }

        #[test]
        fn add_query_map() {
            let mut params = BTreeMap::new();
            params.insert("foo", "bar");
            params.insert("qux", "three");

            let client = Client::new();
            let some_url = "https://google.com/";
            let mut r = client.get(some_url);

            r = r.query(&params);

            let req = r.build().expect("request is valid");
            assert_eq!(req.url().query(), Some("foo=bar&qux=three"));
        }

        #[test]
        fn add_form() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url);

            let mut form_data = HashMap::new();
            form_data.insert("foo", "bar");

            let mut r = r.form(&form_data).build().unwrap();

            // Make sure the content type was set
            assert_eq!(
                r.headers().get(CONTENT_TYPE).unwrap(),
                &"application/x-www-form-urlencoded"
            );

            let buf = body::read_to_string(r.body_mut().take().unwrap()).unwrap();

            let body_should_be = serde_urlencoded::to_string(&form_data).unwrap();
            assert_eq!(buf, body_should_be);
        }

        #[test]
        #[cfg(feature = "json")]
        fn add_json() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url);

            let mut json_data = HashMap::new();
            json_data.insert("foo", "bar");

            let mut r = r.json(&json_data).build().unwrap();

            // Make sure the content type was set
            assert_eq!(r.headers().get(CONTENT_TYPE).unwrap(), &"application/json");

            let buf = body::read_to_string(r.body_mut().take().unwrap()).unwrap();

            let body_should_be = serde_json::to_string(&json_data).unwrap();
            assert_eq!(buf, body_should_be);
        }

        #[test]
        #[cfg(feature = "json")]
        fn add_json_fail() {
            use serde::ser::Error as _;
            use serde::{Serialize, Serializer};
            use std::error::Error as _;
            struct MyStruct;
            impl Serialize for MyStruct {
                fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: Serializer,
                {
                    Err(S::Error::custom("nope"))
                }
            }

            let client = Client::new();
            let some_url = "https://google.com/";
            let r = client.post(some_url);
            let json_data = MyStruct;
            let err = r.json(&json_data).build().unwrap_err();
            assert!(err.is_builder()); // well, duh ;)
            assert!(err.source().unwrap().is::<serde_json::Error>());
        }

        #[test]
        fn test_replace_headers() {
            use http::HeaderMap;

            let mut headers = HeaderMap::new();
            headers.insert("foo", "bar".parse().unwrap());
            headers.append("foo", "baz".parse().unwrap());

            let client = Client::new();
            let req = client
                .get("https://hyper.rs")
                .header("im-a", "keeper")
                .header("foo", "pop me")
                .headers(headers)
                .build()
                .expect("request build");

            assert_eq!(req.headers()["im-a"], "keeper");

            let foo = req.headers().get_all("foo").iter().collect::<Vec<_>>();
            assert_eq!(foo.len(), 2);
            assert_eq!(foo[0], "bar");
            assert_eq!(foo[1], "baz");
        }

        #[test]
        fn normalize_empty_query() {
            let client = Client::new();
            let some_url = "https://google.com/";
            let empty_query: &[(&str, &str)] = &[];

            let req = client
                .get(some_url)
                .query(empty_query)
                .build()
                .expect("request build");

            assert_eq!(req.url().query(), None);
            assert_eq!(req.url().as_str(), "https://google.com/");
        }

        #[test]
        fn convert_url_authority_into_basic_auth() {
            let client = Client::new();
            let some_url = "https://Aladdin:open sesame@localhost/";

            let req = client.get(some_url).build().expect("request build");

            assert_eq!(req.url().as_str(), "https://localhost/");
            assert_eq!(
                req.headers()["authorization"],
                "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
            );
        }

        #[test]
        fn convert_from_http_request() {
            let http_request = HttpRequest::builder()
                .method("GET")
                .uri("http://localhost/")
                .header("User-Agent", "my-awesome-agent/1.0")
                .body("test test test")
                .unwrap();
            let req: Request = Request::try_from(http_request).unwrap();
            assert_eq!(req.body().is_none(), false);
            let test_data = b"test test test";
            assert_eq!(req.body().unwrap().as_bytes(), Some(&test_data[..]));
            let headers = req.headers();
            assert_eq!(headers.get("User-Agent").unwrap(), "my-awesome-agent/1.0");
            assert_eq!(req.method(), Method::GET);
            assert_eq!(req.url().as_str(), "http://localhost/");
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `add_query_struct` test demonstrate the use of the `query` method in the Hyper project?
  codeQuestion3: What steps are involved in converting an HTTP request into a `Request` object using the Hyper project's API?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[test]
        fn set_http_request_version() {
            let http_request = HttpRequest::builder()
                .method("GET")
                .uri("http://localhost/")
                .header("User-Agent", "my-awesome-agent/1.0")
                .version(Version::HTTP_11)
                .body("test test test")
                .unwrap();
            let req: Request = Request::try_from(http_request).unwrap();
            assert_eq!(req.body().is_none(), false);
            let test_data = b"test test test";
            assert_eq!(req.body().unwrap().as_bytes(), Some(&test_data[..]));
            let headers = req.headers();
            assert_eq!(headers.get("User-Agent").unwrap(), "my-awesome-agent/1.0");
            assert_eq!(req.method(), Method::GET);
            assert_eq!(req.url().as_str(), "http://localhost/");
            assert_eq!(req.version(), Version::HTTP_11);
        }

        #[test]
        fn test_basic_auth_sensitive_header() {
            let client = Client::new();
            let some_url = "https://localhost/";

            let req = client
                .get(some_url)
                .basic_auth("Aladdin", Some("open sesame"))
                .build()
                .expect("request build");

            assert_eq!(req.url().as_str(), "https://localhost/");
            assert_eq!(
                req.headers()["authorization"],
                "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
            );
            assert_eq!(req.headers()["authorization"].is_sensitive(), true);
        }

        #[test]
        fn test_bearer_auth_sensitive_header() {
            let client = Client::new();
            let some_url = "https://localhost/";

            let req = client
                .get(some_url)
                .bearer_auth("Hold my bear")
                .build()
                .expect("request build");

            assert_eq!(req.url().as_str(), "https://localhost/");
            assert_eq!(req.headers()["authorization"], "Bearer Hold my bear");
            assert_eq!(req.headers()["authorization"].is_sensitive(), true);
        }

        #[test]
        fn test_request_cloning() {
            let mut request = Request::new(Method::GET, "https://example.com".try_into().unwrap());
            *request.timeout_mut() = Some(Duration::from_secs(42));
            *request.version_mut() = Version::HTTP_11;

            let clone = request.try_clone().unwrap();
            assert_eq!(request.version(), clone.version());
            assert_eq!(request.headers(), clone.headers());
            assert_eq!(request.timeout(), clone.timeout());
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle authentication headers, and what is an example of setting a basic auth header?
  codeQuestion3: What mechanisms are used to ensure that sensitive headers like Authorization are properly handled in the request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/wait.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::future::Future;
    use std::sync::Arc;
    use std::task::{Context, Poll, Wake, Waker};
    use std::thread::{self, Thread};
    use std::time::Duration;

    use tokio::time::Instant;

    pub(crate) fn timeout<F, I, E>(fut: F, timeout: Option<Duration>) -> Result<I, Waited<E>>
    where
        F: Future<Output = Result<I, E>>,
    {
        enter();

        let deadline = timeout.map(|d| {
            log::trace!("wait at most {d:?}");
            Instant::now() + d
        });

        let thread = ThreadWaker(thread::current());
        // Arc shouldn't be necessary, since `Thread` is reference counted internally,
        // but let's just stay safe for now.
        let waker = Waker::from(Arc::new(thread));
        let mut cx = Context::from_waker(&waker);

        futures_util::pin_mut!(fut);

        loop {
            match fut.as_mut().poll(&mut cx) {
                Poll::Ready(Ok(val)) => return Ok(val),
                Poll::Ready(Err(err)) => return Err(Waited::Inner(err)),
                Poll::Pending => (), // fallthrough
            }

            if let Some(deadline) = deadline {
                let now = Instant::now();
                if now >= deadline {
                    log::trace!("wait timeout exceeded");
                    return Err(Waited::TimedOut(crate::error::TimedOut));
                }

                log::trace!(
                    "({:?}) park timeout {:?}",
                    thread::current().id(),
                    deadline - now
                );
                thread::park_timeout(deadline - now);
            } else {
                log::trace!("({:?}) park without timeout", thread::current().id());
                thread::park();
            }
        }
    }

    #[derive(Debug)]
    pub(crate) enum Waited<E> {
        TimedOut(crate::error::TimedOut),
        Inner(E),
    }

    struct ThreadWaker(Thread);

    impl Wake for ThreadWaker {
        fn wake(self: Arc<Self>) {
            self.wake_by_ref();
        }

        fn wake_by_ref(self: &Arc<Self>) {
            self.0.unpark();
        }
    }

    fn enter() {
        // Check we aren't already in a runtime
        #[cfg(debug_assertions)]
        {
            let _enter = tokio::runtime::Builder::new_current_thread()
                .build()
                .expect("build shell runtime")
                .enter();
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `timeout` function handle the case where a future takes longer than the specified timeout duration?
  codeQuestion3: What is the role of the `ThreadWaker` struct and how does it integrate with the Tokio runtime?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(any(feature = "native-tls", feature = "__rustls",))]
    use std::any::Any;
    use std::convert::TryInto;
    use std::fmt;
    use std::future::Future;
    use std::net::IpAddr;
    use std::net::SocketAddr;
    use std::sync::Arc;
    use std::task::ready;
    use std::thread;
    use std::time::Duration;

    use http::header::HeaderValue;
    use log::{error, trace};
    use tokio::sync::{mpsc, oneshot};
    use tower::Layer;
    use tower::Service;

    use super::request::{Request, RequestBuilder};
    use super::response::Response;
    use super::wait;
    use crate::connect::sealed::{Conn, Unnameable};
    use crate::connect::BoxedConnectorService;
    use crate::dns::Resolve;
    use crate::error::BoxError;
    #[cfg(feature = "__tls")]
    use crate::tls;
    #[cfg(feature = "__rustls")]
    use crate::tls::CertificateRevocationList;
    #[cfg(feature = "__tls")]
    use crate::Certificate;
    #[cfg(any(feature = "native-tls", feature = "__rustls"))]
    use crate::Identity;
    use crate::{async_impl, header, redirect, IntoUrl, Method, Proxy};

    /// A `Client` to make Requests with.
    ///
    /// The Client has various configuration values to tweak, but the defaults
    /// are set to what is usually the most commonly desired value. To configure a
    /// `Client`, use `Client::builder()`.
    ///
    /// The `Client` holds a connection pool internally, so it is advised that
    /// you create one and **reuse** it.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use reqwest::blocking::Client;
    /// #
    /// # fn run() -> Result<(), reqwest::Error> {
    /// let client = Client::new();
    /// let resp = client.get("http://httpbin.org/").send()?;
    /// #   drop(resp);
    /// #   Ok(())
    /// # }
    ///
    /// ```
    #[derive(Clone)]
    pub struct Client {
        inner: ClientHandle,
    }

    /// A `ClientBuilder` can be used to create a `Client` with  custom configuration.
    ///
    /// # Example
    ///
    /// ```
    /// # fn run() -> Result<(), reqwest::Error> {
    /// use std::time::Duration;
    ///
    /// let client = reqwest::blocking::Client::builder()
    ///     .timeout(Duration::from_secs(10))
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    #[must_use]
    pub struct ClientBuilder {
        inner: async_impl::ClientBuilder,
        timeout: Timeout,
    }

    impl Default for ClientBuilder {
        fn default() -> Self {
            Self::new()
        }
    }

    impl ClientBuilder {
        /// Constructs a new `ClientBuilder`.
        ///
        /// This is the same as `Client::builder()`.
        pub fn new() -> Self {
            ClientBuilder {
                inner: async_impl::ClientBuilder::new(),
                timeout: Timeout::default(),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user set a custom timeout for HTTP requests using this code?
  codeQuestion3: What is the role of the `Client` struct and how does it differ from the `ClientBuilder`?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl ClientBuilder
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle HTTP requests with custom headers?
  codeQuestion3: What is the process for configuring and sending a POST request with JSON data?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        /// Returns a `Client` that uses this `ClientBuilder` configuration.
        ///
        /// # Errors
        ///
        /// This method fails if TLS backend cannot be initialized, or the resolver
        /// cannot load the system configuration.
        ///
        /// # Panics
        ///
        /// This method panics if called from within an async runtime. See docs on
        /// [`reqwest::blocking`][crate::blocking] for details.
        pub fn build(self) -> crate::Result<Client> {
            ClientHandle::new(self).map(|handle| Client { inner: handle })
        }

        // Higher-level options

        /// Sets the `User-Agent` header to be used by this client.
        ///
        /// # Example
        ///
        /// ```rust
        /// # fn doc() -> Result<(), reqwest::Error> {
        /// // Name your user agent after your app?
        /// static APP_USER_AGENT: &str = concat!(
        ///     env!("CARGO_PKG_NAME"),
        ///     "/",
        ///     env!("CARGO_PKG_VERSION"),
        /// );
        ///
        /// let client = reqwest::blocking::Client::builder()
        ///     .user_agent(APP_USER_AGENT)
        ///     .build()?;
        /// let res = client.get("https://www.rust-lang.org").send()?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn user_agent<V>(self, value: V) -> ClientBuilder
        where
            V: TryInto<HeaderValue>,
            V::Error: Into<http::Error>,
        {
            self.with_inner(move |inner| inner.user_agent(value))
        }

        /// Sets the default headers for every request.
        ///
        /// # Example
        ///
        /// ```rust
        /// use reqwest::header;
        /// # fn build_client() -> Result<(), reqwest::Error> {
        /// let mut headers = header::HeaderMap::new();
        /// headers.insert("X-MY-HEADER", header::HeaderValue::from_static("value"));
        /// headers.insert(header::AUTHORIZATION, header::HeaderValue::from_static("secret"));
        ///
        /// // Consider marking security-sensitive headers with `set_sensitive`.
        /// let mut auth_value = header::HeaderValue::from_static("secret");
        /// auth_value.set_sensitive(true);
        /// headers.insert(header::AUTHORIZATION, auth_value);
        ///
        /// // get a client builder
        /// let client = reqwest::blocking::Client::builder()
        ///     .default_headers(headers)
        ///     .build()?;
        /// let res = client.get("https://www.rust-lang.org").send()?;
        /// # Ok(())
        /// # }
        /// ```
        pub fn default_headers(self, headers: header::HeaderMap) -> ClientBuilder {
            self.with_inner(move |inner| inner.default_headers(headers))
        }

        /// Enable a persistent cookie store for the client.
        ///
        /// Cookies received in responses will be preserved and included in
        /// additional requests.
        ///
        /// By default, no cookie store is used.
        ///
        /// # Optional
        ///
        /// This requires the optional `cookies` feature to be enabled.
        #[cfg(feature = "cookies")]
        #[cfg_attr(docsrs, doc(cfg(feature = "cookies")))]
        pub fn cookie_store(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.cookie_store(enable))
        }

        /// Set the persistent cookie store for the client.
        ///
        /// Cookies received in responses will be passed to this store, and
        /// additional requests will query this store for cookies.
        ///
        /// By default, no cookie store is used.
        ///
        /// # Optional
        ///
        /// This requires the optional `cookies` feature to be enabled.
        #[cfg(feature = "cookies")]
        #[cfg_attr(docsrs, doc(cfg(feature = "cookies")))]
        pub fn cookie_provider<C: crate::cookie::CookieStore + 'static>(
            self,
            cookie_store: Arc<C>,
        ) -> ClientBuilder {
            self.with_inner(|inner| inner.cookie_provider(cookie_store))
        }

        /// Enable auto gzip decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto gzip decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `gzip`.
        ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if it's headers contain a `Content-Encoding` value that
        ///   equals to `gzip`, both values `Content-Encoding` and `Content-Length` are removed from the
        ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `gzip` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `gzip` feature to be enabled
        #[cfg(feature = "gzip")]
        #[cfg_attr(docsrs, doc(cfg(feature = "gzip")))]
        pub fn gzip(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.gzip(enable))
        }

        /// Enable auto brotli decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto brotli decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `br`.
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer set custom headers for all requests made by the client, and what is an example of this usage?
  codeQuestion3: What steps are involved in enabling auto-gzip decompression for the client, and how is it configured using available APIs?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if it's headers contain a `Content-Encoding` value that
        ///   equals to `br`, both values `Content-Encoding` and `Content-Length` are removed from the
        ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `brotli` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `brotli` feature to be enabled
        #[cfg(feature = "brotli")]
        #[cfg_attr(docsrs, doc(cfg(feature = "brotli")))]
        pub fn brotli(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.brotli(enable))
        }

        /// Enable auto zstd decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto zstd decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `zstd`.
        ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if its headers contain a `Content-Encoding` value of
        ///   `zstd`, both `Content-Encoding` and `Content-Length` are removed from the
        ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `zstd` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `zstd` feature to be enabled
        #[cfg(feature = "zstd")]
        #[cfg_attr(docsrs, doc(cfg(feature = "zstd")))]
        pub fn zstd(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.zstd(enable))
        }

        /// Enable auto deflate decompression by checking the `Content-Encoding` response header.
        ///
        /// If auto deflate decompression is turned on:
        ///
        /// - When sending a request and if the request's headers do not already contain
        ///   an `Accept-Encoding` **and** `Range` values, the `Accept-Encoding` header is set to `deflate`.
        ///   The request body is **not** automatically compressed.
        /// - When receiving a response, if it's headers contain a `Content-Encoding` value that
        ///   equals to `deflate`, both values `Content-Encoding` and `Content-Length` are removed from the
        ///   headers' set. The response body is automatically decompressed.
        ///
        /// If the `deflate` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `deflate` feature to be enabled
        #[cfg(feature = "deflate")]
        #[cfg_attr(docsrs, doc(cfg(feature = "deflate")))]
        pub fn deflate(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.deflate(enable))
        }

        /// Disable auto response body gzip decompression.
        ///
        /// This method exists even if the optional `gzip` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use gzip decompression
        /// even if another dependency were to enable the optional `gzip` feature.
        pub fn no_gzip(self) -> ClientBuilder {
            self.with_inner(|inner| inner.no_gzip())
        }

        /// Disable auto response body brotli decompression.
        ///
        /// This method exists even if the optional `brotli` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use brotli decompression
        /// even if another dependency were to enable the optional `brotli` feature.
        pub fn no_brotli(self) -> ClientBuilder {
            self.with_inner(|inner| inner.no_brotli())
        }

        /// Disable auto response body zstd decompression.
        ///
        /// This method exists even if the optional `zstd` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use zstd decompression
        /// even if another dependency were to enable the optional `zstd` feature.
        pub fn no_zstd(self) -> ClientBuilder {
            self.with_inner(|inner| inner.no_zstd())
        }

        /// Disable auto response body deflate decompression.
        ///
        /// This method exists even if the optional `deflate` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use deflate decompression
        /// even if another dependency were to enable the optional `deflate` feature.
        pub fn no_deflate(self) -> ClientBuilder {
            self.with_inner(|inner| inner.no_deflate())
        }

        // Redirect options

        /// Set a `redirect::Policy` for this client.
        ///
        /// Default will follow redirects up to a maximum of 10.
        pub fn redirect(self, policy: redirect::Policy) -> ClientBuilder {
            self.with_inner(move |inner| inner.redirect(policy))
        }

        /// Enable or disable automatic setting of the `Referer` header.
        ///
        /// Default is `true`.
        pub fn referer(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.referer(enable))
        }

        // Proxy options

        /// Add a `Proxy` to the list of proxies the `Client` will use.
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure the client to automatically decompress responses using the `zstd` feature and what is the correct API call?
  codeQuestion3: What steps are taken to handle redirect policies and referer settings in the client configuration?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    ///
        /// # Note
        ///
        /// Adding a proxy will disable the automatic usage of the "system" proxy.
        pub fn proxy(self, proxy: Proxy) -> ClientBuilder {
            self.with_inner(move |inner| inner.proxy(proxy))
        }

        /// Clear all `Proxies`, so `Client` will use no proxy anymore.
        ///
        /// # Note
        /// To add a proxy exclusion list, use [Proxy::no_proxy()]
        /// on all desired proxies instead.
        ///
        /// This also disables the automatic usage of the "system" proxy.
        pub fn no_proxy(self) -> ClientBuilder {
            self.with_inner(move |inner| inner.no_proxy())
        }

        // Timeout options

        /// Set a timeout for connect, read and write operations of a `Client`.
        ///
        /// Default is 30 seconds.
        ///
        /// Pass `None` to disable timeout.
        pub fn timeout<T>(mut self, timeout: T) -> ClientBuilder
        where
            T: Into<Option<Duration>>,
        {
            self.timeout = Timeout(timeout.into());
            self
        }

        /// Set a timeout for only the connect phase of a `Client`.
        ///
        /// Default is `None`.
        pub fn connect_timeout<T>(self, timeout: T) -> ClientBuilder
        where
            T: Into<Option<Duration>>,
        {
            let timeout = timeout.into();
            if let Some(dur) = timeout {
                self.with_inner(|inner| inner.connect_timeout(dur))
            } else {
                self
            }
        }

        /// Set whether connections should emit verbose logs.
        ///
        /// Enabling this option will emit [log][] messages at the `TRACE` level
        /// for read and write operations on connections.
        ///
        /// [log]: https://crates.io/crates/log
        pub fn connection_verbose(self, verbose: bool) -> ClientBuilder {
            self.with_inner(move |inner| inner.connection_verbose(verbose))
        }

        // HTTP options

        /// Set an optional timeout for idle sockets being kept-alive.
        ///
        /// Pass `None` to disable timeout.
        ///
        /// Default is 90 seconds.
        pub fn pool_idle_timeout<D>(self, val: D) -> ClientBuilder
        where
            D: Into<Option<Duration>>,
        {
            self.with_inner(|inner| inner.pool_idle_timeout(val))
        }

        /// Sets the maximum idle connection per host allowed in the pool.
        pub fn pool_max_idle_per_host(self, max: usize) -> ClientBuilder {
            self.with_inner(move |inner| inner.pool_max_idle_per_host(max))
        }

        /// Send headers as title case instead of lowercase.
        pub fn http1_title_case_headers(self) -> ClientBuilder {
            self.with_inner(|inner| inner.http1_title_case_headers())
        }

        /// Set whether HTTP/1 connections will accept obsolete line folding for
        /// header values.
        ///
        /// Newline codepoints (`\r` and `\n`) will be transformed to spaces when
        /// parsing.
        pub fn http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.http1_allow_obsolete_multiline_headers_in_responses(value))
        }

        /// Sets whether invalid header lines should be silently ignored in HTTP/1 responses.
        pub fn http1_ignore_invalid_headers_in_responses(self, value: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.http1_ignore_invalid_headers_in_responses(value))
        }

        /// Set whether HTTP/1 connections will accept spaces between header
        /// names and the colon that follow them in responses.
        ///
        /// Newline codepoints (\r and \n) will be transformed to spaces when
        /// parsing.
        pub fn http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.http1_allow_spaces_after_header_name_in_responses(value))
        }

        /// Only use HTTP/1.
        pub fn http1_only(self) -> ClientBuilder {
            self.with_inner(|inner| inner.http1_only())
        }

        /// Allow HTTP/0.9 responses
        pub fn http09_responses(self) -> ClientBuilder {
            self.with_inner(|inner| inner.http09_responses())
        }

        /// Only use HTTP/2.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_prior_knowledge(self) -> ClientBuilder {
            self.with_inner(|inner| inner.http2_prior_knowledge())
        }

        /// Sets the `SETTINGS_INITIAL_WINDOW_SIZE` option for HTTP2 stream-level flow control.
        ///
        /// Default is currently 65,535 but may change internally to optimize for common uses.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_initial_stream_window_size(self, sz: impl Into<Option<u32>>) -> ClientBuilder {
            self.with_inner(|inner| inner.http2_initial_stream_window_size(sz))
        }

        /// Sets the max connection-level flow control for HTTP2
        ///
        /// Default is currently 65,535 but may change internally to optimize for common uses.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_initial_connection_window_size(self, sz: impl Into<Option<u32>>) -> ClientBuilder {
            self.with_inner(|inner| inner.http2_initial_connection_window_size(sz))
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user set a custom timeout for connection, read, and write operations in the Hyper client?
  codeQuestion3: What steps are involved in configuring HTTP/1 settings, such as title case headers and handling obsolete header lines?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// Sets whether to use an adaptive flow control.
        ///
        /// Enabling this will override the limits set in `http2_initial_stream_window_size` and
        /// `http2_initial_connection_window_size`.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_adaptive_window(self, enabled: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.http2_adaptive_window(enabled))
        }

        /// Sets the maximum frame size to use for HTTP2.
        ///
        /// Default is currently 16,384 but may change internally to optimize for common uses.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_max_frame_size(self, sz: impl Into<Option<u32>>) -> ClientBuilder {
            self.with_inner(|inner| inner.http2_max_frame_size(sz))
        }

        /// Sets the maximum size of received header frames for HTTP2.
        ///
        /// Default is currently 16KB, but can change.
        #[cfg(feature = "http2")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http2")))]
        pub fn http2_max_header_list_size(self, max_header_size_bytes: u32) -> ClientBuilder {
            self.with_inner(|inner| inner.http2_max_header_list_size(max_header_size_bytes))
        }

        /// This requires the optional `http3` feature to be
        /// enabled.
        #[cfg(feature = "http3")]
        #[cfg_attr(docsrs, doc(cfg(feature = "http3")))]
        pub fn http3_prior_knowledge(self) -> ClientBuilder {
            self.with_inner(|inner| inner.http3_prior_knowledge())
        }

        // TCP options

        /// Set whether sockets have `TCP_NODELAY` enabled.
        ///
        /// Default is `true`.
        pub fn tcp_nodelay(self, enabled: bool) -> ClientBuilder {
            self.with_inner(move |inner| inner.tcp_nodelay(enabled))
        }

        /// Bind to a local IP Address.
        ///
        /// # Example
        ///
        /// ```
        /// use std::net::IpAddr;
        /// let local_addr = IpAddr::from([12, 4, 1, 8]);
        /// let client = reqwest::blocking::Client::builder()
        ///     .local_address(local_addr)
        ///     .build().unwrap();
        /// ```
        pub fn local_address<T>(self, addr: T) -> ClientBuilder
        where
            T: Into<Option<IpAddr>>,
        {
            self.with_inner(move |inner| inner.local_address(addr))
        }

        /// Bind to an interface by `SO_BINDTODEVICE`.
        ///
        /// # Example
        ///
        /// ```
        /// let interface = "lo";
        /// let client = reqwest::blocking::Client::builder()
        ///     .interface(interface)
        ///     .build().unwrap();
        /// ```
        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
        pub fn interface(self, interface: &str) -> ClientBuilder {
            self.with_inner(move |inner| inner.interface(interface))
        }

        /// Set that all sockets have `SO_KEEPALIVE` set with the supplied duration.
        ///
        /// If `None`, the option will not be set.
        pub fn tcp_keepalive<D>(self, val: D) -> ClientBuilder
        where
            D: Into<Option<Duration>>,
        {
            self.with_inner(move |inner| inner.tcp_keepalive(val))
        }

        // TLS options

        /// Add a custom root certificate.
        ///
        /// This allows connecting to a server that has a self-signed
        /// certificate for example. This **does not** replace the existing
        /// trusted store.
        ///
        /// # Example
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn build_client() -> Result<(), Box<dyn std::error::Error>> {
        /// // read a local binary DER encoded certificate
        /// let der = std::fs::read("my-cert.der")?;
        ///
        /// // create a certificate
        /// let cert = reqwest::Certificate::from_der(&der)?;
        ///
        /// // get a client builder
        /// let client = reqwest::blocking::Client::builder()
        ///     .add_root_certificate(cert)
        ///     .build()?;
        /// # drop(client);
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn add_root_certificate(self, cert: Certificate) -> ClientBuilder {
            self.with_inner(move |inner| inner.add_root_certificate(cert))
        }

        /// Add a certificate revocation list.
        ///
        ///
        /// # Optional
        ///
        /// This requires the `rustls-tls(-...)` Cargo feature enabled.
        #[cfg(feature = "__rustls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls")))]
        pub fn add_crl(self, crl: CertificateRevocationList) -> ClientBuilder {
            self.with_inner(move |inner| inner.add_crl(crl))
        }

        /// Add multiple certificate revocation lists.
        ///
        ///
        /// # Optional
        ///
        /// This requires the `rustls-tls(-...)` Cargo feature enabled.
        #[cfg(feature = "__rustls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls")))]
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer set the maximum frame size for HTTP/2 connections, and what is an example of using this API?
  codeQuestion3: What steps are involved in adding a custom root certificate for TLS connections, and how is this implemented in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub fn add_crls(
            self,
            crls: impl IntoIterator<Item = CertificateRevocationList>,
        ) -> ClientBuilder {
            self.with_inner(move |inner| inner.add_crls(crls))
        }

        /// Controls the use of built-in system certificates during certificate validation.
        ///
        /// Defaults to `true` -- built-in system certs will be used.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn tls_built_in_root_certs(self, tls_built_in_root_certs: bool) -> ClientBuilder {
            self.with_inner(move |inner| inner.tls_built_in_root_certs(tls_built_in_root_certs))
        }

        /// Sets whether to load webpki root certs with rustls.
        ///
        /// If the feature is enabled, this value is `true` by default.
        #[cfg(feature = "rustls-tls-webpki-roots-no-provider")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls-webpki-roots-no-provider")))]
        pub fn tls_built_in_webpki_certs(self, enabled: bool) -> ClientBuilder {
            self.with_inner(move |inner| inner.tls_built_in_webpki_certs(enabled))
        }

        /// Sets whether to load native root certs with rustls.
        ///
        /// If the feature is enabled, this value is `true` by default.
        #[cfg(feature = "rustls-tls-native-roots-no-provider")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls-native-roots-no-provider")))]
        pub fn tls_built_in_native_certs(self, enabled: bool) -> ClientBuilder {
            self.with_inner(move |inner| inner.tls_built_in_native_certs(enabled))
        }

        /// Sets the identity to be used for client certificate authentication.
        ///
        /// # Optional
        ///
        /// This requires the optional `native-tls` or `rustls-tls(-...)` feature to be
        /// enabled.
        #[cfg(any(feature = "native-tls", feature = "__rustls"))]
        #[cfg_attr(docsrs, doc(cfg(any(feature = "native-tls", feature = "rustls-tls"))))]
        pub fn identity(self, identity: Identity) -> ClientBuilder {
            self.with_inner(move |inner| inner.identity(identity))
        }

        /// Controls the use of hostname verification.
        ///
        /// Defaults to `false`.
        ///
        /// # Warning
        ///
        /// You should think very carefully before you use this method. If
        /// hostname verification is not used, any valid certificate for any
        /// site will be trusted for use from any other. This introduces a
        /// significant vulnerability to man-in-the-middle attacks.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn danger_accept_invalid_hostnames(self, accept_invalid_hostname: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.danger_accept_invalid_hostnames(accept_invalid_hostname))
        }

        /// Controls the use of certificate validation.
        ///
        /// Defaults to `false`.
        ///
        /// # Warning
        ///
        /// You should think very carefully before using this method. If
        /// invalid certificates are trusted, *any* certificate for *any* site
        /// will be trusted for use. This includes expired certificates. This
        /// introduces significant vulnerabilities, and should only be used
        /// as a last resort.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn danger_accept_invalid_certs(self, accept_invalid_certs: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.danger_accept_invalid_certs(accept_invalid_certs))
        }

        /// Controls the use of TLS server name indication.
        ///
        /// Defaults to `true`.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn tls_sni(self, tls_sni: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.tls_sni(tls_sni))
        }

        /// Set the minimum required TLS version for connections.
        ///
        /// By default, the TLS backend's own default is used.
        ///
        /// # Errors
        ///
        /// A value of `tls::Version::TLS_1_3` will cause an error with the
        /// `native-tls`/`default-tls` backend. This does not mean the version
        /// isn't supported, just that it can't be set as a minimum due to
        /// technical limitations.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure the client to accept invalid hostnames during TLS validation, and what is the correct usage of the API for this configuration?
  codeQuestion3: What steps are taken in the code to allow users to set custom TLS certificates for client authentication, and how is this implemented through the provided API?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn min_tls_version(self, version: tls::Version) -> ClientBuilder {
            self.with_inner(|inner| inner.min_tls_version(version))
        }

        /// Set the maximum allowed TLS version for connections.
        ///
        /// By default, there's no maximum.
        ///
        /// # Errors
        ///
        /// A value of `tls::Version::TLS_1_3` will cause an error with the
        /// `native-tls`/`default-tls` backend. This does not mean the version
        /// isn't supported, just that it can't be set as a maximum due to
        /// technical limitations.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn max_tls_version(self, version: tls::Version) -> ClientBuilder {
            self.with_inner(|inner| inner.max_tls_version(version))
        }

        /// Force using the native TLS backend.
        ///
        /// Since multiple TLS backends can be optionally enabled, this option will
        /// force the `native-tls` backend to be used for this `Client`.
        ///
        /// # Optional
        ///
        /// This requires the optional `native-tls` feature to be enabled.
        #[cfg(feature = "native-tls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "native-tls")))]
        pub fn use_native_tls(self) -> ClientBuilder {
            self.with_inner(move |inner| inner.use_native_tls())
        }

        /// Force using the Rustls TLS backend.
        ///
        /// Since multiple TLS backends can be optionally enabled, this option will
        /// force the `rustls` backend to be used for this `Client`.
        ///
        /// # Optional
        ///
        /// This requires the optional `rustls-tls(-...)` feature to be enabled.
        #[cfg(feature = "__rustls")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rustls-tls")))]
        pub fn use_rustls_tls(self) -> ClientBuilder {
            self.with_inner(move |inner| inner.use_rustls_tls())
        }

        /// Add TLS information as `TlsInfo` extension to responses.
        ///
        /// # Optional
        ///
        /// This requires the optional `default-tls`, `native-tls`, or `rustls-tls(-...)`
        /// feature to be enabled.
        #[cfg(feature = "__tls")]
        #[cfg_attr(
            docsrs,
            doc(cfg(any(
                feature = "default-tls",
                feature = "native-tls",
                feature = "rustls-tls"
            )))
        )]
        pub fn tls_info(self, tls_info: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.tls_info(tls_info))
        }

        /// Use a preconfigured TLS backend.
        ///
        /// If the passed `Any` argument is not a TLS backend that reqwest
        /// understands, the `ClientBuilder` will error when calling `build`.
        ///
        /// # Advanced
        ///
        /// This is an advanced option, and can be somewhat brittle. Usage requires
        /// keeping the preconfigured TLS argument version in sync with reqwest,
        /// since version mismatches will result in an "unknown" TLS backend.
        ///
        /// If possible, it's preferable to use the methods on `ClientBuilder`
        /// to configure reqwest's TLS.
        ///
        /// # Optional
        ///
        /// This requires one of the optional features `native-tls` or
        /// `rustls-tls(-...)` to be enabled.
        #[cfg(any(feature = "native-tls", feature = "__rustls",))]
        #[cfg_attr(docsrs, doc(cfg(any(feature = "native-tls", feature = "rustls-tls"))))]
        pub fn use_preconfigured_tls(self, tls: impl Any) -> ClientBuilder {
            self.with_inner(move |inner| inner.use_preconfigured_tls(tls))
        }

        /// Enables the [hickory-dns](hickory_resolver) async resolver instead of a default threadpool using `getaddrinfo`.
        ///
        /// If the `hickory-dns` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `hickory-dns` feature to be enabled
        #[cfg(feature = "hickory-dns")]
        #[cfg_attr(docsrs, doc(cfg(feature = "hickory-dns")))]
        #[deprecated(note = "use `hickory_dns` instead", since = "0.12.0")]
        pub fn trust_dns(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.hickory_dns(enable))
        }

        /// Enables the [hickory-dns](hickory_resolver) async resolver instead of a default threadpool using `getaddrinfo`.
        ///
        /// If the `hickory-dns` feature is turned on, the default option is enabled.
        ///
        /// # Optional
        ///
        /// This requires the optional `hickory-dns` feature to be enabled
        #[cfg(feature = "hickory-dns")]
        #[cfg_attr(docsrs, doc(cfg(feature = "hickory-dns")))]
        pub fn hickory_dns(self, enable: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.hickory_dns(enable))
        }

        /// Disables the hickory-dns async resolver.
        ///
        /// This method exists even if the optional `hickory-dns` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use the hickory-dns async resolver
        /// even if another dependency were to enable the optional `hickory-dns` feature.
        #[deprecated(note = "use `no_hickory_dns` instead", since = "0.12.0")]
        pub fn no_trust_dns(self) -> ClientBuilder {
            self.with_inner(|inner| inner.no_hickory_dns())
        }

        /// Disables the hickory-dns async resolver.
        ///
        /// This method exists even if the optional `hickory-dns` feature is not enabled.
        /// This can be used to ensure a `Client` doesn't use the hickory-dns async resolver
        /// even if another dependency were to enable the optional `hickory-dns` feature.
        pub fn no_hickory_dns(self) -> ClientBuilder {
            self.with_inner(|inner| inner.no_hickory_dns())
        }

        /// Restrict the Client to be used with HTTPS only requests.
        ///
        /// Defaults to false.
        pub fn https_only(self, enabled: bool) -> ClientBuilder {
            self.with_inner(|inner| inner.https_only(enabled))
        }

        /// Override DNS resolution for specific domains to a particular IP address.
        ///
        /// Set the port to `0` to use the conventional port for the given scheme (e.g. 80 for http).
        /// Ports in the URL itself will always be used instead of the port in the overridden addr.
        pub fn resolve(self, domain: &str, addr: SocketAddr) -> ClientBuilder {
            self.resolve_to_addrs(domain, &[addr])
        }

        /// Override DNS resolution for specific domains to particular IP addresses.
        ///
        /// Set the port to `0` to use the conventional port for the given scheme (e.g. 80 for http).
        /// Ports in the URL itself will always be used instead of the port in the overridden addr.
        pub fn resolve_to_addrs(self, domain: &str, addrs: &[SocketAddr]) -> ClientBuilder {
            self.with_inner(|inner| inner.resolve_to_addrs(domain, addrs))
        }

        /// Override the DNS resolver implementation.
        ///
        /// Pass an `Arc` wrapping a trait object implementing `Resolve`.
        /// Overrides for specific names passed to `resolve` and `resolve_to_addrs` will
        /// still be applied on top of this resolver.
        pub fn dns_resolver<R: Resolve + 'static>(self, resolver: Arc<R>) -> ClientBuilder {
            self.with_inner(|inner| inner.dns_resolver(resolver))
        }

        /// Adds a new Tower [`Layer`](https://docs.rs/tower/latest/tower/trait.Layer.html) to the
        /// base connector [`Service`](https://docs.rs/tower/latest/tower/trait.Service.html) which
        /// is responsible for connection establishment.
        ///
        /// Each subsequent invocation of this function will wrap previous layers.
        ///
        /// Example usage:
        /// ```
        /// use std::time::Duration;
        ///
        /// let client = reqwest::blocking::Client::builder()
        ///                      // resolved to outermost layer, meaning while we are waiting on concurrency limit
        ///                      .connect_timeout(Duration::from_millis(200))
        ///                      // underneath the concurrency check, so only after concurrency limit lets us through
        ///                      .connector_layer(tower::timeout::TimeoutLayer::new(Duration::from_millis(50)))
        ///                      .connector_layer(tower::limit::concurrency::ConcurrencyLimitLayer::new(2))
        ///                      .build()
        ///                      .unwrap();
        /// ```
        pub fn connector_layer<L>(self, layer: L) -> ClientBuilder
        where
            L: Layer<BoxedConnectorService> + Clone + Send + Sync + 'static,
            L::Service:
                Service<Unnameable, Response = Conn, Error = BoxError> + Clone + Send + Sync + 'static,
            <L::Service as Service<Unnameable>>::Future: Send + 'static,
        {
            self.with_inner(|inner| inner.connector_layer(layer))
        }

        // private

        fn with_inner<F>(mut self, func: F) -> ClientBuilder
        where
            F: FnOnce(async_impl::ClientBuilder) -> async_impl::ClientBuilder,
        {
            self.inner = func(self.inner);
            self
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer set a custom TLS backend for the client and what is an example of using the `use_preconfigured_tls` method?
  codeQuestion3: What steps are taken to configure DNS resolution for specific domains in the client, and how is it implemented?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl From<async_impl::ClientBuilder> for ClientBuilder {
        fn from(builder: async_impl::ClientBuilder) -> Self {
            Self {
                inner: builder,
                timeout: Timeout::default(),
            }
        }
    }

    impl Default for Client {
        fn default() -> Self {
            Self::new()
        }
    }

    impl Client {
        /// Constructs a new `Client`.
        ///
        /// # Panic
        ///
        /// This method panics if TLS backend cannot be initialized, or the resolver
        /// cannot load the system configuration.
        ///
        /// Use `Client::builder()` if you wish to handle the failure as an `Error`
        /// instead of panicking.
        ///
        /// This method also panics if called from within an async runtime. See docs
        /// on [`reqwest::blocking`][crate::blocking] for details.
        pub fn new() -> Client {
            ClientBuilder::new().build().expect("Client::new()")
        }

        /// Creates a `ClientBuilder` to configure a `Client`.
        ///
        /// This is the same as `ClientBuilder::new()`.
        pub fn builder() -> ClientBuilder {
            ClientBuilder::new()
        }

        /// Convenience method to make a `GET` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn get<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::GET, url)
        }

        /// Convenience method to make a `POST` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn post<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::POST, url)
        }

        /// Convenience method to make a `PUT` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn put<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::PUT, url)
        }

        /// Convenience method to make a `PATCH` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn patch<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::PATCH, url)
        }

        /// Convenience method to make a `DELETE` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn delete<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::DELETE, url)
        }

        /// Convenience method to make a `HEAD` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn head<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::HEAD, url)
        }

        /// Start building a `Request` with the `Method` and `Url`.
        ///
        /// Returns a `RequestBuilder`, which will allow setting headers and
        /// request body before sending.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn request<U: IntoUrl>(&self, method: Method, url: U) -> RequestBuilder {
            let req = url.into_url().map(move |url| Request::new(method, url));
            RequestBuilder::new(self.clone(), req)
        }

        /// Executes a `Request`.
        ///
        /// A `Request` can be built manually with `Request::new()` or obtained
        /// from a RequestBuilder with `RequestBuilder::build()`.
        ///
        /// You should prefer to use the `RequestBuilder` and
        /// `RequestBuilder::send()`.
        ///
        /// # Errors
        ///
        /// This method fails if there was an error while sending request,
        /// or redirect limit was exhausted.
        pub fn execute(&self, request: Request) -> crate::Result<Response> {
            self.inner.execute_request(request)
        }
    }

    impl fmt::Debug for Client {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Client")
                //.field("gzip", &self.inner.gzip)
                //.field("redirect_policy", &self.inner.redirect_policy)
                //.field("referer", &self.inner.referer)
                .finish()
        }
    }

    impl fmt::Debug for ClientBuilder {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.inner.fmt(f)
        }
    }

    #[derive(Clone)]
    struct ClientHandle {
        timeout: Timeout,
        inner: Arc<InnerClientHandle>,
    }

    type OneshotResponse = oneshot::Sender<crate::Result<async_impl::Response>>;
    type ThreadSender = mpsc::UnboundedSender<(async_impl::Request, OneshotResponse)>;

    struct InnerClientHandle {
        tx: Option<ThreadSender>,
        thread: Option<thread::JoinHandle<()>>,
    }

    impl Drop for InnerClientHandle {
        fn drop(&mut self) {
            let id = self
                .thread
                .as_ref()
                .map(|h| h.thread().id())
                .expect("thread not dropped yet");

            trace!("closing runtime thread ({id:?})");
            self.tx.take();
            trace!("signaled close for runtime thread ({id:?})");
            self.thread.take().map(|h| h.join());
            trace!("closed runtime thread ({id:?})");
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Client::new()` method handle initialization errors, and what is the role of the `From` implementation for `ClientBuilder`?
  codeQuestion3: What steps are involved in executing a request using the `Client` struct, and how does it utilize internal components?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl ClientHandle {
        fn new(builder: ClientBuilder) -> crate::Result<ClientHandle> {
            let timeout = builder.timeout;
            let builder = builder.inner;
            let (tx, rx) = mpsc::unbounded_channel::<(async_impl::Request, OneshotResponse)>();
            let (spawn_tx, spawn_rx) = oneshot::channel::<crate::Result<()>>();
            let handle = thread::Builder::new()
                .name("reqwest-internal-sync-runtime".into())
                .spawn(move || {
                    use tokio::runtime;
                    let rt = match runtime::Builder::new_current_thread()
                        .enable_all()
                        .build()
                        .map_err(crate::error::builder)
                    {
                        Err(e) => {
                            if let Err(e) = spawn_tx.send(Err(e)) {
                                error!("Failed to communicate runtime creation failure: {e:?}");
                            }
                            return;
                        }
                        Ok(v) => v,
                    };

                    let f = async move {
                        let client = match builder.build() {
                            Err(e) => {
                                if let Err(e) = spawn_tx.send(Err(e)) {
                                    error!("Failed to communicate client creation failure: {e:?}");
                                }
                                return;
                            }
                            Ok(v) => v,
                        };
                        if let Err(e) = spawn_tx.send(Ok(())) {
                            error!("Failed to communicate successful startup: {e:?}");
                            return;
                        }

                        let mut rx = rx;

                        while let Some((req, req_tx)) = rx.recv().await {
                            let req_fut = client.execute(req);
                            tokio::spawn(forward(req_fut, req_tx));
                        }

                        trace!("({:?}) Receiver is shutdown", thread::current().id());
                    };

                    trace!("({:?}) start runtime::block_on", thread::current().id());
                    rt.block_on(f);
                    trace!("({:?}) end runtime::block_on", thread::current().id());
                    drop(rt);
                    trace!("({:?}) finished", thread::current().id());
                })
                .map_err(crate::error::builder)?;

            // Wait for the runtime thread to start up...
            match wait::timeout(spawn_rx, None) {
                Ok(Ok(())) => (),
                Ok(Err(err)) => return Err(err),
                Err(_canceled) => event_loop_panicked(),
            }

            let inner_handle = Arc::new(InnerClientHandle {
                tx: Some(tx),
                thread: Some(handle),
            });

            Ok(ClientHandle {
                timeout,
                inner: inner_handle,
            })
        }

        fn execute_request(&self, req: Request) -> crate::Result<Response> {
            let (tx, rx) = oneshot::channel();
            let (req, body) = req.into_async();
            let url = req.url().clone();
            let timeout = req.timeout().copied().or(self.timeout.0);

            self.inner
                .tx
                .as_ref()
                .expect("core thread exited early")
                .send((req, tx))
                .expect("core thread panicked");

            let result: Result<crate::Result<async_impl::Response>, wait::Waited<crate::Error>> =
                if let Some(body) = body {
                    let f = async move {
                        body.send().await?;
                        rx.await.map_err(|_canceled| event_loop_panicked())
                    };
                    wait::timeout(f, timeout)
                } else {
                    let f = async move { rx.await.map_err(|_canceled| event_loop_panicked()) };
                    wait::timeout(f, timeout)
                };

            match result {
                Ok(Err(err)) => Err(err.with_url(url)),
                Ok(Ok(res)) => Ok(Response::new(
                    res,
                    timeout,
                    KeepCoreThreadAlive(Some(self.inner.clone())),
                )),
                Err(wait::Waited::TimedOut(e)) => Err(crate::error::request(e).with_url(url)),
                Err(wait::Waited::Inner(err)) => Err(err.with_url(url)),
            }
        }
    }

    async fn forward<F>(fut: F, mut tx: OneshotResponse)
    where
        F: Future<Output = crate::Result<async_impl::Response>>,
    {
        use std::task::Poll;

        futures_util::pin_mut!(fut);

        // "select" on the sender being canceled, and the future completing
        let res = std::future::poll_fn(|cx| {
            match fut.as_mut().poll(cx) {
                Poll::Ready(val) => Poll::Ready(Some(val)),
                Poll::Pending => {
                    // check if the callback is canceled
                    ready!(tx.poll_closed(cx));
                    Poll::Ready(None)
                }
            }
        })
        .await;

        if let Some(res) = res {
            let _ = tx.send(res);
        }
        // else request is canceled
    }

    #[derive(Clone, Copy)]
    struct Timeout(Option<Duration>);

    impl Default for Timeout {
        fn default() -> Timeout {
            // default mentioned in ClientBuilder::timeout() doc comment
            Timeout(Some(Duration::from_secs(30)))
        }
    }
    ```
  codeQuestion1: What is the overall purpose of this code?
  codeQuestion2: How does the `execute_request` method handle timeouts and what is an example of its usage?
  codeQuestion3: What steps are involved in setting up the Tokio runtime and how is it utilized within this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub(crate) struct KeepCoreThreadAlive(#[allow(dead_code)] Option<Arc<InnerClientHandle>>);

    impl KeepCoreThreadAlive {
        pub(crate) fn empty() -> KeepCoreThreadAlive {
            KeepCoreThreadAlive(None)
        }
    }

    #[cold]
    #[inline(never)]
    fn event_loop_panicked() -> ! {
        // The only possible reason there would be a Canceled error
        // is if the thread running the event loop panicked. We could return
        // an Err here, like a BrokenPipe, but the Client is not
        // recoverable. Additionally, the panic in the other thread
        // is not normal, and should likely be propagated.
        panic!("event loop thread panicked");
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the `event_loop_panicked` function handle a panic in the event loop thread?
  codeQuestion3: What is the role of the `KeepCoreThreadAlive` struct in the Hyper project?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/body.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::fmt;
    use std::fs::File;
    use std::future::Future;
    #[cfg(feature = "multipart")]
    use std::io::Cursor;
    use std::io::{self, Read};
    use std::mem::{self, MaybeUninit};
    use std::ptr;

    use bytes::Bytes;
    use futures_channel::mpsc;

    use crate::async_impl;

    /// The body of a `Request`.
    ///
    /// In most cases, this is not needed directly, as the
    /// [`RequestBuilder.body`][builder] method uses `Into<Body>`, which allows
    /// passing many things (like a string or vector of bytes).
    ///
    /// [builder]: ./struct.RequestBuilder.html#method.body
    #[derive(Debug)]
    pub struct Body {
        kind: Kind,
    }

    impl Body {
        /// Instantiate a `Body` from a reader.
        ///
        /// # Note
        ///
        /// While allowing for many types to be used, these bodies do not have
        /// a way to reset to the beginning and be reused. This means that when
        /// encountering a 307 or 308 status code, instead of repeating the
        /// request at the new location, the `Response` will be returned with
        /// the redirect status code set.
        ///
        /// ```rust
        /// # use std::fs::File;
        /// # use reqwest::blocking::Body;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let file = File::open("national_secrets.txt")?;
        /// let body = Body::new(file);
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// If you have a set of bytes, like `String` or `Vec<u8>`, using the
        /// `From` implementations for `Body` will store the data in a manner
        /// it can be reused.
        ///
        /// ```rust
        /// # use reqwest::blocking::Body;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let s = "A stringy body";
        /// let body = Body::from(s);
        /// # Ok(())
        /// # }
        /// ```
        pub fn new<R: Read + Send + 'static>(reader: R) -> Body {
            Body {
                kind: Kind::Reader(Box::from(reader), None),
            }
        }

        /// Create a `Body` from a `Read` where the size is known in advance
        /// but the data should not be fully loaded into memory. This will
        /// set the `Content-Length` header and stream from the `Read`.
        ///
        /// ```rust
        /// # use std::fs::File;
        /// # use reqwest::blocking::Body;
        /// # fn run() -> Result<(), Box<dyn std::error::Error>> {
        /// let file = File::open("a_large_file.txt")?;
        /// let file_size = file.metadata()?.len();
        /// let body = Body::sized(file, file_size);
        /// # Ok(())
        /// # }
        /// ```
        pub fn sized<R: Read + Send + 'static>(reader: R, len: u64) -> Body {
            Body {
                kind: Kind::Reader(Box::from(reader), Some(len)),
            }
        }

        /// Returns the body as a byte slice if the body is already buffered in
        /// memory. For streamed requests this method returns `None`.
        pub fn as_bytes(&self) -> Option<&[u8]> {
            match self.kind {
                Kind::Reader(_, _) => None,
                Kind::Bytes(ref bytes) => Some(bytes.as_ref()),
            }
        }

        /// Converts streamed requests to their buffered equivalent and
        /// returns a reference to the buffer. If the request is already
        /// buffered, this has no effect.
        ///
        /// Be aware that for large requests this method is expensive
        /// and may cause your program to run out of memory.
        pub fn buffer(&mut self) -> Result<&[u8], crate::Error> {
            match self.kind {
                Kind::Reader(ref mut reader, maybe_len) => {
                    let mut bytes = if let Some(len) = maybe_len {
                        Vec::with_capacity(len as usize)
                    } else {
                        Vec::new()
                    };
                    io::copy(reader, &mut bytes).map_err(crate::error::builder)?;
                    self.kind = Kind::Bytes(bytes.into());
                    self.buffer()
                }
                Kind::Bytes(ref bytes) => Ok(bytes.as_ref()),
            }
        }

        #[cfg(feature = "multipart")]
        pub(crate) fn len(&self) -> Option<u64> {
            match self.kind {
                Kind::Reader(_, len) => len,
                Kind::Bytes(ref bytes) => Some(bytes.len() as u64),
            }
        }

        #[cfg(feature = "multipart")]
        pub(crate) fn into_reader(self) -> Reader {
            match self.kind {
                Kind::Reader(r, _) => Reader::Reader(r),
                Kind::Bytes(b) => Reader::Bytes(Cursor::new(b)),
            }
        }

        pub(crate) fn into_async(self) -> (Option<Sender>, async_impl::Body, Option<u64>) {
            match self.kind {
                Kind::Reader(read, len) => {
                    let (tx, rx) = mpsc::channel(0);
                    let tx = Sender {
                        body: (read, len),
                        tx,
                    };
                    (Some(tx), async_impl::Body::stream(rx), len)
                }
                Kind::Bytes(chunk) => {
                    let len = chunk.len() as u64;
                    (None, async_impl::Body::reusable(chunk), Some(len))
                }
            }
        }

        pub(crate) fn try_clone(&self) -> Option<Body> {
            self.kind.try_clone().map(|kind| Body { kind })
        }
    }

    enum Kind {
        Reader(Box<dyn Read + Send>, Option<u64>),
        Bytes(Bytes),
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user create a body from a file and set the Content-Length header, and what system calls are involved in handling this action?
  codeQuestion3: What steps are taken to handle the conversion of a streamed request into a buffered one, and what is the role of the `buffer` method?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/body.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Kind {
        fn try_clone(&self) -> Option<Kind> {
            match self {
                Kind::Reader(..) => None,
                Kind::Bytes(v) => Some(Kind::Bytes(v.clone())),
            }
        }
    }

    impl From<Vec<u8>> for Body {
        #[inline]
        fn from(v: Vec<u8>) -> Body {
            Body {
                kind: Kind::Bytes(v.into()),
            }
        }
    }

    impl From<String> for Body {
        #[inline]
        fn from(s: String) -> Body {
            s.into_bytes().into()
        }
    }

    impl From<&'static [u8]> for Body {
        #[inline]
        fn from(s: &'static [u8]) -> Body {
            Body {
                kind: Kind::Bytes(Bytes::from_static(s)),
            }
        }
    }

    impl From<&'static str> for Body {
        #[inline]
        fn from(s: &'static str) -> Body {
            s.as_bytes().into()
        }
    }

    impl From<File> for Body {
        #[inline]
        fn from(f: File) -> Body {
            let len = f.metadata().map(|m| m.len()).ok();
            Body {
                kind: Kind::Reader(Box::new(f), len),
            }
        }
    }
    impl From<Bytes> for Body {
        #[inline]
        fn from(b: Bytes) -> Body {
            Body {
                kind: Kind::Bytes(b),
            }
        }
    }

    impl fmt::Debug for Kind {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                Kind::Reader(_, ref v) => f
                    .debug_struct("Reader")
                    .field("length", &DebugLength(v))
                    .finish(),
                Kind::Bytes(ref v) => fmt::Debug::fmt(v, f),
            }
        }
    }

    struct DebugLength<'a>(&'a Option<u64>);

    impl<'a> fmt::Debug for DebugLength<'a> {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match *self.0 {
                Some(ref len) => fmt::Debug::fmt(len, f),
                None => f.write_str("Unknown"),
            }
        }
    }

    #[cfg(feature = "multipart")]
    pub(crate) enum Reader {
        Reader(Box<dyn Read + Send>),
        Bytes(Cursor<Bytes>),
    }

    #[cfg(feature = "multipart")]
    impl Read for Reader {
        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
            match *self {
                Reader::Reader(ref mut rdr) => rdr.read(buf),
                Reader::Bytes(ref mut rdr) => rdr.read(buf),
            }
        }
    }

    pub(crate) struct Sender {
        body: (Box<dyn Read + Send>, Option<u64>),
        tx: mpsc::Sender<Result<Bytes, Abort>>,
    }

    #[derive(Debug)]
    struct Abort;

    impl fmt::Display for Abort {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_str("abort request body")
        }
    }

    impl std::error::Error for Abort {}

    async fn send_future(sender: Sender) -> Result<(), crate::Error> {
        use bytes::{BufMut, BytesMut};
        use futures_util::SinkExt;
        use std::cmp;

        let con_len = sender.body.1;
        let cap = cmp::min(sender.body.1.unwrap_or(8192), 8192);
        let mut written = 0;
        let mut buf = BytesMut::zeroed(cap as usize);
        buf.clear();
        let mut body = sender.body.0;
        // Put in an option so that it can be consumed on error to call abort()
        let mut tx = Some(sender.tx);

        loop {
            if Some(written) == con_len {
                // Written up to content-length, so stop.
                return Ok(());
            }

            // The input stream is read only if the buffer is empty so
            // that there is only one read in the buffer at any time.
            //
            // We need to know whether there is any data to send before
            // we check the transmission channel (with poll_ready below)
            // because sometimes the receiver disappears as soon as it
            // considers the data is completely transmitted, which may
            // be true.
            //
            // The use case is a web server that closes its
            // input stream as soon as the data received is valid JSON.
            // This behaviour is questionable, but it exists and the
            // fact is that there is actually no remaining data to read.
            if buf.is_empty() {
                if buf.capacity() == buf.len() {
                    buf.reserve(8192);
                    // zero out the reserved memory
                    let uninit = buf.spare_capacity_mut();
                    let uninit_len = uninit.len();
                    unsafe {
                        ptr::write_bytes(uninit.as_mut_ptr().cast::<u8>(), 0, uninit_len);
                    }
                }

                let bytes = unsafe {
                    mem::transmute::<&mut [MaybeUninit<u8>], &mut [u8]>(buf.spare_capacity_mut())
                };
                match body.read(bytes) {
                    Ok(0) => {
                        // The buffer was empty and nothing's left to
                        // read. Return.
                        return Ok(());
                    }
                    Ok(n) => unsafe {
                        buf.advance_mut(n);
                    },
                    Err(e) => {
                        let _ = tx
                            .take()
                            .expect("tx only taken on error")
                            .clone()
                            .try_send(Err(Abort));
                        return Err(crate::error::body(e));
                    }
                }
            }

            // The only way to get here is when the buffer is not empty.
            // We can check the transmission channel

            let buf_len = buf.len() as u64;
            tx.as_mut()
                .expect("tx only taken on error")
                .send(Ok(buf.split().freeze()))
                .await
                .map_err(crate::error::body)?;

            written += buf_len;
        }
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the `send_future` function handle reading data from a file and sending it over a network?
  codeQuestion3: What mechanisms are in place to handle abort requests during data transmission?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/body.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Sender {
        // A `Future` that may do blocking read calls.
        // As a `Future`, this integrates easily with `wait::timeout`.
        pub(crate) fn send(self) -> impl Future<Output = Result<(), crate::Error>> {
            send_future(self)
        }
    }

    // useful for tests, but not publicly exposed
    #[cfg(test)]
    pub(crate) fn read_to_string(mut body: Body) -> io::Result<String> {
        let mut s = String::new();
        match body.kind {
            Kind::Reader(ref mut reader, _) => reader.read_to_string(&mut s),
            Kind::Bytes(ref mut bytes) => (&**bytes).read_to_string(&mut s),
        }
        .map(|_| s)
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `read_to_string` function handle different types of body data?
  codeQuestion3: What is the role of the `send` method in the `Sender` struct and how does it utilize the `send_future` function?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! multipart/form-data
    //!
    //! To send a `multipart/form-data` body, a [`Form`] is built up, adding
    //! fields or customized [`Part`]s, and then calling the
    //! [`multipart`][builder] method on the `RequestBuilder`.
    //!
    //! # Example
    //!
    //! ```
    //! use reqwest::blocking::multipart;
    //!
    //! # fn run() -> Result<(), Box<dyn std::error::Error>> {
    //! let form = multipart::Form::new()
    //!     // Adding just a simple text field...
    //!     .text("username", "seanmonstar")
    //!     // And a file...
    //!     .file("photo", "/path/to/photo.png")?;
    //!
    //! // Customize all the details of a Part if needed...
    //! let bio = multipart::Part::text("hallo peeps")
    //!     .file_name("bio.txt")
    //!     .mime_str("text/plain")?;
    //!
    //! // Add the custom part to our form...
    //! let form = form.part("biography", bio);
    //!
    //! // And finally, send the form
    //! let client = reqwest::blocking::Client::new();
    //! let resp = client
    //!     .post("http://localhost:8080/user")
    //!     .multipart(form)
    //!     .send()?;
    //! # Ok(())
    //! # }
    //! # fn main() {}
    //! ```
    //!
    //! [builder]: ../struct.RequestBuilder.html#method.multipart
    use std::borrow::Cow;
    use std::fmt;
    use std::fs::File;
    use std::io::{self, Cursor, Read};
    use std::path::Path;

    use mime_guess::{self, Mime};

    use super::Body;
    use crate::async_impl::multipart::{FormParts, PartMetadata, PartProps};
    use crate::header::HeaderMap;

    /// A multipart/form-data request.
    pub struct Form {
        inner: FormParts<Part>,
    }

    /// A field in a multipart form.
    pub struct Part {
        meta: PartMetadata,
        value: Body,
    }

    impl Default for Form {
        fn default() -> Self {
            Self::new()
        }
    }

    impl Form {
        /// Creates a new Form without any content.
        pub fn new() -> Form {
            Form {
                inner: FormParts::new(),
            }
        }

        /// Get the boundary that this form will use.
        #[inline]
        pub fn boundary(&self) -> &str {
            self.inner.boundary()
        }

        /// Add a data field with supplied name and value.
        ///
        /// # Examples
        ///
        /// ```
        /// let form = reqwest::blocking::multipart::Form::new()
        ///     .text("username", "seanmonstar")
        ///     .text("password", "secret");
        /// ```
        pub fn text<T, U>(self, name: T, value: U) -> Form
        where
            T: Into<Cow<'static, str>>,
            U: Into<Cow<'static, str>>,
        {
            self.part(name, Part::text(value))
        }

        /// Adds a file field.
        ///
        /// The path will be used to try to guess the filename and mime.
        ///
        /// # Examples
        ///
        /// ```no_run
        /// # fn run() -> std::io::Result<()> {
        /// let form = reqwest::blocking::multipart::Form::new()
        ///     .file("key", "/path/to/file")?;
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Errors
        ///
        /// Errors when the file cannot be opened.
        pub fn file<T, U>(self, name: T, path: U) -> io::Result<Form>
        where
            T: Into<Cow<'static, str>>,
            U: AsRef<Path>,
        {
            Ok(self.part(name, Part::file(path)?))
        }

        /// Adds a customized Part.
        pub fn part<T>(self, name: T, part: Part) -> Form
        where
            T: Into<Cow<'static, str>>,
        {
            self.with_inner(move |inner| inner.part(name, part))
        }

        /// Configure this `Form` to percent-encode using the `path-segment` rules.
        pub fn percent_encode_path_segment(self) -> Form {
            self.with_inner(|inner| inner.percent_encode_path_segment())
        }

        /// Configure this `Form` to percent-encode using the `attr-char` rules.
        pub fn percent_encode_attr_chars(self) -> Form {
            self.with_inner(|inner| inner.percent_encode_attr_chars())
        }

        /// Configure this `Form` to skip percent-encoding
        pub fn percent_encode_noop(self) -> Form {
            self.with_inner(|inner| inner.percent_encode_noop())
        }

        pub(crate) fn reader(self) -> Reader {
            Reader::new(self)
        }

        /// Produce a reader over the multipart form data.
        pub fn into_reader(self) -> impl Read {
            self.reader()
        }

        // If predictable, computes the length the request will have
        // The length should be predictable if only String and file fields have been added,
        // but not if a generic reader has been added;
        pub(crate) fn compute_length(&mut self) -> Option<u64> {
            self.inner.compute_length()
        }

        fn with_inner<F>(self, func: F) -> Self
        where
            F: FnOnce(FormParts<Part>) -> FormParts<Part>,
        {
            Form {
                inner: func(self.inner),
            }
        }
    }

    impl fmt::Debug for Form {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.inner.fmt_fields("Form", f)
        }
    }

    impl Part {
        /// Makes a text parameter.
        pub fn text<T>(value: T) -> Part
        where
            T: Into<Cow<'static, str>>,
        {
            let body = match value.into() {
                Cow::Borrowed(slice) => Body::from(slice),
                Cow::Owned(string) => Body::from(string),
            };
            Part::new(body)
        }

        /// Makes a new parameter from arbitrary bytes.
        pub fn bytes<T>(value: T) -> Part
        where
            T: Into<Cow<'static, [u8]>>,
        {
            let body = match value.into() {
                Cow::Borrowed(slice) => Body::from(slice),
                Cow::Owned(vec) => Body::from(vec),
            };
            Part::new(body)
        }

        /// Adds a generic reader.
        ///
        /// Does not set filename or mime.
        pub fn reader<T: Read + Send + 'static>(value: T) -> Part {
            Part::new(Body::new(value))
        }

        /// Adds a generic reader with known length.
        ///
        /// Does not set filename or mime.
        pub fn reader_with_length<T: Read + Send + 'static>(value: T, length: u64) -> Part {
            Part::new(Body::sized(value, length))
        }

        /// Makes a file parameter.
        ///
        /// # Errors
        ///
        /// Errors when the file cannot be opened.
        pub fn file<T: AsRef<Path>>(path: T) -> io::Result<Part> {
            let path = path.as_ref();
            let file_name = path
                .file_name()
                .map(|filename| filename.to_string_lossy().into_owned());
            let ext = path.extension().and_then(|ext| ext.to_str()).unwrap_or("");
            let mime = mime_guess::from_ext(ext).first_or_octet_stream();
            let file = File::open(path)?;
            let field = Part::new(Body::from(file)).mime(mime);

            Ok(if let Some(file_name) = file_name {
                field.file_name(file_name)
            } else {
                field
            })
        }

        fn new(value: Body) -> Part {
            Part {
                meta: PartMetadata::new(),
                value,
            }
        }

        /// Tries to set the mime of this part.
        pub fn mime_str(self, mime: &str) -> crate::Result<Part> {
            Ok(self.mime(mime.parse().map_err(crate::error::builder)?))
        }

        // Re-export when mime 0.4 is available, with split MediaType/MediaRange.
        fn mime(self, mime: Mime) -> Part {
            self.with_inner(move |inner| inner.mime(mime))
        }

        /// Sets the filename, builder style.
        pub fn file_name<T>(self, filename: T) -> Part
        where
            T: Into<Cow<'static, str>>,
        {
            self.with_inner(move |inner| inner.file_name(filename))
        }

        /// Sets custom headers for the part.
        pub fn headers(self, headers: HeaderMap) -> Part {
            self.with_inner(move |inner| inner.headers(headers))
        }

        fn with_inner<F>(self, func: F) -> Self
        where
            F: FnOnce(PartMetadata) -> PartMetadata,
        {
            Part {
                meta: func(self.meta),
                value: self.value,
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user add a custom part to the form, and what is an example of using the `part` method?
  codeQuestion3: What steps are taken to handle file uploads in the `file` method, and what is an example of using it?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Part {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut dbg = f.debug_struct("Part");
            dbg.field("value", &self.value);
            self.meta.fmt_fields(&mut dbg);
            dbg.finish()
        }
    }

    impl PartProps for Part {
        fn value_len(&self) -> Option<u64> {
            self.value.len()
        }

        fn metadata(&self) -> &PartMetadata {
            &self.meta
        }
    }

    pub(crate) struct Reader {
        form: Form,
        active_reader: Option<Box<dyn Read + Send>>,
    }

    impl fmt::Debug for Reader {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Reader").field("form", &self.form).finish()
        }
    }

    impl Reader {
        fn new(form: Form) -> Reader {
            let mut reader = Reader {
                form,
                active_reader: None,
            };
            reader.next_reader();
            reader
        }

        fn next_reader(&mut self) {
            self.active_reader = if !self.form.inner.fields.is_empty() {
                // We need to move out of the vector here because we are consuming the field's reader
                let (name, field) = self.form.inner.fields.remove(0);
                let boundary = Cursor::new(format!("--{}\r\n", self.form.boundary()));
                let header = Cursor::new({
                    // Try to use cached headers created by compute_length
                    let mut h = if !self.form.inner.computed_headers.is_empty() {
                        self.form.inner.computed_headers.remove(0)
                    } else {
                        self.form
                            .inner
                            .percent_encoding
                            .encode_headers(&name, field.metadata())
                    };
                    h.extend_from_slice(b"\r\n\r\n");
                    h
                });
                let reader = boundary
                    .chain(header)
                    .chain(field.value.into_reader())
                    .chain(Cursor::new("\r\n"));
                // According to https://tools.ietf.org/html/rfc2046#section-5.1.1
                // the very last field has a special boundary
                if !self.form.inner.fields.is_empty() {
                    Some(Box::new(reader))
                } else {
                    Some(Box::new(reader.chain(Cursor::new(format!(
                        "--{}--\r\n",
                        self.form.boundary()
                    )))))
                }
            } else {
                None
            }
        }
    }

    impl Read for Reader {
        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
            let mut total_bytes_read = 0usize;
            let mut last_read_bytes;
            loop {
                match self.active_reader {
                    Some(ref mut reader) => {
                        last_read_bytes = reader.read(&mut buf[total_bytes_read..])?;
                        total_bytes_read += last_read_bytes;
                        if total_bytes_read == buf.len() {
                            return Ok(total_bytes_read);
                        }
                    }
                    None => return Ok(total_bytes_read),
                };
                if last_read_bytes == 0 && !buf.is_empty() {
                    self.next_reader();
                }
            }
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn form_empty() {
            let mut output = Vec::new();
            let mut form = Form::new();
            let length = form.compute_length();
            form.reader().read_to_end(&mut output).unwrap();
            assert_eq!(output, b"");
            assert_eq!(length.unwrap(), 0);
        }

        #[test]
        fn read_to_end() {
            let mut output = Vec::new();
            let mut form = Form::new()
                .part("reader1", Part::reader(std::io::empty()))
                .part("key1", Part::text("value1"))
                .part("key2", Part::text("value2").mime(mime::IMAGE_BMP))
                .part("reader2", Part::reader(std::io::empty()))
                .part("key3", Part::text("value3").file_name("filename"));
            form.inner.boundary = "boundary".to_string();
            let length = form.compute_length();
            let expected = "--boundary\r\n\
                 Content-Disposition: form-data; name=\"reader1\"\r\n\r\n\
                 \r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key1\"\r\n\r\n\
                 value1\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key2\"\r\n\
                 Content-Type: image/bmp\r\n\r\n\
                 value2\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"reader2\"\r\n\r\n\
                 \r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key3\"; filename=\"filename\"\r\n\r\n\
                 value3\r\n--boundary--\r\n";
            form.reader().read_to_end(&mut output).unwrap();
            // These prints are for debug purposes in case the test fails
            println!(
                "START REAL\n{}\nEND REAL",
                std::str::from_utf8(&output).unwrap()
            );
            println!("START EXPECTED\n{expected}\nEND EXPECTED");
            assert_eq!(std::str::from_utf8(&output).unwrap(), expected);
            assert!(length.is_none());
        }

        #[test]
        fn read_to_end_with_length() {
            let mut output = Vec::new();
            let mut form = Form::new()
                .text("key1", "value1")
                .part("key2", Part::text("value2").mime(mime::IMAGE_BMP))
                .part("key3", Part::text("value3").file_name("filename"));
            form.inner.boundary = "boundary".to_string();
            let length = form.compute_length();
            let expected = "--boundary\r\n\
                 Content-Disposition: form-data; name=\"key1\"\r\n\r\n\
                 value1\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key2\"\r\n\
                 Content-Type: image/bmp\r\n\r\n\
                 value2\r\n\
                 --boundary\r\n\
                 Content-Disposition: form-data; name=\"key3\"; filename=\"filename\"\r\n\r\n\
                 value3\r\n--boundary--\r\n";
            form.reader().read_to_end(&mut output).unwrap();
            // These prints are for debug purposes in case the test fails
            println!(
                "START REAL\n{}\nEND REAL",
                std::str::from_utf8(&output).unwrap()
            );
            println!("START EXPECTED\n{expected}\nEND EXPECTED");
            assert_eq!(std::str::from_utf8(&output).unwrap(), expected);
            assert_eq!(length.unwrap(), expected.len() as u64);
        }

        #[test]
        fn read_to_end_with_header() {
            let mut output = Vec::new();
            let mut part = Part::text("value2").mime(mime::IMAGE_BMP);
            let mut headers = HeaderMap::new();
            headers.insert("Hdr3", "/a/b/c".parse().unwrap());
            part = part.headers(headers);
            let mut form = Form::new().part("key2", part);
            form.inner.boundary = "boundary".to_string();
            let expected = "--boundary\r\n\
                            Content-Disposition: form-data; name=\"key2\"\r\n\
                            Content-Type: image/bmp\r\n\
                            hdr3: /a/b/c\r\n\
                            \r\n\
                            value2\r\n\
                            --boundary--\r\n";
            form.reader().read_to_end(&mut output).unwrap();
            // These prints are for debug purposes in case the test fails
            println!(
                "START REAL\n{}\nEND REAL",
                std::str::from_utf8(&output).unwrap()
            );
            println!("START EXPECTED\n{expected}\nEND EXPECTED");
            assert_eq!(std::str::from_utf8(&output).unwrap(), expected);
        }
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the `Reader` struct handle reading data from a multipart form, and what is an example of its usage in the `read_to_end` test?
  codeQuestion3: What steps are involved in setting up the terminal input and output for the game, and how do system calls contribute to this process?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/blocking/mod.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! A blocking Client API.
    //!
    //! The blocking `Client` will block the current thread to execute, instead
    //! of returning futures that need to be executed on a runtime.
    //!
    //! Conversely, the functionality in `reqwest::blocking` must *not* be executed
    //! within an async runtime, or it will panic when attempting to block. If
    //! calling directly from an async function, consider using an async
    //! [`reqwest::Client`][crate::Client] instead. If the immediate context is only
    //! synchronous, but a transitive caller is async, consider changing that caller
    //! to use [`tokio::task::spawn_blocking`] around the calls that need to block.
    //!
    //! # Optional
    //!
    //! This requires the optional `blocking` feature to be enabled.
    //!
    //! # Making a GET request
    //!
    //! For a single request, you can use the [`get`] shortcut method.
    //!
    //! ```rust
    //! # use reqwest::{Error, Response};
    //!
    //! # fn run() -> Result<(), Error> {
    //! let body = reqwest::blocking::get("https://www.rust-lang.org")?
    //!     .text()?;
    //!
    //! println!("body = {body:?}");
    //! # Ok(())
    //! # }
    //! ```
    //!
    //! Additionally, the blocking [`Response`] struct implements Rust's
    //! `Read` trait, so many useful standard library and third party crates will
    //! have convenience methods that take a `Response` anywhere `T: Read` is
    //! acceptable.
    //!
    //! **NOTE**: If you plan to perform multiple requests, it is best to create a
    //! [`Client`] and reuse it, taking advantage of keep-alive connection pooling.
    //!
    //! # Making POST requests (or setting request bodies)
    //!
    //! There are several ways you can set the body of a request. The basic one is
    //! by using the `body()` method of a [`RequestBuilder`]. This lets you set the
    //! exact raw bytes of what the body should be. It accepts various types,
    //! including `String`, `Vec<u8>`, and `File`. If you wish to pass a custom
    //! Reader, you can use the `reqwest::blocking::Body::new()` constructor.
    //!
    //! ```rust
    //! # use reqwest::Error;
    //! #
    //! # fn run() -> Result<(), Error> {
    //! let client = reqwest::blocking::Client::new();
    //! let res = client.post("http://httpbin.org/post")
    //!     .body("the exact body that is sent")
    //!     .send()?;
    //! # Ok(())
    //! # }
    //! ```
    //!
    //! ## And More
    //!
    //! Most features available to the asynchronous `Client` are also available,
    //! on the blocking `Client`, see those docs for more.

    mod body;
    mod client;
    #[cfg(feature = "multipart")]
    pub mod multipart;
    mod request;
    mod response;
    mod wait;

    pub use self::body::Body;
    pub use self::client::{Client, ClientBuilder};
    pub use self::request::{Request, RequestBuilder};
    pub use self::response::Response;

    /// Shortcut method to quickly make a *blocking* `GET` request.
    ///
    /// **NOTE**: This function creates a new internal `Client` on each call,
    /// and so should not be used if making many requests. Create a
    /// [`Client`](./struct.Client.html) instead.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # fn run() -> Result<(), reqwest::Error> {
    /// let body = reqwest::blocking::get("https://www.rust-lang.org")?
    ///     .text()?;
    /// # Ok(())
    /// # }
    /// # fn main() { }
    /// ```
    ///
    /// # Errors
    ///
    /// This function fails if:
    ///
    /// - the native TLS backend cannot be initialized,
    /// - the supplied `Url` cannot be parsed,
    /// - there was an error while sending request,
    /// - a redirect loop was detected,
    /// - the redirect limit was exhausted, or
    /// - the total download time exceeds 30 seconds.
    pub fn get<T: crate::IntoUrl>(url: T) -> crate::Result<Response> {
        Client::builder().build()?.get(url).send()
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user make a POST request with custom body data using this API?
  codeQuestion3: What steps are taken to handle the initialization of a blocking client and what system calls are involved in making HTTP requests?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/error.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![cfg_attr(target_arch = "wasm32", allow(unused))]
    use std::error::Error as StdError;
    use std::fmt;
    use std::io;

    use crate::{StatusCode, Url};

    /// A `Result` alias where the `Err` case is `reqwest::Error`.
    pub type Result<T> = std::result::Result<T, Error>;

    /// The Errors that may occur when processing a `Request`.
    ///
    /// Note: Errors may include the full URL used to make the `Request`. If the URL
    /// contains sensitive information (e.g. an API key as a query parameter), be
    /// sure to remove it ([`without_url`](Error::without_url))
    pub struct Error {
        inner: Box<Inner>,
    }

    pub(crate) type BoxError = Box<dyn StdError + Send + Sync>;

    struct Inner {
        kind: Kind,
        source: Option<BoxError>,
        url: Option<Url>,
    }

    impl Error {
        pub(crate) fn new<E>(kind: Kind, source: Option<E>) -> Error
        where
            E: Into<BoxError>,
        {
            Error {
                inner: Box::new(Inner {
                    kind,
                    source: source.map(Into::into),
                    url: None,
                }),
            }
        }

        /// Returns a possible URL related to this error.
        ///
        /// # Examples
        ///
        /// ```
        /// # async fn run() {
        /// // displays last stop of a redirect loop
        /// let response = reqwest::get("http://site.with.redirect.loop").await;
        /// if let Err(e) = response {
        ///     if e.is_redirect() {
        ///         if let Some(final_stop) = e.url() {
        ///             println!("redirect loop at {final_stop}");
        ///         }
        ///     }
        /// }
        /// # }
        /// ```
        pub fn url(&self) -> Option<&Url> {
            self.inner.url.as_ref()
        }

        /// Returns a mutable reference to the URL related to this error
        ///
        /// This is useful if you need to remove sensitive information from the URL
        /// (e.g. an API key in the query), but do not want to remove the URL
        /// entirely.
        pub fn url_mut(&mut self) -> Option<&mut Url> {
            self.inner.url.as_mut()
        }

        /// Add a url related to this error (overwriting any existing)
        pub fn with_url(mut self, url: Url) -> Self {
            self.inner.url = Some(url);
            self
        }

        /// Strip the related url from this error (if, for example, it contains
        /// sensitive information)
        pub fn without_url(mut self) -> Self {
            self.inner.url = None;
            self
        }

        /// Returns true if the error is from a type Builder.
        pub fn is_builder(&self) -> bool {
            matches!(self.inner.kind, Kind::Builder)
        }

        /// Returns true if the error is from a `RedirectPolicy`.
        pub fn is_redirect(&self) -> bool {
            matches!(self.inner.kind, Kind::Redirect)
        }

        /// Returns true if the error is from `Response::error_for_status`.
        pub fn is_status(&self) -> bool {
            matches!(self.inner.kind, Kind::Status(_))
        }

        /// Returns true if the error is related to a timeout.
        pub fn is_timeout(&self) -> bool {
            let mut source = self.source();

            while let Some(err) = source {
                if err.is::<TimedOut>() {
                    return true;
                }
                if let Some(io) = err.downcast_ref::<io::Error>() {
                    if io.kind() == io::ErrorKind::TimedOut {
                        return true;
                    }
                }
                source = err.source();
            }

            false
        }

        /// Returns true if the error is related to the request
        pub fn is_request(&self) -> bool {
            matches!(self.inner.kind, Kind::Request)
        }

        #[cfg(not(target_arch = "wasm32"))]
        /// Returns true if the error is related to connect
        pub fn is_connect(&self) -> bool {
            let mut source = self.source();

            while let Some(err) = source {
                if let Some(hyper_err) = err.downcast_ref::<hyper_util::client::legacy::Error>() {
                    if hyper_err.is_connect() {
                        return true;
                    }
                }

                source = err.source();
            }

            false
        }

        /// Returns true if the error is related to the request or response body
        pub fn is_body(&self) -> bool {
            matches!(self.inner.kind, Kind::Body)
        }

        /// Returns true if the error is related to decoding the response's body
        pub fn is_decode(&self) -> bool {
            matches!(self.inner.kind, Kind::Decode)
        }

        /// Returns the status code, if the error was generated from a response.
        pub fn status(&self) -> Option<StatusCode> {
            match self.inner.kind {
                Kind::Status(code) => Some(code),
                _ => None,
            }
        }

        // private

        #[allow(unused)]
        pub(crate) fn into_io(self) -> io::Error {
            io::Error::new(io::ErrorKind::Other, self)
        }
    }

    /// Converts from external types to reqwest's
    /// internal equivalents.
    ///
    /// Currently only is used for `tower::timeout::error::Elapsed`.
    #[cfg(not(target_arch = "wasm32"))]
    pub(crate) fn cast_to_internal_error(error: BoxError) -> BoxError {
        if error.is::<tower::timeout::error::Elapsed>() {
            Box::new(crate::error::TimedOut) as BoxError
        } else {
            error
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How is the `url()` method used in error handling, and what is an example of its application?
  codeQuestion3: What steps are involved in converting an external error type to reqwest's internal error handling system?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/error.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Error {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut builder = f.debug_struct("reqwest::Error");

            builder.field("kind", &self.inner.kind);

            if let Some(ref url) = self.inner.url {
                builder.field("url", &url.as_str());
            }
            if let Some(ref source) = self.inner.source {
                builder.field("source", source);
            }

            builder.finish()
        }
    }

    impl fmt::Display for Error {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self.inner.kind {
                Kind::Builder => f.write_str("builder error")?,
                Kind::Request => f.write_str("error sending request")?,
                Kind::Body => f.write_str("request or response body error")?,
                Kind::Decode => f.write_str("error decoding response body")?,
                Kind::Redirect => f.write_str("error following redirect")?,
                Kind::Upgrade => f.write_str("error upgrading connection")?,
                Kind::Status(ref code) => {
                    let prefix = if code.is_client_error() {
                        "HTTP status client error"
                    } else {
                        debug_assert!(code.is_server_error());
                        "HTTP status server error"
                    };
                    write!(f, "{prefix} ({code})")?;
                }
            };

            if let Some(url) = &self.inner.url {
                write!(f, " for url ({url})")?;
            }

            Ok(())
        }
    }

    impl StdError for Error {
        fn source(&self) -> Option<&(dyn StdError + 'static)> {
            self.inner.source.as_ref().map(|e| &**e as _)
        }
    }

    #[cfg(target_arch = "wasm32")]
    impl From<crate::error::Error> for wasm_bindgen::JsValue {
        fn from(err: Error) -> wasm_bindgen::JsValue {
            js_sys::Error::from(err).into()
        }
    }

    #[cfg(target_arch = "wasm32")]
    impl From<crate::error::Error> for js_sys::Error {
        fn from(err: Error) -> js_sys::Error {
            js_sys::Error::new(&format!("{err}"))
        }
    }

    #[derive(Debug)]
    pub(crate) enum Kind {
        Builder,
        Request,
        Redirect,
        Status(StatusCode),
        Body,
        Decode,
        Upgrade,
    }

    // constructors

    pub(crate) fn builder<E: Into<BoxError>>(e: E) -> Error {
        Error::new(Kind::Builder, Some(e))
    }

    pub(crate) fn body<E: Into<BoxError>>(e: E) -> Error {
        Error::new(Kind::Body, Some(e))
    }

    pub(crate) fn decode<E: Into<BoxError>>(e: E) -> Error {
        Error::new(Kind::Decode, Some(e))
    }

    pub(crate) fn request<E: Into<BoxError>>(e: E) -> Error {
        Error::new(Kind::Request, Some(e))
    }

    pub(crate) fn redirect<E: Into<BoxError>>(e: E, url: Url) -> Error {
        Error::new(Kind::Redirect, Some(e)).with_url(url)
    }

    pub(crate) fn status_code(url: Url, status: StatusCode) -> Error {
        Error::new(Kind::Status(status), None::<Error>).with_url(url)
    }

    pub(crate) fn url_bad_scheme(url: Url) -> Error {
        Error::new(Kind::Builder, Some(BadScheme)).with_url(url)
    }

    pub(crate) fn url_invalid_uri(url: Url) -> Error {
        Error::new(Kind::Builder, Some("Parsed Url is not a valid Uri")).with_url(url)
    }

    if_wasm! {
        pub(crate) fn wasm(js_val: wasm_bindgen::JsValue) -> BoxError {
            format!("{js_val:?}").into()
        }
    }

    pub(crate) fn upgrade<E: Into<BoxError>>(e: E) -> Error {
        Error::new(Kind::Upgrade, Some(e))
    }

    // io::Error helpers

    #[cfg(any(
        feature = "gzip",
        feature = "zstd",
        feature = "brotli",
        feature = "deflate",
        feature = "blocking",
    ))]
    pub(crate) fn into_io(e: BoxError) -> io::Error {
        io::Error::new(io::ErrorKind::Other, e)
    }

    #[allow(unused)]
    pub(crate) fn decode_io(e: io::Error) -> Error {
        if e.get_ref().map(|r| r.is::<Error>()).unwrap_or(false) {
            *e.into_inner()
                .expect("io::Error::get_ref was Some(_)")
                .downcast::<Error>()
                .expect("StdError::is() was true")
        } else {
            decode(e)
        }
    }

    // internal Error "sources"

    #[derive(Debug)]
    pub(crate) struct TimedOut;

    impl fmt::Display for TimedOut {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_str("operation timed out")
        }
    }

    impl StdError for TimedOut {}

    #[derive(Debug)]
    pub(crate) struct BadScheme;

    impl fmt::Display for BadScheme {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_str("URL scheme is not allowed")
        }
    }

    impl StdError for BadScheme {}

    #[cfg(test)]
    mod tests {
        use super::*;

        fn assert_send<T: Send>() {}
        fn assert_sync<T: Sync>() {}

        #[test]
        fn test_source_chain() {
            let root = Error::new(Kind::Request, None::<Error>);
            assert!(root.source().is_none());

            let link = super::body(root);
            assert!(link.source().is_some());
            assert_send::<Error>();
            assert_sync::<Error>();
        }

        #[test]
        fn mem_size_of() {
            use std::mem::size_of;
            assert_eq!(size_of::<Error>(), size_of::<usize>());
        }

        #[test]
        fn roundtrip_io_error() {
            let orig = super::request("orig");
            // Convert reqwest::Error into an io::Error...
            let io = orig.into_io();
            // Convert that io::Error back into a reqwest::Error...
            let err = super::decode_io(io);
            // It should have pulled out the original, not nested it...
            match err.inner.kind {
                Kind::Request => (),
                _ => panic!("{err:?}"),
            }
        }

        #[test]
        fn from_unknown_io_error() {
            let orig = io::Error::new(io::ErrorKind::Other, "orly");
            let err = super::decode_io(orig);
            match err.inner.kind {
                Kind::Decode => (),
                _ => panic!("{err:?}"),
            }
        }

        #[test]
        fn is_timeout() {
            let err = super::request(super::TimedOut);
            assert!(err.is_timeout());

            let io = io::Error::new(io::ErrorKind::Other, err);
            let nested = super::request(io);
            assert!(nested.is_timeout());
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Error` struct handle different types of errors in the reqwest library?
  codeQuestion3: What is the process for converting an `io::Error` into a `reqwest::Error` and back again?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/config.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! The `config` module provides a generic mechanism for loading and managing
    //! request-scoped configuration.
    //!
    //! # Design Overview
    //!
    //! This module is centered around two abstractions:
    //!
    //! - The [`RequestConfigValue`] trait, used to associate a config key type with its value type.
    //! - The [`RequestConfig`] struct, which wraps an optional value of the type linked via [`RequestConfigValue`].
    //!
    //! Under the hood, the [`RequestConfig`] struct holds a single value for the associated config type.
    //! This value can be conveniently accessed, inserted, or mutated using [`http::Extensions`],
    //! enabling type-safe configuration storage and retrieval on a per-request basis.
    //!
    //! # Motivation
    //!
    //! The key design benefit is the ability to store multiple config typespotentially even with the same
    //! value type (e.g., [`Duration`])without code duplication or ambiguity. By leveraging trait association,
    //! each config key is distinct at the type level, while code for storage and access remains totally generic.
    //!
    //! # Usage
    //!
    //! Implement [`RequestConfigValue`] for any marker type you wish to use as a config key,
    //! specifying the associated value type. Then use [`RequestConfig<T>`] in [`Extensions`]
    //! to set or retrieve config values for each key type in a uniform way.

    use std::any::type_name;
    use std::fmt::Debug;
    use std::time::Duration;

    use http::Extensions;

    /// This trait is empty and is only used to associate a configuration key type with its
    /// corresponding value type.
    pub(crate) trait RequestConfigValue: Copy + Clone + 'static {
        type Value: Clone + Debug + Send + Sync + 'static;
    }

    /// RequestConfig carries a request-scoped configuration value.
    #[derive(Clone, Copy)]
    pub(crate) struct RequestConfig<T: RequestConfigValue>(Option<T::Value>);

    impl<T: RequestConfigValue> Default for RequestConfig<T> {
        fn default() -> Self {
            RequestConfig(None)
        }
    }

    impl<T> RequestConfig<T>
    where
        T: RequestConfigValue,
    {
        pub(crate) fn new(v: Option<T::Value>) -> Self {
            RequestConfig(v)
        }

        /// format request config value as struct field.
        ///
        /// We provide this API directly to avoid leak internal value to callers.
        pub(crate) fn fmt_as_field(&self, f: &mut std::fmt::DebugStruct<'_, '_>) {
            if let Some(v) = &self.0 {
                f.field(type_name::<T>(), v);
            }
        }

        /// Retrieve the value from the request-scoped configuration.
        ///
        /// If the request specifies a value, use that value; otherwise, attempt to retrieve it from the current instance (typically a client instance).
        pub(crate) fn fetch<'client, 'request>(
            &'client self,
            ext: &'request Extensions,
        ) -> Option<&'request T::Value>
        where
            'client: 'request,
        {
            ext.get::<RequestConfig<T>>()
                .and_then(|v| v.0.as_ref())
                .or(self.0.as_ref())
        }

        /// Retrieve the value from the request's Extensions.
        pub(crate) fn get(ext: &Extensions) -> Option<&T::Value> {
            ext.get::<RequestConfig<T>>().and_then(|v| v.0.as_ref())
        }

        /// Retrieve the mutable value from the request's Extensions.
        pub(crate) fn get_mut(ext: &mut Extensions) -> &mut Option<T::Value> {
            let cfg = ext.get_or_insert_default::<RequestConfig<T>>();
            &mut cfg.0
        }
    }

    // ================================
    //
    // The following sections are all configuration types
    // provided by reqwets.
    //
    // To add a new config:
    //
    // 1. create a new struct for the config key like `RequestTimeout`.
    // 2. implement `RequestConfigValue` for the struct, the `Value` is the config value's type.
    //
    // ================================

    #[derive(Clone, Copy)]
    pub(crate) struct RequestTimeout;

    impl RequestConfigValue for RequestTimeout {
        type Value = Duration;
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer add a new configuration type to the system, and what is an example of such a configuration?
  codeQuestion3: What is the process for retrieving and modifying a configuration value from the request's Extensions?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/lib.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #![deny(missing_docs)]
    #![deny(missing_debug_implementations)]
    #![cfg_attr(docsrs, feature(doc_cfg))]
    #![cfg_attr(test, deny(warnings))]

    //! # reqwest
    //!
    //! The `reqwest` crate provides a convenient, higher-level HTTP
    //! [`Client`][client].
    //!
    //! It handles many of the things that most people just expect an HTTP client
    //! to do for them.
    //!
    //! - Async and [blocking] Clients
    //! - Plain bodies, [JSON](#json), [urlencoded](#forms), [multipart]
    //! - Customizable [redirect policy](#redirect-policies)
    //! - HTTP [Proxies](#proxies)
    //! - Uses [TLS](#tls) by default
    //! - Cookies
    //!
    //! The [`reqwest::Client`][client] is asynchronous. For applications wishing
    //! to only make a few HTTP requests, the [`reqwest::blocking`](blocking) API
    //! may be more convenient.
    //!
    //! Additional learning resources include:
    //!
    //! - [The Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/web/clients.html)
    //! - [Reqwest Repository Examples](https://github.com/seanmonstar/reqwest/tree/master/examples)
    //!
    //! ## Commercial Support
    //!
    //! For private advice, support, reviews, access to the maintainer, and the
    //! like, reach out for [commercial support][sponsor].
    //!
    //! ## Making a GET request
    //!
    //! For a single request, you can use the [`get`][get] shortcut method.
    //!
    //! ```rust
    //! # async fn run() -> Result<(), reqwest::Error> {
    //! let body = reqwest::get("https://www.rust-lang.org")
    //!     .await?
    //!     .text()
    //!     .await?;
    //!
    //! println!("body = {body:?}");
    //! # Ok(())
    //! # }
    //! ```
    //!
    //! **NOTE**: If you plan to perform multiple requests, it is best to create a
    //! [`Client`][client] and reuse it, taking advantage of keep-alive connection
    //! pooling.
    //!
    //! ## Making POST requests (or setting request bodies)
    //!
    //! There are several ways you can set the body of a request. The basic one is
    //! by using the `body()` method of a [`RequestBuilder`][builder]. This lets you set the
    //! exact raw bytes of what the body should be. It accepts various types,
    //! including `String` and `Vec<u8>`. If you wish to pass a custom
    //! type, you can use the `reqwest::Body` constructors.
    //!
    //! ```rust
    //! # use reqwest::Error;
    //! #
    //! # async fn run() -> Result<(), Error> {
    //! let client = reqwest::Client::new();
    //! let res = client.post("http://httpbin.org/post")
    //!     .body("the exact body that is sent")
    //!     .send()
    //!     .await?;
    //! # Ok(())
    //! # }
    //! ```
    //!
    //! ### Forms
    //!
    //! It's very common to want to send form data in a request body. This can be
    //! done with any type that can be serialized into form data.
    //!
    //! This can be an array of tuples, or a `HashMap`, or a custom type that
    //! implements [`Serialize`][serde].
    //!
    //! ```rust
    //! # use reqwest::Error;
    //! #
    //! # async fn run() -> Result<(), Error> {
    //! // This will POST a body of `foo=bar&baz=quux`
    //! let params = [("foo", "bar"), ("baz", "quux")];
    //! let client = reqwest::Client::new();
    //! let res = client.post("http://httpbin.org/post")
    //!     .form(&params)
    //!     .send()
    //!     .await?;
    //! # Ok(())
    //! # }
    //! ```
    //!
    //! ### JSON
    //!
    //! There is also a `json` method helper on the [`RequestBuilder`][builder] that works in
    //! a similar fashion the `form` method. It can take any value that can be
    //! serialized into JSON. The feature `json` is required.
    //!
    //! ```rust
    //! # use reqwest::Error;
    //! # use std::collections::HashMap;
    //! #
    //! # #[cfg(feature = "json")]
    //! # async fn run() -> Result<(), Error> {
    //! // This will POST a body of `{"lang":"rust","body":"json"}`
    //! let mut map = HashMap::new();
    //! map.insert("lang", "rust");
    //! map.insert("body", "json");
    //!
    //! let client = reqwest::Client::new();
    //! let res = client.post("http://httpbin.org/post")
    //!     .json(&map)
    //!     .send()
    //!     .await?;
    //! # Ok(())
    //! # }
    //! ```
    //!
    //! ## Redirect Policies
    //!
    //! By default, a `Client` will automatically handle HTTP redirects, having a
    //! maximum redirect chain of 10 hops. To customize this behavior, a
    //! [`redirect::Policy`][redirect] can be used with a `ClientBuilder`.
    //!
    //! ## Cookies
    //!
    //! The automatic storing and sending of session cookies can be enabled with
    //! the [`cookie_store`][ClientBuilder::cookie_store] method on `ClientBuilder`.
    //!
    //! ## Proxies
    //!
    //! **NOTE**: System proxies are enabled by default.
    //!
    //! System proxies look in environment variables to set HTTP or HTTPS proxies.
    //!
    //! `HTTP_PROXY` or `http_proxy` provide HTTP proxies for HTTP connections while
    //! `HTTPS_PROXY` or `https_proxy` provide HTTPS proxies for HTTPS connections.
    //! `ALL_PROXY` or `all_proxy` provide proxies for both HTTP and HTTPS connections.
    //! If both the all proxy and HTTP or HTTPS proxy variables are set the more specific
    //! HTTP or HTTPS proxies take precedence.
    //!
    //! These can be overwritten by adding a [`Proxy`] to `ClientBuilder`
    //! i.e. `let proxy = reqwest::Proxy::http("https://secure.example")?;`
    //! or disabled by calling `ClientBuilder::no_proxy()`.
    //!
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user make a POST request with form data, and what is the correct usage of the `form` method in this context?
  codeQuestion3: What steps are involved in configuring a custom redirect policy for the `reqwest` client, and how is it applied during request processing?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/lib.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! `socks` feature is required if you have configured socks proxy like this:
    //!
    //! ```bash
    //! export https_proxy=socks5://127.0.0.1:1086
    //! ```
    //!
    //! ## TLS
    //!
    //! A `Client` will use transport layer security (TLS) by default to connect to
    //! HTTPS destinations.
    //!
    //! - Additional server certificates can be configured on a `ClientBuilder`
    //!   with the [`Certificate`] type.
    //! - Client certificates can be added to a `ClientBuilder` with the
    //!   [`Identity`] type.
    //! - Various parts of TLS can also be configured or even disabled on the
    //!   `ClientBuilder`.
    //!
    //! See more details in the [`tls`] module.
    //!
    //! ## WASM
    //!
    //! The Client implementation automatically switches to the WASM one when the target_arch is wasm32,
    //! the usage is basically the same as the async api. Some of the features are disabled in wasm
    //! : [`tls`], [`cookie`], [`blocking`], as well as various `ClientBuilder` methods such as `timeout()` and `connector_layer()`.
    //!
    //! TLS and cookies are provided through the browser environment, so reqwest can issue TLS requests with cookies,
    //! but has limited configuration.
    //!
    //! ## Optional Features
    //!
    //! The following are a list of [Cargo features][cargo-features] that can be
    //! enabled or disabled:
    //!
    //! - **http2** *(enabled by default)*: Enables HTTP/2 support.
    //! - **default-tls** *(enabled by default)*: Provides TLS support to connect
    //!   over HTTPS.
    //! - **native-tls**: Enables TLS functionality provided by `native-tls`.
    //! - **native-tls-vendored**: Enables the `vendored` feature of `native-tls`.
    //! - **native-tls-alpn**: Enables the `alpn` feature of `native-tls`.
    //! - **rustls-tls**: Enables TLS functionality provided by `rustls`.
    //!   Equivalent to `rustls-tls-webpki-roots`.
    //! - **rustls-tls-manual-roots**: Enables TLS functionality provided by `rustls`,
    //!   without setting any root certificates. Roots have to be specified manually.
    //! - **rustls-tls-webpki-roots**: Enables TLS functionality provided by `rustls`,
    //!   while using root certificates from the `webpki-roots` crate.
    //! - **rustls-tls-native-roots**: Enables TLS functionality provided by `rustls`,
    //!   while using root certificates from the `rustls-native-certs` crate.
    //! - **blocking**: Provides the [blocking][] client API.
    //! - **charset** *(enabled by default)*: Improved support for decoding text.
    //! - **cookies**: Provides cookie session support.
    //! - **gzip**: Provides response body gzip decompression.
    //! - **brotli**: Provides response body brotli decompression.
    //! - **zstd**: Provides response body zstd decompression.
    //! - **deflate**: Provides response body deflate decompression.
    //! - **json**: Provides serialization and deserialization for JSON bodies.
    //! - **multipart**: Provides functionality for multipart forms.
    //! - **stream**: Adds support for `futures::Stream`.
    //! - **socks**: Provides SOCKS5 proxy support.
    //! - **hickory-dns**: Enables a hickory-dns async resolver instead of default
    //!   threadpool using `getaddrinfo`.
    //!
    //! ## Unstable Features
    //!
    //! Some feature flags require additional opt-in by the application, by setting
    //! a `reqwest_unstable` flag.
    //!
    //! - **http3** *(unstable)*: Enables support for sending HTTP/3 requests.
    //!
    //! These features are unstable, and experimental. Details about them may be
    //! changed in patch releases.
    //!
    //! You can pass such a flag to the compiler via `.cargo/config`, or
    //! environment variables, such as:
    //!
    //! ```notrust
    //! RUSTFLAGS="--cfg reqwest_unstable" cargo build
    //! ```
    //!
    //! ## Sponsors
    //!
    //! Support this project by becoming a [sponsor][].
    //!
    //! [hyper]: https://hyper.rs
    //! [blocking]: ./blocking/index.html
    //! [client]: ./struct.Client.html
    //! [response]: ./struct.Response.html
    //! [get]: ./fn.get.html
    //! [builder]: ./struct.RequestBuilder.html
    //! [serde]: http://serde.rs
    //! [redirect]: crate::redirect
    //! [Proxy]: ./struct.Proxy.html
    //! [cargo-features]: https://doc.rust-lang.org/stable/cargo/reference/manifest.html#the-features-section
    //! [sponsor]: https://seanmonstar.com/sponsor

    #[cfg(all(feature = "http3", not(reqwest_unstable)))]
    compile_error!(
        "\
        The `http3` feature is unstable, and requires the \
        `RUSTFLAGS='--cfg reqwest_unstable'` environment variable to be set.\
    "
    );

    macro_rules! if_wasm {
        ($($item:item)*) => {$(
            #[cfg(target_arch = "wasm32")]
            $item
        )*}
    }

    macro_rules! if_hyper {
        ($($item:item)*) => {$(
            #[cfg(not(target_arch = "wasm32"))]
            $item
        )*}
    }

    pub use http::header;
    pub use http::Method;
    pub use http::{StatusCode, Version};
    pub use url::Url;

    // universal mods
    #[macro_use]
    mod error;
    // TODO: remove `if_hyper` if wasm has been mirgated to new config system.
    if_hyper! {
        mod config;
    }
    mod into_url;
    mod response;

    pub use self::error::{Error, Result};
    pub use self::into_url::IntoUrl;
    pub use self::response::ResponseBuilderExt;

    /// Shortcut method to quickly make a `GET` request.
    ///
    /// See also the methods on the [`reqwest::Response`](./struct.Response.html)
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user configure the client to use a SOCKS5 proxy, and what system calls or API methods are involved in this configuration?
  codeQuestion3: What steps are taken to handle TLS configuration for a client, and what are the different options available for configuring TLS in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/lib.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// type.
    ///
    /// **NOTE**: This function creates a new internal `Client` on each call,
    /// and so should not be used if making many requests. Create a
    /// [`Client`](./struct.Client.html) instead.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # async fn run() -> Result<(), reqwest::Error> {
    /// let body = reqwest::get("https://www.rust-lang.org").await?
    ///     .text().await?;
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Errors
    ///
    /// This function fails if:
    ///
    /// - native TLS backend cannot be initialized
    /// - supplied `Url` cannot be parsed
    /// - there was an error while sending request
    /// - redirect limit was exhausted
    pub async fn get<T: IntoUrl>(url: T) -> crate::Result<Response> {
        Client::builder().build()?.get(url).send().await
    }

    fn _assert_impls() {
        fn assert_send<T: Send>() {}
        fn assert_sync<T: Sync>() {}
        fn assert_clone<T: Clone>() {}

        assert_send::<Client>();
        assert_sync::<Client>();
        assert_clone::<Client>();

        assert_send::<Request>();
        assert_send::<RequestBuilder>();

        #[cfg(not(target_arch = "wasm32"))]
        {
            assert_send::<Response>();
        }

        assert_send::<Error>();
        assert_sync::<Error>();

        assert_send::<Body>();
        assert_sync::<Body>();
    }

    if_hyper! {
        #[cfg(test)]
        #[macro_use]
        extern crate doc_comment;

        #[cfg(test)]
        doctest!("../README.md");

        pub use self::async_impl::{
            Body, Client, ClientBuilder, Request, RequestBuilder, Response, Upgraded,
        };
        pub use self::proxy::{Proxy,NoProxy};
        #[cfg(feature = "__tls")]
        // Re-exports, to be removed in a future release
        pub use tls::{Certificate, Identity};
        #[cfg(feature = "multipart")]
        pub use self::async_impl::multipart;


        mod async_impl;
        #[cfg(feature = "blocking")]
        pub mod blocking;
        mod connect;
        #[cfg(feature = "cookies")]
        pub mod cookie;
        pub mod dns;
        mod proxy;
        pub mod redirect;
        #[cfg(feature = "__tls")]
        pub mod tls;
        mod util;
    }

    if_wasm! {
        mod wasm;
        mod util;

        pub use self::wasm::{Body, Client, ClientBuilder, Request, RequestBuilder, Response};
        #[cfg(feature = "multipart")]
        pub use self::wasm::multipart;
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `get` function handle asynchronous requests and what system calls are involved in making HTTP requests?
  codeQuestion3: What steps are taken to ensure thread safety and memory management for the `Client` type in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__tls")]
    use http::header::HeaderValue;
    use http::uri::{Authority, Scheme};
    use http::Uri;
    use hyper::rt::{Read, ReadBufCursor, Write};
    use hyper_util::client::legacy::connect::{Connected, Connection};
    #[cfg(any(feature = "socks", feature = "__tls"))]
    use hyper_util::rt::TokioIo;
    #[cfg(feature = "default-tls")]
    use native_tls_crate::{TlsConnector, TlsConnectorBuilder};
    use pin_project_lite::pin_project;
    use tower::util::{BoxCloneSyncServiceLayer, MapRequestLayer};
    use tower::{timeout::TimeoutLayer, util::BoxCloneSyncService, ServiceBuilder};
    use tower_service::Service;

    use std::future::Future;
    use std::io::{self, IoSlice};
    use std::net::IpAddr;
    use std::pin::Pin;
    use std::sync::Arc;
    use std::task::{Context, Poll};
    use std::time::Duration;

    #[cfg(feature = "default-tls")]
    use self::native_tls_conn::NativeTlsConn;
    #[cfg(feature = "__rustls")]
    use self::rustls_tls_conn::RustlsTlsConn;
    use crate::dns::DynResolver;
    use crate::error::{cast_to_internal_error, BoxError};
    use crate::proxy::{Proxy, ProxyScheme};
    use sealed::{Conn, Unnameable};

    pub(crate) type HttpConnector = hyper_util::client::legacy::connect::HttpConnector<DynResolver>;

    #[derive(Clone)]
    pub(crate) enum Connector {
        // base service, with or without an embedded timeout
        Simple(ConnectorService),
        // at least one custom layer along with maybe an outer timeout layer
        // from `builder.connect_timeout()`
        WithLayers(BoxCloneSyncService<Unnameable, Conn, BoxError>),
    }

    impl Service<Uri> for Connector {
        type Response = Conn;
        type Error = BoxError;
        type Future = Connecting;

        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            match self {
                Connector::Simple(service) => service.poll_ready(cx),
                Connector::WithLayers(service) => service.poll_ready(cx),
            }
        }

        fn call(&mut self, dst: Uri) -> Self::Future {
            match self {
                Connector::Simple(service) => service.call(dst),
                Connector::WithLayers(service) => service.call(Unnameable(dst)),
            }
        }
    }

    pub(crate) type BoxedConnectorService = BoxCloneSyncService<Unnameable, Conn, BoxError>;

    pub(crate) type BoxedConnectorLayer =
        BoxCloneSyncServiceLayer<BoxedConnectorService, Unnameable, Conn, BoxError>;

    pub(crate) struct ConnectorBuilder {
        inner: Inner,
        proxies: Arc<Vec<Proxy>>,
        verbose: verbose::Wrapper,
        timeout: Option<Duration>,
        #[cfg(feature = "__tls")]
        nodelay: bool,
        #[cfg(feature = "__tls")]
        tls_info: bool,
        #[cfg(feature = "__tls")]
        user_agent: Option<HeaderValue>,
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the Connector enum handle different types of connections, and what are the steps involved in creating a new connection using the ConnectorService?
  codeQuestion3: What is the role of the ConnectorBuilder struct and how are its configuration options used to build a custom connector?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl ConnectorBuilder {
        pub(crate) fn build(self, layers: Vec<BoxedConnectorLayer>) -> Connector
    where {
            // construct the inner tower service
            let mut base_service = ConnectorService {
                inner: self.inner,
                proxies: self.proxies,
                verbose: self.verbose,
                #[cfg(feature = "__tls")]
                nodelay: self.nodelay,
                #[cfg(feature = "__tls")]
                tls_info: self.tls_info,
                #[cfg(feature = "__tls")]
                user_agent: self.user_agent,
                simple_timeout: None,
            };

            if layers.is_empty() {
                // we have no user-provided layers, only use concrete types
                base_service.simple_timeout = self.timeout;
                return Connector::Simple(base_service);
            }

            // otherwise we have user provided layers
            // so we need type erasure all the way through
            // as well as mapping the unnameable type of the layers back to Uri for the inner service
            let unnameable_service = ServiceBuilder::new()
                .layer(MapRequestLayer::new(|request: Unnameable| request.0))
                .service(base_service);
            let mut service = BoxCloneSyncService::new(unnameable_service);

            for layer in layers {
                service = ServiceBuilder::new().layer(layer).service(service);
            }

            // now we handle the concrete stuff - any `connect_timeout`,
            // plus a final map_err layer we can use to cast default tower layer
            // errors to internal errors
            match self.timeout {
                Some(timeout) => {
                    let service = ServiceBuilder::new()
                        .layer(TimeoutLayer::new(timeout))
                        .service(service);
                    let service = ServiceBuilder::new()
                        .map_err(|error: BoxError| cast_to_internal_error(error))
                        .service(service);
                    let service = BoxCloneSyncService::new(service);

                    Connector::WithLayers(service)
                }
                None => {
                    // no timeout, but still map err
                    // no named timeout layer but we still map errors since
                    // we might have user-provided timeout layer
                    let service = ServiceBuilder::new().service(service);
                    let service = ServiceBuilder::new()
                        .map_err(|error: BoxError| cast_to_internal_error(error))
                        .service(service);
                    let service = BoxCloneSyncService::new(service);
                    Connector::WithLayers(service)
                }
            }
        }

        #[cfg(not(feature = "__tls"))]
        pub(crate) fn new<T>(
            mut http: HttpConnector,
            proxies: Arc<Vec<Proxy>>,
            local_addr: T,
            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            interface: Option<&str>,
            nodelay: bool,
        ) -> ConnectorBuilder
        where
            T: Into<Option<IpAddr>>,
        {
            http.set_local_address(local_addr.into());
            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            if let Some(interface) = interface {
                http.set_interface(interface.to_owned());
            }
            http.set_nodelay(nodelay);

            ConnectorBuilder {
                inner: Inner::Http(http),
                proxies,
                verbose: verbose::OFF,
                timeout: None,
            }
        }

        #[cfg(feature = "default-tls")]
        pub(crate) fn new_default_tls<T>(
            http: HttpConnector,
            tls: TlsConnectorBuilder,
            proxies: Arc<Vec<Proxy>>,
            user_agent: Option<HeaderValue>,
            local_addr: T,
            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            interface: Option<&str>,
            nodelay: bool,
            tls_info: bool,
        ) -> crate::Result<ConnectorBuilder>
        where
            T: Into<Option<IpAddr>>,
        {
            let tls = tls.build().map_err(crate::error::builder)?;
            Ok(Self::from_built_default_tls(
                http,
                tls,
                proxies,
                user_agent,
                local_addr,
                #[cfg(any(
                    target_os = "android",
                    target_os = "fuchsia",
                    target_os = "illumos",
                    target_os = "ios",
                    target_os = "linux",
                    target_os = "macos",
                    target_os = "solaris",
                    target_os = "tvos",
                    target_os = "visionos",
                    target_os = "watchos",
                ))]
                interface,
                nodelay,
                tls_info,
            ))
        }

        #[cfg(feature = "default-tls")]
        pub(crate) fn from_built_default_tls<T>(
            mut http: HttpConnector,
            tls: TlsConnector,
            proxies: Arc<Vec<Proxy>>,
            user_agent: Option<HeaderValue>,
            local_addr: T,
            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            interface: Option<&str>,
            nodelay: bool,
            tls_info: bool,
        ) -> ConnectorBuilder
        where
            T: Into<Option<IpAddr>>,
        {
            http.set_local_address(local_addr.into());
            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            if let Some(interface) = interface {
                http.set_interface(interface);
            }
            http.set_nodelay(nodelay);
            http.enforce_http(false);

            ConnectorBuilder {
                inner: Inner::DefaultTls(http, tls),
                proxies,
                verbose: verbose::OFF,
                nodelay,
                tls_info,
                user_agent,
                timeout: None,
            }
        }

        #[cfg(feature = "__rustls")]
        pub(crate) fn new_rustls_tls<T>(
            mut http: HttpConnector,
            tls: rustls::ClientConfig,
            proxies: Arc<Vec<Proxy>>,
            user_agent: Option<HeaderValue>,
            local_addr: T,
            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            interface: Option<&str>,
            nodelay: bool,
            tls_info: bool,
        ) -> ConnectorBuilder
        where
            T: Into<Option<IpAddr>>,
        {
            http.set_local_address(local_addr.into());
            #[cfg(any(
                target_os = "android",
                target_os = "fuchsia",
                target_os = "illumos",
                target_os = "ios",
                target_os = "linux",
                target_os = "macos",
                target_os = "solaris",
                target_os = "tvos",
                target_os = "visionos",
                target_os = "watchos",
            ))]
            if let Some(interface) = interface {
                http.set_interface(interface.to_owned());
            }
            http.set_nodelay(nodelay);
            http.enforce_http(false);

            let (tls, tls_proxy) = if proxies.is_empty() {
                let tls = Arc::new(tls);
                (tls.clone(), tls)
            } else {
                let mut tls_proxy = tls.clone();
                tls_proxy.alpn_protocols.clear();
                (Arc::new(tls), Arc::new(tls_proxy))
            };

            ConnectorBuilder {
                inner: Inner::RustlsTls {
                    http,
                    tls,
                    tls_proxy,
                },
                proxies,
                verbose: verbose::OFF,
                nodelay,
                tls_info,
                user_agent,
                timeout: None,
            }
        }

        pub(crate) fn set_timeout(&mut self, timeout: Option<Duration>) {
            self.timeout = timeout;
        }

        pub(crate) fn set_verbose(&mut self, enabled: bool) {
            self.verbose.0 = enabled;
        }

        pub(crate) fn set_keepalive(&mut self, dur: Option<Duration>) {
            match &mut self.inner {
                #[cfg(feature = "default-tls")]
                Inner::DefaultTls(http, _tls) => http.set_keepalive(dur),
                #[cfg(feature = "__rustls")]
                Inner::RustlsTls { http, .. } => http.set_keepalive(dur),
                #[cfg(not(feature = "__tls"))]
                Inner::Http(http) => http.set_keepalive(dur),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `build` method handle user-provided layers and what is an example of using them in a request?
  codeQuestion3: What steps are taken to configure the HTTP connector with TLS settings and how is this done in code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[allow(missing_debug_implementations)]
    #[derive(Clone)]
    pub(crate) struct ConnectorService {
        inner: Inner,
        proxies: Arc<Vec<Proxy>>,
        verbose: verbose::Wrapper,
        /// When there is a single timeout layer and no other layers,
        /// we embed it directly inside our base Service::call().
        /// This lets us avoid an extra `Box::pin` indirection layer
        /// since `tokio::time::Timeout` is `Unpin`
        simple_timeout: Option<Duration>,
        #[cfg(feature = "__tls")]
        nodelay: bool,
        #[cfg(feature = "__tls")]
        tls_info: bool,
        #[cfg(feature = "__tls")]
        user_agent: Option<HeaderValue>,
    }

    #[derive(Clone)]
    enum Inner {
        #[cfg(not(feature = "__tls"))]
        Http(HttpConnector),
        #[cfg(feature = "default-tls")]
        DefaultTls(HttpConnector, TlsConnector),
        #[cfg(feature = "__rustls")]
        RustlsTls {
            http: HttpConnector,
            tls: Arc<rustls::ClientConfig>,
            tls_proxy: Arc<rustls::ClientConfig>,
        },
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `ConnectorService` struct manage different types of connectors based on feature flags?
  codeQuestion3: What is the role of the `simple_timeout` field in the `ConnectorService` struct and how might it be used in practice?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl ConnectorService
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle establishing a connection to a remote server, and what API is used for this?
  codeQuestion3: What steps are taken to handle errors during the connection process, and how are they communicated back to the user?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        #[cfg(feature = "socks")]
        async fn connect_socks(&self, dst: Uri, proxy: ProxyScheme) -> Result<Conn, BoxError> {
            let dns = match proxy {
                ProxyScheme::Socks4 {
                    remote_dns: false, ..
                } => socks::DnsResolve::Local,
                ProxyScheme::Socks4 {
                    remote_dns: true, ..
                } => socks::DnsResolve::Proxy,
                ProxyScheme::Socks5 {
                    remote_dns: false, ..
                } => socks::DnsResolve::Local,
                ProxyScheme::Socks5 {
                    remote_dns: true, ..
                } => socks::DnsResolve::Proxy,
                ProxyScheme::Http { .. } | ProxyScheme::Https { .. } => {
                    unreachable!("connect_socks is only called for socks proxies");
                }
            };

            match &self.inner {
                #[cfg(feature = "default-tls")]
                Inner::DefaultTls(_http, tls) => {
                    if dst.scheme() == Some(&Scheme::HTTPS) {
                        let host = dst.host().ok_or("no host in url")?.to_string();
                        let conn = socks::connect(proxy, dst, dns).await?;
                        let conn = TokioIo::new(conn);
                        let conn = TokioIo::new(conn);
                        let tls_connector = tokio_native_tls::TlsConnector::from(tls.clone());
                        let io = tls_connector.connect(&host, conn).await?;
                        let io = TokioIo::new(io);
                        return Ok(Conn {
                            inner: self.verbose.wrap(NativeTlsConn { inner: io }),
                            is_proxy: false,
                            tls_info: self.tls_info,
                        });
                    }
                }
                #[cfg(feature = "__rustls")]
                Inner::RustlsTls { tls, .. } => {
                    if dst.scheme() == Some(&Scheme::HTTPS) {
                        use std::convert::TryFrom;
                        use tokio_rustls::TlsConnector as RustlsConnector;

                        let tls = tls.clone();
                        let host = dst.host().ok_or("no host in url")?.to_string();
                        let conn = socks::connect(proxy, dst, dns).await?;
                        let conn = TokioIo::new(conn);
                        let conn = TokioIo::new(conn);
                        let server_name =
                            rustls_pki_types::ServerName::try_from(host.as_str().to_owned())
                                .map_err(|_| "Invalid Server Name")?;
                        let io = RustlsConnector::from(tls)
                            .connect(server_name, conn)
                            .await?;
                        let io = TokioIo::new(io);
                        return Ok(Conn {
                            inner: self.verbose.wrap(RustlsTlsConn { inner: io }),
                            is_proxy: false,
                            tls_info: false,
                        });
                    }
                }
                #[cfg(not(feature = "__tls"))]
                Inner::Http(_) => (),
            }

            socks::connect(proxy, dst, dns).await.map(|tcp| Conn {
                inner: self.verbose.wrap(TokioIo::new(tcp)),
                is_proxy: false,
                tls_info: false,
            })
        }

        async fn connect_with_maybe_proxy(self, dst: Uri, is_proxy: bool) -> Result<Conn, BoxError> {
            match self.inner {
                #[cfg(not(feature = "__tls"))]
                Inner::Http(mut http) => {
                    let io = http.call(dst).await?;
                    Ok(Conn {
                        inner: self.verbose.wrap(io),
                        is_proxy,
                        tls_info: false,
                    })
                }
                #[cfg(feature = "default-tls")]
                Inner::DefaultTls(http, tls) => {
                    let mut http = http.clone();

                    // Disable Nagle's algorithm for TLS handshake
                    //
                    // https://www.openssl.org/docs/man1.1.1/man3/SSL_connect.html#NOTES
                    if !self.nodelay && (dst.scheme() == Some(&Scheme::HTTPS)) {
                        http.set_nodelay(true);
                    }

                    let tls_connector = tokio_native_tls::TlsConnector::from(tls.clone());
                    let mut http = hyper_tls::HttpsConnector::from((http, tls_connector));
                    let io = http.call(dst).await?;

                    if let hyper_tls::MaybeHttpsStream::Https(stream) = io {
                        if !self.nodelay {
                            stream
                                .inner()
                                .get_ref()
                                .get_ref()
                                .get_ref()
                                .inner()
                                .inner()
                                .set_nodelay(false)?;
                        }
                        Ok(Conn {
                            inner: self.verbose.wrap(NativeTlsConn { inner: stream }),
                            is_proxy,
                            tls_info: self.tls_info,
                        })
                    } else {
                        Ok(Conn {
                            inner: self.verbose.wrap(io),
                            is_proxy,
                            tls_info: false,
                        })
                    }
                }
                #[cfg(feature = "__rustls")]
                Inner::RustlsTls { http, tls, .. } => {
                    let mut http = http.clone();

                    // Disable Nagle's algorithm for TLS handshake
                    //
                    // https://www.openssl.org/docs/man1.1.1/man3/SSL_connect.html#NOTES
                    if !self.nodelay && (dst.scheme() == Some(&Scheme::HTTPS)) {
                        http.set_nodelay(true);
                    }

                    let mut http = hyper_rustls::HttpsConnector::from((http, tls.clone()));
                    let io = http.call(dst).await?;

                    if let hyper_rustls::MaybeHttpsStream::Https(stream) = io {
                        if !self.nodelay {
                            let (io, _) = stream.inner().get_ref();
                            io.inner().inner().set_nodelay(false)?;
                        }
                        Ok(Conn {
                            inner: self.verbose.wrap(RustlsTlsConn { inner: stream }),
                            is_proxy,
                            tls_info: self.tls_info,
                        })
                    } else {
                        Ok(Conn {
                            inner: self.verbose.wrap(io),
                            is_proxy,
                            tls_info: false,
                        })
                    }
                }
            }
        }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the code handle establishing a connection through a SOCKS proxy for HTTPS requests?
  codeQuestion3: What steps are taken to configure and use the TLS connector for secure connections in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    async fn connect_via_proxy(
            self,
            dst: Uri,
            proxy_scheme: ProxyScheme,
        ) -> Result<Conn, BoxError> {
            log::debug!("proxy({proxy_scheme:?}) intercepts '{dst:?}'");

            let (proxy_dst, _auth) = match proxy_scheme {
                ProxyScheme::Http { host, auth } => (into_uri(Scheme::HTTP, host), auth),
                ProxyScheme::Https { host, auth } => (into_uri(Scheme::HTTPS, host), auth),
                #[cfg(feature = "socks")]
                ProxyScheme::Socks4 { .. } => return self.connect_socks(dst, proxy_scheme).await,
                #[cfg(feature = "socks")]
                ProxyScheme::Socks5 { .. } => return self.connect_socks(dst, proxy_scheme).await,
            };

            #[cfg(feature = "__tls")]
            let auth = _auth;

            match &self.inner {
                #[cfg(feature = "default-tls")]
                Inner::DefaultTls(http, tls) => {
                    if dst.scheme() == Some(&Scheme::HTTPS) {
                        let host = dst.host().to_owned();
                        let port = dst.port().map(|p| p.as_u16()).unwrap_or(443);
                        let http = http.clone();
                        let tls_connector = tokio_native_tls::TlsConnector::from(tls.clone());
                        let mut http = hyper_tls::HttpsConnector::from((http, tls_connector));
                        let conn = http.call(proxy_dst).await?;
                        log::trace!("tunneling HTTPS over proxy");
                        let tunneled = tunnel(
                            conn,
                            host.ok_or("no host in url")?.to_string(),
                            port,
                            self.user_agent.clone(),
                            auth,
                        )
                        .await?;
                        let tls_connector = tokio_native_tls::TlsConnector::from(tls.clone());
                        let io = tls_connector
                            .connect(host.ok_or("no host in url")?, TokioIo::new(tunneled))
                            .await?;
                        return Ok(Conn {
                            inner: self.verbose.wrap(NativeTlsConn {
                                inner: TokioIo::new(io),
                            }),
                            is_proxy: false,
                            tls_info: false,
                        });
                    }
                }
                #[cfg(feature = "__rustls")]
                Inner::RustlsTls {
                    http,
                    tls,
                    tls_proxy,
                } => {
                    if dst.scheme() == Some(&Scheme::HTTPS) {
                        use rustls_pki_types::ServerName;
                        use std::convert::TryFrom;
                        use tokio_rustls::TlsConnector as RustlsConnector;

                        let host = dst.host().ok_or("no host in url")?.to_string();
                        let port = dst.port().map(|r| r.as_u16()).unwrap_or(443);
                        let http = http.clone();
                        let mut http = hyper_rustls::HttpsConnector::from((http, tls_proxy.clone()));
                        let tls = tls.clone();
                        let conn = http.call(proxy_dst).await?;
                        log::trace!("tunneling HTTPS over proxy");
                        let maybe_server_name = ServerName::try_from(host.as_str().to_owned())
                            .map_err(|_| "Invalid Server Name");
                        let tunneled = tunnel(conn, host, port, self.user_agent.clone(), auth).await?;
                        let server_name = maybe_server_name?;
                        let io = RustlsConnector::from(tls)
                            .connect(server_name, TokioIo::new(tunneled))
                            .await?;

                        return Ok(Conn {
                            inner: self.verbose.wrap(RustlsTlsConn {
                                inner: TokioIo::new(io),
                            }),
                            is_proxy: false,
                            tls_info: false,
                        });
                    }
                }
                #[cfg(not(feature = "__tls"))]
                Inner::Http(_) => (),
            }

            self.connect_with_maybe_proxy(proxy_dst, true).await
        }
    }

    fn into_uri(scheme: Scheme, host: Authority) -> Uri {
        // TODO: Should the `http` crate get `From<(Scheme, Authority)> for Uri`?
        http::Uri::builder()
            .scheme(scheme)
            .authority(host)
            .path_and_query(http::uri::PathAndQuery::from_static("/"))
            .build()
            .expect("scheme and authority is valid Uri")
    }

    async fn with_timeout<T, F>(f: F, timeout: Option<Duration>) -> Result<T, BoxError>
    where
        F: Future<Output = Result<T, BoxError>>,
    {
        if let Some(to) = timeout {
            match tokio::time::timeout(to, f).await {
                Err(_elapsed) => Err(Box::new(crate::error::TimedOut) as BoxError),
                Ok(Ok(try_res)) => Ok(try_res),
                Ok(Err(e)) => Err(e),
            }
        } else {
            f.await
        }
    }

    impl Service<Uri> for ConnectorService {
        type Response = Conn;
        type Error = BoxError;
        type Future = Connecting;

        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }

        fn call(&mut self, dst: Uri) -> Self::Future {
            log::debug!("starting new connection: {dst:?}");
            let timeout = self.simple_timeout;
            for prox in self.proxies.iter() {
                if let Some(proxy_scheme) = prox.intercept(&dst) {
                    return Box::pin(with_timeout(
                        self.clone().connect_via_proxy(dst, proxy_scheme),
                        timeout,
                    ));
                }
            }

            Box::pin(with_timeout(
                self.clone().connect_with_maybe_proxy(dst, false),
                timeout,
            ))
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `connect_via_proxy` function handle different proxy schemes, and what is an example of using it with HTTP and HTTPS proxies?
  codeQuestion3: What steps are taken in the `into_uri` function to construct a URI from a scheme and host authority?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__tls")]
    trait TlsInfoFactory {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo>;
    }

    #[cfg(feature = "__tls")]
    impl TlsInfoFactory for tokio::net::TcpStream {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            None
        }
    }

    #[cfg(feature = "__tls")]
    impl<T: TlsInfoFactory> TlsInfoFactory for TokioIo<T> {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            self.inner().tls_info()
        }
    }

    #[cfg(feature = "default-tls")]
    impl TlsInfoFactory for tokio_native_tls::TlsStream<TokioIo<TokioIo<tokio::net::TcpStream>>> {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            let peer_certificate = self
                .get_ref()
                .peer_certificate()
                .ok()
                .flatten()
                .and_then(|c| c.to_der().ok());
            Some(crate::tls::TlsInfo { peer_certificate })
        }
    }

    #[cfg(feature = "default-tls")]
    impl TlsInfoFactory
        for tokio_native_tls::TlsStream<
            TokioIo<hyper_tls::MaybeHttpsStream<TokioIo<tokio::net::TcpStream>>>,
        >
    {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            let peer_certificate = self
                .get_ref()
                .peer_certificate()
                .ok()
                .flatten()
                .and_then(|c| c.to_der().ok());
            Some(crate::tls::TlsInfo { peer_certificate })
        }
    }

    #[cfg(feature = "default-tls")]
    impl TlsInfoFactory for hyper_tls::MaybeHttpsStream<TokioIo<tokio::net::TcpStream>> {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            match self {
                hyper_tls::MaybeHttpsStream::Https(tls) => tls.tls_info(),
                hyper_tls::MaybeHttpsStream::Http(_) => None,
            }
        }
    }

    #[cfg(feature = "__rustls")]
    impl TlsInfoFactory for tokio_rustls::client::TlsStream<TokioIo<TokioIo<tokio::net::TcpStream>>> {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            let peer_certificate = self
                .get_ref()
                .1
                .peer_certificates()
                .and_then(|certs| certs.first())
                .map(|c| c.to_vec());
            Some(crate::tls::TlsInfo { peer_certificate })
        }
    }

    #[cfg(feature = "__rustls")]
    impl TlsInfoFactory
        for tokio_rustls::client::TlsStream<
            TokioIo<hyper_rustls::MaybeHttpsStream<TokioIo<tokio::net::TcpStream>>>,
        >
    {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            let peer_certificate = self
                .get_ref()
                .1
                .peer_certificates()
                .and_then(|certs| certs.first())
                .map(|c| c.to_vec());
            Some(crate::tls::TlsInfo { peer_certificate })
        }
    }

    #[cfg(feature = "__rustls")]
    impl TlsInfoFactory for hyper_rustls::MaybeHttpsStream<TokioIo<tokio::net::TcpStream>> {
        fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
            match self {
                hyper_rustls::MaybeHttpsStream::Https(tls) => tls.tls_info(),
                hyper_rustls::MaybeHttpsStream::Http(_) => None,
            }
        }
    }

    pub(crate) trait AsyncConn:
        Read + Write + Connection + Send + Sync + Unpin + 'static
    {
    }

    impl<T: Read + Write + Connection + Send + Sync + Unpin + 'static> AsyncConn for T {}

    #[cfg(feature = "__tls")]
    trait AsyncConnWithInfo: AsyncConn + TlsInfoFactory {}
    #[cfg(not(feature = "__tls"))]
    trait AsyncConnWithInfo: AsyncConn {}

    #[cfg(feature = "__tls")]
    impl<T: AsyncConn + TlsInfoFactory> AsyncConnWithInfo for T {}
    #[cfg(not(feature = "__tls"))]
    impl<T: AsyncConn> AsyncConnWithInfo for T {}

    type BoxConn = Box<dyn AsyncConnWithInfo>;

    pub(crate) mod sealed {
        use super::*;
        #[derive(Debug)]
        pub struct Unnameable(pub(super) Uri);

        pin_project! {
            /// Note: the `is_proxy` member means *is plain text HTTP proxy*.
            /// This tells hyper whether the URI should be written in
            /// * origin-form (`GET /just/a/path HTTP/1.1`), when `is_proxy == false`, or
            /// * absolute-form (`GET http://foo.bar/and/a/path HTTP/1.1`), otherwise.
            #[allow(missing_debug_implementations)]
            pub struct Conn {
                #[pin]
                pub(super)inner: BoxConn,
                pub(super) is_proxy: bool,
                // Only needed for __tls, but #[cfg()] on fields breaks pin_project!
                pub(super) tls_info: bool,
            }
        }

        impl Connection for Conn {
            fn connected(&self) -> Connected {
                let connected = self.inner.connected().proxy(self.is_proxy);
                #[cfg(feature = "__tls")]
                if self.tls_info {
                    if let Some(tls_info) = self.inner.tls_info() {
                        connected.extra(tls_info)
                    } else {
                        connected
                    }
                } else {
                    connected
                }
                #[cfg(not(feature = "__tls"))]
                connected
            }
        }

        impl Read for Conn {
            fn poll_read(
                self: Pin<&mut Self>,
                cx: &mut Context,
                buf: ReadBufCursor<'_>,
            ) -> Poll<io::Result<()>> {
                let this = self.project();
                Read::poll_read(this.inner, cx, buf)
            }
        }

        impl Write for Conn {
            fn poll_write(
                self: Pin<&mut Self>,
                cx: &mut Context,
                buf: &[u8],
            ) -> Poll<Result<usize, io::Error>> {
                let this = self.project();
                Write::poll_write(this.inner, cx, buf)
            }

            fn poll_write_vectored(
                self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                bufs: &[IoSlice<'_>],
            ) -> Poll<Result<usize, io::Error>> {
                let this = self.project();
                Write::poll_write_vectored(this.inner, cx, bufs)
            }

            fn is_write_vectored(&self) -> bool {
                self.inner.is_write_vectored()
            }

            fn poll_flush(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Result<(), io::Error>> {
                let this = self.project();
                Write::poll_flush(this.inner, cx)
            }

            fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Result<(), io::Error>> {
                let this = self.project();
                Write::poll_shutdown(this.inner, cx)
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user retrieve TLS information from a hyper connection, and what system calls or APIs are involved in this process?
  codeQuestion3: What steps are taken to ensure that the connection object supports TLS information retrieval, and how is this integrated with the hyper framework?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    pub(crate) type Connecting = Pin<Box<dyn Future<Output = Result<Conn, BoxError>> + Send>>;

    #[cfg(feature = "__tls")]
    async fn tunnel<T>(
        mut conn: T,
        host: String,
        port: u16,
        user_agent: Option<HeaderValue>,
        auth: Option<HeaderValue>,
    ) -> Result<T, BoxError>
    where
        T: Read + Write + Unpin,
    {
        use hyper_util::rt::TokioIo;
        use tokio::io::{AsyncReadExt, AsyncWriteExt};

        let mut buf = format!(
            "\
             CONNECT {host}:{port} HTTP/1.1\r\n\
             Host: {host}:{port}\r\n\
             "
        )
        .into_bytes();

        // user-agent
        if let Some(user_agent) = user_agent {
            buf.extend_from_slice(b"User-Agent: ");
            buf.extend_from_slice(user_agent.as_bytes());
            buf.extend_from_slice(b"\r\n");
        }

        // proxy-authorization
        if let Some(value) = auth {
            log::debug!("tunnel to {host}:{port} using basic auth");
            buf.extend_from_slice(b"Proxy-Authorization: ");
            buf.extend_from_slice(value.as_bytes());
            buf.extend_from_slice(b"\r\n");
        }

        // headers end
        buf.extend_from_slice(b"\r\n");

        let mut tokio_conn = TokioIo::new(&mut conn);

        tokio_conn.write_all(&buf).await?;

        let mut buf = [0; 8192];
        let mut pos = 0;

        loop {
            let n = tokio_conn.read(&mut buf[pos..]).await?;

            if n == 0 {
                return Err(tunnel_eof());
            }
            pos += n;

            let recvd = &buf[..pos];
            if recvd.starts_with(b"HTTP/1.1 200") || recvd.starts_with(b"HTTP/1.0 200") {
                if recvd.ends_with(b"\r\n\r\n") {
                    return Ok(conn);
                }
                if pos == buf.len() {
                    return Err("proxy headers too long for tunnel".into());
                }
            // else read more
            } else if recvd.starts_with(b"HTTP/1.1 407") {
                return Err("proxy authentication required".into());
            } else {
                return Err("unsuccessful tunnel".into());
            }
        }
    }

    #[cfg(feature = "__tls")]
    fn tunnel_eof() -> BoxError {
        "unexpected eof while tunneling".into()
    }

    #[cfg(feature = "default-tls")]
    mod native_tls_conn {
        use super::TlsInfoFactory;
        use hyper::rt::{Read, ReadBufCursor, Write};
        use hyper_tls::MaybeHttpsStream;
        use hyper_util::client::legacy::connect::{Connected, Connection};
        use hyper_util::rt::TokioIo;
        use pin_project_lite::pin_project;
        use std::{
            io::{self, IoSlice},
            pin::Pin,
            task::{Context, Poll},
        };
        use tokio::io::{AsyncRead, AsyncWrite};
        use tokio::net::TcpStream;
        use tokio_native_tls::TlsStream;

        pin_project! {
            pub(super) struct NativeTlsConn<T> {
                #[pin] pub(super) inner: TokioIo<TlsStream<T>>,
            }
        }

        impl Connection for NativeTlsConn<TokioIo<TokioIo<TcpStream>>> {
            fn connected(&self) -> Connected {
                let connected = self
                    .inner
                    .inner()
                    .get_ref()
                    .get_ref()
                    .get_ref()
                    .inner()
                    .connected();
                #[cfg(feature = "native-tls-alpn")]
                match self.inner.inner().get_ref().negotiated_alpn().ok() {
                    Some(Some(alpn_protocol)) if alpn_protocol == b"h2" => connected.negotiated_h2(),
                    _ => connected,
                }
                #[cfg(not(feature = "native-tls-alpn"))]
                connected
            }
        }

        impl Connection for NativeTlsConn<TokioIo<MaybeHttpsStream<TokioIo<TcpStream>>>> {
            fn connected(&self) -> Connected {
                let connected = self
                    .inner
                    .inner()
                    .get_ref()
                    .get_ref()
                    .get_ref()
                    .inner()
                    .connected();
                #[cfg(feature = "native-tls-alpn")]
                match self.inner.inner().get_ref().negotiated_alpn().ok() {
                    Some(Some(alpn_protocol)) if alpn_protocol == b"h2" => connected.negotiated_h2(),
                    _ => connected,
                }
                #[cfg(not(feature = "native-tls-alpn"))]
                connected
            }
        }

        impl<T: AsyncRead + AsyncWrite + Unpin> Read for NativeTlsConn<T> {
            fn poll_read(
                self: Pin<&mut Self>,
                cx: &mut Context,
                buf: ReadBufCursor<'_>,
            ) -> Poll<tokio::io::Result<()>> {
                let this = self.project();
                Read::poll_read(this.inner, cx, buf)
            }
        }

        impl<T: AsyncRead + AsyncWrite + Unpin> Write for NativeTlsConn<T> {
            fn poll_write(
                self: Pin<&mut Self>,
                cx: &mut Context,
                buf: &[u8],
            ) -> Poll<Result<usize, tokio::io::Error>> {
                let this = self.project();
                Write::poll_write(this.inner, cx, buf)
            }

            fn poll_write_vectored(
                self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                bufs: &[IoSlice<'_>],
            ) -> Poll<Result<usize, io::Error>> {
                let this = self.project();
                Write::poll_write_vectored(this.inner, cx, bufs)
            }

            fn is_write_vectored(&self) -> bool {
                self.inner.is_write_vectored()
            }

            fn poll_flush(
                self: Pin<&mut Self>,
                cx: &mut Context,
            ) -> Poll<Result<(), tokio::io::Error>> {
                let this = self.project();
                Write::poll_flush(this.inner, cx)
            }

            fn poll_shutdown(
                self: Pin<&mut Self>,
                cx: &mut Context,
            ) -> Poll<Result<(), tokio::io::Error>> {
                let this = self.project();
                Write::poll_shutdown(this.inner, cx)
            }
        }

        impl<T> TlsInfoFactory for NativeTlsConn<T>
        where
            TokioIo<TlsStream<T>>: TlsInfoFactory,
        {
            fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
                self.inner.tls_info()
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `tunnel` function handle proxy authentication and what is the process for establishing a secure connection through the proxy?
  codeQuestion3: What steps are involved in creating and managing a TLS connection using the `native_tls_conn` module?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__rustls")]
    mod rustls_tls_conn {
        use super::TlsInfoFactory;
        use hyper::rt::{Read, ReadBufCursor, Write};
        use hyper_rustls::MaybeHttpsStream;
        use hyper_util::client::legacy::connect::{Connected, Connection};
        use hyper_util::rt::TokioIo;
        use pin_project_lite::pin_project;
        use std::{
            io::{self, IoSlice},
            pin::Pin,
            task::{Context, Poll},
        };
        use tokio::io::{AsyncRead, AsyncWrite};
        use tokio::net::TcpStream;
        use tokio_rustls::client::TlsStream;

        pin_project! {
            pub(super) struct RustlsTlsConn<T> {
                #[pin] pub(super) inner: TokioIo<TlsStream<T>>,
            }
        }

        impl Connection for RustlsTlsConn<TokioIo<TokioIo<TcpStream>>> {
            fn connected(&self) -> Connected {
                if self.inner.inner().get_ref().1.alpn_protocol() == Some(b"h2") {
                    self.inner
                        .inner()
                        .get_ref()
                        .0
                        .inner()
                        .connected()
                        .negotiated_h2()
                } else {
                    self.inner.inner().get_ref().0.inner().connected()
                }
            }
        }
        impl Connection for RustlsTlsConn<TokioIo<MaybeHttpsStream<TokioIo<TcpStream>>>> {
            fn connected(&self) -> Connected {
                if self.inner.inner().get_ref().1.alpn_protocol() == Some(b"h2") {
                    self.inner
                        .inner()
                        .get_ref()
                        .0
                        .inner()
                        .connected()
                        .negotiated_h2()
                } else {
                    self.inner.inner().get_ref().0.inner().connected()
                }
            }
        }

        impl<T: AsyncRead + AsyncWrite + Unpin> Read for RustlsTlsConn<T> {
            fn poll_read(
                self: Pin<&mut Self>,
                cx: &mut Context,
                buf: ReadBufCursor<'_>,
            ) -> Poll<tokio::io::Result<()>> {
                let this = self.project();
                Read::poll_read(this.inner, cx, buf)
            }
        }

        impl<T: AsyncRead + AsyncWrite + Unpin> Write for RustlsTlsConn<T> {
            fn poll_write(
                self: Pin<&mut Self>,
                cx: &mut Context,
                buf: &[u8],
            ) -> Poll<Result<usize, tokio::io::Error>> {
                let this = self.project();
                Write::poll_write(this.inner, cx, buf)
            }

            fn poll_write_vectored(
                self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                bufs: &[IoSlice<'_>],
            ) -> Poll<Result<usize, io::Error>> {
                let this = self.project();
                Write::poll_write_vectored(this.inner, cx, bufs)
            }

            fn is_write_vectored(&self) -> bool {
                self.inner.is_write_vectored()
            }

            fn poll_flush(
                self: Pin<&mut Self>,
                cx: &mut Context,
            ) -> Poll<Result<(), tokio::io::Error>> {
                let this = self.project();
                Write::poll_flush(this.inner, cx)
            }

            fn poll_shutdown(
                self: Pin<&mut Self>,
                cx: &mut Context,
            ) -> Poll<Result<(), tokio::io::Error>> {
                let this = self.project();
                Write::poll_shutdown(this.inner, cx)
            }
        }
        impl<T> TlsInfoFactory for RustlsTlsConn<T>
        where
            TokioIo<TlsStream<T>>: TlsInfoFactory,
        {
            fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
                self.inner.tls_info()
            }
        }
    }

    #[cfg(feature = "socks")]
    mod socks {
        use std::io;

        use http::Uri;
        use tokio::net::TcpStream;
        use tokio_socks::tcp::{Socks4Stream, Socks5Stream};

        use super::{BoxError, Scheme};
        use crate::proxy::ProxyScheme;

        pub(super) enum DnsResolve {
            Local,
            Proxy,
        }

        pub(super) async fn connect(
            proxy: ProxyScheme,
            dst: Uri,
            dns: DnsResolve,
        ) -> Result<TcpStream, BoxError> {
            let https = dst.scheme() == Some(&Scheme::HTTPS);
            let original_host = dst
                .host()
                .ok_or(io::Error::new(io::ErrorKind::Other, "no host in url"))?;
            let mut host = original_host.to_owned();
            let port = match dst.port() {
                Some(p) => p.as_u16(),
                None if https => 443u16,
                _ => 80u16,
            };

            if let DnsResolve::Local = dns {
                let maybe_new_target = tokio::net::lookup_host((host.as_str(), port)).await?.next();
                if let Some(new_target) = maybe_new_target {
                    host = new_target.ip().to_string();
                }
            }

            match proxy {
                ProxyScheme::Socks4 { addr, .. } => {
                    let stream = Socks4Stream::connect(addr, (host.as_str(), port))
                        .await
                        .map_err(|e| format!("socks connect error: {e}"))?;
                    Ok(stream.into_inner())
                }
                ProxyScheme::Socks5 { addr, ref auth, .. } => {
                    let stream = if let Some((username, password)) = auth {
                        Socks5Stream::connect_with_password(
                            addr,
                            (host.as_str(), port),
                            &username,
                            &password,
                        )
                        .await
                        .map_err(|e| format!("socks connect error: {e}"))?
                    } else {
                        Socks5Stream::connect(addr, (host.as_str(), port))
                            .await
                            .map_err(|e| format!("socks connect error: {e}"))?
                    };

                    Ok(stream.into_inner())
                }
                _ => unreachable!(),
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle establishing a secure connection through an SOCKS proxy, and what system calls are involved in this process?
  codeQuestion3: What steps are taken to handle TLS information retrieval for the connection, and how is it integrated with the hyper framework?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    mod verbose {
        use hyper::rt::{Read, ReadBufCursor, Write};
        use hyper_util::client::legacy::connect::{Connected, Connection};
        use std::cmp::min;
        use std::fmt;
        use std::io::{self, IoSlice};
        use std::pin::Pin;
        use std::task::{Context, Poll};

        pub(super) const OFF: Wrapper = Wrapper(false);

        #[derive(Clone, Copy)]
        pub(super) struct Wrapper(pub(super) bool);

        impl Wrapper {
            pub(super) fn wrap<T: super::AsyncConnWithInfo>(&self, conn: T) -> super::BoxConn {
                if self.0 && log::log_enabled!(log::Level::Trace) {
                    Box::new(Verbose {
                        // truncate is fine
                        id: crate::util::fast_random() as u32,
                        inner: conn,
                    })
                } else {
                    Box::new(conn)
                }
            }
        }

        struct Verbose<T> {
            id: u32,
            inner: T,
        }

        impl<T: Connection + Read + Write + Unpin> Connection for Verbose<T> {
            fn connected(&self) -> Connected {
                self.inner.connected()
            }
        }

        impl<T: Read + Write + Unpin> Read for Verbose<T> {
            fn poll_read(
                mut self: Pin<&mut Self>,
                cx: &mut Context,
                mut buf: ReadBufCursor<'_>,
            ) -> Poll<std::io::Result<()>> {
                // TODO: This _does_ forget the `init` len, so it could result in
                // re-initializing twice. Needs upstream support, perhaps.
                // SAFETY: Passing to a ReadBuf will never de-initialize any bytes.
                let mut vbuf = hyper::rt::ReadBuf::uninit(unsafe { buf.as_mut() });
                match Pin::new(&mut self.inner).poll_read(cx, vbuf.unfilled()) {
                    Poll::Ready(Ok(())) => {
                        log::trace!("{:08x} read: {:?}", self.id, Escape(vbuf.filled()));
                        let len = vbuf.filled().len();
                        // SAFETY: The two cursors were for the same buffer. What was
                        // filled in one is safe in the other.
                        unsafe {
                            buf.advance(len);
                        }
                        Poll::Ready(Ok(()))
                    }
                    Poll::Ready(Err(e)) => Poll::Ready(Err(e)),
                    Poll::Pending => Poll::Pending,
                }
            }
        }

        impl<T: Read + Write + Unpin> Write for Verbose<T> {
            fn poll_write(
                mut self: Pin<&mut Self>,
                cx: &mut Context,
                buf: &[u8],
            ) -> Poll<Result<usize, std::io::Error>> {
                match Pin::new(&mut self.inner).poll_write(cx, buf) {
                    Poll::Ready(Ok(n)) => {
                        log::trace!("{:08x} write: {:?}", self.id, Escape(&buf[..n]));
                        Poll::Ready(Ok(n))
                    }
                    Poll::Ready(Err(e)) => Poll::Ready(Err(e)),
                    Poll::Pending => Poll::Pending,
                }
            }

            fn poll_write_vectored(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                bufs: &[IoSlice<'_>],
            ) -> Poll<Result<usize, io::Error>> {
                match Pin::new(&mut self.inner).poll_write_vectored(cx, bufs) {
                    Poll::Ready(Ok(nwritten)) => {
                        log::trace!(
                            "{:08x} write (vectored): {:?}",
                            self.id,
                            Vectored { bufs, nwritten }
                        );
                        Poll::Ready(Ok(nwritten))
                    }
                    Poll::Ready(Err(e)) => Poll::Ready(Err(e)),
                    Poll::Pending => Poll::Pending,
                }
            }

            fn is_write_vectored(&self) -> bool {
                self.inner.is_write_vectored()
            }

            fn poll_flush(
                mut self: Pin<&mut Self>,
                cx: &mut Context,
            ) -> Poll<Result<(), std::io::Error>> {
                Pin::new(&mut self.inner).poll_flush(cx)
            }

            fn poll_shutdown(
                mut self: Pin<&mut Self>,
                cx: &mut Context,
            ) -> Poll<Result<(), std::io::Error>> {
                Pin::new(&mut self.inner).poll_shutdown(cx)
            }
        }

        #[cfg(feature = "__tls")]
        impl<T: super::TlsInfoFactory> super::TlsInfoFactory for Verbose<T> {
            fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
                self.inner.tls_info()
            }
        }

        struct Escape<'a>(&'a [u8]);

        impl fmt::Debug for Escape<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "b\"")?;
                for &c in self.0 {
                    // https://doc.rust-lang.org/reference.html#byte-escapes
                    if c == b'\n' {
                        write!(f, "\\n")?;
                    } else if c == b'\r' {
                        write!(f, "\\r")?;
                    } else if c == b'\t' {
                        write!(f, "\\t")?;
                    } else if c == b'\\' || c == b'"' {
                        write!(f, "\\{}", c as char)?;
                    } else if c == b'\0' {
                        write!(f, "\\0")?;
                    // ASCII printable
                    } else if c >= 0x20 && c < 0x7f {
                        write!(f, "{}", c as char)?;
                    } else {
                        write!(f, "\\x{c:02x}")?;
                    }
                }
                write!(f, "\"")?;
                Ok(())
            }
        }

        struct Vectored<'a, 'b> {
            bufs: &'a [IoSlice<'b>],
            nwritten: usize,
        }

        impl fmt::Debug for Vectored<'_, '_> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                let mut left = self.nwritten;
                for buf in self.bufs.iter() {
                    if left == 0 {
                        break;
                    }
                    let n = min(left, buf.len());
                    Escape(&buf[..n]).fmt(f)?;
                    left -= n;
                }
                Ok(())
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle user input for a game after losing and what system calls are involved in processing this input?
  codeQuestion3: What steps are taken to configure terminal settings for the game and how are they utilized in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/connect.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__tls")]
    #[cfg(test)]
    mod tests {
        use super::tunnel;
        use crate::proxy;
        use hyper_util::rt::TokioIo;
        use std::io::{Read, Write};
        use std::net::TcpListener;
        use std::thread;
        use tokio::net::TcpStream;
        use tokio::runtime;

        static TUNNEL_UA: &str = "tunnel-test/x.y";
        static TUNNEL_OK: &[u8] = b"\
            HTTP/1.1 200 OK\r\n\
            \r\n\
        ";

        macro_rules! mock_tunnel {
            () => {{
                mock_tunnel!(TUNNEL_OK)
            }};
            ($write:expr) => {{
                mock_tunnel!($write, "")
            }};
            ($write:expr, $auth:expr) => {{
                let listener = TcpListener::bind("127.0.0.1:0").unwrap();
                let addr = listener.local_addr().unwrap();
                let connect_expected = format!(
                    "\
                     CONNECT {0}:{1} HTTP/1.1\r\n\
                     Host: {0}:{1}\r\n\
                     User-Agent: {2}\r\n\
                     {3}\
                     \r\n\
                     ",
                    addr.ip(),
                    addr.port(),
                    TUNNEL_UA,
                    $auth
                )
                .into_bytes();

                thread::spawn(move || {
                    let (mut sock, _) = listener.accept().unwrap();
                    let mut buf = [0u8; 4096];
                    let n = sock.read(&mut buf).unwrap();
                    assert_eq!(&buf[..n], &connect_expected[..]);

                    sock.write_all($write).unwrap();
                });
                addr
            }};
        }

        fn ua() -> Option<http::header::HeaderValue> {
            Some(http::header::HeaderValue::from_static(TUNNEL_UA))
        }

        #[test]
        fn test_tunnel() {
            let addr = mock_tunnel!();

            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let f = async move {
                let tcp = TokioIo::new(TcpStream::connect(&addr).await?);
                let host = addr.ip().to_string();
                let port = addr.port();
                tunnel(tcp, host, port, ua(), None).await
            };

            rt.block_on(f).unwrap();
        }

        #[test]
        fn test_tunnel_eof() {
            let addr = mock_tunnel!(b"HTTP/1.1 200 OK");

            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let f = async move {
                let tcp = TokioIo::new(TcpStream::connect(&addr).await?);
                let host = addr.ip().to_string();
                let port = addr.port();
                tunnel(tcp, host, port, ua(), None).await
            };

            rt.block_on(f).unwrap_err();
        }

        #[test]
        fn test_tunnel_non_http_response() {
            let addr = mock_tunnel!(b"foo bar baz hallo");

            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let f = async move {
                let tcp = TokioIo::new(TcpStream::connect(&addr).await?);
                let host = addr.ip().to_string();
                let port = addr.port();
                tunnel(tcp, host, port, ua(), None).await
            };

            rt.block_on(f).unwrap_err();
        }

        #[test]
        fn test_tunnel_proxy_unauthorized() {
            let addr = mock_tunnel!(
                b"\
                HTTP/1.1 407 Proxy Authentication Required\r\n\
                Proxy-Authenticate: Basic realm=\"nope\"\r\n\
                \r\n\
            "
            );

            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let f = async move {
                let tcp = TokioIo::new(TcpStream::connect(&addr).await?);
                let host = addr.ip().to_string();
                let port = addr.port();
                tunnel(tcp, host, port, ua(), None).await
            };

            let error = rt.block_on(f).unwrap_err();
            assert_eq!(error.to_string(), "proxy authentication required");
        }

        #[test]
        fn test_tunnel_basic_auth() {
            let addr = mock_tunnel!(
                TUNNEL_OK,
                "Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\r\n"
            );

            let rt = runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .expect("new rt");
            let f = async move {
                let tcp = TokioIo::new(TcpStream::connect(&addr).await?);
                let host = addr.ip().to_string();
                let port = addr.port();
                tunnel(
                    tcp,
                    host,
                    port,
                    ua(),
                    Some(proxy::encode_basic_auth("Aladdin", "open sesame")),
                )
                .await
            };

            rt.block_on(f).unwrap();
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `mock_tunnel` macro simulate a tunnel server for testing purposes, and what system calls or APIs are involved in setting up the server?
  codeQuestion3: What steps are taken to handle proxy authentication in the `test_tunnel_proxy_unauthorized` test case, and how is the authorization header processed?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::fmt;

    use bytes::Bytes;
    use http::{HeaderMap, StatusCode};
    use js_sys::Uint8Array;
    use url::Url;

    use crate::wasm::AbortGuard;

    #[cfg(feature = "stream")]
    use wasm_bindgen::JsCast;

    #[cfg(feature = "stream")]
    use futures_util::stream::{self, StreamExt};

    #[cfg(feature = "json")]
    use serde::de::DeserializeOwned;

    /// A Response to a submitted `Request`.
    pub struct Response {
        http: http::Response<web_sys::Response>,
        _abort: AbortGuard,
        // Boxed to save space (11 words to 1 word), and it's not accessed
        // frequently internally.
        url: Box<Url>,
    }

    impl Response {
        pub(super) fn new(
            res: http::Response<web_sys::Response>,
            url: Url,
            abort: AbortGuard,
        ) -> Response {
            Response {
                http: res,
                url: Box::new(url),
                _abort: abort,
            }
        }

        /// Get the `StatusCode` of this `Response`.
        #[inline]
        pub fn status(&self) -> StatusCode {
            self.http.status()
        }

        /// Get the `Headers` of this `Response`.
        #[inline]
        pub fn headers(&self) -> &HeaderMap {
            self.http.headers()
        }

        /// Get a mutable reference to the `Headers` of this `Response`.
        #[inline]
        pub fn headers_mut(&mut self) -> &mut HeaderMap {
            self.http.headers_mut()
        }

        /// Get the content-length of this response, if known.
        ///
        /// Reasons it may not be known:
        ///
        /// - The server didn't send a `content-length` header.
        /// - The response is compressed and automatically decoded (thus changing
        ///   the actual decoded length).
        pub fn content_length(&self) -> Option<u64> {
            self.headers()
                .get(http::header::CONTENT_LENGTH)?
                .to_str()
                .ok()?
                .parse()
                .ok()
        }

        /// Get the final `Url` of this `Response`.
        #[inline]
        pub fn url(&self) -> &Url {
            &self.url
        }

        /* It might not be possible to detect this in JS?
        /// Get the HTTP `Version` of this `Response`.
        #[inline]
        pub fn version(&self) -> Version {
            self.http.version()
        }
        */

        /// Try to deserialize the response body as JSON.
        #[cfg(feature = "json")]
        #[cfg_attr(docsrs, doc(cfg(feature = "json")))]
        pub async fn json<T: DeserializeOwned>(self) -> crate::Result<T> {
            let full = self.bytes().await?;

            serde_json::from_slice(&full).map_err(crate::error::decode)
        }

        /// Get the response text.
        pub async fn text(self) -> crate::Result<String> {
            let p = self
                .http
                .body()
                .text()
                .map_err(crate::error::wasm)
                .map_err(crate::error::decode)?;
            let js_val = super::promise::<wasm_bindgen::JsValue>(p)
                .await
                .map_err(crate::error::decode)?;
            if let Some(s) = js_val.as_string() {
                Ok(s)
            } else {
                Err(crate::error::decode("response.text isn't string"))
            }
        }

        /// Get the response as bytes
        pub async fn bytes(self) -> crate::Result<Bytes> {
            let p = self
                .http
                .body()
                .array_buffer()
                .map_err(crate::error::wasm)
                .map_err(crate::error::decode)?;

            let buf_js = super::promise::<wasm_bindgen::JsValue>(p)
                .await
                .map_err(crate::error::decode)?;

            let buffer = Uint8Array::new(&buf_js);
            let mut bytes = vec![0; buffer.length() as usize];
            buffer.copy_to(&mut bytes);
            Ok(bytes.into())
        }

        /// Convert the response into a `Stream` of `Bytes` from the body.
        #[cfg(feature = "stream")]
        pub fn bytes_stream(self) -> impl futures_core::Stream<Item = crate::Result<Bytes>> {
            use futures_core::Stream;
            use std::pin::Pin;

            let web_response = self.http.into_body();
            let abort = self._abort;

            if let Some(body) = web_response.body() {
                let body = wasm_streams::ReadableStream::from_raw(body.unchecked_into());
                Box::pin(body.into_stream().map(move |buf_js| {
                    // Keep the abort guard alive as long as this stream is.
                    let _abort = &abort;
                    let buffer = Uint8Array::new(
                        &buf_js
                            .map_err(crate::error::wasm)
                            .map_err(crate::error::decode)?,
                    );
                    let mut bytes = vec![0; buffer.length() as usize];
                    buffer.copy_to(&mut bytes);
                    Ok(bytes.into())
                })) as Pin<Box<dyn Stream<Item = crate::Result<Bytes>>>>
            } else {
                // If there's no body, return an empty stream.
                Box::pin(stream::empty()) as Pin<Box<dyn Stream<Item = crate::Result<Bytes>>>>
            }
        }

        // util methods

        /// Turn a response into an error if the server returned an error.
        pub fn error_for_status(self) -> crate::Result<Self> {
            let status = self.status();
            if status.is_client_error() || status.is_server_error() {
                Err(crate::error::status_code(*self.url, status))
            } else {
                Ok(self)
            }
        }

        /// Turn a reference to a response into an error if the server returned an error.
        pub fn error_for_status_ref(&self) -> crate::Result<&Self> {
            let status = self.status();
            if status.is_client_error() || status.is_server_error() {
                Err(crate::error::status_code(*self.url.clone(), status))
            } else {
                Ok(self)
            }
        }
    }
    ```
  codeQuestion1: What is the primary purpose of this Rust code?
  codeQuestion2: How does the `json<T>` method deserialize the response body, and what dependencies are required for this functionality?
  codeQuestion3: What is the role of the `bytes_stream` method, and how does it handle reading data from the response body as a stream?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/response.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Response {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Response")
                //.field("url", self.url())
                .field("status", &self.status())
                .field("headers", self.headers())
                .finish()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `fmt::Debug` implementation for `Response` enable debugging of HTTP responses in the Hyper project?
  codeQuestion3: What is the role of the `headers()` method in the `fmt::Debug` implementation for `Response`?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::convert::TryFrom;
    use std::fmt;
    use std::time::Duration;

    use bytes::Bytes;
    use http::{request::Parts, Method, Request as HttpRequest};
    use serde::Serialize;
    #[cfg(feature = "json")]
    use serde_json;
    use url::Url;
    use web_sys::RequestCredentials;

    use super::{Body, Client, Response};
    use crate::header::{HeaderMap, HeaderName, HeaderValue, CONTENT_TYPE};

    /// A request which can be executed with `Client::execute()`.
    pub struct Request {
        method: Method,
        url: Url,
        headers: HeaderMap,
        body: Option<Body>,
        timeout: Option<Duration>,
        pub(super) cors: bool,
        pub(super) credentials: Option<RequestCredentials>,
    }

    /// A builder to construct the properties of a `Request`.
    pub struct RequestBuilder {
        client: Client,
        request: crate::Result<Request>,
    }

    impl Request {
        /// Constructs a new request.
        #[inline]
        pub fn new(method: Method, url: Url) -> Self {
            Request {
                method,
                url,
                headers: HeaderMap::new(),
                body: None,
                timeout: None,
                cors: true,
                credentials: None,
            }
        }

        /// Get the method.
        #[inline]
        pub fn method(&self) -> &Method {
            &self.method
        }

        /// Get a mutable reference to the method.
        #[inline]
        pub fn method_mut(&mut self) -> &mut Method {
            &mut self.method
        }

        /// Get the url.
        #[inline]
        pub fn url(&self) -> &Url {
            &self.url
        }

        /// Get a mutable reference to the url.
        #[inline]
        pub fn url_mut(&mut self) -> &mut Url {
            &mut self.url
        }

        /// Get the headers.
        #[inline]
        pub fn headers(&self) -> &HeaderMap {
            &self.headers
        }

        /// Get a mutable reference to the headers.
        #[inline]
        pub fn headers_mut(&mut self) -> &mut HeaderMap {
            &mut self.headers
        }

        /// Get the body.
        #[inline]
        pub fn body(&self) -> Option<&Body> {
            self.body.as_ref()
        }

        /// Get a mutable reference to the body.
        #[inline]
        pub fn body_mut(&mut self) -> &mut Option<Body> {
            &mut self.body
        }

        /// Get the timeout.
        #[inline]
        pub fn timeout(&self) -> Option<&Duration> {
            self.timeout.as_ref()
        }

        /// Get a mutable reference to the timeout.
        #[inline]
        pub fn timeout_mut(&mut self) -> &mut Option<Duration> {
            &mut self.timeout
        }

        /// Attempts to clone the `Request`.
        ///
        /// None is returned if a body is which can not be cloned.
        pub fn try_clone(&self) -> Option<Request> {
            let body = match self.body.as_ref() {
                Some(body) => Some(body.try_clone()?),
                None => None,
            };

            Some(Self {
                method: self.method.clone(),
                url: self.url.clone(),
                headers: self.headers.clone(),
                body,
                timeout: self.timeout,
                cors: self.cors,
                credentials: self.credentials,
            })
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer set a custom header in a request using this code?
  codeQuestion3: What is the process for creating a new request with a specific URL and method, and how does it handle the body?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl RequestBuilder
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user set a custom header for an HTTP request using this code?
  codeQuestion3: What steps are involved in sending an HTTP request with the given code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    {
        pub(super) fn new(client: Client, request: crate::Result<Request>) -> RequestBuilder {
            RequestBuilder { client, request }
        }

        /// Assemble a builder starting from an existing `Client` and a `Request`.
        pub fn from_parts(client: crate::Client, request: crate::Request) -> crate::RequestBuilder {
            crate::RequestBuilder {
                client,
                request: crate::Result::Ok(request),
            }
        }

        /// Modify the query string of the URL.
        ///
        /// Modifies the URL of this request, adding the parameters provided.
        /// This method appends and does not overwrite. This means that it can
        /// be called multiple times and that existing query parameters are not
        /// overwritten if the same key is used. The key will simply show up
        /// twice in the query string.
        /// Calling `.query([("foo", "a"), ("foo", "b")])` gives `"foo=a&foo=b"`.
        ///
        /// # Note
        /// This method does not support serializing a single key-value
        /// pair. Instead of using `.query(("key", "val"))`, use a sequence, such
        /// as `.query(&[("key", "val")])`. It's also possible to serialize structs
        /// and maps into a key-value pair.
        ///
        /// # Errors
        /// This method will fail if the object you provide cannot be serialized
        /// into a query string.
        pub fn query<T: Serialize + ?Sized>(mut self, query: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                let url = req.url_mut();
                let mut pairs = url.query_pairs_mut();
                let serializer = serde_urlencoded::Serializer::new(&mut pairs);

                if let Err(err) = query.serialize(serializer) {
                    error = Some(crate::error::builder(err));
                }
            }
            if let Ok(ref mut req) = self.request {
                if let Some("") = req.url().query() {
                    req.url_mut().set_query(None);
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Send a form body.
        ///
        /// Sets the body to the url encoded serialization of the passed value,
        /// and also sets the `Content-Type: application/x-www-form-urlencoded`
        /// header.
        ///
        /// # Errors
        ///
        /// This method fails if the passed value cannot be serialized into
        /// url encoded format
        pub fn form<T: Serialize + ?Sized>(mut self, form: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match serde_urlencoded::to_string(form) {
                    Ok(body) => {
                        req.headers_mut().insert(
                            CONTENT_TYPE,
                            HeaderValue::from_static("application/x-www-form-urlencoded"),
                        );
                        *req.body_mut() = Some(body.into());
                    }
                    Err(err) => error = Some(crate::error::builder(err)),
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        #[cfg(feature = "json")]
        #[cfg_attr(docsrs, doc(cfg(feature = "json")))]
        /// Set the request json
        pub fn json<T: Serialize + ?Sized>(mut self, json: &T) -> RequestBuilder {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match serde_json::to_vec(json) {
                    Ok(body) => {
                        req.headers_mut()
                            .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
                        *req.body_mut() = Some(body.into());
                    }
                    Err(err) => error = Some(crate::error::builder(err)),
                }
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Enable HTTP basic authentication.
        pub fn basic_auth<U, P>(self, username: U, password: Option<P>) -> RequestBuilder
        where
            U: fmt::Display,
            P: fmt::Display,
        {
            let header_value = crate::util::basic_auth(username, password);
            self.header(crate::header::AUTHORIZATION, header_value)
        }

        /// Enable HTTP bearer authentication.
        pub fn bearer_auth<T>(self, token: T) -> RequestBuilder
        where
            T: fmt::Display,
        {
            let header_value = format!("Bearer {token}");
            self.header(crate::header::AUTHORIZATION, header_value)
        }

        /// Set the request body.
        pub fn body<T: Into<Body>>(mut self, body: T) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                req.body = Some(body.into());
            }
            self
        }

        /// Enables a request timeout.
        pub fn timeout(mut self, timeout: Duration) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                *req.timeout_mut() = Some(timeout);
            }
            self
        }

        /// TODO
        #[cfg(feature = "multipart")]
        #[cfg_attr(docsrs, doc(cfg(feature = "multipart")))]
        pub fn multipart(mut self, multipart: super::multipart::Form) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                *req.body_mut() = Some(Body::from_form(multipart))
            }
            self
        }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `query` method handle adding query parameters to a request, and what is an example of its usage?
  codeQuestion3: What are the steps involved in setting up a request with form data, and how is that implemented in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    /// Add a `Header` to this Request.
        pub fn header<K, V>(mut self, key: K, value: V) -> RequestBuilder
        where
            HeaderName: TryFrom<K>,
            <HeaderName as TryFrom<K>>::Error: Into<http::Error>,
            HeaderValue: TryFrom<V>,
            <HeaderValue as TryFrom<V>>::Error: Into<http::Error>,
        {
            let mut error = None;
            if let Ok(ref mut req) = self.request {
                match <HeaderName as TryFrom<K>>::try_from(key) {
                    Ok(key) => match <HeaderValue as TryFrom<V>>::try_from(value) {
                        Ok(value) => {
                            req.headers_mut().append(key, value);
                        }
                        Err(e) => error = Some(crate::error::builder(e.into())),
                    },
                    Err(e) => error = Some(crate::error::builder(e.into())),
                };
            }
            if let Some(err) = error {
                self.request = Err(err);
            }
            self
        }

        /// Add a set of Headers to the existing ones on this Request.
        ///
        /// The headers will be merged in to any already set.
        pub fn headers(mut self, headers: crate::header::HeaderMap) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                crate::util::replace_headers(req.headers_mut(), headers);
            }
            self
        }

        /// Disable CORS on fetching the request.
        ///
        /// # WASM
        ///
        /// This option is only effective with WebAssembly target.
        ///
        /// The [request mode][mdn] will be set to 'no-cors'.
        ///
        /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/Request/mode
        pub fn fetch_mode_no_cors(mut self) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                req.cors = false;
            }
            self
        }

        /// Set fetch credentials to 'same-origin'
        ///
        /// # WASM
        ///
        /// This option is only effective with WebAssembly target.
        ///
        /// The [request credentials][mdn] will be set to 'same-origin'.
        ///
        /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
        pub fn fetch_credentials_same_origin(mut self) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                req.credentials = Some(RequestCredentials::SameOrigin);
            }
            self
        }

        /// Set fetch credentials to 'include'
        ///
        /// # WASM
        ///
        /// This option is only effective with WebAssembly target.
        ///
        /// The [request credentials][mdn] will be set to 'include'.
        ///
        /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
        pub fn fetch_credentials_include(mut self) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                req.credentials = Some(RequestCredentials::Include);
            }
            self
        }

        /// Set fetch credentials to 'omit'
        ///
        /// # WASM
        ///
        /// This option is only effective with WebAssembly target.
        ///
        /// The [request credentials][mdn] will be set to 'omit'.
        ///
        /// [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
        pub fn fetch_credentials_omit(mut self) -> RequestBuilder {
            if let Ok(ref mut req) = self.request {
                req.credentials = Some(RequestCredentials::Omit);
            }
            self
        }

        /// Build a `Request`, which can be inspected, modified and executed with
        /// `Client::execute()`.
        pub fn build(self) -> crate::Result<Request> {
            self.request
        }

        /// Build a `Request`, which can be inspected, modified and executed with
        /// `Client::execute()`.
        ///
        /// This is similar to [`RequestBuilder::build()`], but also returns the
        /// embedded `Client`.
        pub fn build_split(self) -> (Client, crate::Result<Request>) {
            (self.client, self.request)
        }

        /// Constructs the Request and sends it to the target URL, returning a
        /// future Response.
        ///
        /// # Errors
        ///
        /// This method fails if there was an error while sending request.
        ///
        /// # Example
        ///
        /// ```no_run
        /// # use reqwest::Error;
        /// #
        /// # async fn run() -> Result<(), Error> {
        /// let response = reqwest::Client::new()
        ///     .get("https://hyper.rs")
        ///     .send()
        ///     .await?;
        /// # Ok(())
        /// # }
        /// ```
        pub async fn send(self) -> crate::Result<Response> {
            let req = self.request?;
            self.client.execute_request(req).await
        }

        /// Attempt to clone the RequestBuilder.
        ///
        /// `None` is returned if the RequestBuilder can not be cloned.
        ///
        /// # Examples
        ///
        /// ```no_run
        /// # use reqwest::Error;
        /// #
        /// # fn run() -> Result<(), Error> {
        /// let client = reqwest::Client::new();
        /// let builder = client.post("http://httpbin.org/post")
        ///     .body("from a &str!");
        /// let clone = builder.try_clone();
        /// assert!(clone.is_some());
        /// # Ok(())
        /// # }
        /// ```
        pub fn try_clone(&self) -> Option<RequestBuilder> {
            self.request
                .as_ref()
                .ok()
                .and_then(|req| req.try_clone())
                .map(|req| RequestBuilder {
                    client: self.client.clone(),
                    request: Ok(req),
                })
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer add multiple headers to a request using the API, and what is an example of this usage?
  codeQuestion3: What steps are involved in building and sending a request using the API, including handling potential errors?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/request.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Request {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            fmt_request_fields(&mut f.debug_struct("Request"), self).finish()
        }
    }

    impl fmt::Debug for RequestBuilder {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut builder = f.debug_struct("RequestBuilder");
            match self.request {
                Ok(ref req) => fmt_request_fields(&mut builder, req).finish(),
                Err(ref err) => builder.field("error", err).finish(),
            }
        }
    }

    fn fmt_request_fields<'a, 'b>(
        f: &'a mut fmt::DebugStruct<'a, 'b>,
        req: &Request,
    ) -> &'a mut fmt::DebugStruct<'a, 'b> {
        f.field("method", &req.method)
            .field("url", &req.url)
            .field("headers", &req.headers)
    }

    impl<T> TryFrom<HttpRequest<T>> for Request
    where
        T: Into<Body>,
    {
        type Error = crate::Error;

        fn try_from(req: HttpRequest<T>) -> crate::Result<Self> {
            let (parts, body) = req.into_parts();
            let Parts {
                method,
                uri,
                headers,
                ..
            } = parts;
            let url = Url::parse(&uri.to_string()).map_err(crate::error::builder)?;
            Ok(Request {
                method,
                url,
                headers,
                body: Some(body.into()),
                timeout: None,
                cors: true,
                credentials: None,
            })
        }
    }

    impl TryFrom<Request> for HttpRequest<Body> {
        type Error = crate::Error;

        fn try_from(req: Request) -> crate::Result<Self> {
            let Request {
                method,
                url,
                headers,
                body,
                ..
            } = req;

            let mut req = HttpRequest::builder()
                .method(method)
                .uri(url.as_str())
                .body(body.unwrap_or_else(|| Body::from(Bytes::default())))
                .map_err(crate::error::builder)?;

            *req.headers_mut() = headers;
            Ok(req)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `fmt::Debug` implementation for `RequestBuilder` handle errors during formatting?
  codeQuestion3: What is the process for converting between `HttpRequest<T>` and `Request`, and how are errors handled during this conversion?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use http::header::USER_AGENT;
    use http::{HeaderMap, HeaderValue, Method};
    use js_sys::{Promise, JSON};
    use std::convert::TryInto;
    use std::{fmt, future::Future, sync::Arc};
    use url::Url;
    use wasm_bindgen::prelude::{wasm_bindgen, UnwrapThrowExt as _};

    use super::{AbortGuard, Request, RequestBuilder, Response};
    use crate::IntoUrl;

    #[wasm_bindgen]
    extern "C" {
        #[wasm_bindgen(js_name = fetch)]
        fn fetch_with_request(input: &web_sys::Request) -> Promise;
    }

    fn js_fetch(req: &web_sys::Request) -> Promise {
        use wasm_bindgen::{JsCast, JsValue};
        let global = js_sys::global();

        if let Ok(true) = js_sys::Reflect::has(&global, &JsValue::from_str("ServiceWorkerGlobalScope"))
        {
            global
                .unchecked_into::<web_sys::ServiceWorkerGlobalScope>()
                .fetch_with_request(req)
        } else {
            // browser
            fetch_with_request(req)
        }
    }

    /// dox
    #[derive(Clone)]
    pub struct Client {
        config: Arc<Config>,
    }

    /// dox
    pub struct ClientBuilder {
        config: Config,
    }

    impl Client {
        /// dox
        pub fn new() -> Self {
            Client::builder().build().unwrap_throw()
        }

        /// dox
        pub fn builder() -> ClientBuilder {
            ClientBuilder::new()
        }

        /// Convenience method to make a `GET` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn get<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::GET, url)
        }

        /// Convenience method to make a `POST` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn post<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::POST, url)
        }

        /// Convenience method to make a `PUT` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn put<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::PUT, url)
        }

        /// Convenience method to make a `PATCH` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn patch<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::PATCH, url)
        }

        /// Convenience method to make a `DELETE` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn delete<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::DELETE, url)
        }

        /// Convenience method to make a `HEAD` request to a URL.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn head<U: IntoUrl>(&self, url: U) -> RequestBuilder {
            self.request(Method::HEAD, url)
        }

        /// Start building a `Request` with the `Method` and `Url`.
        ///
        /// Returns a `RequestBuilder`, which will allow setting headers and
        /// request body before sending.
        ///
        /// # Errors
        ///
        /// This method fails whenever supplied `Url` cannot be parsed.
        pub fn request<U: IntoUrl>(&self, method: Method, url: U) -> RequestBuilder {
            let req = url.into_url().map(move |url| Request::new(method, url));
            RequestBuilder::new(self.clone(), req)
        }

        /// Executes a `Request`.
        ///
        /// A `Request` can be built manually with `Request::new()` or obtained
        /// from a RequestBuilder with `RequestBuilder::build()`.
        ///
        /// You should prefer to use the `RequestBuilder` and
        /// `RequestBuilder::send()`.
        ///
        /// # Errors
        ///
        /// This method fails if there was an error while sending request,
        /// redirect loop was detected or redirect limit was exhausted.
        pub fn execute(
            &self,
            request: Request,
        ) -> impl Future<Output = Result<Response, crate::Error>> {
            self.execute_request(request)
        }

        // merge request headers with Client default_headers, prior to external http fetch
        fn merge_headers(&self, req: &mut Request) {
            use http::header::Entry;
            let headers: &mut HeaderMap = req.headers_mut();
            // insert default headers in the request headers
            // without overwriting already appended headers.
            for (key, value) in self.config.headers.iter() {
                if let Entry::Vacant(entry) = headers.entry(key) {
                    entry.insert(value.clone());
                }
            }
        }

        pub(super) fn execute_request(
            &self,
            mut req: Request,
        ) -> impl Future<Output = crate::Result<Response>> {
            self.merge_headers(&mut req);
            fetch(req)
        }
    }

    impl Default for Client {
        fn default() -> Self {
            Self::new()
        }
    }

    impl fmt::Debug for Client {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut builder = f.debug_struct("Client");
            self.config.fmt_fields(&mut builder);
            builder.finish()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Client` struct handle request headers and what is the role of the `merge_headers` method?
  codeQuestion3: What system calls or API functions are used in the `js_fetch` function to perform a network request?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/client.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for ClientBuilder {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut builder = f.debug_struct("ClientBuilder");
            self.config.fmt_fields(&mut builder);
            builder.finish()
        }
    }

    // Can use new methods in web-sys when requiring v0.2.93.
    // > `init.method(m)` to `init.set_method(m)`
    // For now, ignore their deprecation.
    #[allow(deprecated)]
    async fn fetch(req: Request) -> crate::Result<Response> {
        // Build the js Request
        let mut init = web_sys::RequestInit::new();
        init.method(req.method().as_str());

        // convert HeaderMap to Headers
        let js_headers = web_sys::Headers::new()
            .map_err(crate::error::wasm)
            .map_err(crate::error::builder)?;

        for (name, value) in req.headers() {
            js_headers
                .append(
                    name.as_str(),
                    value.to_str().map_err(crate::error::builder)?,
                )
                .map_err(crate::error::wasm)
                .map_err(crate::error::builder)?;
        }
        init.headers(&js_headers.into());

        // When req.cors is true, do nothing because the default mode is 'cors'
        if !req.cors {
            init.mode(web_sys::RequestMode::NoCors);
        }

        if let Some(creds) = req.credentials {
            init.credentials(creds);
        }

        if let Some(body) = req.body() {
            if !body.is_empty() {
                init.body(Some(body.to_js_value()?.as_ref()));
            }
        }

        let mut abort = AbortGuard::new()?;
        if let Some(timeout) = req.timeout() {
            abort.timeout(*timeout);
        }
        init.signal(Some(&abort.signal()));

        let js_req = web_sys::Request::new_with_str_and_init(req.url().as_str(), &init)
            .map_err(crate::error::wasm)
            .map_err(crate::error::builder)?;

        // Await the fetch() promise
        let p = js_fetch(&js_req);
        let js_resp = super::promise::<web_sys::Response>(p)
            .await
            .map_err(|error| {
                if error.to_string() == "JsValue(\"reqwest::errors::TimedOut\")" {
                    crate::error::TimedOut.into()
                } else {
                    error
                }
            })
            .map_err(crate::error::request)?;

        // Convert from the js Response
        let mut resp = http::Response::builder().status(js_resp.status());

        let url = Url::parse(&js_resp.url()).expect_throw("url parse");

        let js_headers = js_resp.headers();
        let js_iter = js_sys::try_iter(&js_headers)
            .expect_throw("headers try_iter")
            .expect_throw("headers have an iterator");

        for item in js_iter {
            let item = item.expect_throw("headers iterator doesn't throw");
            let serialized_headers: String = JSON::stringify(&item)
                .expect_throw("serialized headers")
                .into();
            let [name, value]: [String; 2] = serde_json::from_str(&serialized_headers)
                .expect_throw("deserializable serialized headers");
            resp = resp.header(&name, &value);
        }

        resp.body(js_resp)
            .map(|resp| Response::new(resp, url, abort))
            .map_err(crate::error::request)
    }

    // ===== impl ClientBuilder =====

    impl ClientBuilder {
        /// dox
        pub fn new() -> Self {
            ClientBuilder {
                config: Config::default(),
            }
        }

        /// Returns a 'Client' that uses this ClientBuilder configuration
        pub fn build(mut self) -> Result<Client, crate::Error> {
            if let Some(err) = self.config.error {
                return Err(err);
            }

            let config = std::mem::take(&mut self.config);
            Ok(Client {
                config: Arc::new(config),
            })
        }

        /// Sets the `User-Agent` header to be used by this client.
        pub fn user_agent<V>(mut self, value: V) -> ClientBuilder
        where
            V: TryInto<HeaderValue>,
            V::Error: Into<http::Error>,
        {
            match value.try_into() {
                Ok(value) => {
                    self.config.headers.insert(USER_AGENT, value);
                }
                Err(e) => {
                    self.config.error = Some(crate::error::builder(e.into()));
                }
            }
            self
        }

        /// Sets the default headers for every request
        pub fn default_headers(mut self, headers: HeaderMap) -> ClientBuilder {
            for (key, value) in headers.iter() {
                self.config.headers.insert(key, value.clone());
            }
            self
        }
    }

    impl Default for ClientBuilder {
        fn default() -> Self {
            Self::new()
        }
    }

    #[derive(Debug)]
    struct Config {
        headers: HeaderMap,
        error: Option<crate::Error>,
    }

    impl Default for Config {
        fn default() -> Config {
            Config {
                headers: HeaderMap::new(),
                error: None,
            }
        }
    }

    impl Config {
        fn fmt_fields(&self, f: &mut fmt::DebugStruct<'_, '_>) {
            f.field("default_headers", &self.headers);
        }
    }

    #[cfg(test)]
    mod tests {
        use wasm_bindgen_test::*;

        wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);

        #[wasm_bindgen_test]
        async fn default_headers() {
            use crate::header::{HeaderMap, HeaderValue, CONTENT_TYPE};

            let mut headers = HeaderMap::new();
            headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
            headers.insert("x-custom", HeaderValue::from_static("flibbertigibbet"));
            let client = crate::Client::builder()
                .default_headers(headers)
                .build()
                .expect("client");
            let mut req = client
                .get("https://www.example.com")
                .build()
                .expect("request");
            // merge headers as if client were about to issue fetch
            client.merge_headers(&mut req);

            let test_headers = req.headers();
            assert!(test_headers.get(CONTENT_TYPE).is_some(), "content-type");
            assert!(test_headers.get("x-custom").is_some(), "custom header");
            assert!(test_headers.get("accept").is_none(), "no accept header");
        }

        #[wasm_bindgen_test]
        async fn default_headers_clone() {
            use crate::header::{HeaderMap, HeaderValue, CONTENT_TYPE};

            let mut headers = HeaderMap::new();
            headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
            headers.insert("x-custom", HeaderValue::from_static("flibbertigibbet"));
            let client = crate::Client::builder()
                .default_headers(headers)
                .build()
                .expect("client");

            let mut req = client
                .get("https://www.example.com")
                .header(CONTENT_TYPE, "text/plain")
                .build()
                .expect("request");
            client.merge_headers(&mut req);
            let headers1 = req.headers();

            // confirm that request headers override defaults
            assert_eq!(
                headers1.get(CONTENT_TYPE).unwrap(),
                "text/plain",
                "request headers override defaults"
            );

            // confirm that request headers don't change client defaults
            let mut req2 = client
                .get("https://www.example.com/x")
                .build()
                .expect("req 2");
            client.merge_headers(&mut req2);
            let headers2 = req2.headers();
            assert_eq!(
                headers2.get(CONTENT_TYPE).unwrap(),
                "application/json",
                "request headers don't change client defaults"
            );
        }

        #[wasm_bindgen_test]
        fn user_agent_header() {
            use crate::header::USER_AGENT;

            let client = crate::Client::builder()
                .user_agent("FooBar/1.2.3")
                .build()
                .expect("client");

            let mut req = client
                .get("https://www.example.com")
                .build()
                .expect("request");

            // Merge the client headers with the request's one.
            client.merge_headers(&mut req);
            let headers1 = req.headers();

            // Confirm that we have the `User-Agent` header set
            assert_eq!(
                headers1.get(USER_AGENT).unwrap(),
                "FooBar/1.2.3",
                "The user-agent header was not set: {req:#?}"
            );

            // Now we try to overwrite the `User-Agent` value

            let mut req2 = client
                .get("https://www.example.com")
                .header(USER_AGENT, "Another-User-Agent/42")
                .build()
                .expect("request 2");

            client.merge_headers(&mut req2);
            let headers2 = req2.headers();

            assert_eq!(
                headers2.get(USER_AGENT).expect("headers2 user agent"),
                "Another-User-Agent/42",
                "Was not able to overwrite the User-Agent value on the request-builder"
            );
        }
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How does the `fetch` function handle headers when making a request, and can you provide an example of converting Rust headers to WebAssembly-compatible headers?
  codeQuestion3: What is the role of the `ClientBuilder` struct and how are default headers managed within it?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/body.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "multipart")]
    use super::multipart::Form;
    /// dox
    use bytes::Bytes;
    use js_sys::Uint8Array;
    use std::{borrow::Cow, fmt};
    use wasm_bindgen::JsValue;

    /// The body of a `Request`.
    ///
    /// In most cases, this is not needed directly, as the
    /// [`RequestBuilder.body`][builder] method uses `Into<Body>`, which allows
    /// passing many things (like a string or vector of bytes).
    ///
    /// [builder]: ./struct.RequestBuilder.html#method.body
    pub struct Body {
        inner: Inner,
    }

    enum Inner {
        Single(Single),
        /// MultipartForm holds a multipart/form-data body.
        #[cfg(feature = "multipart")]
        MultipartForm(Form),
    }

    #[derive(Clone)]
    pub(crate) enum Single {
        Bytes(Bytes),
        Text(Cow<'static, str>),
    }

    impl Single {
        fn as_bytes(&self) -> &[u8] {
            match self {
                Single::Bytes(bytes) => bytes.as_ref(),
                Single::Text(text) => text.as_bytes(),
            }
        }

        pub(crate) fn to_js_value(&self) -> JsValue {
            match self {
                Single::Bytes(bytes) => {
                    let body_bytes: &[u8] = bytes.as_ref();
                    let body_uint8_array: Uint8Array = body_bytes.into();
                    let js_value: &JsValue = body_uint8_array.as_ref();
                    js_value.to_owned()
                }
                Single::Text(text) => JsValue::from_str(text),
            }
        }

        fn is_empty(&self) -> bool {
            match self {
                Single::Bytes(bytes) => bytes.is_empty(),
                Single::Text(text) => text.is_empty(),
            }
        }
    }

    impl Body {
        /// Returns a reference to the internal data of the `Body`.
        ///
        /// `None` is returned, if the underlying data is a multipart form.
        #[inline]
        pub fn as_bytes(&self) -> Option<&[u8]> {
            match &self.inner {
                Inner::Single(single) => Some(single.as_bytes()),
                #[cfg(feature = "multipart")]
                Inner::MultipartForm(_) => None,
            }
        }

        pub(crate) fn to_js_value(&self) -> crate::Result<JsValue> {
            match &self.inner {
                Inner::Single(single) => Ok(single.to_js_value()),
                #[cfg(feature = "multipart")]
                Inner::MultipartForm(form) => {
                    let form_data = form.to_form_data()?;
                    let js_value: &JsValue = form_data.as_ref();
                    Ok(js_value.to_owned())
                }
            }
        }

        #[cfg(feature = "multipart")]
        pub(crate) fn as_single(&self) -> Option<&Single> {
            match &self.inner {
                Inner::Single(single) => Some(single),
                Inner::MultipartForm(_) => None,
            }
        }

        #[inline]
        #[cfg(feature = "multipart")]
        pub(crate) fn from_form(f: Form) -> Body {
            Self {
                inner: Inner::MultipartForm(f),
            }
        }

        /// into_part turns a regular body into the body of a multipart/form-data part.
        #[cfg(feature = "multipart")]
        pub(crate) fn into_part(self) -> Body {
            match self.inner {
                Inner::Single(single) => Self {
                    inner: Inner::Single(single),
                },
                Inner::MultipartForm(form) => Self {
                    inner: Inner::MultipartForm(form),
                },
            }
        }

        pub(crate) fn is_empty(&self) -> bool {
            match &self.inner {
                Inner::Single(single) => single.is_empty(),
                #[cfg(feature = "multipart")]
                Inner::MultipartForm(form) => form.is_empty(),
            }
        }

        pub(crate) fn try_clone(&self) -> Option<Body> {
            match &self.inner {
                Inner::Single(single) => Some(Self {
                    inner: Inner::Single(single.clone()),
                }),
                #[cfg(feature = "multipart")]
                Inner::MultipartForm(_) => None,
            }
        }
    }

    impl From<Bytes> for Body {
        #[inline]
        fn from(bytes: Bytes) -> Body {
            Body {
                inner: Inner::Single(Single::Bytes(bytes)),
            }
        }
    }

    impl From<Vec<u8>> for Body {
        #[inline]
        fn from(vec: Vec<u8>) -> Body {
            Body {
                inner: Inner::Single(Single::Bytes(vec.into())),
            }
        }
    }

    impl From<&'static [u8]> for Body {
        #[inline]
        fn from(s: &'static [u8]) -> Body {
            Body {
                inner: Inner::Single(Single::Bytes(Bytes::from_static(s))),
            }
        }
    }

    impl From<String> for Body {
        #[inline]
        fn from(s: String) -> Body {
            Body {
                inner: Inner::Single(Single::Text(s.into())),
            }
        }
    }

    impl From<&'static str> for Body {
        #[inline]
        fn from(s: &'static str) -> Body {
            Body {
                inner: Inner::Single(Single::Text(s.into())),
            }
        }
    }

    impl fmt::Debug for Body {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Body").finish()
        }
    }

    // Can use new methods in web-sys when requiring v0.2.93.
    // > `init.method(m)` to `init.set_method(m)`
    // For now, ignore their deprecation.
    #[allow(deprecated)]
    #[cfg(test)]
    mod tests {
        use crate::Body;
        use js_sys::Uint8Array;
        use wasm_bindgen::prelude::*;
        use wasm_bindgen_test::*;

        wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);

        #[wasm_bindgen]
        extern "C" {
            // Use `js_namespace` here to bind `console.log(..)` instead of just
            // `log(..)`
            #[wasm_bindgen(js_namespace = console)]
            fn log(s: String);
        }

        #[wasm_bindgen_test]
        async fn test_body() {
            let body = Body::from("TEST");
            assert_eq!([84, 69, 83, 84], body.as_bytes().unwrap());
        }

        #[wasm_bindgen_test]
        async fn test_body_js_static_str() {
            let body_value = "TEST";
            let body = Body::from(body_value);

            let mut init = web_sys::RequestInit::new();
            init.method("POST");
            init.body(Some(
                body.to_js_value()
                    .expect("could not convert body to JsValue")
                    .as_ref(),
            ));

            let js_req = web_sys::Request::new_with_str_and_init("", &init)
                .expect("could not create JS request");
            let text_promise = js_req.text().expect("could not get text promise");
            let text = crate::wasm::promise::<JsValue>(text_promise)
                .await
                .expect("could not get request body as text");

            assert_eq!(text.as_string().expect("text is not a string"), body_value);
        }
        #[wasm_bindgen_test]
        async fn test_body_js_string() {
            let body_value = "TEST".to_string();
            let body = Body::from(body_value.clone());

            let mut init = web_sys::RequestInit::new();
            init.method("POST");
            init.body(Some(
                body.to_js_value()
                    .expect("could not convert body to JsValue")
                    .as_ref(),
            ));

            let js_req = web_sys::Request::new_with_str_and_init("", &init)
                .expect("could not create JS request");
            let text_promise = js_req.text().expect("could not get text promise");
            let text = crate::wasm::promise::<JsValue>(text_promise)
                .await
                .expect("could not get request body as text");

            assert_eq!(text.as_string().expect("text is not a string"), body_value);
        }

        #[wasm_bindgen_test]
        async fn test_body_js_static_u8_slice() {
            let body_value: &'static [u8] = b"\x00\x42";
            let body = Body::from(body_value);

            let mut init = web_sys::RequestInit::new();
            init.method("POST");
            init.body(Some(
                body.to_js_value()
                    .expect("could not convert body to JsValue")
                    .as_ref(),
            ));

            let js_req = web_sys::Request::new_with_str_and_init("", &init)
                .expect("could not create JS request");

            let array_buffer_promise = js_req
                .array_buffer()
                .expect("could not get array_buffer promise");
            let array_buffer = crate::wasm::promise::<JsValue>(array_buffer_promise)
                .await
                .expect("could not get request body as array buffer");

            let v = Uint8Array::new(&array_buffer).to_vec();

            assert_eq!(v, body_value);
        }

        #[wasm_bindgen_test]
        async fn test_body_js_vec_u8() {
            let body_value = vec![0u8, 42];
            let body = Body::from(body_value.clone());

            let mut init = web_sys::RequestInit::new();
            init.method("POST");
            init.body(Some(
                body.to_js_value()
                    .expect("could not convert body to JsValue")
                    .as_ref(),
            ));

            let js_req = web_sys::Request::new_with_str_and_init("", &init)
                .expect("could not create JS request");

            let array_buffer_promise = js_req
                .array_buffer()
                .expect("could not get array_buffer promise");
            let array_buffer = crate::wasm::promise::<JsValue>(array_buffer_promise)
                .await
                .expect("could not get request body as array buffer");

            let v = Uint8Array::new(&array_buffer).to_vec();

            assert_eq!(v, body_value);
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user convert a string into a `Body` object and what APIs are used in this process?
  codeQuestion3: What steps are taken to convert a `Body` object into a JavaScript value for use in HTTP requests?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! multipart/form-data
    use std::borrow::Cow;
    use std::fmt;

    use http::HeaderMap;
    use mime_guess::Mime;
    use web_sys::FormData;

    use super::Body;

    /// An async multipart/form-data request.
    pub struct Form {
        inner: FormParts<Part>,
    }

    impl Form {
        pub(crate) fn is_empty(&self) -> bool {
            self.inner.fields.is_empty()
        }
    }

    /// A field in a multipart form.
    pub struct Part {
        meta: PartMetadata,
        value: Body,
    }

    pub(crate) struct FormParts<P> {
        pub(crate) fields: Vec<(Cow<'static, str>, P)>,
    }

    pub(crate) struct PartMetadata {
        mime: Option<Mime>,
        file_name: Option<Cow<'static, str>>,
        pub(crate) headers: HeaderMap,
    }

    pub(crate) trait PartProps {
        fn metadata(&self) -> &PartMetadata;
    }

    // ===== impl Form =====

    impl Default for Form {
        fn default() -> Self {
            Self::new()
        }
    }

    impl Form {
        /// Creates a new async Form without any content.
        pub fn new() -> Form {
            Form {
                inner: FormParts::new(),
            }
        }

        /// Add a data field with supplied name and value.
        ///
        /// # Examples
        ///
        /// ```
        /// let form = reqwest::multipart::Form::new()
        ///     .text("username", "seanmonstar")
        ///     .text("password", "secret");
        /// ```
        pub fn text<T, U>(self, name: T, value: U) -> Form
        where
            T: Into<Cow<'static, str>>,
            U: Into<Cow<'static, str>>,
        {
            self.part(name, Part::text(value))
        }

        /// Adds a customized Part.
        pub fn part<T>(self, name: T, part: Part) -> Form
        where
            T: Into<Cow<'static, str>>,
        {
            self.with_inner(move |inner| inner.part(name, part))
        }

        fn with_inner<F>(self, func: F) -> Self
        where
            F: FnOnce(FormParts<Part>) -> FormParts<Part>,
        {
            Form {
                inner: func(self.inner),
            }
        }

        pub(crate) fn to_form_data(&self) -> crate::Result<FormData> {
            let form = FormData::new()
                .map_err(crate::error::wasm)
                .map_err(crate::error::builder)?;

            for (name, part) in self.inner.fields.iter() {
                part.append_to_form(name, &form)
                    .map_err(crate::error::wasm)
                    .map_err(crate::error::builder)?;
            }
            Ok(form)
        }
    }

    impl fmt::Debug for Form {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.inner.fmt_fields("Form", f)
        }
    }

    // ===== impl Part =====

    impl Part {
        /// Makes a text parameter.
        pub fn text<T>(value: T) -> Part
        where
            T: Into<Cow<'static, str>>,
        {
            let body = match value.into() {
                Cow::Borrowed(slice) => Body::from(slice),
                Cow::Owned(string) => Body::from(string),
            };
            Part::new(body)
        }

        /// Makes a new parameter from arbitrary bytes.
        pub fn bytes<T>(value: T) -> Part
        where
            T: Into<Cow<'static, [u8]>>,
        {
            let body = match value.into() {
                Cow::Borrowed(slice) => Body::from(slice),
                Cow::Owned(vec) => Body::from(vec),
            };
            Part::new(body)
        }

        /// Makes a new parameter from an arbitrary stream.
        pub fn stream<T: Into<Body>>(value: T) -> Part {
            Part::new(value.into())
        }

        fn new(value: Body) -> Part {
            Part {
                meta: PartMetadata::new(),
                value: value.into_part(),
            }
        }

        /// Tries to set the mime of this part.
        pub fn mime_str(self, mime: &str) -> crate::Result<Part> {
            Ok(self.mime(mime.parse().map_err(crate::error::builder)?))
        }

        // Re-export when mime 0.4 is available, with split MediaType/MediaRange.
        fn mime(self, mime: Mime) -> Part {
            self.with_inner(move |inner| inner.mime(mime))
        }

        /// Sets the filename, builder style.
        pub fn file_name<T>(self, filename: T) -> Part
        where
            T: Into<Cow<'static, str>>,
        {
            self.with_inner(move |inner| inner.file_name(filename))
        }

        /// Sets custom headers for the part.
        pub fn headers(self, headers: HeaderMap) -> Part {
            self.with_inner(move |inner| inner.headers(headers))
        }

        fn with_inner<F>(self, func: F) -> Self
        where
            F: FnOnce(PartMetadata) -> PartMetadata,
        {
            Part {
                meta: func(self.meta),
                value: self.value,
            }
        }

        fn append_to_form(
            &self,
            name: &str,
            form: &web_sys::FormData,
        ) -> Result<(), wasm_bindgen::JsValue> {
            let single = self
                .value
                .as_single()
                .expect("A part's body can't be multipart itself");

            let mut mime_type = self.metadata().mime.as_ref();

            // The JS fetch API doesn't support file names and mime types for strings. So we do our best
            // effort to use `append_with_str` and fallback to `append_with_blob_*` if that's not
            // possible.
            if let super::body::Single::Text(text) = single {
                if mime_type.is_none() || mime_type == Some(&mime_guess::mime::TEXT_PLAIN) {
                    if self.metadata().file_name.is_none() {
                        return form.append_with_str(name, text);
                    }
                } else {
                    mime_type = Some(&mime_guess::mime::TEXT_PLAIN);
                }
            }

            let blob = self.blob(mime_type)?;

            if let Some(file_name) = &self.metadata().file_name {
                form.append_with_blob_and_filename(name, &blob, file_name)
            } else {
                form.append_with_blob(name, &blob)
            }
        }

        fn blob(&self, mime_type: Option<&Mime>) -> crate::Result<web_sys::Blob> {
            use web_sys::Blob;
            use web_sys::BlobPropertyBag;
            let mut properties = BlobPropertyBag::new();
            if let Some(mime) = mime_type {
                properties.type_(mime.as_ref());
            }

            let js_value = self
                .value
                .as_single()
                .expect("A part's body can't be set to a multipart body")
                .to_js_value();

            let body_array = js_sys::Array::new();
            body_array.push(&js_value);

            Blob::new_with_u8_array_sequence_and_options(body_array.as_ref(), &properties)
                .map_err(crate::error::wasm)
                .map_err(crate::error::builder)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer add a file upload part to a multipart form and what API methods are used for this?
  codeQuestion3: What steps are involved in converting a part's body into a Blob object for the web_sys::FormData API?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/multipart.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for Part {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut dbg = f.debug_struct("Part");
            dbg.field("value", &self.value);
            self.meta.fmt_fields(&mut dbg);
            dbg.finish()
        }
    }

    impl PartProps for Part {
        fn metadata(&self) -> &PartMetadata {
            &self.meta
        }
    }

    // ===== impl FormParts =====

    impl<P: PartProps> FormParts<P> {
        pub(crate) fn new() -> Self {
            FormParts { fields: Vec::new() }
        }

        /// Adds a customized Part.
        pub(crate) fn part<T>(mut self, name: T, part: P) -> Self
        where
            T: Into<Cow<'static, str>>,
        {
            self.fields.push((name.into(), part));
            self
        }
    }

    impl<P: fmt::Debug> FormParts<P> {
        pub(crate) fn fmt_fields(&self, ty_name: &'static str, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct(ty_name)
                .field("parts", &self.fields)
                .finish()
        }
    }

    // ===== impl PartMetadata =====

    impl PartMetadata {
        pub(crate) fn new() -> Self {
            PartMetadata {
                mime: None,
                file_name: None,
                headers: HeaderMap::default(),
            }
        }

        pub(crate) fn mime(mut self, mime: Mime) -> Self {
            self.mime = Some(mime);
            self
        }

        pub(crate) fn file_name<T>(mut self, filename: T) -> Self
        where
            T: Into<Cow<'static, str>>,
        {
            self.file_name = Some(filename.into());
            self
        }

        pub(crate) fn headers<T>(mut self, headers: T) -> Self
        where
            T: Into<HeaderMap>,
        {
            self.headers = headers.into();
            self
        }
    }

    impl PartMetadata {
        pub(crate) fn fmt_fields<'f, 'fa, 'fb>(
            &self,
            debug_struct: &'f mut fmt::DebugStruct<'fa, 'fb>,
        ) -> &'f mut fmt::DebugStruct<'fa, 'fb> {
            debug_struct
                .field("mime", &self.mime)
                .field("file_name", &self.file_name)
                .field("headers", &self.headers)
        }
    }

    #[cfg(test)]
    mod tests {

        use wasm_bindgen_test::*;

        wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);

        #[wasm_bindgen_test]
        async fn test_multipart_js() {
            use super::{Form, Part};
            use js_sys::Uint8Array;
            use wasm_bindgen::JsValue;
            use web_sys::{File, FormData};

            let text_file_name = "test.txt";
            let text_file_type = "text/plain";
            let text_content = "TEST";
            let text_part = Part::text(text_content)
                .file_name(text_file_name)
                .mime_str(text_file_type)
                .expect("invalid mime type");

            let binary_file_name = "binary.bin";
            let binary_file_type = "application/octet-stream";
            let binary_content = vec![0u8, 42];
            let binary_part = Part::bytes(binary_content.clone())
                .file_name(binary_file_name)
                .mime_str(binary_file_type)
                .expect("invalid mime type");

            let string_name = "string";
            let string_content = "CONTENT";
            let string_part = Part::text(string_content);

            let text_name = "text part";
            let binary_name = "binary part";
            let form = Form::new()
                .part(text_name, text_part)
                .part(binary_name, binary_part)
                .part(string_name, string_part);

            let mut init = web_sys::RequestInit::new();
            init.method("POST");
            init.body(Some(
                form.to_form_data()
                    .expect("could not convert to FormData")
                    .as_ref(),
            ));

            let js_req = web_sys::Request::new_with_str_and_init("", &init)
                .expect("could not create JS request");

            let form_data_promise = js_req.form_data().expect("could not get form_data promise");

            let form_data = crate::wasm::promise::<FormData>(form_data_promise)
                .await
                .expect("could not get body as form data");

            // check text part
            let text_file = File::from(form_data.get(text_name));
            assert_eq!(text_file.name(), text_file_name);
            assert_eq!(text_file.type_(), text_file_type);

            let text_promise = text_file.text();
            let text = crate::wasm::promise::<JsValue>(text_promise)
                .await
                .expect("could not get text body as text");
            assert_eq!(
                text.as_string().expect("text is not a string"),
                text_content
            );

            // check binary part
            let binary_file = File::from(form_data.get(binary_name));
            assert_eq!(binary_file.name(), binary_file_name);
            assert_eq!(binary_file.type_(), binary_file_type);

            // check string part
            let string = form_data
                .get(string_name)
                .as_string()
                .expect("content is not a string");
            assert_eq!(string, string_content);

            let binary_array_buffer_promise = binary_file.array_buffer();
            let array_buffer = crate::wasm::promise::<JsValue>(binary_array_buffer_promise)
                .await
                .expect("could not get request body as array buffer");

            let binary = Uint8Array::new(&array_buffer).to_vec();

            assert_eq!(binary, binary_content);
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle the creation and configuration of multipart form data parts?
  codeQuestion3: What steps are involved in testing the multipart form data functionality?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/wasm/mod.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use std::convert::TryInto;
    use std::time::Duration;

    use js_sys::Function;
    use wasm_bindgen::prelude::{wasm_bindgen, Closure};
    use wasm_bindgen::{JsCast, JsValue};
    use web_sys::{AbortController, AbortSignal};

    mod body;
    mod client;
    /// TODO
    #[cfg(feature = "multipart")]
    pub mod multipart;
    mod request;
    mod response;

    pub use self::body::Body;
    pub use self::client::{Client, ClientBuilder};
    pub use self::request::{Request, RequestBuilder};
    pub use self::response::Response;

    #[wasm_bindgen]
    extern "C" {
        #[wasm_bindgen(js_name = "setTimeout")]
        fn set_timeout(handler: &Function, timeout: i32) -> JsValue;

        #[wasm_bindgen(js_name = "clearTimeout")]
        fn clear_timeout(handle: JsValue) -> JsValue;
    }

    async fn promise<T>(promise: js_sys::Promise) -> Result<T, crate::error::BoxError>
    where
        T: JsCast,
    {
        use wasm_bindgen_futures::JsFuture;

        let js_val = JsFuture::from(promise).await.map_err(crate::error::wasm)?;

        js_val
            .dyn_into::<T>()
            .map_err(|_js_val| "promise resolved to unexpected type".into())
    }

    /// A guard that cancels a fetch request when dropped.
    struct AbortGuard {
        ctrl: AbortController,
        timeout: Option<(JsValue, Closure<dyn FnMut()>)>,
    }

    impl AbortGuard {
        fn new() -> crate::Result<Self> {
            Ok(AbortGuard {
                ctrl: AbortController::new()
                    .map_err(crate::error::wasm)
                    .map_err(crate::error::builder)?,
                timeout: None,
            })
        }

        fn signal(&self) -> AbortSignal {
            self.ctrl.signal()
        }

        fn timeout(&mut self, timeout: Duration) {
            let ctrl = self.ctrl.clone();
            let abort =
                Closure::once(move || ctrl.abort_with_reason(&"reqwest::errors::TimedOut".into()));
            let timeout = set_timeout(
                abort.as_ref().unchecked_ref::<js_sys::Function>(),
                timeout.as_millis().try_into().expect("timeout"),
            );
            if let Some((id, _)) = self.timeout.replace((timeout, abort)) {
                clear_timeout(id);
            }
        }
    }

    impl Drop for AbortGuard {
        fn drop(&mut self) {
            self.ctrl.abort();
            if let Some((id, _)) = self.timeout.take() {
                clear_timeout(id);
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer set up a timeout for a fetch request using the provided APIs?
  codeQuestion3: What is the role of the `AbortGuard` struct in managing abort signals for HTTP requests?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/into_url.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use url::Url;

    /// A trait to try to convert some type into a `Url`.
    ///
    /// This trait is "sealed", such that only types within reqwest can
    /// implement it.
    pub trait IntoUrl: IntoUrlSealed {}

    impl IntoUrl for Url {}
    impl IntoUrl for String {}
    impl<'a> IntoUrl for &'a str {}
    impl<'a> IntoUrl for &'a String {}

    pub trait IntoUrlSealed {
        // Besides parsing as a valid `Url`, the `Url` must be a valid
        // `http::Uri`, in that it makes sense to use in a network request.
        fn into_url(self) -> crate::Result<Url>;

        fn as_str(&self) -> &str;
    }

    impl IntoUrlSealed for Url {
        fn into_url(self) -> crate::Result<Url> {
            // With blob url the `self.has_host()` check is always false, so we
            // remove the `blob:` scheme and check again if the url is valid.
            #[cfg(target_arch = "wasm32")]
            if self.scheme() == "blob"
                && self.path().starts_with("http") // Check if the path starts with http or https to avoid validating a `blob:blob:...` url.
                && self.as_str()[5..].into_url().is_ok()
            {
                return Ok(self);
            }

            if self.has_host() {
                Ok(self)
            } else {
                Err(crate::error::url_bad_scheme(self))
            }
        }

        fn as_str(&self) -> &str {
            self.as_ref()
        }
    }

    impl<'a> IntoUrlSealed for &'a str {
        fn into_url(self) -> crate::Result<Url> {
            Url::parse(self).map_err(crate::error::builder)?.into_url()
        }

        fn as_str(&self) -> &str {
            self
        }
    }

    impl<'a> IntoUrlSealed for &'a String {
        fn into_url(self) -> crate::Result<Url> {
            (&**self).into_url()
        }

        fn as_str(&self) -> &str {
            self.as_ref()
        }
    }

    impl IntoUrlSealed for String {
        fn into_url(self) -> crate::Result<Url> {
            (&*self).into_url()
        }

        fn as_str(&self) -> &str {
            self.as_ref()
        }
    }

    if_hyper! {
        pub(crate) fn try_uri(url: &Url) -> crate::Result<http::Uri> {
            url.as_str()
                .parse()
                .map_err(|_| crate::error::url_invalid_uri(url.clone()))
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::error::Error;

        #[test]
        fn into_url_file_scheme() {
            let err = "file:///etc/hosts".into_url().unwrap_err();
            assert_eq!(
                err.source().unwrap().to_string(),
                "URL scheme is not allowed"
            );
        }

        #[test]
        fn into_url_blob_scheme() {
            let err = "blob:https://example.com".into_url().unwrap_err();
            assert_eq!(
                err.source().unwrap().to_string(),
                "URL scheme is not allowed"
            );
        }

        if_wasm! {
            use wasm_bindgen_test::*;

            #[wasm_bindgen_test]
            fn into_url_blob_scheme_wasm() {
                let url = "blob:http://example.com".into_url().unwrap();

                assert_eq!(url.as_str(), "blob:http://example.com");
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of the `IntoUrl` trait in this code?
  codeQuestion2: How does the code handle validation of URLs with different schemes, such as 'blob' and 'file'? Provide a code example.
  codeQuestion3: What is the role of the `IntoUrlSealed` trait, and how does it differ from the public `IntoUrl` trait?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/dns/resolve.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use hyper_util::client::legacy::connect::dns::Name as HyperName;
    use tower_service::Service;

    use std::collections::HashMap;
    use std::future::Future;
    use std::net::SocketAddr;
    use std::pin::Pin;
    use std::str::FromStr;
    use std::sync::Arc;
    use std::task::{Context, Poll};

    use crate::error::BoxError;

    /// Alias for an `Iterator` trait object over `SocketAddr`.
    pub type Addrs = Box<dyn Iterator<Item = SocketAddr> + Send>;

    /// Alias for the `Future` type returned by a DNS resolver.
    pub type Resolving = Pin<Box<dyn Future<Output = Result<Addrs, BoxError>> + Send>>;

    /// Trait for customizing DNS resolution in reqwest.
    pub trait Resolve: Send + Sync {
        /// Performs DNS resolution on a `Name`.
        /// The return type is a future containing an iterator of `SocketAddr`.
        ///
        /// It differs from `tower_service::Service<Name>` in several ways:
        ///  * It is assumed that `resolve` will always be ready to poll.
        ///  * It does not need a mutable reference to `self`.
        ///  * Since trait objects cannot make use of associated types, it requires
        ///    wrapping the returned `Future` and its contained `Iterator` with `Box`.
        ///
        /// Explicitly specified port in the URL will override any port in the resolved `SocketAddr`s.
        /// Otherwise, port `0` will be replaced by the conventional port for the given scheme (e.g. 80 for http).
        fn resolve(&self, name: Name) -> Resolving;
    }

    /// A name that must be resolved to addresses.
    #[derive(Debug)]
    pub struct Name(pub(super) HyperName);

    impl Name {
        /// View the name as a string.
        pub fn as_str(&self) -> &str {
            self.0.as_str()
        }
    }

    impl FromStr for Name {
        type Err = sealed::InvalidNameError;

        fn from_str(host: &str) -> Result<Self, Self::Err> {
            HyperName::from_str(host)
                .map(Name)
                .map_err(|_| sealed::InvalidNameError { _ext: () })
        }
    }

    #[derive(Clone)]
    pub(crate) struct DynResolver {
        resolver: Arc<dyn Resolve>,
    }

    impl DynResolver {
        pub(crate) fn new(resolver: Arc<dyn Resolve>) -> Self {
            Self { resolver }
        }
    }

    impl Service<HyperName> for DynResolver {
        type Response = Addrs;
        type Error = BoxError;
        type Future = Resolving;

        fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }

        fn call(&mut self, name: HyperName) -> Self::Future {
            self.resolver.resolve(Name(name))
        }
    }

    pub(crate) struct DnsResolverWithOverrides {
        dns_resolver: Arc<dyn Resolve>,
        overrides: Arc<HashMap<String, Vec<SocketAddr>>>,
    }

    impl DnsResolverWithOverrides {
        pub(crate) fn new(
            dns_resolver: Arc<dyn Resolve>,
            overrides: HashMap<String, Vec<SocketAddr>>,
        ) -> Self {
            DnsResolverWithOverrides {
                dns_resolver,
                overrides: Arc::new(overrides),
            }
        }
    }

    impl Resolve for DnsResolverWithOverrides {
        fn resolve(&self, name: Name) -> Resolving {
            match self.overrides.get(name.as_str()) {
                Some(dest) => {
                    let addrs: Addrs = Box::new(dest.clone().into_iter());
                    Box::pin(std::future::ready(Ok(addrs)))
                }
                None => self.dns_resolver.resolve(name),
            }
        }
    }

    mod sealed {
        use std::fmt;

        #[derive(Debug)]
        pub struct InvalidNameError {
            pub(super) _ext: (),
        }

        impl fmt::Display for InvalidNameError {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("invalid DNS name")
            }
        }

        impl std::error::Error for InvalidNameError {}
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `DnsResolverWithOverrides` handle DNS resolution for a given name, and what is an example of its usage?
  codeQuestion3: What steps are taken to handle the `Name` type and its conversion from a string?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/dns/mod.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! DNS resolution

    pub use resolve::{Addrs, Name, Resolve, Resolving};
    pub(crate) use resolve::{DnsResolverWithOverrides, DynResolver};

    pub(crate) mod gai;
    #[cfg(feature = "hickory-dns")]
    pub(crate) mod hickory;
    pub(crate) mod resolve;
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle DNS resolution when using the Hickory DNS provider?
  codeQuestion3: What is the role of the `resolve` module in this code? Provide an example of how it might be used in a program.

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/dns/gai.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    use futures_util::future::FutureExt;
    use hyper_util::client::legacy::connect::dns::GaiResolver as HyperGaiResolver;
    use tower_service::Service;

    use crate::dns::{Addrs, Name, Resolve, Resolving};
    use crate::error::BoxError;

    #[derive(Debug)]
    pub struct GaiResolver(HyperGaiResolver);

    impl GaiResolver {
        pub fn new() -> Self {
            Self(HyperGaiResolver::new())
        }
    }

    impl Default for GaiResolver {
        fn default() -> Self {
            GaiResolver::new()
        }
    }

    impl Resolve for GaiResolver {
        fn resolve(&self, name: Name) -> Resolving {
            let this = &mut self.0.clone();
            Box::pin(this.call(name.0).map(|result| {
                result
                    .map(|addrs| -> Addrs { Box::new(addrs) })
                    .map_err(|err| -> BoxError { Box::new(err) })
            }))
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the GaiResolver struct handle the resolution process for DNS names?
  codeQuestion3: What system calls or APIs are used to handle the resolution of DNS names in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/dns/hickory.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! DNS resolution via the [hickory-resolver](https://github.com/hickory-dns/hickory-dns) crate

    use hickory_resolver::{
        config::LookupIpStrategy, error::ResolveError, lookup_ip::LookupIpIntoIter, system_conf,
        TokioAsyncResolver,
    };
    use once_cell::sync::OnceCell;

    use std::fmt;
    use std::net::SocketAddr;
    use std::sync::Arc;

    use super::{Addrs, Name, Resolve, Resolving};

    /// Wrapper around an `AsyncResolver`, which implements the `Resolve` trait.
    #[derive(Debug, Default, Clone)]
    pub(crate) struct HickoryDnsResolver {
        /// Since we might not have been called in the context of a
        /// Tokio Runtime in initialization, so we must delay the actual
        /// construction of the resolver.
        state: Arc<OnceCell<TokioAsyncResolver>>,
    }

    struct SocketAddrs {
        iter: LookupIpIntoIter,
    }

    #[derive(Debug)]
    struct HickoryDnsSystemConfError(ResolveError);

    impl Resolve for HickoryDnsResolver {
        fn resolve(&self, name: Name) -> Resolving {
            let resolver = self.clone();
            Box::pin(async move {
                let resolver = resolver.state.get_or_try_init(new_resolver)?;

                let lookup = resolver.lookup_ip(name.as_str()).await?;
                let addrs: Addrs = Box::new(SocketAddrs {
                    iter: lookup.into_iter(),
                });
                Ok(addrs)
            })
        }
    }

    impl Iterator for SocketAddrs {
        type Item = SocketAddr;

        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next().map(|ip_addr| SocketAddr::new(ip_addr, 0))
        }
    }

    /// Create a new resolver with the default configuration,
    /// which reads from `/etc/resolve.conf`. The options are
    /// overridden to look up for both IPv4 and IPv6 addresses
    /// to work with "happy eyeballs" algorithm.
    fn new_resolver() -> Result<TokioAsyncResolver, HickoryDnsSystemConfError> {
        let (config, mut opts) = system_conf::read_system_conf().map_err(HickoryDnsSystemConfError)?;
        opts.ip_strategy = LookupIpStrategy::Ipv4AndIpv6;
        Ok(TokioAsyncResolver::tokio(config, opts))
    }

    impl fmt::Display for HickoryDnsSystemConfError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_str("error reading DNS system conf for hickory-dns")
        }
    }

    impl std::error::Error for HickoryDnsSystemConfError {
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            Some(&self.0)
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a user set up a custom DNS resolver configuration for the application?
  codeQuestion3: What is the role of the `new_resolver` function in this code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/tls.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! TLS configuration and types
    //!
    //! A `Client` will use transport layer security (TLS) by default to connect to
    //! HTTPS destinations.
    //!
    //! # Backends
    //!
    //! reqwest supports several TLS backends, enabled with Cargo features.
    //!
    //! ## default-tls
    //!
    //! reqwest will pick a TLS backend by default. This is true when the
    //! `default-tls` feature is enabled.
    //!
    //! While it currently uses `native-tls`, the feature set is designed to only
    //! enable configuration that is shared among available backends. This allows
    //! reqwest to change the default to `rustls` (or another) at some point in the
    //! future.
    //!
    //! <div class="warning">This feature is enabled by default, and takes
    //! precedence if any other crate enables it. This is true even if you declare
    //! `features = []`. You must set `default-features = false` instead.</div>
    //!
    //! Since Cargo features are additive, other crates in your dependency tree can
    //! cause the default backend to be enabled. If you wish to ensure your
    //! `Client` uses a specific backend, call the appropriate builder methods
    //! (such as [`use_rustls_tls()`][]).
    //!
    //! [`use_rustls_tls()`]: crate::ClientBuilder::use_rustls_tls()
    //!
    //! ## native-tls
    //!
    //! This backend uses the [native-tls][] crate. That will try to use the system
    //! TLS on Windows and Mac, and OpenSSL on Linux targets.
    //!
    //! Enabling the feature explicitly allows for `native-tls`-specific
    //! configuration options.
    //!
    //! [native-tls]: https://crates.io/crates/native-tls
    //!
    //! ## rustls-tls
    //!
    //! This backend uses the [rustls][] crate, a TLS library written in Rust.
    //!
    //! [rustls]: https://crates.io/crates/rustls

    #[cfg(feature = "__rustls")]
    use rustls::{
        client::danger::HandshakeSignatureValid, client::danger::ServerCertVerified,
        client::danger::ServerCertVerifier, crypto::WebPkiSupportedAlgorithms,
        server::ParsedCertificate, DigitallySignedStruct, Error as TLSError, RootCertStore,
        SignatureScheme,
    };
    #[cfg(feature = "__rustls")]
    use rustls_pki_types::{ServerName, UnixTime};
    use std::{
        fmt,
        io::{BufRead, BufReader},
    };

    /// Represents a X509 certificate revocation list.
    #[cfg(feature = "__rustls")]
    pub struct CertificateRevocationList {
        #[cfg(feature = "__rustls")]
        inner: rustls_pki_types::CertificateRevocationListDer<'static>,
    }

    /// Represents a server X509 certificate.
    #[derive(Clone)]
    pub struct Certificate {
        #[cfg(feature = "default-tls")]
        native: native_tls_crate::Certificate,
        #[cfg(feature = "__rustls")]
        original: Cert,
    }

    #[cfg(feature = "__rustls")]
    #[derive(Clone)]
    enum Cert {
        Der(Vec<u8>),
        Pem(Vec<u8>),
    }

    /// Represents a private key and X509 cert as a client certificate.
    #[derive(Clone)]
    pub struct Identity {
        #[cfg_attr(not(any(feature = "native-tls", feature = "__rustls")), allow(unused))]
        inner: ClientCert,
    }

    enum ClientCert {
        #[cfg(feature = "native-tls")]
        Pkcs12(native_tls_crate::Identity),
        #[cfg(feature = "native-tls")]
        Pkcs8(native_tls_crate::Identity),
        #[cfg(feature = "__rustls")]
        Pem {
            key: rustls_pki_types::PrivateKeyDer<'static>,
            certs: Vec<rustls_pki_types::CertificateDer<'static>>,
        },
    }

    impl Clone for ClientCert {
        fn clone(&self) -> Self {
            match self {
                #[cfg(feature = "native-tls")]
                Self::Pkcs8(i) => Self::Pkcs8(i.clone()),
                #[cfg(feature = "native-tls")]
                Self::Pkcs12(i) => Self::Pkcs12(i.clone()),
                #[cfg(feature = "__rustls")]
                ClientCert::Pem { key, certs } => ClientCert::Pem {
                    key: key.clone_key(),
                    certs: certs.clone(),
                },
                #[cfg_attr(
                    any(feature = "native-tls", feature = "__rustls"),
                    allow(unreachable_patterns)
                )]
                _ => unreachable!(),
            }
        }
    }

    impl Certificate {
        /// Create a `Certificate` from a binary DER encoded certificate
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn cert() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut buf = Vec::new();
        /// File::open("my_cert.der")?
        ///     .read_to_end(&mut buf)?;
        /// let cert = reqwest::Certificate::from_der(&buf)?;
        /// # drop(cert);
        /// # Ok(())
        /// # }
        /// ```
        pub fn from_der(der: &[u8]) -> crate::Result<Certificate> {
            Ok(Certificate {
                #[cfg(feature = "default-tls")]
                native: native_tls_crate::Certificate::from_der(der).map_err(crate::error::builder)?,
                #[cfg(feature = "__rustls")]
                original: Cert::Der(der.to_owned()),
            })
        }

        /// Create a `Certificate` from a PEM encoded certificate
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn cert() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut buf = Vec::new();
        /// File::open("my_cert.pem")?
        ///     .read_to_end(&mut buf)?;
        /// let cert = reqwest::Certificate::from_pem(&buf)?;
        /// # drop(cert);
        /// # Ok(())
        /// # }
        /// ```
        pub fn from_pem(pem: &[u8]) -> crate::Result<Certificate> {
            Ok(Certificate {
                #[cfg(feature = "default-tls")]
                native: native_tls_crate::Certificate::from_pem(pem).map_err(crate::error::builder)?,
                #[cfg(feature = "__rustls")]
                original: Cert::Pem(pem.to_owned()),
            })
        }

        /// Create a collection of `Certificate`s from a PEM encoded certificate bundle.
        /// Example byte sources may be `.crt`, `.cer` or `.pem` files.
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn cert() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut buf = Vec::new();
        /// File::open("ca-bundle.crt")?
        ///     .read_to_end(&mut buf)?;
        /// let certs = reqwest::Certificate::from_pem_bundle(&buf)?;
        /// # drop(certs);
        /// # Ok(())
        /// # }
        /// ```
        pub fn from_pem_bundle(pem_bundle: &[u8]) -> crate::Result<Vec<Certificate>> {
            let mut reader = BufReader::new(pem_bundle);

            Self::read_pem_certs(&mut reader)?
                .iter()
                .map(|cert_vec| Certificate::from_der(cert_vec))
                .collect::<crate::Result<Vec<Certificate>>>()
        }

        #[cfg(feature = "default-tls")]
        pub(crate) fn add_to_native_tls(self, tls: &mut native_tls_crate::TlsConnectorBuilder) {
            tls.add_root_certificate(self.native);
        }

        #[cfg(feature = "__rustls")]
        pub(crate) fn add_to_rustls(
            self,
            root_cert_store: &mut rustls::RootCertStore,
        ) -> crate::Result<()> {
            use std::io::Cursor;

            match self.original {
                Cert::Der(buf) => root_cert_store
                    .add(buf.into())
                    .map_err(crate::error::builder)?,
                Cert::Pem(buf) => {
                    let mut reader = Cursor::new(buf);
                    let certs = Self::read_pem_certs(&mut reader)?;
                    for c in certs {
                        root_cert_store
                            .add(c.into())
                            .map_err(crate::error::builder)?;
                    }
                }
            }
            Ok(())
        }

        fn read_pem_certs(reader: &mut impl BufRead) -> crate::Result<Vec<Vec<u8>>> {
            rustls_pemfile::certs(reader)
                .map(|result| match result {
                    Ok(cert) => Ok(cert.as_ref().to_vec()),
                    Err(_) => Err(crate::error::builder("invalid certificate encoding")),
                })
                .collect()
        }
    }
    ```
  codeQuestion1: What is the primary purpose of this code?
  codeQuestion2: How can a developer create a certificate from PEM encoded data and use it in a TLS connection?
  codeQuestion3: What is the process for adding a certificate to a Rustls root certificate store?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/tls.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl Identity {
        /// Parses a DER-formatted PKCS #12 archive, using the specified password to decrypt the key.
        ///
        /// The archive should contain a leaf certificate and its private key, as well any intermediate
        /// certificates that allow clients to build a chain to a trusted root.
        /// The chain certificates should be in order from the leaf certificate towards the root.
        ///
        /// PKCS #12 archives typically have the file extension `.p12` or `.pfx`, and can be created
        /// with the OpenSSL `pkcs12` tool:
        ///
        /// ```bash
        /// openssl pkcs12 -export -out identity.pfx -inkey key.pem -in cert.pem -certfile chain_certs.pem
        /// ```
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn pkcs12() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut buf = Vec::new();
        /// File::open("my-ident.pfx")?
        ///     .read_to_end(&mut buf)?;
        /// let pkcs12 = reqwest::Identity::from_pkcs12_der(&buf, "my-privkey-password")?;
        /// # drop(pkcs12);
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the `native-tls` Cargo feature enabled.
        #[cfg(feature = "native-tls")]
        pub fn from_pkcs12_der(der: &[u8], password: &str) -> crate::Result<Identity> {
            Ok(Identity {
                inner: ClientCert::Pkcs12(
                    native_tls_crate::Identity::from_pkcs12(der, password)
                        .map_err(crate::error::builder)?,
                ),
            })
        }

        /// Parses a chain of PEM encoded X509 certificates, with the leaf certificate first.
        /// `key` is a PEM encoded PKCS #8 formatted private key for the leaf certificate.
        ///
        /// The certificate chain should contain any intermediate certificates that should be sent to
        /// clients to allow them to build a chain to a trusted root.
        ///
        /// A certificate chain here means a series of PEM encoded certificates concatenated together.
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs;
        /// # fn pkcs8() -> Result<(), Box<dyn std::error::Error>> {
        /// let cert = fs::read("client.pem")?;
        /// let key = fs::read("key.pem")?;
        /// let pkcs8 = reqwest::Identity::from_pkcs8_pem(&cert, &key)?;
        /// # drop(pkcs8);
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the `native-tls` Cargo feature enabled.
        #[cfg(feature = "native-tls")]
        pub fn from_pkcs8_pem(pem: &[u8], key: &[u8]) -> crate::Result<Identity> {
            Ok(Identity {
                inner: ClientCert::Pkcs8(
                    native_tls_crate::Identity::from_pkcs8(pem, key).map_err(crate::error::builder)?,
                ),
            })
        }

        /// Parses PEM encoded private key and certificate.
        ///
        /// The input should contain a PEM encoded private key
        /// and at least one PEM encoded certificate.
        ///
        /// Note: The private key must be in RSA, SEC1 Elliptic Curve or PKCS#8 format.
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn pem() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut buf = Vec::new();
        /// File::open("my-ident.pem")?
        ///     .read_to_end(&mut buf)?;
        /// let id = reqwest::Identity::from_pem(&buf)?;
        /// # drop(id);
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the `rustls-tls(-...)` Cargo feature enabled.
        #[cfg(feature = "__rustls")]
        pub fn from_pem(buf: &[u8]) -> crate::Result<Identity> {
            use rustls_pemfile::Item;
            use std::io::Cursor;

            let (key, certs) = {
                let mut pem = Cursor::new(buf);
                let mut sk = Vec::<rustls_pki_types::PrivateKeyDer>::new();
                let mut certs = Vec::<rustls_pki_types::CertificateDer>::new();

                for result in rustls_pemfile::read_all(&mut pem) {
                    match result {
                        Ok(Item::X509Certificate(cert)) => certs.push(cert),
                        Ok(Item::Pkcs1Key(key)) => sk.push(key.into()),
                        Ok(Item::Pkcs8Key(key)) => sk.push(key.into()),
                        Ok(Item::Sec1Key(key)) => sk.push(key.into()),
                        Ok(_) => {
                            return Err(crate::error::builder(TLSError::General(String::from(
                                "No valid certificate was found",
                            ))))
                        }
                        Err(_) => {
                            return Err(crate::error::builder(TLSError::General(String::from(
                                "Invalid identity PEM file",
                            ))))
                        }
                    }
                }

                if let (Some(sk), false) = (sk.pop(), certs.is_empty()) {
                    (sk, certs)
                } else {
                    return Err(crate::error::builder(TLSError::General(String::from(
                        "private key or certificate not found",
                    ))));
                }
            };

            Ok(Identity {
                inner: ClientCert::Pem { key, certs },
            })
        }

        #[cfg(feature = "native-tls")]
        pub(crate) fn add_to_native_tls(
            self,
            tls: &mut native_tls_crate::TlsConnectorBuilder,
        ) -> crate::Result<()> {
            match self.inner {
                ClientCert::Pkcs12(id) | ClientCert::Pkcs8(id) => {
                    tls.identity(id);
                    Ok(())
                }
                #[cfg(feature = "__rustls")]
                ClientCert::Pem { .. } => Err(crate::error::builder("incompatible TLS identity type")),
            }
        }

        #[cfg(feature = "__rustls")]
        pub(crate) fn add_to_rustls(
            self,
            config_builder: rustls::ConfigBuilder<
                rustls::ClientConfig,
                // Not sure here
                rustls::client::WantsClientCert,
            >,
        ) -> crate::Result<rustls::ClientConfig> {
            match self.inner {
                ClientCert::Pem { key, certs } => config_builder
                    .with_client_auth_cert(certs, key)
                    .map_err(crate::error::builder),
                #[cfg(feature = "native-tls")]
                ClientCert::Pkcs12(..) | ClientCert::Pkcs8(..) => {
                    Err(crate::error::builder("incompatible TLS identity type"))
                }
            }
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle parsing a PKCS#12 archive and what is an example of its usage?
  codeQuestion3: What steps are taken to handle the parsing of PEM-encoded certificates and private keys?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/tls.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    #[cfg(feature = "__rustls")]
    impl CertificateRevocationList {
        /// Parses a PEM encoded CRL.
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn crl() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut buf = Vec::new();
        /// File::open("my_crl.pem")?
        ///     .read_to_end(&mut buf)?;
        /// let crl = reqwest::tls::CertificateRevocationList::from_pem(&buf)?;
        /// # drop(crl);
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the `rustls-tls(-...)` Cargo feature enabled.
        #[cfg(feature = "__rustls")]
        pub fn from_pem(pem: &[u8]) -> crate::Result<CertificateRevocationList> {
            Ok(CertificateRevocationList {
                #[cfg(feature = "__rustls")]
                inner: rustls_pki_types::CertificateRevocationListDer::from(pem.to_vec()),
            })
        }

        /// Creates a collection of `CertificateRevocationList`s from a PEM encoded CRL bundle.
        /// Example byte sources may be `.crl` or `.pem` files.
        ///
        /// # Examples
        ///
        /// ```
        /// # use std::fs::File;
        /// # use std::io::Read;
        /// # fn crls() -> Result<(), Box<dyn std::error::Error>> {
        /// let mut buf = Vec::new();
        /// File::open("crl-bundle.crl")?
        ///     .read_to_end(&mut buf)?;
        /// let crls = reqwest::tls::CertificateRevocationList::from_pem_bundle(&buf)?;
        /// # drop(crls);
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// # Optional
        ///
        /// This requires the `rustls-tls(-...)` Cargo feature enabled.
        #[cfg(feature = "__rustls")]
        pub fn from_pem_bundle(pem_bundle: &[u8]) -> crate::Result<Vec<CertificateRevocationList>> {
            let mut reader = BufReader::new(pem_bundle);

            rustls_pemfile::crls(&mut reader)
                .map(|result| match result {
                    Ok(crl) => Ok(CertificateRevocationList { inner: crl }),
                    Err(_) => Err(crate::error::builder("invalid crl encoding")),
                })
                .collect::<crate::Result<Vec<CertificateRevocationList>>>()
        }

        #[cfg(feature = "__rustls")]
        pub(crate) fn as_rustls_crl<'a>(&self) -> rustls_pki_types::CertificateRevocationListDer<'a> {
            self.inner.clone()
        }
    }

    impl fmt::Debug for Certificate {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Certificate").finish()
        }
    }

    impl fmt::Debug for Identity {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("Identity").finish()
        }
    }

    #[cfg(feature = "__rustls")]
    impl fmt::Debug for CertificateRevocationList {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_struct("CertificateRevocationList").finish()
        }
    }

    /// A TLS protocol version.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
    pub struct Version(InnerVersion);

    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
    #[non_exhaustive]
    enum InnerVersion {
        Tls1_0,
        Tls1_1,
        Tls1_2,
        Tls1_3,
    }

    // These could perhaps be From/TryFrom implementations, but those would be
    // part of the public API so let's be careful
    impl Version {
        /// Version 1.0 of the TLS protocol.
        pub const TLS_1_0: Version = Version(InnerVersion::Tls1_0);
        /// Version 1.1 of the TLS protocol.
        pub const TLS_1_1: Version = Version(InnerVersion::Tls1_1);
        /// Version 1.2 of the TLS protocol.
        pub const TLS_1_2: Version = Version(InnerVersion::Tls1_2);
        /// Version 1.3 of the TLS protocol.
        pub const TLS_1_3: Version = Version(InnerVersion::Tls1_3);

        #[cfg(feature = "default-tls")]
        pub(crate) fn to_native_tls(self) -> Option<native_tls_crate::Protocol> {
            match self.0 {
                InnerVersion::Tls1_0 => Some(native_tls_crate::Protocol::Tlsv10),
                InnerVersion::Tls1_1 => Some(native_tls_crate::Protocol::Tlsv11),
                InnerVersion::Tls1_2 => Some(native_tls_crate::Protocol::Tlsv12),
                InnerVersion::Tls1_3 => None,
            }
        }

        #[cfg(feature = "__rustls")]
        pub(crate) fn from_rustls(version: rustls::ProtocolVersion) -> Option<Self> {
            match version {
                rustls::ProtocolVersion::SSLv2 => None,
                rustls::ProtocolVersion::SSLv3 => None,
                rustls::ProtocolVersion::TLSv1_0 => Some(Self(InnerVersion::Tls1_0)),
                rustls::ProtocolVersion::TLSv1_1 => Some(Self(InnerVersion::Tls1_1)),
                rustls::ProtocolVersion::TLSv1_2 => Some(Self(InnerVersion::Tls1_2)),
                rustls::ProtocolVersion::TLSv1_3 => Some(Self(InnerVersion::Tls1_3)),
                _ => None,
            }
        }
    }

    pub(crate) enum TlsBackend {
        // This is the default and HTTP/3 feature does not use it so suppress it.
        #[allow(dead_code)]
        #[cfg(feature = "default-tls")]
        Default,
        #[cfg(feature = "native-tls")]
        BuiltNativeTls(native_tls_crate::TlsConnector),
        #[cfg(feature = "__rustls")]
        Rustls,
        #[cfg(feature = "__rustls")]
        BuiltRustls(rustls::ClientConfig),
        #[cfg(any(feature = "native-tls", feature = "__rustls",))]
        UnknownPreconfigured,
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How can a developer create a TLS connection using the `CertificateRevocationList` from PEM encoded data, and what system calls are involved in handling the input for this action?
  codeQuestion3: What steps are taken to handle TLS protocol versioning and conversion between different TLS backends in the code?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/tls.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl fmt::Debug for TlsBackend {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                #[cfg(feature = "default-tls")]
                TlsBackend::Default => write!(f, "Default"),
                #[cfg(feature = "native-tls")]
                TlsBackend::BuiltNativeTls(_) => write!(f, "BuiltNativeTls"),
                #[cfg(feature = "__rustls")]
                TlsBackend::Rustls => write!(f, "Rustls"),
                #[cfg(feature = "__rustls")]
                TlsBackend::BuiltRustls(_) => write!(f, "BuiltRustls"),
                #[cfg(any(feature = "native-tls", feature = "__rustls",))]
                TlsBackend::UnknownPreconfigured => write!(f, "UnknownPreconfigured"),
            }
        }
    }

    #[allow(clippy::derivable_impls)]
    impl Default for TlsBackend {
        fn default() -> TlsBackend {
            #[cfg(all(feature = "default-tls", not(feature = "http3")))]
            {
                TlsBackend::Default
            }

            #[cfg(any(
                all(feature = "__rustls", not(feature = "default-tls")),
                feature = "http3"
            ))]
            {
                TlsBackend::Rustls
            }
        }
    }

    #[cfg(feature = "__rustls")]
    #[derive(Debug)]
    pub(crate) struct NoVerifier;

    #[cfg(feature = "__rustls")]
    impl ServerCertVerifier for NoVerifier {
        fn verify_server_cert(
            &self,
            _end_entity: &rustls_pki_types::CertificateDer,
            _intermediates: &[rustls_pki_types::CertificateDer],
            _server_name: &ServerName,
            _ocsp_response: &[u8],
            _now: UnixTime,
        ) -> Result<ServerCertVerified, TLSError> {
            Ok(ServerCertVerified::assertion())
        }

        fn verify_tls12_signature(
            &self,
            _message: &[u8],
            _cert: &rustls_pki_types::CertificateDer,
            _dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, TLSError> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn verify_tls13_signature(
            &self,
            _message: &[u8],
            _cert: &rustls_pki_types::CertificateDer,
            _dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, TLSError> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
            vec![
                SignatureScheme::RSA_PKCS1_SHA1,
                SignatureScheme::ECDSA_SHA1_Legacy,
                SignatureScheme::RSA_PKCS1_SHA256,
                SignatureScheme::ECDSA_NISTP256_SHA256,
                SignatureScheme::RSA_PKCS1_SHA384,
                SignatureScheme::ECDSA_NISTP384_SHA384,
                SignatureScheme::RSA_PKCS1_SHA512,
                SignatureScheme::ECDSA_NISTP521_SHA512,
                SignatureScheme::RSA_PSS_SHA256,
                SignatureScheme::RSA_PSS_SHA384,
                SignatureScheme::RSA_PSS_SHA512,
                SignatureScheme::ED25519,
                SignatureScheme::ED448,
            ]
        }
    }

    #[cfg(feature = "__rustls")]
    #[derive(Debug)]
    pub(crate) struct IgnoreHostname {
        roots: RootCertStore,
        signature_algorithms: WebPkiSupportedAlgorithms,
    }

    #[cfg(feature = "__rustls")]
    impl IgnoreHostname {
        pub(crate) fn new(
            roots: RootCertStore,
            signature_algorithms: WebPkiSupportedAlgorithms,
        ) -> Self {
            Self {
                roots,
                signature_algorithms,
            }
        }
    }

    #[cfg(feature = "__rustls")]
    impl ServerCertVerifier for IgnoreHostname {
        fn verify_server_cert(
            &self,
            end_entity: &rustls_pki_types::CertificateDer<'_>,
            intermediates: &[rustls_pki_types::CertificateDer<'_>],
            _server_name: &ServerName<'_>,
            _ocsp_response: &[u8],
            now: UnixTime,
        ) -> Result<ServerCertVerified, TLSError> {
            let cert = ParsedCertificate::try_from(end_entity)?;

            rustls::client::verify_server_cert_signed_by_trust_anchor(
                &cert,
                &self.roots,
                intermediates,
                now,
                self.signature_algorithms.all,
            )?;
            Ok(ServerCertVerified::assertion())
        }

        fn verify_tls12_signature(
            &self,
            message: &[u8],
            cert: &rustls_pki_types::CertificateDer<'_>,
            dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, TLSError> {
            rustls::crypto::verify_tls12_signature(message, cert, dss, &self.signature_algorithms)
        }

        fn verify_tls13_signature(
            &self,
            message: &[u8],
            cert: &rustls_pki_types::CertificateDer<'_>,
            dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, TLSError> {
            rustls::crypto::verify_tls13_signature(message, cert, dss, &self.signature_algorithms)
        }

        fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
            self.signature_algorithms.supported_schemes()
        }
    }

    /// Hyper extension carrying extra TLS layer information.
    /// Made available to clients on responses when `tls_info` is set.
    #[derive(Clone)]
    pub struct TlsInfo {
        pub(crate) peer_certificate: Option<Vec<u8>>,
    }

    impl TlsInfo {
        /// Get the DER encoded leaf certificate of the peer.
        pub fn peer_certificate(&self) -> Option<&[u8]> {
            self.peer_certificate.as_ref().map(|der| &der[..])
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `TlsBackend` type determine which TLS implementation to use based on feature flags?
  codeQuestion3: What is the role of the `IgnoreHostname` struct in TLS verification, and how is it configured?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/tls.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    impl std::fmt::Debug for TlsInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("TlsInfo").finish()
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[cfg(feature = "default-tls")]
        #[test]
        fn certificate_from_der_invalid() {
            Certificate::from_der(b"not der").unwrap_err();
        }

        #[cfg(feature = "default-tls")]
        #[test]
        fn certificate_from_pem_invalid() {
            Certificate::from_pem(b"not pem").unwrap_err();
        }

        #[cfg(feature = "native-tls")]
        #[test]
        fn identity_from_pkcs12_der_invalid() {
            Identity::from_pkcs12_der(b"not der", "nope").unwrap_err();
        }

        #[cfg(feature = "native-tls")]
        #[test]
        fn identity_from_pkcs8_pem_invalid() {
            Identity::from_pkcs8_pem(b"not pem", b"not key").unwrap_err();
        }

        #[cfg(feature = "__rustls")]
        #[test]
        fn identity_from_pem_invalid() {
            Identity::from_pem(b"not pem").unwrap_err();
        }

        #[cfg(feature = "__rustls")]
        #[test]
        fn identity_from_pem_pkcs1_key() {
            let pem = b"-----BEGIN CERTIFICATE-----\n\
                -----END CERTIFICATE-----\n\
                -----BEGIN RSA PRIVATE KEY-----\n\
                -----END RSA PRIVATE KEY-----\n";

            Identity::from_pem(pem).unwrap();
        }

        #[test]
        fn certificates_from_pem_bundle() {
            const PEM_BUNDLE: &[u8] = b"
                -----BEGIN CERTIFICATE-----
                MIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5
                MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
                Um9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
                A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
                Q0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl
                ui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j
                QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr
                ttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr
                BqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM
                YyRIHN8wfdVoOw==
                -----END CERTIFICATE-----

                -----BEGIN CERTIFICATE-----
                MIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5
                MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
                Um9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
                A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
                Q0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi
                9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk
                M6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB
                /zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB
                MAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw
                CkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW
                1KyLa2tJElMzrdfkviT8tQp21KW8EA==
                -----END CERTIFICATE-----
            ";

            assert!(Certificate::from_pem_bundle(PEM_BUNDLE).is_ok())
        }

        #[cfg(feature = "__rustls")]
        #[test]
        fn crl_from_pem() {
            let pem = b"-----BEGIN X509 CRL-----\n-----END X509 CRL-----\n";

            CertificateRevocationList::from_pem(pem).unwrap();
        }

        #[cfg(feature = "__rustls")]
        #[test]
        fn crl_from_pem_bundle() {
            let pem_bundle = std::fs::read("tests/support/crl.pem").unwrap();

            let result = CertificateRevocationList::from_pem_bundle(&pem_bundle);

            assert!(result.is_ok());
            let result = result.unwrap();
            assert_eq!(result.len(), 1);
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the code handle invalid certificate or identity data when using different TLS features?
  codeQuestion3: What steps are taken to parse and validate a PEM bundle containing multiple certificates?

- prompt: |-
    You are playing the role of a senior software engineer developing questions for a code review. Here is some source code from inputs/code/reqwest/src/cookie.rs. It is part of the Hyper project.



    Source Code:

    ```rust
    //! HTTP Cookies

    use std::convert::TryInto;
    use std::fmt;
    use std::sync::RwLock;
    use std::time::SystemTime;

    use crate::header::{HeaderValue, SET_COOKIE};
    use bytes::Bytes;

    /// Actions for a persistent cookie store providing session support.
    pub trait CookieStore: Send + Sync {
        /// Store a set of Set-Cookie header values received from `url`
        fn set_cookies(&self, cookie_headers: &mut dyn Iterator<Item = &HeaderValue>, url: &url::Url);
        /// Get any Cookie values in the store for `url`
        fn cookies(&self, url: &url::Url) -> Option<HeaderValue>;
    }

    /// A single HTTP cookie.
    pub struct Cookie<'a>(cookie_crate::Cookie<'a>);

    /// A good default `CookieStore` implementation.
    ///
    /// This is the implementation used when simply calling `cookie_store(true)`.
    /// This type is exposed to allow creating one and filling it with some
    /// existing cookies more easily, before creating a `Client`.
    ///
    /// For more advanced scenarios, such as needing to serialize the store or
    /// manipulate it between requests, you may refer to the
    /// [reqwest_cookie_store crate](https://crates.io/crates/reqwest_cookie_store).
    #[derive(Debug, Default)]
    pub struct Jar(RwLock<cookie_store::CookieStore>);

    // ===== impl Cookie =====

    impl<'a> Cookie<'a> {
        fn parse(value: &'a HeaderValue) -> Result<Cookie<'a>, CookieParseError> {
            std::str::from_utf8(value.as_bytes())
                .map_err(cookie_crate::ParseError::from)
                .and_then(cookie_crate::Cookie::parse)
                .map_err(CookieParseError)
                .map(Cookie)
        }

        /// The name of the cookie.
        pub fn name(&self) -> &str {
            self.0.name()
        }

        /// The value of the cookie.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Returns true if the 'HttpOnly' directive is enabled.
        pub fn http_only(&self) -> bool {
            self.0.http_only().unwrap_or(false)
        }

        /// Returns true if the 'Secure' directive is enabled.
        pub fn secure(&self) -> bool {
            self.0.secure().unwrap_or(false)
        }

        /// Returns true if  'SameSite' directive is 'Lax'.
        pub fn same_site_lax(&self) -> bool {
            self.0.same_site() == Some(cookie_crate::SameSite::Lax)
        }

        /// Returns true if  'SameSite' directive is 'Strict'.
        pub fn same_site_strict(&self) -> bool {
            self.0.same_site() == Some(cookie_crate::SameSite::Strict)
        }

        /// Returns the path directive of the cookie, if set.
        pub fn path(&self) -> Option<&str> {
            self.0.path()
        }

        /// Returns the domain directive of the cookie, if set.
        pub fn domain(&self) -> Option<&str> {
            self.0.domain()
        }

        /// Get the Max-Age information.
        pub fn max_age(&self) -> Option<std::time::Duration> {
            self.0.max_age().map(|d| {
                d.try_into()
                    .expect("time::Duration into std::time::Duration")
            })
        }

        /// The cookie expiration time.
        pub fn expires(&self) -> Option<SystemTime> {
            match self.0.expires() {
                Some(cookie_crate::Expiration::DateTime(offset)) => Some(SystemTime::from(offset)),
                None | Some(cookie_crate::Expiration::Session) => None,
            }
        }
    }

    impl<'a> fmt::Debug for Cookie<'a> {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.0.fmt(f)
        }
    }

    pub(crate) fn extract_response_cookie_headers<'a>(
        headers: &'a hyper::HeaderMap,
    ) -> impl Iterator<Item = &'a HeaderValue> + 'a {
        headers.get_all(SET_COOKIE).iter()
    }

    pub(crate) fn extract_response_cookies<'a>(
        headers: &'a hyper::HeaderMap,
    ) -> impl Iterator<Item = Result<Cookie<'a>, CookieParseError>> + 'a {
        headers
            .get_all(SET_COOKIE)
            .iter()
            .map(|value| Cookie::parse(value))
    }

    /// Error representing a parse failure of a 'Set-Cookie' header.
    pub(crate) struct CookieParseError(cookie_crate::ParseError);

    impl<'a> fmt::Debug for CookieParseError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.0.fmt(f)
        }
    }

    impl<'a> fmt::Display for CookieParseError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.0.fmt(f)
        }
    }

    impl std::error::Error for CookieParseError {}

    // ===== impl Jar =====

    impl Jar {
        /// Add a cookie to this jar.
        ///
        /// # Example
        ///
        /// ```
        /// use reqwest::{cookie::Jar, Url};
        ///
        /// let cookie = "foo=bar; Domain=yolo.local";
        /// let url = "https://yolo.local".parse::<Url>().unwrap();
        ///
        /// let jar = Jar::default();
        /// jar.add_cookie_str(cookie, &url);
        ///
        /// // and now add to a `ClientBuilder`?
        /// ```
        pub fn add_cookie_str(&self, cookie: &str, url: &url::Url) {
            let cookies = cookie_crate::Cookie::parse(cookie)
                .ok()
                .map(|c| c.into_owned())
                .into_iter();
            self.0.write().unwrap().store_response_cookies(cookies, url);
        }
    }

    impl CookieStore for Jar {
        fn set_cookies(&self, cookie_headers: &mut dyn Iterator<Item = &HeaderValue>, url: &url::Url) {
            let iter =
                cookie_headers.filter_map(|val| Cookie::parse(val).map(|c| c.0.into_owned()).ok());

            self.0.write().unwrap().store_response_cookies(iter, url);
        }

        fn cookies(&self, url: &url::Url) -> Option<HeaderValue> {
            let s = self
                .0
                .read()
                .unwrap()
                .get_request_values(url)
                .map(|(name, value)| format!("{name}={value}"))
                .collect::<Vec<_>>()
                .join("; ");

            if s.is_empty() {
                return None;
            }

            HeaderValue::from_maybe_shared(Bytes::from(s)).ok()
        }
    }
    ```
  codeQuestion1: What is the purpose of this code?
  codeQuestion2: How does the `Jar` struct store and manage cookies, and what is an example of adding a cookie to it?
  codeQuestion3: What steps are involved in parsing and handling `Set-Cookie` headers when a request is made?

