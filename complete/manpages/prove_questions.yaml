- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `prove`.\n\n\n\nManpage text:\n\nPROVE(1)\t       Perl Programmers Reference Guide \t      PROVE(1)\n\n\nNAME\n       prove - Run tests through a TAP harness.\n\nUSAGE\n\tprove [options] [files or directories]\n\nOPTIONS\n       Boolean options:\n\n\t-v,  --verbose\t       Print all test lines.\n\t-l,  --lib\t       Add 'lib' to the path for your tests (-Ilib).\n\t-b,  --blib\t       Add 'blib/lib' and 'blib/arch' to the path for\n\t\t\t       your tests\n\t-s,  --shuffle\t       Run the tests in random order.\n\t-c,  --color\t       Colored test output (default).\n\t     --nocolor\t       Do not color test output.\n\t     --count\t       Show the X/Y test count when not verbose\n\t\t\t       (default)\n\t     --nocount\t       Disable the X/Y test count.\n\t-D   --dry\t       Dry run. Show test that would have run.\n\t-f,  --failures        Show failed tests.\n\t-o,  --comments        Show comments.\n\t     --ignore-exit     Ignore exit status from test scripts.\n\t-m,  --merge\t       Merge test scripts' STDERR with their STDOUT.\n\t-r,  --recurse\t       Recursively descend into directories.\n\t     --reverse\t       Run the tests in reverse order.\n\t-q,  --quiet\t       Suppress some test output while running tests.\n\t-Q,  --QUIET\t       Only print summary results.\n\t-p,  --parse\t       Show full list of TAP parse errors, if any.\n\t     --directives      Only show results with TODO or SKIP directives.\n\t     --timer\t       Print elapsed time after each test.\n\t     --trap\t       Trap Ctrl-C and print summary on interrupt.\n\t     --normalize       Normalize TAP output in verbose output\n\t-T\t\t       Enable tainting checks.\n\t-t\t\t       Enable tainting warnings.\n\t-W\t\t       Enable fatal warnings.\n\t-w\t\t       Enable warnings.\n\t-h,  --help\t       Display this help\n\t-?,\t\t       Display this help\n\t-V,  --version\t       Display the version\n\t-H,  --man\t       Longer manpage for prove\n\t     --norc\t       Don't process default .proverc\n\n       Options that take arguments:\n\n\t-I\t\t       Library paths to include.\n\t-P\t\t       Load plugin (searches App::Prove::Plugin::*.)\n\t-M\t\t       Load a module.\n\t-e,  --exec\t       Interpreter to run the tests ('' for compiled\n\t\t\t       tests.)\n\t     --ext\t       Set the extension for tests (default '.t')\n\t     --harness\t       Define test harness to use.  See TAP::Harness.\n\t     --formatter       Result formatter to use. See FORMATTERS.\n\t     --source\t       Load and/or configure a SourceHandler. See\n\t\t\t       SOURCE HANDLERS.\n\t-a,  --archive out.tgz Store the resulting TAP in an archive file.\n\t-j,  --jobs N\t       Run N test jobs in parallel (try 9.)\n\t     --state=opts      Control prove's persistent state.\n\t     --statefile=file  Use `file` instead of `.prove` for state\n\t     --rc=rcfile       Process options from rcfile\n\t     --rules\t       Rules for parallel vs sequential processing.\n\nNOTES\n   .proverc\n       If ~/.proverc or ./.proverc exist they will be read and any options\n       they contain processed before the command line options. Options in\n       .proverc are specified in the same way as command line options:\n\n\t   # .proverc\n\t   --state=hot,fast,save\n\t   -j9\n\n       Additional option files may be specified with the \"--rc\" option.\n       Default option file processing is disabled by the \"--norc\" option.\n\n       Under Windows and VMS the option file is named _proverc rather than\n       .proverc and is sought only in the current directory.\n\n   Reading from \"STDIN\"\n       If you have a list of tests (or URLs, or anything else you want to\n       test) in a file, you can add them to your tests by using a '-':\n\n\tprove - < my_list_of_things_to_test.txt\n\n       See the \"README\" in the \"examples\" directory of this distribution.\n\n   Default Test Directory\n       If no files or directories are supplied, \"prove\" looks for all files\n       matching the pattern \"t/*.t\".\n\n   Colored Test Output\n       Colored test output using TAP::Formatter::Color is the default, but if\n       output is not to a terminal, color is disabled. You can override this\n       by adding the \"--color\" switch.\n\n       Color support requires Term::ANSIColor and, on windows platforms, also\n       Win32::Console::ANSI. If the necessary module(s) are not installed\n       colored output will not be available.\n\n   Exit Code\n       If the tests fail \"prove\" will exit with non-zero status.\n\n   Arguments to Tests\n       It is possible to supply arguments to tests. To do so separate them\n       from prove's own arguments with the arisdottle, '::'. For example\n\n\tprove -v t/mytest.t :: --url http://example.com\n\n       would run t/mytest.t with the options '--url http://example.com'.  When\n       running multiple tests they will each receive the same arguments.\n\n   \"--exec\"\n       Normally you can just pass a list of Perl tests and the harness will\n       know how to execute them.  However, if your tests are not written in\n       Perl or if you want all tests invoked exactly the same way, use the\n       \"-e\", or \"--exec\" switch:\n\n\tprove --exec '/usr/bin/ruby -w' t/\n\tprove --exec '/usr/bin/perl -Tw -mstrict -Ilib' t/\n\tprove --exec '/path/to/my/customer/exec'\n\n   \"--merge\"\n       If you need to make sure your diagnostics are displayed in the correct\n       order relative to test results you can use the \"--merge\" option to\n       merge the test scripts' STDERR into their STDOUT.\n\n       This guarantees that STDOUT (where the test results appear) and STDERR\n       (where the diagnostics appear) will stay in sync. The harness will\n       display any diagnostics your tests emit on STDERR.\n\n       Caveat: this is a bit of a kludge. In particular note that if anything\n       that appears on STDERR looks like a test result the test harness will\n       get confused. Use this option only if you understand the consequences\n       and can live with the risk.\n\n   \"--trap\"\n       The \"--trap\" option will attempt to trap SIGINT (Ctrl-C) during a test\n       run and display the test summary even if the run is interrupted\n\n   \"--state\"\n       You can ask \"prove\" to remember the state of previous test runs and\n       select and/or order the tests to be run based on that saved state.\n\n       The \"--state\" switch requires an argument which must be a comma\n       separated list of one or more of the following options.\n\n       \"last\"\n\t   Run the same tests as the last time the state was saved. This makes\n\t   it possible, for example, to recreate the ordering of a shuffled\n\t   test.\n\n\t       # Run all tests in random order\n\t       $ prove -b --state=save --shuffle\n\n\t       # Run them again in the same order\n\t       $ prove -b --state=last\n\n       \"failed\"\n\t   Run only the tests that failed on the last run.\n\n\t       # Run all tests\n\t       $ prove -b --state=save\n\n\t       # Run failures\n\t       $ prove -b --state=failed\n\n\t   If you also specify the \"save\" option newly passing tests will be\n\t   excluded from subsequent runs.\n\n\t       # Repeat until no more failures\n\t       $ prove -b --state=failed,save\n\n       \"passed\"\n\t   Run only the passed tests from last time. Useful to make sure that\n\t   no new problems have been introduced.\n\n       \"all\"\n\t   Run all tests in normal order. Multple options may be specified, so\n\t   to run all tests with the failures from last time first:\n\n\t       $ prove -b --state=failed,all,save\n\n       \"hot\"\n\t   Run the tests that most recently failed first. The last failure\n\t   time of each test is stored. The \"hot\" option causes tests to be\n\t   run in most-recent- failure order.\n\n\t       $ prove -b --state=hot,save\n\n\t   Tests that have never failed will not be selected. To run all tests\n\t   with the most recently failed first use\n\n\t       $ prove -b --state=hot,all,save\n\n\t   This combination of options may also be specified thus\n\n\t       $ prove -b --state=adrian\n\n       \"todo\"\n\t   Run any tests with todos.\n\n       \"slow\"\n\t   Run the tests in slowest to fastest order. This is useful in\n\t   conjunction with the \"-j\" parallel testing switch to ensure that\n\t   your slowest tests start running first.\n\n\t       $ prove -b --state=slow -j9\n\n       \"fast\"\n\t   Run test tests in fastest to slowest order.\n\n       \"new\"\n\t   Run the tests in newest to oldest order based on the modification\n\t   times of the test scripts.\n\n       \"old\"\n\t   Run the tests in oldest to newest order.\n\n       \"fresh\"\n\t   Run those test scripts that have been modified since the last test\n\t   run.\n\n       \"save\"\n\t   Save the state on exit. The state is stored in a file called .prove\n\t   (_prove on Windows and VMS) in the current directory.\n\n       The \"--state\" switch may be used more than once.\n\n\t   $ prove -b --state=hot --state=all,save\n\n   --rules\n       The \"--rules\" option is used to control which tests are run\n       sequentially and which are run in parallel, if the \"--jobs\" option is\n       specified. The option may be specified multiple times, and the order\n       matters.\n\n       The most practical use is likely to specify that some tests are not\n       \"parallel-ready\".  Since mentioning a file with --rules doesn't cause\n       it to be selected to run as a test, you can \"set and forget\" some rules\n       preferences in your .proverc file. Then you'll be able to take maximum\n       advantage of the performance benefits of parallel testing, while some\n       exceptions are still run in parallel.\n\n       --rules examples\n\n\t   # All tests are allowed to run in parallel, except those starting with \"p\"\n\t   --rules='seq=t/p*.t' --rules='par=**'\n\n\t   # All tests must run in sequence except those starting with \"p\", which should be run parallel\n\t   --rules='par=t/p*.t'\n\n       --rules resolution\n\n       •   By default, all tests are eligible to be run in parallel.\n\t   Specifying any of your own rules removes this one.\n\n       •   \"First match wins\". The first rule that matches a test will be the\n\t   one that applies.\n\n       •   Any test which does not match a rule will be run in sequence at the\n\t   end of the run.\n\n       •   The existence of a rule does not imply selecting a test. You must\n\t   still specify the tests to run.\n\n       •   Specifying a rule to allow tests to run in parallel does not make\n\t   them run in parallel. You still need specify the number of parallel\n\t   \"jobs\" in your Harness object.\n\n       --rules Glob-style pattern matching\n\n       We implement our own glob-style pattern matching for --rules. Here are\n       the supported patterns:\n\n\t   ** is any number of characters, including /, within a pathname\n\t   * is zero or more characters within a filename/directory name\n\t   ? is exactly one character within a filename/directory name\n\t   {foo,bar,baz} is any of foo, bar or baz.\n\t   \\ is an escape character\n\n       More advanced specifications for parallel vs sequence run rules\n\n       If you need more advanced management of what runs in parallel vs in\n       sequence, see the associated 'rules' documentation in TAP::Harness and\n       TAP::Parser::Scheduler.\tIf what's possible directly through \"prove\" is\n       not sufficient, you can write your own harness to access these features\n       directly.\n\n   @INC\n       prove introduces a separation between \"options passed to the perl which\n       runs prove\" and \"options passed to the perl which runs tests\"; this\n       distinction is by design. Thus the perl which is running a test starts\n       with the default @INC. Additional library directories can be added via\n       the \"PERL5LIB\" environment variable, via -Ifoo in \"PERL5OPT\" or via the\n       \"-Ilib\" option to prove.\n\n   Taint Mode\n       Normally when a Perl program is run in taint mode the contents of the\n       \"PERL5LIB\" environment variable do not appear in @INC.\n\n       Because \"PERL5LIB\" is often used during testing to add build\n       directories to @INC prove passes the names of any directories found in\n       \"PERL5LIB\" as -I switches. The net effect of this is that \"PERL5LIB\" is\n       honoured even when prove is run in taint mode.\n\nFORMATTERS\n       You can load a custom TAP::Parser::Formatter:\n\n\t prove --formatter MyFormatter\n\nSOURCE HANDLERS\n       You can load custom TAP::Parser::SourceHandlers, to change the way the\n       parser interprets particular sources of TAP.\n\n\t prove --source MyHandler --source YetAnother t\n\n       If you want to provide config to the source you can use:\n\n\t prove --source MyCustom \\\n\t       --source Perl --perl-option 'foo=bar baz' --perl-option avg=0.278 \\\n\t       --source File --file-option extensions=.txt --file-option extensions=.tmp t\n\t       --source pgTAP --pgtap-option pset=format=html --pgtap-option pset=border=2\n\n       Each \"--$source-option\" option must specify a key/value pair separated\n       by an \"=\". If an option can take multiple values, just specify it\n       multiple times, as with the \"extensions=\" examples above. If the option\n       should be a hash reference, specify the value as a second pair\n       separated by a \"=\", as in the \"pset=\" examples above (escape \"=\" with a\n       backslash).\n\n       All \"--sources\" are combined into a hash, and passed to \"new\" in\n       TAP::Harness's \"sources\" parameter.\n\n       See TAP::Parser::IteratorFactory for more details on how configuration\n       is passed to SourceHandlers.\n\nPLUGINS\n       Plugins can be loaded using the \"-Pplugin\" syntax, eg:\n\n\t prove -PMyPlugin\n\n       This will search for a module named \"App::Prove::Plugin::MyPlugin\", or\n       failing that, \"MyPlugin\".  If the plugin can't be found, \"prove\" will\n       complain & exit.\n\n       You can pass arguments to your plugin by appending \"=arg1,arg2,etc\" to\n       the plugin name:\n\n\t prove -PMyPlugin=fou,du,fafa\n\n       Please check individual plugin documentation for more details.\n\n   Available Plugins\n       For an up-to-date list of plugins available, please check CPAN:\n\n       <http://search.cpan.org/search?query=App%3A%3AProve+Plugin>\n\n   Writing Plugins\n       Please see \"PLUGINS\" in App::Prove.\n\nperl v5.34.1\t\t\t  2024-12-14\t\t\t      PROVE(1)"
  manpageQuestion1: What is the primary purpose of the `prove` command in Perl testing?
  manpageQuestion2: How can you use the `prove` command to run tests in random order and display colored output?
  manpageQuestion3: What command would you use to run all tests in a directory and save the test state for future runs?

