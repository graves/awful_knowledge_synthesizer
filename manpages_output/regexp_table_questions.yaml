- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `regexp_table`.\n\n\n\nManpage text:\n\nREGEXP_TABLE(5) \t      File Formats Manual\t       REGEXP_TABLE(5)\n\n\nNAME\n       regexp_table - format of Postfix regular expression tables\n\nSYNOPSIS\n       postmap -q \"string\" regexp:/etc/postfix/filename\n\n       postmap -q - regexp:/etc/postfix/filename <inputfile\n\nDESCRIPTION\n       The Postfix mail system uses optional tables for address rewriting,\n       mail routing, or access control. These tables are usually in dbm or db\n       format.\n\n       Alternatively, lookup tables can be specified in POSIX regular\n       expression form. In this case, each input is compared against a list of\n       patterns. When a match is found, the corresponding result is returned\n       and the search is terminated.\n\n       To find out what types of lookup tables your Postfix system supports\n       use the \"postconf -m\" command.\n\n       To test lookup tables, use the \"postmap -q\" command as described in the\n       SYNOPSIS above. Use \"postmap -hmq - <file\" for header_checks(5)\n       patterns, and \"postmap -bmq - <file\" for body_checks(5) (Postfix 2.6\n       and later).\n\nCOMPATIBILITY\n       With Postfix version 2.2 and earlier specify \"postmap -fq\" to query a\n       table that contains case sensitive patterns. Patterns are case\n       insensitive by default.\n\nTABLE FORMAT\n       The general form of a Postfix regular expression table is:\n\n       /pattern/flags result\n\t      When pattern matches the input string, use the corresponding\n\t      result value.\n\n       !/pattern/flags result\n\t      When pattern does not match the input string, use the\n\t      corresponding result value.\n\n       if /pattern/flags\n\n       endif  If the input string matches /pattern/, then match that input\n\t      string against the patterns between if and endif.  The if..endif\n\t      can nest.\n\n\t      Note: do not prepend whitespace to patterns inside if..endif.\n\n\t      This feature is available in Postfix 2.1 and later.\n\n       if !/pattern/flags\n\n       endif  If the input string does not match /pattern/, then match that\n\t      input string against the patterns between if and endif. The\n\t      if..endif can nest.\n\n\t      Note: do not prepend whitespace to patterns inside if..endif.\n\n\t      This feature is available in Postfix 2.1 and later.\n\n       blank lines and comments\n\t      Empty lines and whitespace-only lines are ignored, as are lines\n\t      whose first non-whitespace character is a `#'.\n\n       multi-line text\n\t      A logical line starts with non-whitespace text. A line that\n\t      starts with whitespace continues a logical line.\n\n       Each pattern is a POSIX regular expression enclosed by a pair of\n       delimiters. The regular expression syntax is documented in re_format(7)\n       with 4.4BSD, in regex(5) with Solaris, and in regex(7) with Linux.\n       Other systems may use other document names.\n\n       The expression delimiter can be any non-alphanumerical character,\n       except whitespace or characters that have special meaning\n       (traditionally the forward slash is used). The regular expression can\n       contain whitespace.\n\n       By default, matching is case-insensitive, and newlines are not treated\n       as special characters. The behavior is controlled by flags, which are\n       toggled by appending one or more of the following characters after the\n       pattern:\n\n       i (default: on)\n\t      Toggles the case sensitivity flag. By default, matching is case\n\t      insensitive.\n\n       m (default: off)\n\t      Toggle the multi-line mode flag. When this flag is on, the ^ and\n\t      $ metacharacters match immediately after and immediately before\n\t      a newline character, respectively, in addition to matching at\n\t      the start and end of the input string.\n\n       x (default: on)\n\t      Toggles the extended expression syntax flag. By default, support\n\t      for extended expression syntax is enabled.\n\nTABLE SEARCH ORDER\n       Patterns are applied in the order as specified in the table, until a\n       pattern is found that matches the input string.\n\n       Each pattern is applied to the entire input string.  Depending on the\n       application, that string is an entire client hostname, an entire client\n       IP address, or an entire mail address.  Thus, no parent domain or\n       parent network search is done, and user@domain mail addresses are not\n       broken up into their user and domain constituent parts, nor is user+foo\n       broken up into user and foo.\n\nTEXT SUBSTITUTION\n       Substitution of substrings (text that matches patterns inside \"()\")\n       from the matched expression into the result string is requested with\n       $1, $2, etc.; specify $$ to produce a $ character as output.  The\n       macros in the result string may need to be written as ${n} or $(n) if\n       they aren't followed by whitespace.\n\n       Note: since negated patterns (those preceded by !) return a result when\n       the expression does not match, substitutions are not available for\n       negated patterns.\n\nEXAMPLE SMTPD ACCESS MAP\n       # Disallow sender-specified routing. This is a must if you relay mail\n       # for other domains.\n       /[%!@].*[%!@]/\t    550 Sender-specified routing rejected\n\n       # Postmaster is OK, that way they can talk to us about how to fix\n       # their problem.\n       /^postmaster@/\t    OK\n\n       # Protect your outgoing majordomo exploders\n       if !/^owner-/\n       /^(.*)-outgoing@(.*)$/  550 Use ${1}@${2} instead\n       endif\n\nEXAMPLE HEADER FILTER MAP\n       # These were once common in junk mail.\n       /^Subject: make money fast/     REJECT\n       /^To: friend@public\\.com/       REJECT\n\nEXAMPLE BODY FILTER MAP\n       # First skip over base 64 encoded text to save CPU cycles.\n       ~^[[:alnum:]+/]{60,}$~\t       OK\n\n       # Put your own body patterns here.\n\nSEE ALSO\n       postmap(1), Postfix lookup table manager\n       pcre_table(5), format of PCRE tables\n       cidr_table(5), format of CIDR tables\n\nREADME FILES\n       Use \"postconf readme_directory\" or \"postconf html_directory\" to locate\n       this information.\n       DATABASE_README, Postfix lookup table overview\n\nAUTHOR(S)\n       The regexp table lookup code was originally written by:\n       LaMont Jones\n       lamont@hp.com\n\n       That code was based on the PCRE dictionary contributed by:\n       Andrew McNamara\n       andrewm@connect.com.au\n       connect.com.au Pty. Ltd.\n       Level 3, 213 Miller St\n       North Sydney, NSW, Australia\n\n       Adopted and adapted by:\n       Wietse Venema\n       IBM T.J. Watson Research\n       P.O. Box 704\n       Yorktown Heights, NY 10598, USA\n\n       Wietse Venema\n       Google, Inc.\n       111 8th Avenue\n       New York, NY 10011, USA\n\n\t\t\t\t\t\t\t       REGEXP_TABLE(5)"
  manpageQuestion1: What is the primary purpose of the regexp_table resource in Postfix?
  manpageQuestion2: How can you test a regular expression table in Postfix using the postmap command?
  manpageQuestion3: Can you provide an example of a regular expression pattern in a regexp_table file and explain its functionality?

