- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.



    Manpage text:

    PERLUNIINTRO(1)        Perl Programmers Reference Guide        PERLUNIINTRO(1)
  manpageQuestion1: What is the primary purpose of the perluniintro tool?
  manpageQuestion2: How would you use perluniintro to demonstrate the basic concepts of Unicode in Perl?
  manpageQuestion3: Can you provide an example of using perluniintro to show how Perl handles Unicode character properties?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nNAME\n       perluniintro - Perl Unicode introduction\n\nDESCRIPTION\n       This document gives a general idea of Unicode and how to use Unicode in\n       Perl.  See \"Further Resources\" for references to more in-depth\n       treatments of Unicode.\n\n   Unicode\n       Unicode is a character set standard which plans to codify all of the\n       writing systems of the world, plus many other symbols.\n\n       Unicode and ISO/IEC 10646 are coordinated standards that unify almost\n       all other modern character set standards, covering more than 80 writing\n       systems and hundreds of languages, including all commercially-important\n       modern languages.  All characters in the largest Chinese, Japanese, and\n       Korean dictionaries are also encoded. The standards will eventually\n       cover almost all characters in more than 250 writing systems and\n       thousands of languages.\tUnicode 1.0 was released in October 1991, and\n       6.0 in October 2010.\n\n       A Unicode character is an abstract entity.  It is not bound to any\n       particular integer width, especially not to the C language \"char\".\n       Unicode is language-neutral and display-neutral: it does not encode the\n       language of the text, and it does not generally define fonts or other\n       graphical layout details.  Unicode operates on characters and on text\n       built from those characters."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can Perl be used to handle Unicode characters according to the perluniintro documentation?
  manpageQuestion3: What is the significance of Unicode being language-neutral and display-neutral according to the perluniintro manpage?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nUnicode defines characters like \"LATIN CAPITAL LETTER A\" or \"GREEK\n       SMALL LETTER ALPHA\" and unique numbers for the characters, in this case\n       0x0041 and 0x03B1, respectively.  These unique numbers are called code\n       points.\tA code point is essentially the position of the character\n       within the set of all possible Unicode characters, and thus in Perl,\n       the term ordinal is often used interchangeably with it.\n\n       The Unicode standard prefers using hexadecimal notation for the code\n       points.\tIf numbers like 0x0041 are unfamiliar to you, take a peek at a\n       later section, \"Hexadecimal Notation\".  The Unicode standard uses the\n       notation \"U+0041 LATIN CAPITAL LETTER A\", to give the hexadecimal code\n       point and the normative name of the character.\n\n       Unicode also defines various properties for the characters, like\n       \"uppercase\" or \"lowercase\", \"decimal digit\", or \"punctuation\"; these\n       properties are independent of the names of the characters.\n       Furthermore, various operations on the characters like uppercasing,\n       lowercasing, and collating (sorting) are defined."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you represent the Unicode code point for 'LATIN CAPITAL LETTER A' in Perl?
  manpageQuestion3: What are some of the properties that Unicode characters can have according to the manpage?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.



    Manpage text:

    A Unicode logical "character" can actually consist of more than one
           internal actual "character" or code point.  For Western languages, this
           is adequately modelled by a base character (like "LATIN CAPITAL LETTER
           A") followed by one or more modifiers (like "COMBINING ACUTE ACCENT").
           This sequence of base character and modifiers is called a combining
           character sequence.  Some non-western languages require more
           complicated models, so Unicode created the grapheme cluster concept,
           which was later further refined into the extended grapheme cluster.
           For example, a Korean Hangul syllable is considered a single logical
           character, but most often consists of three actual Unicode characters:
           a leading consonant followed by an interior vowel followed by a
           trailing consonant.

           Whether to call these extended grapheme clusters "characters" depends
           on your point of view. If you are a programmer, you probably would tend
           towards seeing each element in the sequences as one unit, or
           "character".  However from the user's point of view, the whole sequence
           could be seen as one "character" since that's probably what it looks
           like in the context of the user's language.  In this document, we take
           the programmer's point of view: one "character" is one Unicode code
           point.
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use perluniintro to demonstrate the concept of combining character sequences in Unicode?
  manpageQuestion3: Can you provide an example of using perluniintro to explain the difference between a single Unicode code point and an extended grapheme cluster?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nFor some combinations of base character and modifiers, there are\n       precomposed characters.\tThere is a single character equivalent, for\n       example, for the sequence \"LATIN CAPITAL LETTER A\" followed by\n       \"COMBINING ACUTE ACCENT\".  It is called\t\"LATIN CAPITAL LETTER A WITH\n       ACUTE\".\tThese precomposed characters are, however, only available for\n       some combinations, and are mainly meant to support round-trip\n       conversions between Unicode and legacy standards (like ISO 8859).\n       Using sequences, as Unicode does, allows for needing fewer basic\n       building blocks (code points) to express many more potential grapheme\n       clusters.  To support conversion between equivalent forms, various\n       normalization forms are also defined.  Thus, \"LATIN CAPITAL LETTER A\n       WITH ACUTE\" is in Normalization Form Composed, (abbreviated NFC), and\n       the sequence \"LATIN CAPITAL LETTER A\" followed by \"COMBINING ACUTE\n       ACCENT\" represents the same character in Normalization Form Decomposed\n       (NFD)."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use perluniintro to convert a precomposed character like 'LATIN CAPITAL LETTER A WITH ACUTE' into its decomposed form using normalization?
  manpageQuestion3: What is the main function of normalization forms in the context of perluniintro?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nBecause of backward compatibility with legacy encodings, the \"a unique\n       number for every character\" idea breaks down a bit: instead, there is\n       \"at least one number for every character\".  The same character could be\n       represented differently in several legacy encodings.  The converse is\n       not true: some code points do not have an assigned character.  Firstly,\n       there are unallocated code points within otherwise used blocks.\n       Secondly, there are special Unicode control characters that do not\n       represent true characters.\n\n       When Unicode was first conceived, it was thought that all the world's\n       characters could be represented using a 16-bit word; that is a maximum\n       of 0x10000 (or 65,536) characters would be needed, from 0x0000 to\n       0xFFFF.\tThis soon proved to be wrong, and since Unicode 2.0 (July\n       1996), Unicode has been defined all the way up to 21 bits (0x10FFFF),\n       and Unicode 3.1 (March 2001) defined the first characters above 0xFFFF.\n       The first 0x10000 characters are called the Plane 0, or the Basic\n       Multilingual Plane (BMP).  With Unicode 3.1, 17 (yes, seventeen) planes\n       in all were defined--but they are nowhere near full of defined\n       characters, yet."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can perluniintro be used to demonstrate the concept of multiple encodings representing the same character?
  manpageQuestion3: Can you provide an example of how perluniintro might illustrate the difference between code points and assigned characters in Unicode?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nWhen a new language is being encoded, Unicode generally will choose a\n       \"block\" of consecutive unallocated code points for its characters.  So\n       far, the number of code points in these blocks has always been evenly\n       divisible by 16.  Extras in a block, not currently needed, are left\n       unallocated, for future growth.\tBut there have been occasions when a\n       later release needed more code points than the available extras, and a\n       new block had to allocated somewhere else, not contiguous to the\n       initial one, to handle the overflow.  Thus, it became apparent early on\n       that \"block\" wasn't an adequate organizing principle, and so the\n       \"Script\" property was created.  (Later an improved script property was\n       added as well, the \"Script_Extensions\" property.)  Those code points\n       that are in overflow blocks can still have the same script as the\n       original ones.  The script concept fits more closely with natural\n       language: there is \"Latin\" script, \"Greek\" script, and so on; and there\n       are several artificial scripts, like \"Common\" for characters that are\n       used in multiple scripts, such as mathematical symbols.\tScripts\n       usually span varied parts of several blocks.  For more information\n       about scripts, see \"Scripts\" in perlunicode.  The division into blocks\n       exists, but it is almost completely accidental--an artifact of how the\n       characters have been and still are allocated.  (Note that this\n       paragraph has oversimplified things for the sake of this being an\n       introduction.  Unicode doesn't really encode languages, but the writing\n       systems for them--their scripts; and one script can be used by many\n       languages.  Unicode also encodes things that aren't really about\n       languages, such as symbols like \"BAGGAGE CLAIM\".)"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How does the perluniintro resource help in understanding Unicode encoding and script properties?
  manpageQuestion3: Can you explain how the concept of 'Script' properties in Unicode relates to the organization of code points?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.



    Manpage text:

    The Unicode code points are just abstract numbers.  To input and output
           these abstract numbers, the numbers must be encoded or serialised
           somehow.  Unicode defines several character encoding forms, of which
           UTF-8 is the most popular.  UTF-8 is a variable length encoding that
           encodes Unicode characters as 1 to 4 bytes.  Other encodings include
           UTF-16 and UTF-32 and their big- and little-endian variants (UTF-8 is
           byte-order independent).  The ISO/IEC 10646 defines the UCS-2 and UCS-4
           encoding forms.

           For more information about encodings--for instance, to learn what
           surrogates and byte order marks (BOMs) are--see perlunicode.

       Perl's Unicode Support
           Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode
           natively.  Perl v5.8.0, however, is the first recommended release for
           serious Unicode work.  The maintenance release 5.6.1 fixed many of the
           problems of the initial Unicode implementation, but for example regular
           expressions still do not work with Unicode in 5.6.1.  Perl v5.14.0 is
           the first release where Unicode support is (almost) seamlessly
           integratable without some gotchas. (There are a few exceptions.
           Firstly, some differences in quotemeta were fixed starting in Perl
           5.16.0. Secondly, some differences in the range operator were fixed
           starting in Perl 5.26.0. Thirdly, some differences in split were fixed
           started in Perl 5.28.0.)
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can Perl be used to handle Unicode natively, and what is the significance of Perl v5.8.0 in this context?
  manpageQuestion3: What are the key differences between UTF-8, UTF-16, and UTF-32 encoding formats as described in the manpage?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nTo enable this seamless support, you should \"use feature\n       'unicode_strings'\" (which is automatically selected if you \"use 5.012\"\n       or higher).  See feature.  (5.14 also fixes a number of bugs and\n       departures from the Unicode standard.)\n\n       Before Perl v5.8.0, the use of \"use utf8\" was used to declare that\n       operations in the current block or file would be Unicode-aware.\tThis\n       model was found to be wrong, or at least clumsy: the \"Unicodeness\" is\n       now carried with the data, instead of being attached to the operations.\n       Starting with Perl v5.8.0, only one case remains where an explicit \"use\n       utf8\" is needed: if your Perl script itself is encoded in UTF-8, you\n       can use UTF-8 in your identifier names, and in string and regular\n       expression literals, by saying \"use utf8\".  This is not the default\n       because scripts with legacy 8-bit data in them would break.  See utf8.\n\n   Perl's Unicode Model\n       Perl supports both pre-5.6 strings of eight-bit native bytes, and\n       strings of Unicode characters.  The general principle is that Perl\n       tries to keep its data as eight-bit bytes for as long as possible, but\n       as soon as Unicodeness cannot be avoided, the data is transparently\n       upgraded to Unicode.  Prior to Perl v5.14.0, the upgrade was not\n       completely transparent (see \"The \"Unicode Bug\"\" in perlunicode), and\n       for backwards compatibility, full transparency is not gained unless\n       \"use feature 'unicode_strings'\" (see feature) or \"use 5.012\" (or\n       higher) is selected."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you enable Unicode support in a Perl script to handle UTF-8 encoded identifiers and literals?
  manpageQuestion3: What is the difference between using 'use utf8' and 'use feature 'unicode_strings'' in Perl for Unicode handling?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nInternally, Perl currently uses either whatever the native eight-bit\n       character set of the platform (for example Latin-1) is, defaulting to\n       UTF-8, to encode Unicode strings. Specifically, if all code points in\n       the string are 0xFF or less, Perl uses the native eight-bit character\n       set.  Otherwise, it uses UTF-8.\n\n       A user of Perl does not normally need to know nor care how Perl happens\n       to encode its internal strings, but it becomes relevant when outputting\n       Unicode strings to a stream without a PerlIO layer (one with the\n       \"default\" encoding).  In such a case, the raw bytes used internally\n       (the native character set or UTF-8, as appropriate for each string)\n       will be used, and a \"Wide character\" warning will be issued if those\n       strings contain a character beyond 0x00FF.\n\n       For example,\n\n\t     perl -e 'print \"\\x{DF}\\n\", \"\\x{0100}\\x{DF}\\n\"'\n\n       produces a fairly useless mixture of native bytes and UTF-8, as well as\n       a warning:"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can a user ensure that Perl uses UTF-8 encoding for all Unicode strings, even when the platform's default character set is different?
  manpageQuestion3: What happens if a Perl script outputs Unicode characters to a stream without a PerlIO layer when the platform's native character set is not UTF-8?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nWide character in print at ...\n\n       To output UTF-8, use the \":encoding\" or \":utf8\" output layer.\n       Prepending\n\n\t     binmode(STDOUT, \":utf8\");\n\n       to this sample program ensures that the output is completely UTF-8, and\n       removes the program's warning.\n\n       You can enable automatic UTF-8-ification of your standard file handles,\n       default \"open()\" layer, and @ARGV by using either the \"-C\" command line\n       switch or the \"PERL_UNICODE\" environment variable, see perlrun for the\n       documentation of the \"-C\" switch.\n\n       Note that this means that Perl expects other software to work the same\n       way: if Perl has been led to believe that STDIN should be UTF-8, but\n       then STDIN coming in from another command is not UTF-8, Perl will\n       likely complain about the malformed UTF-8.\n\n       All features that combine Unicode and I/O also require using the new\n       PerlIO feature.\tAlmost all Perl 5.8 platforms do use PerlIO, though:\n       you can see whether yours is by running \"perl -V\" and looking for\n       \"useperlio=define\"."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you configure Perl to automatically handle UTF-8 encoding for standard input and output?
  manpageQuestion3: What is the recommended way to ensure that Perl treats standard file handles as UTF-8 by default?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nUnicode and EBCDIC\n       Perl 5.8.0 added support for Unicode on EBCDIC platforms.  This support\n       was allowed to lapse in later releases, but was revived in 5.22.\n       Unicode support is somewhat more complex to implement since additional\n       conversions are needed.\tSee perlebcdic for more information.\n\n       On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC\n       instead of UTF-8.  The difference is that as UTF-8 is \"ASCII-safe\" in\n       that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is\n       \"EBCDIC-safe\", in that all the basic characters (which includes all\n       those that have ASCII equivalents (like \"A\", \"0\", \"%\", etc.) are the\n       same in both EBCDIC and UTF-EBCDIC.  Often, documentation will use the\n       term \"UTF-8\" to mean UTF-EBCDIC as well.  This is the case in this\n       document.\n\n   Creating Unicode\n       This section applies fully to Perls starting with v5.22.  Various\n       caveats for earlier releases are in the \"Earlier releases caveats\"\n       subsection below."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can Perl be used to create Unicode on EBCDIC platforms?
  manpageQuestion3: What is the difference between UTF-8 and UTF-EBCDIC in the context of Perl on EBCDIC platforms?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nTo create Unicode characters in literals, use the \"\\N{...}\" notation in\n       double-quoted strings:\n\n\tmy $smiley_from_name = \"\\N{WHITE SMILING FACE}\";\n\tmy $smiley_from_code_point = \"\\N{U+263a}\";\n\n       Similarly, they can be used in regular expression literals\n\n\t$smiley =~ /\\N{WHITE SMILING FACE}/;\n\t$smiley =~ /\\N{U+263a}/;\n\n       or, starting in v5.32:\n\n\t$smiley =~ /\\p{Name=WHITE SMILING FACE}/;\n\t$smiley =~ /\\p{Name=whitesmilingface}/;\n\n       At run-time you can use:\n\n\tuse charnames ();\n\tmy $hebrew_alef_from_name\n\t\t\t     = charnames::string_vianame(\"HEBREW LETTER ALEF\");\n\tmy $hebrew_alef_from_code_point = charnames::string_vianame(\"U+05D0\");\n\n       Naturally, \"ord()\" will do the reverse: it turns a character into a\n       code point.\n\n       There are other runtime options as well.  You can use \"pack()\":\n\n\tmy $hebrew_alef_from_code_point = pack(\"U\", 0x05d0);\n\n       Or you can use \"chr()\", though it is less convenient in the general\n       case:\n\n\t$hebrew_alef_from_code_point = chr(utf8::unicode_to_native(0x05d0));\n\tutf8::upgrade($hebrew_alef_from_code_point);"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you create a Unicode character in a Perl string using the \\
  manpageQuestion3: Can you demonstrate how to convert a Unicode character to its code point using the ord() function in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nThe \"utf8::unicode_to_native()\" and \"utf8::upgrade()\" aren't needed if\n       the argument is above 0xFF, so the above could have been written as\n\n\t$hebrew_alef_from_code_point = chr(0x05d0);\n\n       since 0x5d0 is above 255.\n\n       \"\\x{}\" and \"\\o{}\" can also be used to specify code points at compile\n       time in double-quotish strings, but, for backward compatibility with\n       older Perls, the same rules apply as with \"chr()\" for code points less\n       than 256.\n\n       \"utf8::unicode_to_native()\" is used so that the Perl code is portable\n       to EBCDIC platforms.  You can omit it if you're really sure no one will\n       ever want to use your code on a non-ASCII platform.  Starting in Perl\n       v5.22, calls to it on ASCII platforms are optimized out, so there's no\n       performance penalty at all in adding it.  Or you can simply use the\n       other constructs that don't require it.\n\n       See \"Further Resources\" for how to find all these names and numeric\n       codes.\n\n       Earlier releases caveats"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you convert a Unicode code point to its corresponding character in Perl without using the utf8::unicode_to_native() function?
  manpageQuestion3: What is the recommended way to handle Unicode code points greater than 0xFF in Perl for ensuring portability across different character encodings?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nOn EBCDIC platforms, prior to v5.22, using \"\\N{U+...}\" doesn't work\n       properly.\n\n       Prior to v5.16, using \"\\N{...}\" with a character name (as opposed to a\n       \"U+...\" code point) required a \"use charnames :full\".\n\n       Prior to v5.14, there were some bugs in \"\\N{...}\" with a character name\n       (as opposed to a \"U+...\" code point).\n\n       \"charnames::string_vianame()\" was introduced in v5.14.  Prior to that,\n       \"charnames::vianame()\" should work, but only if the argument is of the\n       form \"U+...\".  Your best bet there for runtime Unicode by character\n       name is probably:\n\n\tuse charnames ();\n\tmy $hebrew_alef_from_name\n\t\t\t = pack(\"U\", charnames::vianame(\"HEBREW LETTER ALEF\"));\n\n   Handling Unicode\n       Handling Unicode is for the most part transparent: just use the strings\n       as usual.  Functions like \"index()\", \"length()\", and \"substr()\" will\n       work on the Unicode characters; regular expressions will work on the\n       Unicode characters (see perlunicode and perlretut)."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use perluniintro to convert a Unicode character name, such as 'HEBREW LETTER ALEF', into its corresponding Unicode code point?
  manpageQuestion3: What is the recommended method for handling Unicode characters by their names in Perl versions prior to 5.14?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nNote that Perl considers grapheme clusters to be separate characters,\n       so for example\n\n\tprint length(\"\\N{LATIN CAPITAL LETTER A}\\N{COMBINING ACUTE ACCENT}\"),\n\t      \"\\n\";\n\n       will print 2, not 1.  The only exception is that regular expressions\n       have \"\\X\" for matching an extended grapheme cluster.  (Thus \"\\X\" in a\n       regular expression would match the entire sequence of both the example\n       characters.)\n\n       Life is not quite so transparent, however, when working with legacy\n       encodings, I/O, and certain special cases:\n\n   Legacy Encodings\n       When you combine legacy data and Unicode, the legacy data needs to be\n       upgraded to Unicode.  Normally the legacy data is assumed to be ISO\n       8859-1 (or EBCDIC, if applicable).\n\n       The \"Encode\" module knows about many encodings and has interfaces for\n       doing conversions between those encodings:\n\n\t   use Encode 'decode';\n\t   $data = decode(\"iso-8859-3\", $data); # convert from legacy\n\n   Unicode I/O\n       Normally, writing out Unicode data"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How would you use the Encode module to convert legacy ISO 8859-3 encoded data into Unicode?
  manpageQuestion3: Can you provide an example of how to handle grapheme clusters in Perl when processing Unicode text?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nprint FH $some_string_with_unicode, \"\\n\";\n\n       produces raw bytes that Perl happens to use to internally encode the\n       Unicode string.\tPerl's internal encoding depends on the system as well\n       as what characters happen to be in the string at the time. If any of\n       the characters are at code points 0x100 or above, you will get a\n       warning.  To ensure that the output is explicitly rendered in the\n       encoding you desire--and to avoid the warning--open the stream with the\n       desired encoding. Some examples:\n\n\t   open FH, \">:utf8\", \"file\";\n\n\t   open FH, \">:encoding(ucs2)\",      \"file\";\n\t   open FH, \">:encoding(UTF-8)\",     \"file\";\n\t   open FH, \">:encoding(shift_jis)\", \"file\";\n\n       and on already open streams, use \"binmode()\":\n\n\t   binmode(STDOUT, \":utf8\");\n\n\t   binmode(STDOUT, \":encoding(ucs2)\");\n\t   binmode(STDOUT, \":encoding(UTF-8)\");\n\t   binmode(STDOUT, \":encoding(shift_jis)\");\n\n       The matching of encoding names is loose: case does not matter, and many\n       encodings have several aliases.\tNote that the \":utf8\" layer must\n       always be specified exactly like that; it is not subject to the loose\n       matching of encoding names. Also note that currently \":utf8\" is unsafe\n       for input, because it accepts the data without validating that it is\n       indeed valid UTF-8; you should instead use \":encoding(UTF-8)\" (with or\n       without a hyphen)."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How would you use perluniintro to ensure that a file is written in UTF-8 encoding?
  manpageQuestion3: Can you provide an example of using perluniintro to set the encoding for standard output to UCS-2?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nSee PerlIO for the \":utf8\" layer, PerlIO::encoding and Encode::PerlIO\n       for the \":encoding()\" layer, and Encode::Supported for many encodings\n       supported by the \"Encode\" module.\n\n       Reading in a file that you know happens to be encoded in one of the\n       Unicode or legacy encodings does not magically turn the data into\n       Unicode in Perl's eyes.\tTo do that, specify the appropriate layer when\n       opening files\n\n\t   open(my $fh,'<:encoding(UTF-8)', 'anything');\n\t   my $line_of_unicode = <$fh>;\n\n\t   open(my $fh,'<:encoding(Big5)', 'anything');\n\t   my $line_of_unicode = <$fh>;\n\n       The I/O layers can also be specified more flexibly with the \"open\"\n       pragma.\tSee open, or look at the following example.\n\n\t   use open ':encoding(UTF-8)'; # input/output default encoding will be\n\t\t\t\t\t# UTF-8\n\t   open X, \">file\";\n\t   print X chr(0x100), \"\\n\";\n\t   close X;\n\t   open Y, \"<file\";\n\t   printf \"%#x\\n\", ord(<Y>); # this should print 0x100\n\t   close Y;\n\n       With the \"open\" pragma you can use the \":locale\" layer"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use the perluniintro tool to read a file encoded in UTF-8 and convert its contents into Unicode in Perl?
  manpageQuestion3: Can you provide an example of using the perluniintro resource to write a file with UTF-8 encoded characters and then read it back to verify the encoding?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nBEGIN { $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R' }\n\t   # the :locale will probe the locale environment variables like\n\t   # LC_ALL\n\t   use open OUT => ':locale'; # russki parusski\n\t   open(O, \">koi8\");\n\t   print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1\n\t   close O;\n\t   open(I, \"<koi8\");\n\t   printf \"%#x\\n\", ord(<I>), \"\\n\"; # this should print 0xc1\n\t   close I;\n\n       These methods install a transparent filter on the I/O stream that\n       converts data from the specified encoding when it is read in from the\n       stream.\tThe result is always Unicode.\n\n       The open pragma affects all the \"open()\" calls after the pragma by\n       setting default layers.\tIf you want to affect only certain streams,\n       use explicit layers directly in the \"open()\" call.\n\n       You can switch encodings on an already opened stream by using\n       \"binmode()\"; see \"binmode\" in perlfunc.\n\n       The \":locale\" does not currently work with \"open()\" and \"binmode()\",\n       only with the \"open\" pragma.  The \":utf8\" and \":encoding(...)\" methods\n       do work with all of \"open()\", \"binmode()\", and the \"open\" pragma."
  manpageQuestion1: What is the primary purpose of the perluniintro script?
  manpageQuestion2: How can you use the :locale layer in perluniintro to read and write KOI8-R encoded text files?
  manpageQuestion3: Can you provide an example of using the :encoding method in perluniintro to switch the encoding of an already opened file stream?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nSimilarly, you may use these I/O layers on output streams to\n       automatically convert Unicode to the specified encoding when it is\n       written to the stream. For example, the following snippet copies the\n       contents of the file \"text.jis\" (encoded as ISO-2022-JP, aka JIS) to\n       the file \"text.utf8\", encoded as UTF-8:\n\n\t   open(my $nihongo, '<:encoding(iso-2022-jp)', 'text.jis');\n\t   open(my $unicode, '>:utf8',\t\t\t'text.utf8');\n\t   while (<$nihongo>) { print $unicode $_ }\n\n       The naming of encodings, both by the \"open()\" and by the \"open\" pragma\n       allows for flexible names: \"koi8-r\" and \"KOI8R\" will both be\n       understood.\n\n       Common encodings recognized by ISO, MIME, IANA, and various other\n       standardisation organisations are recognised; for a more detailed list\n       see Encode::Supported.\n\n       \"read()\" reads characters and returns the number of characters.\n       \"seek()\" and \"tell()\" operate on byte counts, as does \"sysseek()\".\n\n       \"sysread()\" and \"syswrite()\" should not be used on file handles with\n       character encoding layers, they behave badly, and that behaviour has\n       been deprecated since perl 5.24."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use the perluniintro resource to convert a file encoded in ISO-2022-JP to UTF-8?
  manpageQuestion3: What are some common encoding names that can be used with the perluniintro resource?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nNotice that because of the default behaviour of not doing any\n       conversion upon input if there is no default layer, it is easy to\n       mistakenly write code that keeps on expanding a file by repeatedly\n       encoding the data:\n\n\t   # BAD CODE WARNING\n\t   open F, \"file\";\n\t   local $/; ## read in the whole file of 8-bit characters\n\t   $t = <F>;\n\t   close F;\n\t   open F, \">:encoding(UTF-8)\", \"file\";\n\t   print F $t; ## convert to UTF-8 on output\n\t   close F;\n\n       If you run this code twice, the contents of the file will be twice\n       UTF-8 encoded.  A \"use open ':encoding(UTF-8)'\" would have avoided the\n       bug, or explicitly opening also the file for input as UTF-8.\n\n       NOTE: the \":utf8\" and \":encoding\" features work only if your Perl has\n       been built with PerlIO, which is the default on most systems.\n\n   Displaying Unicode As Text\n       Sometimes you might want to display Perl scalars containing Unicode as\n       simple ASCII (or EBCDIC) text.  The following subroutine converts its\n       argument so that Unicode characters with code points greater than 255\n       are displayed as \"\\x{...}\", control characters (like \"\\n\") are\n       displayed as \"\\x..\", and the rest of the characters as themselves:"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you avoid repeatedly encoding a file in Perl when using the :encoding feature?
  manpageQuestion3: Can you provide an example of a subroutine that converts Unicode characters in a Perl scalar to ASCII-like text representation?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nsub nice_string {\n\t       join(\"\",\n\t       map { $_ > 255\t\t\t # if wide character...\n\t\t     ? sprintf(\"\\\\x{%04X}\", $_)  # \\x{...}\n\t\t     : chr($_) =~ /[[:cntrl:]]/  # else if control character...\n\t\t       ? sprintf(\"\\\\x%02X\", $_)  # \\x..\n\t\t       : quotemeta(chr($_))\t # else quoted or as themselves\n\t       } unpack(\"W*\", $_[0]));\t\t # unpack Unicode characters\n\t  }\n\n       For example,\n\n\t  nice_string(\"foo\\x{100}bar\\n\")\n\n       returns the string\n\n\t  'foo\\x{0100}bar\\x0A'\n\n       which is ready to be printed.\n\n       (\"\\\\x{}\" is used here instead of \"\\\\N{}\", since it's most likely that\n       you want to see what the native values are.)\n\n   Special Cases\n       •   Starting in Perl 5.28, it is illegal for bit operators, like \"~\",\n\t   to operate on strings containing code points above 255.\n\n       •   The vec() function may produce surprising results if used on\n\t   strings containing characters with ordinal values above 255. In\n\t   such a case, the results are consistent with the internal encoding\n\t   of the characters, but not with much else. So don't do that, and\n\t   starting in Perl 5.28, a deprecation message is issued if you do\n\t   so, becoming illegal in Perl 5.32."
  manpageQuestion1: What is the primary purpose of the perluniintro script or function?
  manpageQuestion2: How can you use the nice_string function to handle a Unicode string containing both control characters and wide characters?
  manpageQuestion3: What are the special considerations when using Perl 5.28 or later with strings containing Unicode code points above 255?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\n•   Peeking At Perl's Internal Encoding\n\n\t   Normal users of Perl should never care how Perl encodes any\n\t   particular Unicode string (because the normal ways to get at the\n\t   contents of a string with Unicode--via input and output--should\n\t   always be via explicitly-defined I/O layers). But if you must,\n\t   there are two ways of looking behind the scenes.\n\n\t   One way of peeking inside the internal encoding of Unicode\n\t   characters is to use \"unpack(\"C*\", ...\" to get the bytes of\n\t   whatever the string encoding happens to be, or \"unpack(\"U0..\",\n\t   ...)\" to get the bytes of the UTF-8 encoding:\n\n\t       # this prints  c4 80  for the UTF-8 bytes 0xc4 0x80\n\t       print join(\" \", unpack(\"U0(H2)*\", pack(\"U\", 0x100))), \"\\n\";\n\n\t   Yet another way would be to use the Devel::Peek module:\n\n\t       perl -MDevel::Peek -e 'Dump(chr(0x100))'\n\n\t   That shows the \"UTF8\" flag in FLAGS and both the UTF-8 bytes and\n\t   Unicode characters in \"PV\".\tSee also later in this document the\n\t   discussion about the \"utf8::is_utf8()\" function."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use Perl to inspect the internal encoding of a Unicode string using unpack?
  manpageQuestion3: Can you provide an example of using the Devel::Peek module to examine the internal representation of a Unicode character in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nAdvanced Topics\n       •   String Equivalence\n\n\t   The question of string equivalence turns somewhat complicated in\n\t   Unicode: what do you mean by \"equal\"?\n\n\t   (Is \"LATIN CAPITAL LETTER A WITH ACUTE\" equal to \"LATIN CAPITAL\n\t   LETTER A\"?)\n\n\t   The short answer is that by default Perl compares equivalence\n\t   (\"eq\", \"ne\") based only on code points of the characters.  In the\n\t   above case, the answer is no (because 0x00C1 != 0x0041).  But\n\t   sometimes, any CAPITAL LETTER A's should be considered equal, or\n\t   even A's of any case.\n\n\t   The long answer is that you need to consider character\n\t   normalization and casing issues: see Unicode::Normalize, Unicode\n\t   Technical Report #15, Unicode Normalization Forms\n\t   <https://www.unicode.org/unicode/reports/tr15> and sections on case\n\t   mapping in the Unicode Standard <https://www.unicode.org>.\n\n\t   As of Perl 5.8.0, the \"Full\" case-folding of Case\n\t   Mappings/SpecialCasing is implemented, but bugs remain in \"qr//i\"\n\t   with them, mostly fixed by 5.14, and essentially entirely by 5.18."
  manpageQuestion1: What is the primary purpose of the perluniintro tool?
  manpageQuestion2: How can you compare two Unicode strings in Perl to check if they are equivalent, considering case and normalization?
  manpageQuestion3: What steps should be taken in Perl to ensure that strings with different Unicode representations but equivalent meanings are considered equal?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\n•   String Collation\n\n\t   People like to see their strings nicely sorted--or as Unicode\n\t   parlance goes, collated.  But again, what do you mean by collate?\n\n\t   (Does \"LATIN CAPITAL LETTER A WITH ACUTE\" come before or after\n\t   \"LATIN CAPITAL LETTER A WITH GRAVE\"?)\n\n\t   The short answer is that by default, Perl compares strings (\"lt\",\n\t   \"le\", \"cmp\", \"ge\", \"gt\") based only on the code points of the\n\t   characters.\tIn the above case, the answer is \"after\", since 0x00C1\n\t   > 0x00C0.\n\n\t   The long answer is that \"it depends\", and a good answer cannot be\n\t   given without knowing (at the very least) the language context.\n\t   See Unicode::Collate, and Unicode Collation Algorithm\n\t   <https://www.unicode.org/unicode/reports/tr10/>\n\n   Miscellaneous\n       •   Character Ranges and Classes\n\n\t   Character ranges in regular expression bracketed character classes\n\t   ( e.g., \"/[a-z]/\") and in the \"tr///\" (also known as \"y///\")\n\t   operator are not magically Unicode-aware.  What this means is that\n\t   \"[A-Za-z]\" will not magically start to mean \"all alphabetic\n\t   letters\" (not that it does mean that even for 8-bit characters; for\n\t   those, if you are using locales (perllocale), use \"/[[:alpha:]]/\";\n\t   and if not, use the 8-bit-aware property \"\\p{alpha}\")."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you modify a regular expression to match all Unicode alphabetic characters in a string?
  manpageQuestion3: What is the difference between using [A-Za-z] and \\p{alpha} in regular expressions for matching Unicode characters?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nAll the properties that begin with \"\\p\" (and its inverse \"\\P\") are\n\t   actually character classes that are Unicode-aware.  There are\n\t   dozens of them, see perluniprops.\n\n\t   Starting in v5.22, you can use Unicode code points as the end\n\t   points of regular expression pattern character ranges, and the\n\t   range will include all Unicode code points that lie between those\n\t   end points, inclusive.\n\n\t    qr/ [ \\N{U+03} - \\N{U+20} ] /xx\n\n\t   includes the code points \"\\N{U+03}\", \"\\N{U+04}\", ..., \"\\N{U+20}\".\n\n\t   This also works for ranges in \"tr///\" starting in Perl v5.24.\n\n       •   String-To-Number Conversions\n\n\t   Unicode does define several other decimal--and numeric--characters\n\t   besides the familiar 0 to 9, such as the Arabic and Indic digits.\n\t   Perl does not support string-to-number conversion for digits other\n\t   than ASCII 0 to 9 (and ASCII \"a\" to \"f\" for hexadecimal).  To get\n\t   safe conversions from any Unicode string, use \"num()\" in\n\t   Unicode::UCD.\n\n   Questions With Answers\n       •   Will My Old Scripts Break?"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use Perl to match any Unicode character in the range from U+03 to U+20?
  manpageQuestion3: What is the recommended method for safely converting a Unicode string to a number in Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nVery probably not.  Unless you are generating Unicode characters\n\t   somehow, old behaviour should be preserved.\tAbout the only\n\t   behaviour that has changed and which could start generating Unicode\n\t   is the old behaviour of \"chr()\" where supplying an argument more\n\t   than 255 produced a character modulo 255.  \"chr(300)\", for example,\n\t   was equal to \"chr(45)\" or \"-\" (in ASCII), now it is LATIN CAPITAL\n\t   LETTER I WITH BREVE.\n\n       •   How Do I Make My Scripts Work With Unicode?\n\n\t   Very little work should be needed since nothing changes until you\n\t   generate Unicode data.  The most important thing is getting input\n\t   as Unicode; for that, see the earlier I/O discussion.  To get full\n\t   seamless Unicode support, add \"use feature 'unicode_strings'\" (or\n\t   \"use 5.012\" or higher) to your script.\n\n       •   How Do I Know Whether My String Is In Unicode?\n\n\t   You shouldn't have to care.\tBut you may if your Perl is before\n\t   5.14.0 or you haven't specified \"use feature 'unicode_strings'\" or\n\t   \"use 5.012\" (or higher) because otherwise the rules for the code\n\t   points in the range 128 to 255 are different depending on whether\n\t   the string they are contained within is in Unicode or not.  (See\n\t   \"When Unicode Does Not Happen\" in perlunicode.)"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can I ensure that my Perl script handles Unicode correctly according to the perluniintro documentation?
  manpageQuestion3: What is the difference in behavior between Perl versions before 5.14.0 and after regarding Unicode string handling?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nTo determine if a string is in Unicode, use:\n\n\t       print utf8::is_utf8($string) ? 1 : 0, \"\\n\";\n\n\t   But note that this doesn't mean that any of the characters in the\n\t   string are necessary UTF-8 encoded, or that any of the characters\n\t   have code points greater than 0xFF (255) or even 0x80 (128), or\n\t   that the string has any characters at all.  All the \"is_utf8()\"\n\t   does is to return the value of the internal \"utf8ness\" flag\n\t   attached to the $string.  If the flag is off, the bytes in the\n\t   scalar are interpreted as a single byte encoding.  If the flag is\n\t   on, the bytes in the scalar are interpreted as the (variable-\n\t   length, potentially multi-byte) UTF-8 encoded code points of the\n\t   characters.\tBytes added to a UTF-8 encoded string are\n\t   automatically upgraded to UTF-8.  If mixed non-UTF-8 and UTF-8\n\t   scalars are merged (double-quoted interpolation, explicit\n\t   concatenation, or printf/sprintf parameter substitution), the\n\t   result will be UTF-8 encoded as if copies of the byte strings were\n\t   upgraded to UTF-8: for example,"
  manpageQuestion1: What is the primary purpose of the perluniintro tool?
  manpageQuestion2: How can you check if a string is in Unicode format using perluniintro?
  manpageQuestion3: What does the 'utf8::is_utf8' function in perluniintro do and how is it used?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\n$a = \"ab\\x80c\";\n\t       $b = \"\\x{100}\";\n\t       print \"$a = $b\\n\";\n\n\t   the output string will be UTF-8-encoded \"ab\\x80c = \\x{100}\\n\", but\n\t   $a will stay byte-encoded.\n\n\t   Sometimes you might really need to know the byte length of a string\n\t   instead of the character length. For that use the \"bytes\" pragma\n\t   and the \"length()\" function:\n\n\t       my $unicode = chr(0x100);\n\t       print length($unicode), \"\\n\"; # will print 1\n\t       use bytes;\n\t       print length($unicode), \"\\n\"; # will print 2\n\t\t\t\t\t     # (the 0xC4 0x80 of the UTF-8)\n\t       no bytes;\n\n       •   How Do I Find Out What Encoding a File Has?\n\n\t   You might try Encode::Guess, but it has a number of limitations.\n\n       •   How Do I Detect Data That's Not Valid In a Particular Encoding?\n\n\t   Use the \"Encode\" package to try converting it.  For example,\n\n\t       use Encode 'decode';\n\n\t       if (eval { decode('UTF-8', $string, Encode::FB_CROAK); 1 }) {\n\t\t   # $string is valid UTF-8\n\t       } else {\n\t\t   # $string is not valid UTF-8\n\t       }"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you determine if a string is valid UTF-8 encoding using the Encode module?
  manpageQuestion3: Can you provide an example of how to use the 'bytes' pragma to find the byte length of a Unicode string?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nOr use \"unpack\" to try decoding it:\n\n\t       use warnings;\n\t       @chars = unpack(\"C0U*\", $string_of_bytes_that_I_think_is_utf8);\n\n\t   If invalid, a \"Malformed UTF-8 character\" warning is produced. The\n\t   \"C0\" means \"process the string character per character\".  Without\n\t   that, the \"unpack(\"U*\", ...)\" would work in \"U0\" mode (the default\n\t   if the format string starts with \"U\") and it would return the bytes\n\t   making up the UTF-8 encoding of the target string, something that\n\t   will always work.\n\n       •   How Do I Convert Binary Data Into a Particular Encoding, Or Vice\n\t   Versa?\n\n\t   This probably isn't as useful as you might think.  Normally, you\n\t   shouldn't need to.\n\n\t   In one sense, what you are asking doesn't make much sense:\n\t   encodings are for characters, and binary data are not \"characters\",\n\t   so converting \"data\" into some encoding isn't meaningful unless you\n\t   know in what character set and encoding the binary data is in, in\n\t   which case it's not just binary data, now is it?"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can I use Perl to decode a binary string into UTF-8 characters using the unpack function?
  manpageQuestion3: What is the difference between using 'C0U*' and 'U*' in the unpack function for decoding binary data?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nIf you have a raw sequence of bytes that you know should be\n\t   interpreted via a particular encoding, you can use \"Encode\":\n\n\t       use Encode 'from_to';\n\t       from_to($data, \"iso-8859-1\", \"UTF-8\"); # from latin-1 to UTF-8\n\n\t   The call to \"from_to()\" changes the bytes in $data, but nothing\n\t   material about the nature of the string has changed as far as Perl\n\t   is concerned.  Both before and after the call, the string $data\n\t   contains just a bunch of 8-bit bytes. As far as Perl is concerned,\n\t   the encoding of the string remains as \"system-native 8-bit bytes\".\n\n\t   You might relate this to a fictional 'Translate' module:\n\n\t      use Translate;\n\t      my $phrase = \"Yes\";\n\t      Translate::from_to($phrase, 'english', 'deutsch');\n\t      ## phrase now contains \"Ja\"\n\n\t   The contents of the string changes, but not the nature of the\n\t   string.  Perl doesn't know any more after the call than before that\n\t   the contents of the string indicates the affirmative.\n\n\t   Back to converting data.  If you have (or want) data in your\n\t   system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you\n\t   can use pack/unpack to convert to/from Unicode."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How would you use the Encode module in Perl to convert a string from ISO-8859-1 encoding to UTF-8?
  manpageQuestion3: Can you provide an example of using pack/unpack in Perl to convert a string from system-native 8-bit encoding to Unicode?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\n$native_string  = pack(\"W*\", unpack(\"U*\", $Unicode_string));\n\t       $Unicode_string = pack(\"U*\", unpack(\"W*\", $native_string));\n\n\t   If you have a sequence of bytes you know is valid UTF-8, but Perl\n\t   doesn't know it yet, you can make Perl a believer, too:\n\n\t       $Unicode = $bytes;\n\t       utf8::decode($Unicode);\n\n\t   or:\n\n\t       $Unicode = pack(\"U0a*\", $bytes);\n\n\t   You can find the bytes that make up a UTF-8 sequence with\n\n\t       @bytes = unpack(\"C*\", $Unicode_string)\n\n\t   and you can create well-formed Unicode with\n\n\t       $Unicode_string = pack(\"U*\", 0xff, ...)\n\n       •   How Do I Display Unicode?  How Do I Input Unicode?\n\n\t   See <http://www.alanwood.net/unicode/> and\n\t   <http://www.cl.cam.ac.uk/~mgk25/unicode.html>\n\n       •   How Does Unicode Work With Traditional Locales?\n\n\t   If your locale is a UTF-8 locale, starting in Perl v5.26, Perl\n\t   works well for all categories; before this, starting with Perl\n\t   v5.20, it works for all categories but \"LC_COLLATE\", which deals\n\t   with sorting and the \"cmp\" operator.  But note that the standard\n\t   \"Unicode::Collate\" and \"Unicode::Collate::Locale\" modules offer\n\t   much more powerful solutions to collation issues, and work on\n\t   earlier releases."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can I convert a UTF-8 byte sequence into a Perl Unicode string?
  manpageQuestion3: What is the process for converting a Perl Unicode string back into its UTF-8 byte representation?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nFor other locales, starting in Perl 5.16, you can specify\n\n\t       use locale ':not_characters';\n\n\t   to get Perl to work well with them.\tThe catch is that you have to\n\t   translate from the locale character set to/from Unicode yourself.\n\t   See \"Unicode I/O\" above for how to\n\n\t       use open ':locale';\n\n\t   to accomplish this, but full details are in \"Unicode and UTF-8\" in\n\t   perllocale, including gotchas that happen if you don't specify\n\t   \":not_characters\".\n\n   Hexadecimal Notation\n       The Unicode standard prefers using hexadecimal notation because that\n       more clearly shows the division of Unicode into blocks of 256\n       characters.  Hexadecimal is also simply shorter than decimal.  You can\n       use decimal notation, too, but learning to use hexadecimal just makes\n       life easier with the Unicode standard.  The \"U+HHHH\" notation uses\n       hexadecimal, for example.\n\n       The \"0x\" prefix means a hexadecimal number, the digits are 0-9 and a-f\n       (or A-F, case doesn't matter).  Each hexadecimal digit represents four\n       bits, or half a byte.  \"print 0x..., \"\\n\"\" will show a hexadecimal\n       number in decimal, and \"printf \"%x\\n\", $decimal\" will show a decimal\n       number in hexadecimal.  If you have just the \"hex digits\" of a\n       hexadecimal number, you can use the \"hex()\" function."
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you use Perl to convert a hexadecimal value like 0x1A2B3C4D to its decimal equivalent using Perl's hexadecimal notation?
  manpageQuestion3: Can you provide an example of how to use Perl's 'hex()' function to convert a hexadecimal string like '1A2B3C4D' to a decimal number?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nprint 0x0009, \"\\n\";\t  # 9\n\t   print 0x000a, \"\\n\";\t  # 10\n\t   print 0x000f, \"\\n\";\t  # 15\n\t   print 0x0010, \"\\n\";\t  # 16\n\t   print 0x0011, \"\\n\";\t  # 17\n\t   print 0x0100, \"\\n\";\t  # 256\n\n\t   print 0x0041, \"\\n\";\t  # 65\n\n\t   printf \"%x\\n\",  65;\t  # 41\n\t   printf \"%#x\\n\", 65;\t  # 0x41\n\n\t   print hex(\"41\"), \"\\n\"; # 65\n\n   Further Resources\n       •   Unicode Consortium\n\n\t   <https://www.unicode.org/>\n\n       •   Unicode FAQ\n\n\t   <https://www.unicode.org/unicode/faq/>\n\n       •   Unicode Glossary\n\n\t   <https://www.unicode.org/glossary/>\n\n       •   Unicode Recommended Reading List\n\n\t   The Unicode Consortium has a list of articles and books, some of\n\t   which give a much more in depth treatment of Unicode:\n\t   <http://unicode.org/resources/readinglist.html>\n\n       •   Unicode Useful Resources\n\n\t   <https://www.unicode.org/unicode/onlinedat/resources.html>\n\n       •   Unicode and Multilingual Support in HTML, Fonts, Web Browsers and\n\t   Other Applications\n\n\t   <http://www.alanwood.net/unicode/>"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you convert the hexadecimal value 0x41 to its decimal equivalent using Perl?
  manpageQuestion3: Can you provide an example of converting the decimal number 65 to its hexadecimal representation using Perl?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\n•   UTF-8 and Unicode FAQ for Unix/Linux\n\n\t   <http://www.cl.cam.ac.uk/~mgk25/unicode.html>\n\n       •   Legacy Character Sets\n\n\t   <http://www.czyborra.com/> <http://www.eki.ee/letter/>\n\n       •   You can explore various information from the Unicode data files\n\t   using the \"Unicode::UCD\" module.\n\nUNICODE IN OLDER PERLS\n       If you cannot upgrade your Perl to 5.8.0 or later, you can still do\n       some Unicode processing by using the modules \"Unicode::String\",\n       \"Unicode::Map8\", and \"Unicode::Map\", available from CPAN. If you have\n       the GNU recode installed, you can also use the Perl front-end\n       \"Convert::Recode\" for character conversions.\n\n       The following are fast conversions from ISO 8859-1 (Latin-1) bytes to\n       UTF-8 bytes and back, the code works even with older Perl 5 versions.\n\n\t   # ISO 8859-1 to UTF-8\n\t   s/([\\x80-\\xFF])/chr(0xC0|ord($1)>>6).chr(0x80|ord($1)&0x3F)/eg;\n\n\t   # UTF-8 to ISO 8859-1\n\t   s/([\\xC2\\xC3])([\\x80-\\xBF])/chr(ord($1)<<6&0xC0|ord($2)&0x3F)/eg;"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can you convert a string from ISO 8859-1 encoding to UTF-8 using Perl on an older version of Perl?
  manpageQuestion3: What is a method for converting a UTF-8 encoded string back to ISO 8859-1 encoding in Perl, especially with older versions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perluniintro`.\n\n\n\nManpage text:\n\nSEE ALSO\n       perlunitut, perlunicode, Encode, open, utf8, bytes, perlretut, perlrun,\n       Unicode::Collate, Unicode::Normalize, Unicode::UCD\n\nACKNOWLEDGMENTS\n       Thanks to the kind readers of the perl5-porters@perl.org,\n       perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org\n       mailing lists for their valuable feedback.\n\nAUTHOR, COPYRIGHT, AND LICENSE\n       Copyright 2001-2011 Jarkko Hietaniemi <jhi@iki.fi>.  Now maintained by\n       Perl 5 Porters.\n\n       This document may be distributed under the same terms as Perl itself.\n\nperl v5.34.1\t\t\t  2022-02-19\t\t       PERLUNIINTRO(1)"
  manpageQuestion1: What is the primary purpose of the perluniintro resource?
  manpageQuestion2: How can the perluniintro tool be used to demonstrate Unicode concepts in a Perl script?
  manpageQuestion3: What is the general function of the perluniintro resource in relation to Perl's Unicode handling?

