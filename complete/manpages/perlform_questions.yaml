- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\nPERLFORM(1)\t       Perl Programmers Reference Guide \t   PERLFORM(1)\n\n\nNAME\n       perlform - Perl formats\n\nDESCRIPTION\n       Perl has a mechanism to help you generate simple reports and charts.\n       To facilitate this, Perl helps you code up your output page close to\n       how it will look when it's printed.  It can keep track of things like\n       how many lines are on a page, what page you're on, when to print page\n       headers, etc.  Keywords are borrowed from FORTRAN: format() to declare\n       and write() to execute; see their entries in perlfunc.  Fortunately,\n       the layout is much more legible, more like BASIC's PRINT USING\n       statement.  Think of it as a poor man's nroff(1).\n\n       Formats, like packages and subroutines, are declared rather than\n       executed, so they may occur at any point in your program.  (Usually\n       it's best to keep them all together though.) They have their own\n       namespace apart from all the other \"types\" in Perl.  This means that if\n       you have a function named \"Foo\", it is not the same thing as having a\n       format named \"Foo\".  However, the default name for the format\n       associated with a given filehandle is the same as the name of the\n       filehandle.  Thus, the default format for STDOUT is named \"STDOUT\", and\n       the default format for filehandle TEMP is named \"TEMP\".\tThey just look\n       the same.  They aren't.\n\n       Output record formats are declared as follows:\n\n\t   format NAME =\n\t   FORMLIST\n\t   .\n\n       If the name is omitted, format \"STDOUT\" is defined. A single \".\" in\n       column 1 is used to terminate a format.\tFORMLIST consists of a\n       sequence of lines, each of which may be one of three types:\n\n       1.  A comment, indicated by putting a '#' in the first column.\n\n       2.  A \"picture\" line giving the format for one output line.\n\n       3.  An argument line supplying values to plug into the previous picture\n\t   line.\n\n       Picture lines contain output field definitions, intermingled with\n       literal text. These lines do not undergo any kind of variable\n       interpolation.  Field definitions are made up from a set of characters,\n       for starting and extending a field to its desired width. This is the\n       complete set of characters for field definitions:\n\n\t  @    start of regular field\n\t  ^    start of special field\n\t  <    pad character for left justification\n\t  |    pad character for centering\n\t  >    pad character for right justification\n\t  #    pad character for a right-justified numeric field\n\t  0    instead of first #: pad number with leading zeroes\n\t  .    decimal point within a numeric field\n\t  ...  terminate a text field, show \"...\" as truncation evidence\n\t  @*   variable width field for a multi-line value\n\t  ^*   variable width field for next line of a multi-line value\n\t  ~    suppress line with all fields empty\n\t  ~~   repeat line until all fields are exhausted\n\n       Each field in a picture line starts with either \"@\" (at) or \"^\"\n       (caret), indicating what we'll call, respectively, a \"regular\" or\n       \"special\" field.  The choice of pad characters determines whether a\n       field is textual or numeric. The tilde operators are not part of a\n       field.  Let's look at the various possibilities in detail.\n\n   Text Fields\n       The length of the field is supplied by padding out the field with\n       multiple \"<\", \">\", or \"|\" characters to specify a non-numeric field\n       with, respectively, left justification, right justification, or\n       centering.  For a regular field, the value (up to the first newline) is\n       taken and printed according to the selected justification, truncating\n       excess characters.  If you terminate a text field with \"...\", three\n       dots will be shown if the value is truncated. A special text field may\n       be used to do rudimentary multi-line text block filling; see \"Using\n       Fill Mode\" for details.\n\n\t  Example:\n\t     format STDOUT =\n\t     @<<<<<<   @||||||\t @>>>>>>\n\t     \"left\",   \"middle\", \"right\"\n\t     .\n\t  Output:\n\t     left      middle\t right\n\n   Numeric Fields\n       Using \"#\" as a padding character specifies a numeric field, with right\n       justification. An optional \".\" defines the position of the decimal\n       point. With a \"0\" (zero) instead of the first \"#\", the formatted number\n       will be padded with leading zeroes if necessary.  A special numeric\n       field is blanked out if the value is undefined.\tIf the resulting value\n       would exceed the width specified the field is filled with \"#\" as\n       overflow evidence.\n\n\t  Example:\n\t     format STDOUT =\n\t     @###   @.###   @##.###  @###   @###   ^####\n\t      42,   3.1415,  undef,    0, 10000,   undef\n\t     .\n\t  Output:\n\t       42   3.142     0.000\t0   ####\n\n   The Field @* for Variable-Width Multi-Line Text\n       The field \"@*\" can be used for printing multi-line, nontruncated\n       values; it should (but need not) appear by itself on a line. A final\n       line feed is chomped off, but all other characters are emitted\n       verbatim.\n\n   The Field ^* for Variable-Width One-line-at-a-time Text\n       Like \"@*\", this is a variable-width field. The value supplied must be a\n       scalar variable. Perl puts the first line (up to the first \"\\n\") of the\n       text into the field, and then chops off the front of the string so that\n       the next time the variable is referenced, more of the text can be\n       printed.  The variable will not be restored.\n\n\t  Example:\n\t     $text = \"line 1\\nline 2\\nline 3\";\n\t     format STDOUT =\n\t     Text: ^*\n\t\t   $text\n\t     ~~    ^*\n\t\t   $text\n\t     .\n\t  Output:\n\t     Text: line 1\n\t\t   line 2\n\t\t   line 3\n\n   Specifying Values\n       The values are specified on the following format line in the same order\n       as the picture fields.  The expressions providing the values must be\n       separated by commas.  They are all evaluated in a list context before\n       the line is processed, so a single list expression could produce\n       multiple list elements.\tThe expressions may be spread out to more than\n       one line if enclosed in braces.\tIf so, the opening brace must be the\n       first token on the first line.  If an expression evaluates to a number\n       with a decimal part, and if the corresponding picture specifies that\n       the decimal part should appear in the output (that is, any picture\n       except multiple \"#\" characters without an embedded \".\"), the character\n       used for the decimal point is determined by the current LC_NUMERIC\n       locale if \"use locale\" is in effect.  This means that, if, for example,\n       the run-time environment happens to specify a German locale, \",\" will\n       be used instead of the default \".\".  See perllocale and \"WARNINGS\" for\n       more information.\n\n   Using Fill Mode\n       On text fields the caret enables a kind of fill mode.  Instead of an\n       arbitrary expression, the value supplied must be a scalar variable that\n       contains a text string.\tPerl puts the next portion of the text into\n       the field, and then chops off the front of the string so that the next\n       time the variable is referenced, more of the text can be printed.\n       (Yes, this means that the variable itself is altered during execution\n       of the write() call, and is not restored.)  The next portion of text is\n       determined by a crude line-breaking algorithm. You may use the carriage\n       return character (\"\\r\") to force a line break. You can change which\n       characters are legal to break on by changing the variable $: (that's\n       $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a\n       list of the desired characters.\n\n       Normally you would use a sequence of fields in a vertical stack\n       associated with the same scalar variable to print out a block of text.\n       You might wish to end the final field with the text \"...\", which will\n       appear in the output if the text was too long to appear in its\n       entirety.\n\n   Suppressing Lines Where All Fields Are Void\n       Using caret fields can produce lines where all fields are blank. You\n       can suppress such lines by putting a \"~\" (tilde) character anywhere in\n       the line.  The tilde will be translated to a space upon output.\n\n   Repeating Format Lines\n       If you put two contiguous tilde characters \"~~\" anywhere into a line,\n       the line will be repeated until all the fields on the line are\n       exhausted, i.e. undefined. For special (caret) text fields this will\n       occur sooner or later, but if you use a text field of the at variety,\n       the  expression you supply had better not give the same value every\n       time forever! (\"shift(@f)\" is a simple example that would work.)  Don't\n       use a regular (at) numeric field in such lines, because it will never\n       go blank.\n\n   Top of Form Processing\n       Top-of-form processing is by default handled by a format with the same\n       name as the current filehandle with \"_TOP\" concatenated to it.  It's\n       triggered at the top of each page.  See \"write\" in perlfunc.\n\n       Examples:\n\n\t# a report on the /etc/passwd file\n\tformat STDOUT_TOP =\n\t\t\t\tPasswd File\n\tName\t\t    Login    Office   Uid   Gid Home\n\t------------------------------------------------------------------\n\t.\n\tformat STDOUT =\n\t@<<<<<<<<<<<<<<<<<< @||||||| @<<<<<<@>>>> @>>>> @<<<<<<<<<<<<<<<<<\n\t$name,\t\t    $login,  $office,$uid,$gid, $home\n\t."
  manpageQuestion1: What is the primary purpose of the perlform tool?
  manpageQuestion2: How can you use perlform to format a report that displays user information from the /etc/passwd file?
  manpageQuestion3: Can you provide an example of using perlform to create a multi-line text output with variable-width fields?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\n# a report from a bug report form\n\tformat STDOUT_TOP =\n\t\t\t\tBug Reports\n\t@<<<<<<<<<<<<<<<<<<<<<<<     @|||\t  @>>>>>>>>>>>>>>>>>>>>>>>\n\t$system,\t\t      $%,\t  $date\n\t------------------------------------------------------------------\n\t.\n\tformat STDOUT =\n\tSubject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\t $subject\n\tIndex: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t       $index,\t\t\t     $description\n\tPriority: @<<<<<<<<<< Date: @<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\t  $priority,\t    $date,   $description\n\tFrom: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t      $from,\t\t\t     $description\n\tAssigned to: @<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\t     $programmer,\t     $description\n\t~\t\t\t\t     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\t\t\t\t     $description\n\t~\t\t\t\t     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\t\t\t\t     $description\n\t~\t\t\t\t     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\t\t\t\t     $description\n\t~\t\t\t\t     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\t\t\t\t     $description\n\t~\t\t\t\t     ^<<<<<<<<<<<<<<<<<<<<<<<...\n\t\t\t\t\t     $description\n\t."
  manpageQuestion1: What is the primary purpose of the perlform resource?
  manpageQuestion2: How can you use perlform to generate a bug report form with specific fields such as subject, index, priority, and date?
  manpageQuestion3: Can you provide an example of using perlform to format a report with fields like 'From', 'Assigned to', and multiple descriptions?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\nIt is possible to intermix print()s with write()s on the same output\n       channel, but you'll have to handle \"$-\" ($FORMAT_LINES_LEFT) yourself.\n\n   Format Variables\n       The current format name is stored in the variable $~ ($FORMAT_NAME),\n       and the current top of form format name is in $^ ($FORMAT_TOP_NAME).\n       The current output page number is stored in $% ($FORMAT_PAGE_NUMBER),\n       and the number of lines on the page is in $= ($FORMAT_LINES_PER_PAGE).\n       Whether to autoflush output on this handle is stored in $|\n       ($OUTPUT_AUTOFLUSH).  The string output before each top of page (except\n       the first) is stored in $^L ($FORMAT_FORMFEED).\tThese variables are\n       set on a per-filehandle basis, so you'll need to select() into a\n       different one to affect them:\n\n\t   select((select(OUTF),\n\t\t   $~ = \"My_Other_Format\",\n\t\t   $^ = \"My_Top_Format\"\n\t\t  )[0]);\n\n       Pretty ugly, eh?  It's a common idiom though, so don't be too surprised\n       when you see it.  You can at least use a temporary variable to hold the\n       previous filehandle: (this is a much better approach in general,\n       because not only does legibility improve, you now have an intermediary\n       stage in the expression to single-step the debugger through):"
  manpageQuestion1: What is the primary purpose of the perlform utility?
  manpageQuestion2: How can you change the format name for a filehandle in Perl using perlform?
  manpageQuestion3: Can you provide an example of how to set the top format name and adjust the output page number using perlform?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\n$ofh = select(OUTF);\n\t   $~ = \"My_Other_Format\";\n\t   $^ = \"My_Top_Format\";\n\t   select($ofh);\n\n       If you use the English module, you can even read the variable names:\n\n\t   use English;\n\t   $ofh = select(OUTF);\n\t   $FORMAT_NAME     = \"My_Other_Format\";\n\t   $FORMAT_TOP_NAME = \"My_Top_Format\";\n\t   select($ofh);\n\n       But you still have those funny select()s.  So just use the FileHandle\n       module.\tNow, you can access these special variables using lowercase\n       method names instead:\n\n\t   use FileHandle;\n\t   format_name\t   OUTF \"My_Other_Format\";\n\t   format_top_name OUTF \"My_Top_Format\";\n\n       Much better!\n\nNOTES\n       Because the values line may contain arbitrary expressions (for at\n       fields, not caret fields), you can farm out more sophisticated\n       processing to other functions, like sprintf() or one of your own.  For\n       example:\n\n\t   format Ident =\n\t       @<<<<<<<<<<<<<<<\n\t       &commify($n)\n\t   .\n\n       To get a real at or caret into the field, do this:\n\n\t   format Ident =\n\t   I have an @ here.\n\t\t   \"@\"\n\t   ."
  manpageQuestion1: What is the primary purpose of the perlform resource?
  manpageQuestion2: How can you set a custom format name for an output filehandle in perlform?
  manpageQuestion3: Can you provide an example of using perlform to format a number with commas as thousand separators in a specific format?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\nTo center a whole line of text, do something like this:\n\n\t   format Ident =\n\t   @|||||||||||||||||||||||||||||||||||||||||||||||\n\t\t   \"Some text line\"\n\t   .\n\n       There is no builtin way to say \"float this to the right hand side of\n       the page, however wide it is.\"  You have to specify where it goes.  The\n       truly desperate can generate their own format on the fly, based on the\n       current number of columns, and then eval() it:\n\n\t   $format  = \"format STDOUT = \\n\"\n\t\t    . '^' . '<' x $cols . \"\\n\"\n\t\t    . '$entry' . \"\\n\"\n\t\t    . \"\\t^\" . \"<\" x ($cols-8) . \"~~\\n\"\n\t\t    . '$entry' . \"\\n\"\n\t\t    . \".\\n\";\n\t   print $format if $Debugging;\n\t   eval $format;\n\t   die $@ if $@;\n\n       Which would generate a format looking something like this:\n\n\tformat STDOUT =\n\t^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t$entry\n\t\t^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~\n\t$entry\n\t.\n\n       Here's a little program that's somewhat like fmt(1):\n\n\tformat =\n\t^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ~~\n\t$_"
  manpageQuestion1: What is the primary purpose of the perlform tool?
  manpageQuestion2: How can you use perlform to center a line of text in a formatted output?
  manpageQuestion3: Can you provide an example of using perlformat to generate a custom format for a specific number of columns?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\n.\n\n\t$/ = '';\n\twhile (<>) {\n\t    s/\\s*\\n\\s*/ /g;\n\t    write;\n\t}\n\n   Footers\n       While $FORMAT_TOP_NAME contains the name of the current header format,\n       there is no corresponding mechanism to automatically do the same thing\n       for a footer.  Not knowing how big a format is going to be until you\n       evaluate it is one of the major problems.  It's on the TODO list.\n\n       Here's one strategy:  If you have a fixed-size footer, you can get\n       footers by checking $FORMAT_LINES_LEFT before each write() and print\n       the footer yourself if necessary.\n\n       Here's another strategy: Open a pipe to yourself, using \"open(MYSELF,\n       \"|-\")\" (see \"open\" in perlfunc) and always write() to MYSELF instead of\n       STDOUT. Have your child process massage its STDIN to rearrange headers\n       and footers however you like.  Not very convenient, but doable.\n\n   Accessing Formatting Internals\n       For low-level access to the formatting mechanism, you may use\n       formline() and access $^A (the $ACCUMULATOR variable) directly."
  manpageQuestion1: What is the primary purpose of the perlform utility?
  manpageQuestion2: How can you use perlform to process a file and ensure that headers are properly formatted without duplicate newlines?
  manpageQuestion3: What is a recommended approach for handling footers in perlform when the footer size is not known in advance?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\nFor example:\n\n\t   $str = formline <<'END', 1,2,3;\n\t   @<<<  @|||  @>>>\n\t   END\n\n\t   print \"Wow, I just stored '$^A' in the accumulator!\\n\";\n\n       Or to make an swrite() subroutine, which is to write() what sprintf()\n       is to printf(), do this:\n\n\t   use Carp;\n\t   sub swrite {\n\t       croak \"usage: swrite PICTURE ARGS\" unless @_;\n\t       my $format = shift;\n\t       $^A = \"\";\n\t       formline($format,@_);\n\t       return $^A;\n\t   }\n\n\t   $string = swrite(<<'END', 1, 2, 3);\n\tCheck me out\n\t@<<<  @|||  @>>>\n\tEND\n\t   print $string;\n\nWARNINGS\n       The lone dot that ends a format can also prematurely end a mail message\n       passing through a misconfigured Internet mailer (and based on\n       experience, such misconfiguration is the rule, not the exception).  So\n       when sending format code through mail, you should indent it so that the\n       format-ending dot is not on the left margin; this will prevent SMTP\n       cutoff.\n\n       Lexical variables (declared with \"my\") are not visible within a format\n       unless the format is declared within the scope of the lexical variable."
  manpageQuestion1: What is the primary purpose of the perlform module?
  manpageQuestion2: How can you use the perlform module to create a subroutine that formats and returns a string with specific values?
  manpageQuestion3: What is a common warning associated with using the perlform module when sending formatted content via email?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `perlform`.\n\n\n\nManpage text:\n\nIf a program's environment specifies an LC_NUMERIC locale and \"use\n       locale\" is in effect when the format is declared, the locale is used to\n       specify the decimal point character in formatted output.  Formatted\n       output cannot be controlled by \"use locale\" at the time when write() is\n       called. See perllocale for further discussion of locale handling.\n\n       Within strings that are to be displayed in a fixed-length text field,\n       each control character is substituted by a space. (But remember the\n       special meaning of \"\\r\" when using fill mode.) This is done to avoid\n       misalignment when control characters \"disappear\" on some output media.\n\nperl v5.34.1\t\t\t  2022-02-19\t\t\t   PERLFORM(1)"
  manpageQuestion1: What is the primary purpose of the perlform command?
  manpageQuestion2: How can you ensure that formatted output uses the locale's decimal point character when using perlform?
  manpageQuestion3: What is the effect of substituting control characters with spaces in perlform when displaying text in a fixed-length field?

