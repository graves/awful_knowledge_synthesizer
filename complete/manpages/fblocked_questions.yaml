- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `fblocked`.\n\n\n\nManpage text:\n\nfblocked(n)\t\t     Tcl Built-In Commands\t\t   fblocked(n)\n\n______________________________________________________________________________\n\nNAME\n       fblocked - Test whether the last input operation exhausted all\n       available input\n\nSYNOPSIS\n       fblocked channelId\n______________________________________________________________________________\n\n\nDESCRIPTION\n       The fblocked command returns 1 if the most recent input operation on\n       channelId returned less information than requested because all\n       available input was exhausted.  For example, if gets is invoked when\n       there are only three characters available for input and no end-of-line\n       sequence, gets returns an empty string and a subsequent call to\n       fblocked will return 1.\n\n       ChannelId must be an identifier for an open channel such as a Tcl\n       standard channel (stdin, stdout, or stderr), the return value from an\n       invocation of open or socket, or the result of a channel creation\n       command provided by a Tcl extension.\n\nEXAMPLE\n       The fblocked command is particularly useful when writing network\n       servers, as it allows you to write your code in a line-by-line style\n       without preventing the servicing of other connections.  This can be\n       seen in this simple echo-service:\n\n\t      # This is called whenever a new client connects to the server\n\t      proc connect {chan host port} {\n\t\t  set clientName [format <%s:%d> $host $port]\n\t\t  puts \"connection from $clientName\"\n\t\t  fconfigure $chan -blocking 0 -buffering line\n\t\t  fileevent $chan readable [list echoLine $chan $clientName]\n\t      }\n\n\t      # This is called whenever either at least one byte of input\n\t      # data is available, or the channel was closed by the client.\n\t      proc echoLine {chan clientName} {\n\t\t  gets $chan line\n\t\t  if {[eof $chan]} {\n\t\t      puts \"finishing connection from $clientName\"\n\t\t      close $chan\n\t\t  } elseif {![fblocked $chan]} {\n\t\t      # Didn't block waiting for end-of-line\n\t\t      puts \"$clientName - $line\"\n\t\t      puts $chan $line\n\t\t  }\n\t      }\n\n\t      # Create the server socket and enter the event-loop to wait\n\t      # for incoming connections...\n\t      socket -server connect 12345\n\t      vwait forever"
  manpageQuestion1: What is the primary purpose of the fblocked command in Tcl?
  manpageQuestion2: How can the fblocked command be used to determine if input is exhausted on a channel in a network server?
  manpageQuestion3: Can you provide an example of using the fblocked command in a Tcl script to handle client input?

- prompt: "You are playing the role of a college professor. Here is some text copied from the manpages of the macOS resource `fblocked`.\n\n\n\nManpage text:\n\nSEE ALSO\n       gets(n), open(n), read(n), socket(n), Tcl_StandardChannels(3)\n\n\nKEYWORDS\n       blocking, nonblocking\n\nTcl\t\t\t\t      7.5\t\t\t   fblocked(n)"
  manpageQuestion1: What is the primary purpose of the fblocked command?
  manpageQuestion2: How can you check if a file descriptor is in non-blocking mode using the fblocked command?
  manpageQuestion3: Can you provide an example of using the fblocked command to determine the blocking status of a socket file descriptor?

