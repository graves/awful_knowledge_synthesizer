- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `architecture page of the documentation provided by Helix`.



    Documentation text:

    | Crate           | Description                                                      |
    | -----------     | -----------                                                      |
    | helix-core      | Core editing primitives, functional.                             |
    | helix-lsp       | Language server client                                           |
    | helix-lsp-types | Language Server Protocol type definitions                        |
    | helix-dap       | Debug Adapter Protocol (DAP) client                              |
    | helix-loader    | Functions for building, fetching, and loading external resources |
    | helix-view      | UI abstractions for use in backends, imperative shell.           |
    | helix-term      | Terminal UI                                                      |
    | helix-tui       | TUI primitives, forked from tui-rs, inspired by Cursive          |


    This document contains a high-level overview of Helix internals.

    > NOTE: Use `cargo doc --open` for API documentation as well as dependency
    > documentation.
  documentationQuestion1: What is the primary purpose of the Helix architecture as outlined in the documentation?
  documentationQuestion2: How can a user utilize the `helix-loader` crate to load external resources into Helix?
  documentationQuestion3: What role does the `helix-view` crate play in the Helix architecture, and how is it utilized in different backends?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `architecture page of the documentation provided by Helix`.



    Documentation text:

    ## Core

    The core contains basic building blocks used to construct the editor. It is
    heavily based on [CodeMirror 6](https://codemirror.net/6/docs/). The primitives
    are functional: most operations won't modify data in place but instead return
    a new copy.

    The main data structure used for representing buffers is a `Rope`. We re-export
    the excellent [ropey](https://github.com/cessen/ropey) library. Ropes are cheap
    to clone, and allow us to easily make snapshots of a text state.

    Multiple selections are a core editing primitive. Document selections are
    represented by a `Selection`. Each `Range` in the selection consists of a moving
    `head` and an immovable `anchor`. A single cursor in the editor is simply
    a selection with a single range, with the head and the anchor in the same
    position.

    Ropes are modified by constructing an OT-like `Transaction`. It represents
    a single coherent change to the document and can be applied to the rope.
    A transaction can be inverted to produce an undo. Selections and marks can be
    mapped over a transaction to translate to a position in the new text state after
    applying the transaction.

    > NOTE: `Transaction::change`/`Transaction::change_by_selection` is the main
    > interface used to generate text edits.

    `Syntax` is the interface used to interact with tree-sitter ASTs for syntax
    highlighting and other features.
  documentationQuestion1: What is the primary purpose of the Core module in Helix, as described in the documentation?
  documentationQuestion2: How can you create a text edit transaction in Helix to modify a buffer's content, and what is the main interface used for this task?
  documentationQuestion3: What is the role of the `Rope` data structure in Helix, and how does it facilitate efficient text manipulation and snapshotting?

- prompt: "You are playing the role of a college professor. Here is some text copied from the `architecture page of the documentation provided by Helix`.\n\n\n\nDocumentation text:\n\n## View\n\nThe `view` layer was supposed to be a frontend-agnostic imperative library that\nwould build on top of `core` to provide the common editor logic. Currently it's\ntied to the terminal UI.\n\nA `Document` ties together the `Rope`, `Selection`(s), `Syntax`, document\n`History`, language server (etc.) into a comprehensive representation of an open\nfile.\n\nA `View` represents an open split in the UI. It holds the currently open\ndocument ID and other related state. Views encapsulate the gutter, status line,\ndiagnostics, and the inner area where the code is displayed.\n\n> NOTE: Multiple views are able to display the same document, so the document\n> contains selections for each view. To retrieve, `document.selection()` takes\n> a `ViewId`.\n\n`Info` is the autoinfo box that shows hints when awaiting another key with bindings\nlike `g` and `m`. It is attached to the viewport as a whole.\n\n`Surface` is like a buffer to which widgets draw themselves to, and the\nsurface is then rendered on the screen on each cycle.\n\n`Rect`s are areas (simply an x and y coordinate with the origin at the\nscreen top left and then a height and width) which are part of a\n`Surface`. They can be used to limit the area to which a `Component` can\nrender. For example if we wrap a `Markdown` component in a `Popup`\n(think the documentation popup with space+k), Markdown's render method\nwill get a Rect that is the exact size of the popup.\n\nWidgets are called `Component`s internally, and you can see most of them\nin `helix-term/src/ui`. Some components like `Popup` and `Overlay` can take\nother components as children.\n\n`Layer`s are how multiple components are displayed, and is simply a\n`Vec<Component>`. Layers are managed by the `Compositor`. On each top\nlevel render call, the compositor renders each component in the order\nthey were pushed into the stack. This makes multiple components \"layer\"\non top of one another. Hence we get a file picker displayed over the\neditor, etc.\n\nThe `Editor` holds the global state: all the open documents, a tree\nrepresentation of all the view splits, the configuration, and a registry of \nlanguage servers. To open or close files, interact with the editor."
  documentationQuestion1: What is the primary purpose of the `view` layer in the Helix editor architecture, and how does it interact with the terminal UI?
  documentationQuestion2: How can you use the `Popup` component in Helix to display a markdown document within a confined area of the screen, and what role does the `Rect` play in this process?
  documentationQuestion3: What is the function of the `Compositor` in managing the rendering of multiple components in Helix, and how does it ensure the correct layering of UI elements?

- prompt: "You are playing the role of a college professor. Here is some text copied from the `architecture page of the documentation provided by Helix`.\n\n\n\nDocumentation text:\n\n## LSP\n\nA language server protocol client.\n\n## Term\n\nThe terminal frontend.\n\nThe `main` function sets up a new `Application` that runs the event loop.\n\n`commands.rs` is probably the most interesting file. It contains all commands\n(actions tied to keybindings). \n\n`keymap.rs` links commands to key combinations.\n\n\n## TUI / Term\n\nTODO: document Component and rendering related stuff"
  documentationQuestion1: What are the primary purposes of the LSP and Term components in the Helix editor's architecture as described in the documentation?
  documentationQuestion2: How can a user customize keybindings in Helix to trigger specific commands, based on the structure described in the documentation?
  documentationQuestion3: What is the role of the `commands.rs` file in the Helix source code, and how does it contribute to the editor's functionality?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `releases page of the documentation provided by Helix`.



    Documentation text:

    ## Checklist

    Helix releases are versioned in the Calendar Versioning scheme:
    `YY.0M(.MICRO)`, for example, `22.05` for May of 2022, or in a patch release,
    `22.05.1`. In these instructions we'll use `<tag>` as a placeholder for the tag
    being published.

    * Merge the PR with the release updates. That branch should:
        * Update the version:
            * Update the `workspace.package.version` key in `Cargo.toml`. Cargo only accepts
              SemVer versions so a CalVer version of `22.07` for example must be formatted
              as `22.7.0`. Patch/bugfix releases should increment the SemVer patch number. A
              patch release for 22.07 would be `22.7.1`.
            * Run `cargo check` and commit the resulting change to `Cargo.lock`
        * Add changelog notes to `CHANGELOG.md`
        * Add new `<release>` entry in `contrib/Helix.appdata.xml` with release information according to the [AppStream spec](https://www.freedesktop.org/software/appstream/docs/sect-Metadata-Releases.html)
    * Tag and push
        * Switch to master and pull
        * `git tag -s -m "<tag>" -a <tag> && git push origin <tag>` (note the `-s` which signs the tag)
    * Wait for the Release CI to finish
        * It will automatically turn the git tag into a GitHub release when it uploads artifacts
    * Edit the new release
        * Use `<tag>` as the title
        * Link to the changelog and release notes
    * Merge the release notes PR
    * Download the macos and linux binaries and update the `sha256`s in the [homebrew formula]
        * Use `sha256sum` on the downloaded `.tar.xz` files to determine the hash
    * Link to the release notes in this-week-in-rust
        * [Example PR](https://github.com/rust-lang/this-week-in-rust/pull/3300)
    * Post to reddit
        * [Example post](https://www.reddit.com/r/rust/comments/uzp5ze/helix_editor_2205_released/)

    [homebrew formula]: https://github.com/Homebrew/homebrew-core/blob/master/Formula/h/helix.rb
  documentationQuestion1: What are the key purposes of the Calendar Versioning scheme used by Helix in its release process?
  documentationQuestion2: How can a developer update the version number in `Cargo.toml` for a Helix release, and what is the correct format for CalVer versions in SemVer?
  documentationQuestion3: What steps are involved in tagging and pushing a new release for Helix, including the command used to sign the tag?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `releases page of the documentation provided by Helix`.



    Documentation text:

    ## Changelog Curation

    The changelog is currently created manually by reading through commits in the
    log since the last release. GitHub's compare view is a nice way to approach
    this. For example, when creating the 22.07 release notes, this compare link
    may be used

    ```
    https://github.com/helix-editor/helix/compare/22.05...master
    ```

    Either side of the triple-dot may be replaced with an exact revision, so if
    you wish to incrementally compile the changelog, you can tackle a weeks worth
    or so, record the revision where you stopped, and use that as a starting point
    next week:

    ```
    https://github.com/helix-editor/helix/compare/7706a4a0d8b67b943c31d0c5f7b00d357b5d838d...master
    ```

    A work-in-progress commit for a changelog might look like
    [this example](https://github.com/helix-editor/helix/commit/831adfd4c709ca16b248799bfef19698d5175e55).

    Not every PR or commit needs a blurb in the changelog. Each release section
    tends to have a blurb that links to a GitHub comparison between release
    versions for convenience:

    > As usual, the following is a summary of each of the changes since the last
    > release. For the full log, check out the git log.

    Typically, small changes like dependencies or documentation updates, refactors,
    or meta changes like GitHub Actions work are left out.
  documentationQuestion1: What is the primary purpose of the changelog curation process described in the Helix documentation?
  documentationQuestion2: How can a user generate a changelog for a specific release version using the GitHub compare view, as demonstrated in the example?
  documentationQuestion3: What is the recommended approach for incrementally compiling a changelog over multiple sessions, according to the Helix documentation?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `vision page of the documentation provided by Helix`.



    Documentation text:

    The Helix project still has a ways to go before reaching its goals.  This document outlines some of those goals and the overall vision for the project.

    # Vision

    An efficient, batteries-included editor you can take anywhere and be productive... if it's your kind of thing.

    * **Cross-platform.**  Whether on Linux, Windows, or OSX, you should be able to take your editor with you.
    * **Terminal first.**  Not all environments have a windowing system, and you shouldn't have to abandon your preferred editor in those cases.
    * **Native.**  No Electron or HTML DOM here.  We want an efficient, native-compiled editor that can run with minimal resources when needed.  If you're working on a Raspberry Pi, your editor shouldn't consume half of your RAM.
    * **Batteries included.**  Both the default configuration and bundled features should be enough to have a good editing experience and be productive.  You shouldn't need a massive custom config or external executables and plugins for basic features and functionality.
    * **Don't try to be everything for everyone.**  There are many great editors out there to choose from.  Let's make Helix *one of* those great options, with its own take on things.
  documentationQuestion1: What is the main vision for the Helix project according to the provided documentation?
  documentationQuestion2: How can the cross-platform capability of Helix be leveraged to ensure productivity across different operating systems?
  documentationQuestion3: What does the 'batteries included' philosophy of Helix imply about its default configuration and bundled features?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `vision page of the documentation provided by Helix`.



    Documentation text:

    # Goals

    Vision statements are all well and good, but are also vague and subjective.  Here is a (non-exhaustive) list of some of Helix's more concrete goals, to help give a clearer idea of the project's direction:

    * **Modal.**  Vim is a great idea.
    * **Selection -> Action**, not Verb -> Object.  Interaction models aren't linguistics, and "selection first" lets you see what you're doing (among other benefits).
    * **We aren't playing code golf.**  It's more important for the keymap to be consistent and easy to memorize than it is to save a key stroke or two when editing.
    * **Built-in tools** for working with code bases efficiently.  Most projects aren't a single file, and an editor should handle that as a first-class use case.  In Helix's case, this means (among other things) a fuzzy-search file navigator and LSP support.
    * **Edit anything** that comes up when coding, within reason.  Whether it's a 200 MB XML file, a megabyte of minified javascript on a single line, or Japanese text encoded in ShiftJIS, you should be able to open it and edit it without problems.  (Note: this doesn't mean handle every esoteric use case.  Sometimes you do just need a specialized tool, and Helix isn't that.)
    * **Configurable**, within reason.  Although the defaults should be good, not everyone will agree on what "good" is.  Within the bounds of Helix's core interaction models, it should be reasonably configurable so that it can be "good" for more people.  This means, for example, custom key maps among other things.
    * **Extensible**, within reason.  Although we want Helix to be productive out-of-the-box, it's not practical or desirable to cram every useful feature and use case into the core editor.  The basics should be built-in, but you should be able to extend it with additional functionality as needed.
    * **Clean code base.**  Sometimes other factors (e.g. significant performance gains, important features, correctness, etc.) will trump strict readability, but we nevertheless want to keep the code base straightforward and easy to understand to the extent we can.
  documentationQuestion1: What are the primary goals of Helix as outlined in its documentation, and how do they reflect the project's design philosophy?
  documentationQuestion2: How can a user customize the keymap in Helix to suit their workflow, based on the project's emphasis on configurability?
  documentationQuestion3: What built-in tools does Helix provide for efficient code base navigation and management, and how do they align with its goals?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `CONTRIBUTING page of the documentation provided by Helix`.



    Documentation text:

    # Contributing

    Contributors are very welcome! **No contribution is too small and all contributions are valued.**

    Some suggestions to get started:

    - You can look at the [good first issue][good-first-issue] label on the issue tracker.
    - Help with packaging on various distributions needed!
    - To use print debugging to the [Helix log file][log-file], you must:
      * Print using `log::info!`, `warn!`, or `error!`. (`log::info!("helix!")`)
      * Pass the appropriate verbosity level option for the desired log level. (`hx -v <file>` for info, more `v`s for higher verbosity)
      * Want to display the logs in a separate file instead of using the `:log-open` command in your compiled Helix editor? Start your debug version with `cargo run -- --log foo.log` and in a new terminal use `tail -f foo.log`
    - Instead of running a release version of Helix, while developing you may want to run in debug mode with `cargo run` which is way faster to compile
    - Looking for even faster compile times? Give a try to [mold](https://github.com/rui314/mold)
    - If your preferred language is missing, integrating a tree-sitter grammar for
        it and defining syntax highlight queries for it is straightforward and
        doesn't require much knowledge of the internals.
    - If you don't use the Nix development shell and are getting your rust-analyzer binary from rustup, you may need to run `rustup component add rust-analyzer`.
      This is because `rust-toolchain.toml` selects our MSRV for the development toolchain but doesn't download the matching rust-analyzer automatically.

    We provide an [architecture.md][architecture.md] that should give you
    a good overview of the internals.
  documentationQuestion1: What are the primary purposes of the contributing guidelines in the Helix documentation?
  documentationQuestion2: How can a developer enable print debugging to the Helix log file using the specified logging macros and verbosity options?
  documentationQuestion3: What is the recommended approach for running Helix in debug mode with faster compile times, and how can a developer integrate a new programming language with syntax highlighting support?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `CONTRIBUTING page of the documentation provided by Helix`.



    Documentation text:

    # Auto generated documentation

    Some parts of [the book][docs] are autogenerated from the code itself,
    like the list of `:commands` and supported languages. To generate these
    files, run

    ```shell
    cargo xtask docgen
    ```

    inside the project. We use [xtask][xtask] as an ad-hoc task runner.

    To preview the book itself, install [mdbook][mdbook]. Then, run

    ```shell
    mdbook serve book
    ```

    and visit [http://localhost:3000](http://localhost:3000).

    # Testing

    ## Unit tests/Documentation tests

    Run `cargo test --workspace` to run unit tests and documentation tests in all packages.

    ## Integration tests

    Integration tests for helix-term can be run with `cargo integration-test`. Code
    contributors are strongly encouraged to write integration tests for their code.
    Existing tests can be used as examples. Helpers can be found in
    [helpers.rs][helpers.rs]. The log level can be set with the `HELIX_LOG_LEVEL`
    environment variable, e.g. `HELIX_LOG_LEVEL=debug cargo integration-test`.

    Contributors using MacOS might encounter `Too many open files (os error 24)`
    failures while running integration tests. This can be resolved by increasing
    the default value (e.g. to `10240` from `256`) by running `ulimit -n 10240`.

    ## Minimum Stable Rust Version (MSRV) Policy

    Helix keeps an intentionally low MSRV for the sake of easy building and packaging
    downstream. We follow [Firefox's MSRV policy]. Once Firefox's MSRV increases we
    may bump ours as well, but be sure to check that popular distributions like Ubuntu
    package the new MSRV version. When increasing the MSRV, update these three places:

    * the `workspace.package.rust-version` key in `Cargo.toml` in the repository root
    * the `env.MSRV` key at the top of `.github/workflows/build.yml`
    * the `toolchain.channel` key in `rust-toolchain.toml`

    [Firefox's MSRV policy]: https://firefox-source-docs.mozilla.org/writing-rust-code/update-policy.html
    [good-first-issue]: https://github.com/helix-editor/helix/labels/E-easy
    [log-file]: https://github.com/helix-editor/helix/wiki/FAQ#access-the-log-file
    [architecture.md]: ./architecture.md
    [docs]: https://docs.helix-editor.com/
    [xtask]: https://github.com/matklad/cargo-xtask
    [mdbook]: https://rust-lang.github.io/mdBook/guide/installation.html
    [helpers.rs]: ../helix-term/tests/test/helpers.rs
  documentationQuestion1: What is the primary purpose of the auto-generated documentation feature in Helix, and how does it benefit developers?
  documentationQuestion2: How can a contributor run integration tests for Helix, and what are the common workarounds for macOS-specific issues encountered during testing?
  documentationQuestion3: What steps should a developer take to update the Minimum Stable Rust Version (MSRV) in Helix, and why is this policy important for the project's maintainability?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | Name | Description |
    | --- | --- |
    | `:quit`, `:q` | Close the current view. |
    | `:quit!`, `:q!` | Force close the current view, ignoring unsaved changes. |
    | `:open`, `:o`, `:edit`, `:e` | Open a file from disk into the current view. |
    | `:buffer-close`, `:bc`, `:bclose` | Close the current buffer. |
    | `:buffer-close!`, `:bc!`, `:bclose!` | Close the current buffer forcefully, ignoring unsaved changes. |
    | `:buffer-close-others`, `:bco`, `:bcloseother` | Close all buffers but the currently focused one. |
    | `:buffer-close-others!`, `:bco!`, `:bcloseother!` | Force close all buffers but the currently focused one. |
    | `:buffer-close-all`, `:bca`, `:bcloseall` | Close all buffers without quitting. |
    | `:buffer-close-all!`, `:bca!`, `:bcloseall!` | Force close all buffers ignoring unsaved changes without quitting. |
    | `:buffer-next`, `:bn`, `:bnext` | Goto next buffer. |
    | `:buffer-previous`, `:bp`, `:bprev` | Goto previous buffer. |
    | `:write`, `:w` | Write changes to disk. Accepts an optional path (:write some/path.txt) |
  documentationQuestion1: What are the primary purposes of the buffer management commands in Helix's typable-cmd page?
  documentationQuestion2: How can you force close all buffers in Helix without saving any unsaved changes?
  documentationQuestion3: Provide an example of how to open a file named 'example.txt' in a new buffer using Helix's command syntax.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `:write!`, `:w!` | Force write changes to disk creating necessary subdirectories. Accepts an optional path (:write! some/path.txt) |
    | `:write-buffer-close`, `:wbc` | Write changes to disk and closes the buffer. Accepts an optional path (:write-buffer-close some/path.txt) |
    | `:write-buffer-close!`, `:wbc!` | Force write changes to disk creating necessary subdirectories and closes the buffer. Accepts an optional path (:write-buffer-close! some/path.txt) |
    | `:new`, `:n` | Create a new scratch buffer. |
    | `:format`, `:fmt` | Format the file using an external formatter or language server. |
    | `:indent-style` | Set the indentation style for editing. ('t' for tabs or 1-16 for number of spaces.) |
    | `:line-ending` | Set the document's default line ending. Options: crlf, lf. |
    | `:earlier`, `:ear` | Jump back to an earlier point in edit history. Accepts a number of steps or a time span. |
    | `:later`, `:lat` | Jump to a later point in edit history. Accepts a number of steps or a time span. |
  documentationQuestion1: What are the common use cases for the :write! and :write-buffer-close! commands in the Helix editor?
  documentationQuestion2: How would you format a Rust file using the :format command in Helix, and what additional steps are needed to ensure the changes are saved?
  documentationQuestion3: Explain the difference between :write-buffer-close and :write-buffer-close! in Helix, and provide an example of when each would be appropriate.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `:write-quit`, `:wq`, `:x` | Write changes to disk and close the current view. Accepts an optional path (:wq some/path.txt) |
    | `:write-quit!`, `:wq!`, `:x!` | Write changes to disk and close the current view forcefully. Accepts an optional path (:wq! some/path.txt) |
    | `:write-all`, `:wa` | Write changes from all buffers to disk. |
    | `:write-all!`, `:wa!` | Forcefully write changes from all buffers to disk creating necessary subdirectories. |
    | `:write-quit-all`, `:wqa`, `:xa` | Write changes from all buffers to disk and close all views. |
    | `:write-quit-all!`, `:wqa!`, `:xa!` | Write changes from all buffers to disk and close all views forcefully (ignoring unsaved changes). |
    | `:quit-all`, `:qa` | Close all views. |
    | `:quit-all!`, `:qa!` | Force close all views ignoring unsaved changes. |
    | `:cquit`, `:cq` | Quit with exit code (default 1). Accepts an optional integer exit code (:cq 2). |
    | `:cquit!`, `:cq!` | Force quit with exit code (default 1) ignoring unsaved changes. Accepts an optional integer exit code (:cq! 2). |
  documentationQuestion1: What is the primary purpose of the write commands in Helix's typable-cmd page?
  documentationQuestion2: How would you force quit Helix while saving all changes to disk and closing all views?
  documentationQuestion3: What command would you use to exit Helix with a custom exit code of 3 without saving any changes?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `:theme` | Change the editor theme (show current theme if no name specified). |
    | `:yank-join` | Yank joined selections. A separator can be provided as first argument. Default value is newline. |
    | `:clipboard-yank` | Yank main selection into system clipboard. |
    | `:clipboard-yank-join` | Yank joined selections into system clipboard. A separator can be provided as first argument. Default value is newline. |
    | `:primary-clipboard-yank` | Yank main selection into system primary clipboard. |
    | `:primary-clipboard-yank-join` | Yank joined selections into system primary clipboard. A separator can be provided as first argument. Default value is newline. |
    | `:clipboard-paste-after` | Paste system clipboard after selections. |
    | `:clipboard-paste-before` | Paste system clipboard before selections. |
    | `:clipboard-paste-replace` | Replace selections with content of system clipboard. |
    | `:primary-clipboard-paste-after` | Paste primary clipboard after selections. |
    | `:primary-clipboard-paste-before` | Paste primary clipboard before selections. |
  documentationQuestion1: What are the primary purposes of the clipboard-related commands in the Helix editor's `typable-cmd` page?
  documentationQuestion2: How can you yank joined selections into the system clipboard with a custom separator in Helix?
  documentationQuestion3: What command would you use to paste the system clipboard content before the selected text in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `:primary-clipboard-paste-replace` | Replace selections with content of system primary clipboard. |
    | `:show-clipboard-provider` | Show clipboard provider name in status bar. |
    | `:change-current-directory`, `:cd` | Change the current working directory. |
    | `:show-directory`, `:pwd` | Show the current working directory. |
    | `:encoding` | Set encoding. Based on `https://encoding.spec.whatwg.org`. |
    | `:character-info`, `:char` | Get info about the character under the primary cursor. |
    | `:reload`, `:rl` | Discard changes and reload from the source file. |
    | `:reload-all`, `:rla` | Discard changes and reload all documents from the source files. |
    | `:update`, `:u` | Write changes only if the file has been modified. |
    | `:lsp-workspace-command` | Open workspace command picker |
    | `:lsp-restart` | Restarts the given language servers, or all language servers that are used by the current file if no arguments are supplied |
    | `:lsp-stop` | Stops the given language servers, or all language servers that are used by the current file if no arguments are supplied |
  documentationQuestion1: What is the general purpose of the clipboard-related commands in Helix, such as `:primary-clipboard-paste-replace` and `:show-clipboard-provider`?
  documentationQuestion2: How can a user efficiently reload a single file in Helix without losing unsaved changes, and what is the command for this action?
  documentationQuestion3: What command in Helix is used to restart all language servers associated with the current file, and how does it differ from stopping them?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `:tree-sitter-scopes` | Display tree sitter scopes, primarily for theming and development. |
    | `:tree-sitter-highlight-name` | Display name of tree-sitter highlight scope under the cursor. |
    | `:debug-start`, `:dbg` | Start a debug session from a given template with given parameters. |
    | `:debug-remote`, `:dbg-tcp` | Connect to a debug adapter by TCP address and start a debugging session from a given template with given parameters. |
    | `:debug-eval` | Evaluate expression in current debug context. |
    | `:vsplit`, `:vs` | Open the file in a vertical split. |
    | `:vsplit-new`, `:vnew` | Open a scratch buffer in a vertical split. |
    | `:hsplit`, `:hs`, `:sp` | Open the file in a horizontal split. |
    | `:hsplit-new`, `:hnew` | Open a scratch buffer in a horizontal split. |
    | `:tutor` | Open the tutorial. |
    | `:goto`, `:g` | Goto line number. |
    | `:set-language`, `:lang` | Set the language of current buffer (show current language if no value specified). |
    | `:set-option`, `:set` | Set a config option at runtime.<br>For example to disable smart case search, use `:set search.smart-case false`. |
  documentationQuestion1: What is the primary purpose of the tree-sitter integration in Helix, based on the documentation text provided?
  documentationQuestion2: How can a user evaluate an expression in the current debug context using Helix's debugging commands?
  documentationQuestion3: What is the correct syntax to open a new scratch buffer in a vertical split in Helix, and what is the purpose of this action?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `:toggle-option`, `:toggle` | Toggle a config option at runtime.<br>For example to toggle smart case search, use `:toggle search.smart-case`. |
    | `:get-option`, `:get` | Get the current value of a config option. |
    | `:sort` | Sort ranges in selection. |
    | `:reflow` | Hard-wrap the current selection of lines to a given width. |
    | `:tree-sitter-subtree`, `:ts-subtree` | Display the smallest tree-sitter subtree that spans the primary selection, primarily for debugging queries. |
    | `:config-reload` | Refresh user config. |
    | `:config-open` | Open the user config.toml file. |
    | `:config-open-workspace` | Open the workspace config.toml file. |
    | `:log-open` | Open the helix log file. |
    | `:insert-output` | Run shell command, inserting output before each selection. |
    | `:append-output` | Run shell command, appending output after each selection. |
    | `:pipe`, `:|` | Pipe each selection to the shell command. |
    | `:pipe-to` | Pipe each selection to the shell command, ignoring output. |
    | `:run-shell-command`, `:sh`, `:!` | Run a shell command |
  documentationQuestion1: What is the primary purpose of the `:toggle-option` and `:toggle` commands in Helix?
  documentationQuestion2: How can you use the `:pipe` command to send the current selection to an external shell command for processing?
  documentationQuestion3: What is the function of the `:insert-output` command and how can it be used to enhance the editing experience in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `typable-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `:reset-diff-change`, `:diffget`, `:diffg` | Reset the diff change at the cursor position. |
    | `:clear-register` | Clear given register. If no argument is provided, clear all registers. |
    | `:redraw` | Clear and re-render the whole UI |
    | `:move`, `:mv` | Move the current buffer and its corresponding file to a different path |
    | `:yank-diagnostic` | Yank diagnostic(s) under primary cursor to register, or clipboard by default |
    | `:read`, `:r` | Load a file into buffer |
    | `:echo` | Prints the given arguments to the statusline. |
    | `:noop` | Does nothing. |
  documentationQuestion1: What are the primary purposes of the `:redraw` and `:clear-register` commands in Helix?
  documentationQuestion2: How would you use the `:move` command to relocate a file named `example.txt` from the current directory to a subdirectory called `docs`?
  documentationQuestion3: Provide an example of how to use the `:echo` command to display a custom message in the statusline of Helix.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | Language | Syntax Highlighting | Treesitter Textobjects | Auto Indent | Default language servers |
    | --- | --- | --- | --- | --- |
    | ada | ✓ | ✓ |  | `ada_language_server` |
    | adl | ✓ | ✓ | ✓ |  |
    | agda | ✓ |  |  |  |
    | amber | ✓ |  |  |  |
    | astro | ✓ |  |  | `astro-ls` |
    | awk | ✓ | ✓ |  | `awk-language-server` |
    | bash | ✓ | ✓ | ✓ | `bash-language-server` |
    | bass | ✓ |  |  | `bass` |
    | beancount | ✓ |  |  | `beancount-language-server` |
    | bibtex | ✓ |  |  | `texlab` |
    | bicep | ✓ |  |  | `bicep-langserver` |
    | bitbake | ✓ |  |  | `bitbake-language-server` |
    | blade | ✓ |  |  |  |
    | blueprint | ✓ |  |  | `blueprint-compiler` |
    | c | ✓ | ✓ | ✓ | `clangd` |
    | c-sharp | ✓ | ✓ |  | `OmniSharp` |
    | cabal |  |  |  | `haskell-language-server-wrapper` |
    | cairo | ✓ | ✓ | ✓ | `cairo-language-server` |
    | capnp | ✓ |  | ✓ |  |
    | cel | ✓ |  |  |  |
    | circom | ✓ |  |  | `circom-lsp` |
    | clojure | ✓ |  |  | `clojure-lsp` |
    | cmake | ✓ | ✓ | ✓ | `cmake-language-server` |
    | codeql | ✓ | ✓ |  | `codeql` |
  documentationQuestion1: What is the primary purpose of the language support feature in Helix as described in the documentation?
  documentationQuestion2: How can a user enable syntax highlighting for the Python language in Helix using the available configuration options?
  documentationQuestion3: What is the correct command to configure Helix to use the appropriate language server for the Rust programming language?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | comment | ✓ |  |  |  |
    | common-lisp | ✓ |  | ✓ | `cl-lsp` |
    | cpon | ✓ |  | ✓ |  |
    | cpp | ✓ | ✓ | ✓ | `clangd` |
    | crystal | ✓ | ✓ |  | `crystalline` |
    | css | ✓ |  | ✓ | `vscode-css-language-server` |
    | csv | ✓ |  |  |  |
    | cue | ✓ |  |  | `cuelsp` |
    | cylc | ✓ | ✓ | ✓ |  |
    | d | ✓ | ✓ | ✓ | `serve-d` |
    | dart | ✓ | ✓ | ✓ | `dart` |
    | dbml | ✓ |  |  |  |
    | debian | ✓ |  |  |  |
    | devicetree | ✓ |  |  |  |
    | dhall | ✓ | ✓ |  | `dhall-lsp-server` |
    | diff | ✓ |  |  |  |
    | djot | ✓ |  |  |  |
    | docker-compose | ✓ | ✓ | ✓ | `docker-compose-langserver`, `yaml-language-server` |
    | dockerfile | ✓ | ✓ |  | `docker-langserver` |
    | dot | ✓ |  |  | `dot-language-server` |
    | dtd | ✓ |  |  |  |
    | dune | ✓ |  |  |  |
    | dunstrc | ✓ |  |  |  |
    | earthfile | ✓ | ✓ | ✓ | `earthlyls` |
    | edoc | ✓ |  |  |  |
    | eex | ✓ |  |  |  |
    | ejs | ✓ |  |  |  |
    | elisp | ✓ |  |  |  |
    | elixir | ✓ | ✓ | ✓ | `elixir-ls` |
    | elm | ✓ | ✓ |  | `elm-language-server` |
    | elvish | ✓ |  |  | `elvish` |
    | env | ✓ | ✓ |  |  |
  documentationQuestion1: What are the primary purposes of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user configure Helix to use the `clangd` language server for C++ files?
  documentationQuestion3: What is the correct command to set up the `dart` language server for Dart files in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | erb | ✓ |  |  |  |
    | erlang | ✓ | ✓ |  | `erlang_ls`, `elp` |
    | esdl | ✓ |  |  |  |
    | fennel | ✓ |  |  | `fennel-ls` |
    | fga | ✓ | ✓ | ✓ |  |
    | fidl | ✓ |  |  |  |
    | fish | ✓ | ✓ | ✓ | `fish-lsp` |
    | forth | ✓ |  |  | `forth-lsp` |
    | fortran | ✓ |  | ✓ | `fortls` |
    | fsharp | ✓ |  |  | `fsautocomplete` |
    | gas | ✓ | ✓ |  | `asm-lsp` |
    | gdscript | ✓ | ✓ | ✓ |  |
    | gemini | ✓ |  |  |  |
    | gherkin | ✓ |  |  |  |
    | ghostty | ✓ |  |  |  |
    | git-attributes | ✓ |  |  |  |
    | git-commit | ✓ | ✓ |  |  |
    | git-config | ✓ | ✓ |  |  |
    | git-ignore | ✓ |  |  |  |
    | git-rebase | ✓ |  |  |  |
    | gjs | ✓ | ✓ | ✓ | `typescript-language-server`, `vscode-eslint-language-server`, `ember-language-server` |
    | gleam | ✓ | ✓ |  | `gleam` |
    | glimmer | ✓ |  |  | `ember-language-server` |
    | glsl | ✓ | ✓ | ✓ | `glsl_analyzer` |
    | gn | ✓ |  |  |  |
    | go | ✓ | ✓ | ✓ | `gopls`, `golangci-lint-langserver` |
    | godot-resource | ✓ | ✓ |  |  |
    | gomod | ✓ |  |  | `gopls` |
    | gotmpl | ✓ |  |  | `gopls` |
    | gowork | ✓ |  |  | `gopls` |
  documentationQuestion1: What are the primary purposes of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user configure Helix to use the appropriate language server for Go development?
  documentationQuestion3: What are the common use cases for the `git-commit` and `git-rebase` language support features in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | gpr | ✓ |  |  | `ada_language_server` |
    | graphql | ✓ | ✓ |  | `graphql-lsp` |
    | gren | ✓ | ✓ |  |  |
    | groovy | ✓ |  |  |  |
    | gts | ✓ | ✓ | ✓ | `typescript-language-server`, `vscode-eslint-language-server`, `ember-language-server` |
    | hare | ✓ |  |  |  |
    | haskell | ✓ | ✓ |  | `haskell-language-server-wrapper` |
    | haskell-persistent | ✓ |  |  |  |
    | hcl | ✓ | ✓ | ✓ | `terraform-ls` |
    | heex | ✓ | ✓ |  | `elixir-ls` |
    | helm | ✓ |  |  | `helm_ls` |
    | hocon | ✓ | ✓ | ✓ |  |
    | hoon | ✓ |  |  |  |
    | hosts | ✓ |  |  |  |
    | html | ✓ |  |  | `vscode-html-language-server`, `superhtml` |
    | hurl | ✓ | ✓ | ✓ |  |
    | hyprlang | ✓ |  | ✓ | `hyprls` |
    | idris |  |  |  | `idris2-lsp` |
    | iex | ✓ |  |  |  |
    | ini | ✓ |  |  |  |
    | ink | ✓ |  |  |  |
    | inko | ✓ | ✓ | ✓ |  |
    | janet | ✓ |  |  |  |
    | java | ✓ | ✓ | ✓ | `jdtls` |
    | javascript | ✓ | ✓ | ✓ | `typescript-language-server` |
    | jinja | ✓ |  |  |  |
    | jjdescription | ✓ |  |  |  |
    | jq | ✓ | ✓ |  | `jq-lsp` |
    | jsdoc | ✓ |  |  |  |
    | json | ✓ | ✓ | ✓ | `vscode-json-language-server` |
  documentationQuestion1: What is the primary purpose of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user configure Helix to use the `typescript-language-server` for JavaScript files?
  documentationQuestion3: What are the common use cases for the `graphql-lsp` and `terraform-ls` language servers in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | json5 | ✓ |  |  |  |
    | jsonc | ✓ |  | ✓ | `vscode-json-language-server` |
    | jsonnet | ✓ |  |  | `jsonnet-language-server` |
    | jsx | ✓ | ✓ | ✓ | `typescript-language-server` |
    | julia | ✓ | ✓ | ✓ | `julia` |
    | just | ✓ | ✓ | ✓ | `just-lsp` |
    | kdl | ✓ | ✓ | ✓ |  |
    | koka | ✓ |  | ✓ | `koka` |
    | kotlin | ✓ | ✓ | ✓ | `kotlin-language-server` |
    | koto | ✓ | ✓ | ✓ | `koto-ls` |
    | latex | ✓ | ✓ |  | `texlab` |
    | ld | ✓ |  | ✓ |  |
    | ldif | ✓ |  |  |  |
    | lean | ✓ |  |  | `lean` |
    | ledger | ✓ |  |  |  |
    | llvm | ✓ | ✓ | ✓ |  |
    | llvm-mir | ✓ | ✓ | ✓ |  |
    | llvm-mir-yaml | ✓ |  | ✓ |  |
    | log | ✓ |  |  |  |
    | lpf | ✓ |  |  |  |
    | lua | ✓ | ✓ | ✓ | `lua-language-server` |
    | mail | ✓ | ✓ |  |  |
    | make | ✓ |  | ✓ |  |
    | markdoc | ✓ |  |  | `markdoc-ls` |
    | markdown | ✓ |  |  | `marksman`, `markdown-oxide` |
    | markdown-rustdoc | ✓ |  |  |  |
    | markdown.inline | ✓ |  |  |  |
    | matlab | ✓ | ✓ | ✓ |  |
    | mermaid | ✓ |  |  |  |
    | meson | ✓ |  | ✓ | `mesonlsp` |
    | mint |  |  |  | `mint` |
    | mojo | ✓ | ✓ | ✓ | `magic` |
  documentationQuestion1: What is the primary purpose of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user configure Helix to use the `typescript-language-server` for JSX files?
  documentationQuestion3: What are the steps to set up Helix with the `koto-ls` language server for Koto files?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | move | ✓ |  |  |  |
    | msbuild | ✓ |  | ✓ |  |
    | nasm | ✓ | ✓ |  | `asm-lsp` |
    | nestedtext | ✓ | ✓ | ✓ |  |
    | nginx | ✓ |  |  |  |
    | nickel | ✓ |  | ✓ | `nls` |
    | nim | ✓ | ✓ | ✓ | `nimlangserver` |
    | nix | ✓ | ✓ | ✓ | `nil`, `nixd` |
    | nu | ✓ |  |  | `nu` |
    | nunjucks | ✓ |  |  |  |
    | ocaml | ✓ |  | ✓ | `ocamllsp` |
    | ocaml-interface | ✓ |  |  | `ocamllsp` |
    | odin | ✓ | ✓ | ✓ | `ols` |
    | ohm | ✓ | ✓ | ✓ |  |
    | opencl | ✓ | ✓ | ✓ | `clangd` |
    | openscad | ✓ |  |  | `openscad-lsp` |
    | org | ✓ |  |  |  |
    | pascal | ✓ | ✓ |  | `pasls` |
    | passwd | ✓ |  |  |  |
    | pem | ✓ |  |  |  |
    | perl | ✓ | ✓ | ✓ | `perlnavigator` |
    | pest | ✓ | ✓ | ✓ | `pest-language-server` |
    | php | ✓ | ✓ | ✓ | `intelephense` |
    | php-only | ✓ |  |  |  |
    | pkgbuild | ✓ | ✓ | ✓ | `termux-language-server`, `bash-language-server` |
    | pkl | ✓ |  | ✓ | `pkl-lsp` |
    | po | ✓ | ✓ |  |  |
    | pod | ✓ |  |  |  |
    | ponylang | ✓ | ✓ | ✓ |  |
    | powershell | ✓ |  |  |  |
    | prisma | ✓ | ✓ |  | `prisma-language-server` |
    | prolog | ✓ |  | ✓ | `swipl` |
  documentationQuestion1: What is the primary purpose of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user configure Helix to use the `pest-language-server` for the Pest language?
  documentationQuestion3: What are the common use cases for the `termux-language-server` and `bash-language-server` in the context of pkgbuild language support in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | protobuf | ✓ | ✓ | ✓ | `buf`, `pb`, `protols` |
    | prql | ✓ |  |  |  |
    | pug | ✓ |  |  |  |
    | purescript | ✓ | ✓ |  | `purescript-language-server` |
    | python | ✓ | ✓ | ✓ | `ruff`, `jedi-language-server`, `pylsp` |
    | qml | ✓ |  | ✓ | `qmlls` |
    | quarto | ✓ |  | ✓ |  |
    | quint | ✓ |  |  | `quint-language-server` |
    | r | ✓ |  |  | `R` |
    | racket | ✓ |  | ✓ | `racket` |
    | regex | ✓ |  |  |  |
    | rego | ✓ |  |  | `regols` |
    | rescript | ✓ | ✓ |  | `rescript-language-server` |
    | rmarkdown | ✓ |  | ✓ | `R` |
    | robot | ✓ |  |  | `robotframework_ls` |
    | ron | ✓ |  | ✓ |  |
    | rst | ✓ |  |  |  |
    | ruby | ✓ | ✓ | ✓ | `ruby-lsp`, `solargraph` |
    | rust | ✓ | ✓ | ✓ | `rust-analyzer` |
    | sage | ✓ | ✓ |  |  |
    | scala | ✓ | ✓ | ✓ | `metals` |
    | scheme | ✓ |  | ✓ |  |
    | scss | ✓ |  |  | `vscode-css-language-server` |
    | slang | ✓ | ✓ | ✓ | `slangd` |
    | slint | ✓ | ✓ | ✓ | `slint-lsp` |
    | smali | ✓ |  | ✓ |  |
    | smithy | ✓ |  |  | `cs` |
    | sml | ✓ |  |  |  |
    | snakemake | ✓ |  | ✓ | `pylsp` |
    | solidity | ✓ | ✓ |  | `solc` |
  documentationQuestion1: What is the primary purpose of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user configure Helix to use the `ruff` language server for Python development?
  documentationQuestion3: What are the common use cases for specifying language servers in Helix, and how can they be configured?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | sourcepawn | ✓ | ✓ |  | `sourcepawn-studio` |
    | spade | ✓ |  | ✓ | `spade-language-server` |
    | spicedb | ✓ |  |  |  |
    | sql | ✓ | ✓ |  |  |
    | sshclientconfig | ✓ |  |  |  |
    | starlark | ✓ | ✓ | ✓ | `starpls` |
    | strace | ✓ |  |  |  |
    | supercollider | ✓ |  |  |  |
    | svelte | ✓ |  | ✓ | `svelteserver` |
    | sway | ✓ | ✓ | ✓ | `forc` |
    | swift | ✓ | ✓ |  | `sourcekit-lsp` |
    | t32 | ✓ |  |  |  |
    | tablegen | ✓ | ✓ | ✓ |  |
    | tact | ✓ | ✓ | ✓ |  |
    | task | ✓ |  |  |  |
    | tcl | ✓ |  | ✓ |  |
    | teal | ✓ |  |  | `teal-language-server` |
    | templ | ✓ |  |  | `templ` |
    | tera | ✓ |  |  |  |
    | textproto | ✓ | ✓ | ✓ |  |
    | tfvars | ✓ |  | ✓ | `terraform-ls` |
    | thrift | ✓ |  |  |  |
    | tlaplus | ✓ |  |  |  |
    | todotxt | ✓ |  |  |  |
    | toml | ✓ | ✓ |  | `taplo` |
    | tsq | ✓ |  |  | `ts_query_ls` |
    | tsx | ✓ | ✓ | ✓ | `typescript-language-server` |
    | twig | ✓ |  |  |  |
    | typescript | ✓ | ✓ | ✓ | `typescript-language-server` |
    | typespec | ✓ | ✓ | ✓ | `tsp-server` |
    | typst | ✓ |  |  | `tinymist` |
    | ungrammar | ✓ |  |  |  |
  documentationQuestion1: What is the primary purpose of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user configure the language server for TypeScript in Helix using the provided command example?
  documentationQuestion3: What are the common use cases for the `typescript-language-server` in the Helix editor?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    | unison | ✓ | ✓ | ✓ |  |
    | uxntal | ✓ |  |  |  |
    | v | ✓ | ✓ | ✓ | `v-analyzer` |
    | vala | ✓ | ✓ |  | `vala-language-server` |
    | vento | ✓ |  |  |  |
    | verilog | ✓ | ✓ |  | `svlangserver` |
    | vhdl | ✓ |  |  | `vhdl_ls` |
    | vhs | ✓ |  |  |  |
    | vue | ✓ |  |  | `vue-language-server` |
    | wast | ✓ |  |  |  |
    | wat | ✓ |  |  | `wat_server` |
    | webc | ✓ |  |  |  |
    | werk | ✓ |  |  |  |
    | wesl | ✓ | ✓ |  |  |
    | wgsl | ✓ |  |  | `wgsl-analyzer` |
    | wit | ✓ |  | ✓ |  |
    | wren | ✓ | ✓ | ✓ |  |
    | xit | ✓ |  |  |  |
    | xml | ✓ |  | ✓ |  |
    | xtc | ✓ |  |  |  |
    | yaml | ✓ | ✓ | ✓ | `yaml-language-server`, `ansible-language-server` |
    | yara | ✓ |  |  | `yls` |
    | yuck | ✓ |  |  |  |
    | zig | ✓ | ✓ | ✓ | `zls` |
  documentationQuestion1: What are the primary purposes of the language support features in Helix as described in the documentation?
  documentationQuestion2: How can a user set up language-specific tools like `yaml-language-server` for YAML files in Helix?
  documentationQuestion3: What is the typical workflow for configuring and using the `zls` tool with Zig language support in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | Name | Description | Default keybinds |
    | --- | --- | --- |
    | `no_op` | Do nothing |  |
    | `move_char_left` | Move left | normal: `` h ``, `` <left> ``, insert: `` <left> `` |
    | `move_char_right` | Move right | normal: `` l ``, `` <right> ``, insert: `` <right> `` |
    | `move_line_up` | Move up | normal: `` gk `` |
    | `move_line_down` | Move down | normal: `` gj `` |
    | `move_visual_line_up` | Move up | normal: `` k ``, `` <up> ``, insert: `` <up> `` |
    | `move_visual_line_down` | Move down | normal: `` j ``, `` <down> ``, insert: `` <down> `` |
    | `extend_char_left` | Extend left | select: `` h ``, `` <left> `` |
    | `extend_char_right` | Extend right | select: `` l ``, `` <right> `` |
    | `extend_line_up` | Extend up | select: `` gk `` |
    | `extend_line_down` | Extend down | select: `` gj `` |
    | `extend_visual_line_up` | Extend up | select: `` k ``, `` <up> `` |
    | `extend_visual_line_down` | Extend down | select: `` j ``, `` <down> `` |
    | `copy_selection_on_next_line` | Copy selection on next line | normal: `` C ``, select: `` C `` |
  documentationQuestion1: What is the primary purpose of the `static-cmd` page in the Helix documentation?
  documentationQuestion2: How can a user efficiently move the cursor up by one line in normal mode using Helix?
  documentationQuestion3: What command in Helix is used to copy the selected text to the next line, and what are its key bindings?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `copy_selection_on_prev_line` | Copy selection on previous line | normal: `` <A-C> ``, select: `` <A-C> `` |
    | `move_next_word_start` | Move to start of next word | normal: `` w `` |
    | `move_prev_word_start` | Move to start of previous word | normal: `` b `` |
    | `move_next_word_end` | Move to end of next word | normal: `` e `` |
    | `move_prev_word_end` | Move to end of previous word |  |
    | `move_next_long_word_start` | Move to start of next long word | normal: `` W `` |
    | `move_prev_long_word_start` | Move to start of previous long word | normal: `` B `` |
    | `move_next_long_word_end` | Move to end of next long word | normal: `` E `` |
    | `move_prev_long_word_end` | Move to end of previous long word |  |
    | `move_next_sub_word_start` | Move to start of next sub word |  |
    | `move_prev_sub_word_start` | Move to start of previous sub word |  |
    | `move_next_sub_word_end` | Move to end of next sub word |  |
    | `move_prev_sub_word_end` | Move to end of previous sub word |  |
    | `move_parent_node_end` | Move to end of the parent node | normal: `` <A-e> `` |
  documentationQuestion1: What is the primary purpose of the `move_next_word_start` and `move_next_word_end` commands in Helix?
  documentationQuestion2: How can a user navigate to the start of the next long word using the default keybinding in Helix?
  documentationQuestion3: What is the function of the `move_parent_node_end` command and how is it typically triggered?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `move_parent_node_start` | Move to beginning of the parent node | normal: `` <A-b> `` |
    | `extend_next_word_start` | Extend to start of next word | select: `` w `` |
    | `extend_prev_word_start` | Extend to start of previous word | select: `` b `` |
    | `extend_next_word_end` | Extend to end of next word | select: `` e `` |
    | `extend_prev_word_end` | Extend to end of previous word |  |
    | `extend_next_long_word_start` | Extend to start of next long word | select: `` W `` |
    | `extend_prev_long_word_start` | Extend to start of previous long word | select: `` B `` |
    | `extend_next_long_word_end` | Extend to end of next long word | select: `` E `` |
    | `extend_prev_long_word_end` | Extend to end of prev long word |  |
    | `extend_next_sub_word_start` | Extend to start of next sub word |  |
    | `extend_prev_sub_word_start` | Extend to start of previous sub word |  |
    | `extend_next_sub_word_end` | Extend to end of next sub word |  |
    | `extend_prev_sub_word_end` | Extend to end of prev sub word |  |
    | `extend_parent_node_end` | Extend to end of the parent node | select: `` <A-e> `` |
  documentationQuestion1: What is the primary purpose of the `extend_next_word_start` and `extend_prev_word_start` commands in the Helix text editor?
  documentationQuestion2: How can you use the `extend_next_word_end` command in Helix to select text from the current cursor position to the end of the next word?
  documentationQuestion3: What is the function of the `extend_next_long_word_start` command in Helix and how is it typically used?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `extend_parent_node_start` | Extend to beginning of the parent node | select: `` <A-b> `` |
    | `find_till_char` | Move till next occurrence of char | normal: `` t `` |
    | `find_next_char` | Move to next occurrence of char | normal: `` f `` |
    | `extend_till_char` | Extend till next occurrence of char | select: `` t `` |
    | `extend_next_char` | Extend to next occurrence of char | select: `` f `` |
    | `till_prev_char` | Move till previous occurrence of char | normal: `` T `` |
    | `find_prev_char` | Move to previous occurrence of char | normal: `` F `` |
    | `extend_till_prev_char` | Extend till previous occurrence of char | select: `` T `` |
    | `extend_prev_char` | Extend to previous occurrence of char | select: `` F `` |
    | `repeat_last_motion` | Repeat last motion | normal: `` <A-.> ``, select: `` <A-.> `` |
    | `replace` | Replace with new char | normal: `` r ``, select: `` r `` |
    | `switch_case` | Switch (toggle) case | normal: `` ~ ``, select: `` ~ `` |
    | `switch_to_uppercase` | Switch to uppercase | normal: `` <A-`> ``, select: `` <A-`> `` |
  documentationQuestion1: What are the common use cases for the motion and text object commands in Helix, based on the provided documentation?
  documentationQuestion2: How can you efficiently replace a single character in the current line using Helix's normal mode commands?
  documentationQuestion3: What is the correct way to toggle the case of selected text in Helix, and how does it differ between normal and select modes?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `switch_to_lowercase` | Switch to lowercase | normal: `` ` ``, select: `` ` `` |
    | `page_up` | Move page up | normal: `` <C-b> ``, `` Z<C-b> ``, `` z<C-b> ``, `` <pageup> ``, `` Z<pageup> ``, `` z<pageup> ``, select: `` <C-b> ``, `` Z<C-b> ``, `` z<C-b> ``, `` <pageup> ``, `` Z<pageup> ``, `` z<pageup> ``, insert: `` <pageup> `` |
    | `page_down` | Move page down | normal: `` <C-f> ``, `` Z<C-f> ``, `` z<C-f> ``, `` <pagedown> ``, `` Z<pagedown> ``, `` z<pagedown> ``, select: `` <C-f> ``, `` Z<C-f> ``, `` z<C-f> ``, `` <pagedown> ``, `` Z<pagedown> ``, `` z<pagedown> ``, insert: `` <pagedown> `` |
    | `half_page_up` | Move half page up |  |
    | `half_page_down` | Move half page down |  |
    | `page_cursor_up` | Move page and cursor up |  |
    | `page_cursor_down` | Move page and cursor down |  |
    | `page_cursor_half_up` | Move page and cursor half up | normal: `` <C-u> ``, `` Z<C-u> ``, `` z<C-u> ``, `` Z<backspace> ``, `` z<backspace> ``, select: `` <C-u> ``, `` Z<C-u> ``, `` z<C-u> ``, `` Z<backspace> ``, `` z<backspace> `` |
  documentationQuestion1: What are the common use cases for the page navigation commands in Helix, and what are their primary functions?
  documentationQuestion2: How can a user move up one page in a file using Helix's page navigation commands, and what are the different key bindings available for this action?
  documentationQuestion3: What is the difference between the `page_up` and `page_cursor_up` commands in Helix, and when would each be most appropriate to use?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `page_cursor_half_down` | Move page and cursor half down | normal: `` <C-d> ``, `` Z<C-d> ``, `` z<C-d> ``, `` Z<space> ``, `` z<space> ``, select: `` <C-d> ``, `` Z<C-d> ``, `` z<C-d> ``, `` Z<space> ``, `` z<space> `` |
    | `select_all` | Select whole document | normal: `` % ``, select: `` % `` |
    | `select_regex` | Select all regex matches inside selections | normal: `` s ``, select: `` s `` |
    | `split_selection` | Split selections on regex matches | normal: `` S ``, select: `` S `` |
    | `split_selection_on_newline` | Split selection on newlines | normal: `` <A-s> ``, select: `` <A-s> `` |
    | `merge_selections` | Merge selections | normal: `` <A-minus> ``, select: `` <A-minus> `` |
    | `merge_consecutive_selections` | Merge consecutive selections | normal: `` <A-_> ``, select: `` <A-_> `` |
    | `search` | Search for regex pattern | normal: `` / ``, `` Z/ ``, `` z/ ``, select: `` / ``, `` Z/ ``, `` z/ `` |
    | `rsearch` | Reverse search for regex pattern | normal: `` ? ``, `` Z? ``, `` z? ``, select: `` ? ``, `` Z? ``, `` z? `` |
  documentationQuestion1: What is the primary purpose of the search and reverse search commands in Helix, and how do they differ in their functionality?
  documentationQuestion2: How can a user perform a reverse search for the regex pattern 'error' in the current buffer using Helix's command set?
  documentationQuestion3: Provide an example of using the `split_selection_on_newline` command in Helix to split a selected block of text into separate lines.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `search_next` | Select next search match | normal: `` n ``, `` Zn ``, `` zn ``, select: `` Zn ``, `` zn `` |
    | `search_prev` | Select previous search match | normal: `` N ``, `` ZN ``, `` zN ``, select: `` ZN ``, `` zN `` |
    | `extend_search_next` | Add next search match to selection | select: `` n `` |
    | `extend_search_prev` | Add previous search match to selection | select: `` N `` |
    | `search_selection` | Use current selection as search pattern | normal: `` <A-*> ``, select: `` <A-*> `` |
    | `search_selection_detect_word_boundaries` | Use current selection as the search pattern, automatically wrapping with `\b` on word boundaries | normal: `` * ``, select: `` * `` |
    | `make_search_word_bounded` | Modify current search to make it word bounded |  |
    | `global_search` | Global search in workspace folder | normal: `` <space>/ ``, select: `` <space>/ `` |
    | `extend_line` | Select current line, if already selected, extend to another line based on the anchor |  |
    | `extend_line_below` | Select current line, if already selected, extend to next line | normal: `` x ``, select: `` x `` |
  documentationQuestion1: What are the primary purposes of the search and selection commands in the Helix editor's static-cmd page documentation?
  documentationQuestion2: How can a user perform a global search in the current workspace folder using Helix's search commands?
  documentationQuestion3: What is the difference between using `search_next` and `extend_search_next` in Helix, and when would each be appropriate?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `extend_line_above` | Select current line, if already selected, extend to previous line |  |
    | `select_line_above` | Select current line, if already selected, extend or shrink line above based on the anchor |  |
    | `select_line_below` | Select current line, if already selected, extend or shrink line below based on the anchor |  |
    | `extend_to_line_bounds` | Extend selection to line bounds | normal: `` X ``, select: `` X `` |
    | `shrink_to_line_bounds` | Shrink selection to line bounds | normal: `` <A-x> ``, select: `` <A-x> `` |
    | `delete_selection` | Delete selection | normal: `` d ``, select: `` d `` |
    | `delete_selection_noyank` | Delete selection without yanking | normal: `` <A-d> ``, select: `` <A-d> `` |
    | `change_selection` | Change selection | normal: `` c ``, select: `` c `` |
    | `change_selection_noyank` | Change selection without yanking | normal: `` <A-c> ``, select: `` <A-c> `` |
    | `collapse_selection` | Collapse selection into single cursor | normal: `` ; ``, select: `` ; `` |
  documentationQuestion1: What are the common use cases for the `extend_line_above` and `select_line_above` commands in Helix?
  documentationQuestion2: How can you delete the currently selected text in Helix using the default keybinding?
  documentationQuestion3: What command in Helix is used to collapse the current selection into a single cursor position?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `flip_selections` | Flip selection cursor and anchor | normal: `` <A-;> ``, select: `` <A-;> `` |
    | `ensure_selections_forward` | Ensure all selections face forward | normal: `` <A-:> ``, select: `` <A-:> `` |
    | `insert_mode` | Insert before selection | normal: `` i ``, select: `` i `` |
    | `append_mode` | Append after selection | normal: `` a ``, select: `` a `` |
    | `command_mode` | Enter command mode | normal: `` : ``, select: `` : `` |
    | `file_picker` | Open file picker | normal: `` <space>f ``, select: `` <space>f `` |
    | `file_picker_in_current_buffer_directory` | Open file picker at current buffer's directory |  |
    | `file_picker_in_current_directory` | Open file picker at current working directory | normal: `` <space>F ``, select: `` <space>F `` |
    | `file_explorer` | Open file explorer in workspace root | normal: `` <space>e ``, select: `` <space>e `` |
    | `file_explorer_in_current_buffer_directory` | Open file explorer at current buffer's directory | normal: `` <space>E ``, select: `` <space>E `` |
  documentationQuestion1: What is the primary purpose of the file picker and file explorer commands in Helix as described in the documentation?
  documentationQuestion2: How can a user open a file picker in the current working directory using Helix?
  documentationQuestion3: What command in Helix is used to enter command mode, and what is its typical use case?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `file_explorer_in_current_directory` | Open file explorer at current working directory |  |
    | `code_action` | Perform code action | normal: `` <space>a ``, select: `` <space>a `` |
    | `buffer_picker` | Open buffer picker | normal: `` <space>b ``, select: `` <space>b `` |
    | `jumplist_picker` | Open jumplist picker | normal: `` <space>j ``, select: `` <space>j `` |
    | `symbol_picker` | Open symbol picker | normal: `` <space>s ``, select: `` <space>s `` |
    | `changed_file_picker` | Open changed file picker | normal: `` <space>g ``, select: `` <space>g `` |
    | `select_references_to_symbol_under_cursor` | Select symbol references | normal: `` <space>h ``, select: `` <space>h `` |
    | `workspace_symbol_picker` | Open workspace symbol picker | normal: `` <space>S ``, select: `` <space>S `` |
    | `diagnostics_picker` | Open diagnostic picker | normal: `` <space>d ``, select: `` <space>d `` |
    | `workspace_diagnostics_picker` | Open workspace diagnostic picker | normal: `` <space>D ``, select: `` <space>D `` |
  documentationQuestion1: What are the primary purposes of the file explorer and buffer picker commands in Helix, and how do they enhance the development workflow?
  documentationQuestion2: How can a user open the file explorer at the current working directory using the Helix command-line interface?
  documentationQuestion3: What is the function of the diagnostics picker in Helix, and how is it typically triggered?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `last_picker` | Open last picker | normal: `` <space>' ``, select: `` <space>' `` |
    | `insert_at_line_start` | Insert at start of line | normal: `` I ``, select: `` I `` |
    | `insert_at_line_end` | Insert at end of line | normal: `` A ``, select: `` A `` |
    | `open_below` | Open new line below selection | normal: `` o ``, select: `` o `` |
    | `open_above` | Open new line above selection | normal: `` O ``, select: `` O `` |
    | `normal_mode` | Enter normal mode | normal: `` <esc> ``, select: `` v ``, insert: `` <esc> `` |
    | `select_mode` | Enter selection extend mode | normal: `` v `` |
    | `exit_select_mode` | Exit selection mode | select: `` <esc> `` |
    | `goto_definition` | Goto definition | normal: `` gd ``, select: `` gd `` |
    | `goto_declaration` | Goto declaration | normal: `` gD ``, select: `` gD `` |
    | `add_newline_above` | Add newline above | normal: `` [<space> ``, select: `` [<space> `` |
    | `add_newline_below` | Add newline below | normal: `` ]<space> ``, select: `` ]<space> `` |
    | `goto_type_definition` | Goto type definition | normal: `` gy ``, select: `` gy `` |
  documentationQuestion1: What is the primary purpose of the `normal_mode` and `select_mode` commands in the Helix editor as described in the documentation?
  documentationQuestion2: How can a user insert text at the beginning of the current line in Helix using the normal mode?
  documentationQuestion3: What command in Helix allows a user to add a newline above the current line in normal mode, and how is it typically used?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `goto_implementation` | Goto implementation | normal: `` gi ``, select: `` gi `` |
    | `goto_file_start` | Goto line number <n> else file start | normal: `` gg `` |
    | `goto_file_end` | Goto file end |  |
    | `extend_to_file_start` | Extend to line number<n> else file start | select: `` gg `` |
    | `extend_to_file_end` | Extend to file end |  |
    | `goto_file` | Goto files/URLs in selections | normal: `` gf ``, select: `` gf `` |
    | `goto_file_hsplit` | Goto files in selections (hsplit) | normal: `` <C-w>f ``, `` <space>wf ``, select: `` <C-w>f ``, `` <space>wf `` |
    | `goto_file_vsplit` | Goto files in selections (vsplit) | normal: `` <C-w>F ``, `` <space>wF ``, select: `` <C-w>F ``, `` <space>wF `` |
    | `goto_reference` | Goto references | normal: `` gr ``, select: `` gr `` |
    | `goto_window_top` | Goto window top | normal: `` gt ``, select: `` gt `` |
    | `goto_window_center` | Goto window center | normal: `` gc ``, select: `` gc `` |
    | `goto_window_bottom` | Goto window bottom | normal: `` gb ``, select: `` gb `` |
  documentationQuestion1: What are the primary purposes of the 'goto' commands in Helix's static-cmd page as described in the documentation?
  documentationQuestion2: How can a user navigate to the beginning of a file using Helix's goto commands, and what are the key differences between normal and select modes?
  documentationQuestion3: Provide an example of how to use the 'goto_file' command in Helix to open a specific file in a new split window, including the appropriate key bindings for both normal and select modes.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `goto_last_accessed_file` | Goto last accessed file | normal: `` ga ``, select: `` ga `` |
    | `goto_last_modified_file` | Goto last modified file | normal: `` gm ``, select: `` gm `` |
    | `goto_last_modification` | Goto last modification | normal: `` g. ``, select: `` g. `` |
    | `goto_line` | Goto line | normal: `` G ``, select: `` G `` |
    | `goto_last_line` | Goto last line | normal: `` ge `` |
    | `extend_to_last_line` | Extend to last line | select: `` ge `` |
    | `goto_first_diag` | Goto first diagnostic | normal: `` [D ``, select: `` [D `` |
    | `goto_last_diag` | Goto last diagnostic | normal: `` ]D ``, select: `` ]D `` |
    | `goto_next_diag` | Goto next diagnostic | normal: `` ]d ``, select: `` ]d `` |
    | `goto_prev_diag` | Goto previous diagnostic | normal: `` [d ``, select: `` [d `` |
    | `goto_next_change` | Goto next change | normal: `` ]g ``, select: `` ]g `` |
    | `goto_prev_change` | Goto previous change | normal: `` [g ``, select: `` [g `` |
    | `goto_first_change` | Goto first change | normal: `` [G ``, select: `` [G `` |
  documentationQuestion1: What are the primary purposes of the navigation commands in the Helix editor's static-cmd page as described in the documentation?
  documentationQuestion2: How can a user quickly navigate to the last modified file in Helix using the command-line interface?
  documentationQuestion3: Provide an example of how to use the `goto_line` command in Helix to jump to a specific line number in a file.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `goto_last_change` | Goto last change | normal: `` ]G ``, select: `` ]G `` |
    | `goto_line_start` | Goto line start | normal: `` gh ``, `` <home> ``, select: `` gh ``, insert: `` <home> `` |
    | `goto_line_end` | Goto line end | normal: `` gl ``, `` <end> ``, select: `` gl `` |
    | `goto_column` | Goto column | normal: `` g\| `` |
    | `extend_to_column` | Extend to column | select: `` g\| `` |
    | `goto_next_buffer` | Goto next buffer | normal: `` gn ``, select: `` gn `` |
    | `goto_previous_buffer` | Goto previous buffer | normal: `` gp ``, select: `` gp `` |
    | `goto_line_end_newline` | Goto newline at line end | insert: `` <end> `` |
    | `goto_first_nonwhitespace` | Goto first non-blank in line | normal: `` gs ``, select: `` gs `` |
    | `trim_selections` | Trim whitespace from selections | normal: `` _ ``, select: `` _ `` |
    | `extend_to_line_start` | Extend to line start | select: `` <home> `` |
    | `extend_to_first_nonwhitespace` | Extend to first non-blank in line |  |
    | `extend_to_line_end` | Extend to line end | select: `` <end> `` |
  documentationQuestion1: What are the primary purposes of the navigation commands in Helix's `static-cmd` page, and how do they enhance text editing efficiency?
  documentationQuestion2: How can a user quickly navigate to the end of the current line in Helix, and what are the key differences between normal mode and insert mode for this command?
  documentationQuestion3: Provide an example of how to use the `goto_line_start` command in Helix to move the cursor to the beginning of the line in both normal and select modes.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `extend_to_line_end_newline` | Extend to line end |  |
    | `signature_help` | Show signature help |  |
    | `smart_tab` | Insert tab if all cursors have all whitespace to their left; otherwise, run a separate command. | insert: `` <tab> `` |
    | `insert_tab` | Insert tab char | insert: `` <S-tab> `` |
    | `insert_newline` | Insert newline char | insert: `` <C-j> ``, `` <ret> `` |
    | `delete_char_backward` | Delete previous char | insert: `` <C-h> ``, `` <backspace> ``, `` <S-backspace> `` |
    | `delete_char_forward` | Delete next char | insert: `` <C-d> ``, `` <del> `` |
    | `delete_word_backward` | Delete previous word | insert: `` <C-w> ``, `` <A-backspace> `` |
    | `delete_word_forward` | Delete next word | insert: `` <A-d> ``, `` <A-del> `` |
    | `kill_to_line_start` | Delete till start of line | insert: `` <C-u> `` |
    | `kill_to_line_end` | Delete till end of line | insert: `` <C-k> `` |
    | `undo` | Undo change | normal: `` u ``, select: `` u `` |
    | `redo` | Redo change | normal: `` U ``, select: `` U `` |
  documentationQuestion1: What is the primary purpose of the `smart_tab` feature in the Helix editor as described in the documentation?
  documentationQuestion2: How can you delete the entire line in Helix using the keybindings described in the documentation?
  documentationQuestion3: What command would you use in Helix to undo the last action, and what are the keybindings associated with it?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `earlier` | Move backward in history | normal: `` <A-u> ``, select: `` <A-u> `` |
    | `later` | Move forward in history | normal: `` <A-U> ``, select: `` <A-U> `` |
    | `commit_undo_checkpoint` | Commit changes to new checkpoint | insert: `` <C-s> `` |
    | `yank` | Yank selection | normal: `` y ``, select: `` y `` |
    | `yank_to_clipboard` | Yank selections to clipboard | normal: `` <space>y ``, select: `` <space>y `` |
    | `yank_to_primary_clipboard` | Yank selections to primary clipboard |  |
    | `yank_joined` | Join and yank selections |  |
    | `yank_joined_to_clipboard` | Join and yank selections to clipboard |  |
    | `yank_main_selection_to_clipboard` | Yank main selection to clipboard | normal: `` <space>Y ``, select: `` <space>Y `` |
    | `yank_joined_to_primary_clipboard` | Join and yank selections to primary clipboard |  |
    | `yank_main_selection_to_primary_clipboard` | Yank main selection to primary clipboard |  |
    | `replace_with_yanked` | Replace with yanked text | normal: `` R ``, select: `` R `` |
  documentationQuestion1: What are the primary purposes of the `yank` and `yank_to_clipboard` commands in Helix, and how do they differ in their functionality?
  documentationQuestion2: How can a user yank the main selection to the clipboard using the default keybinding in Helix?
  documentationQuestion3: What is the keybinding for joining and yanking selections to the clipboard in Helix, and what is the purpose of this operation?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `replace_selections_with_clipboard` | Replace selections by clipboard content | normal: `` <space>R ``, select: `` <space>R `` |
    | `replace_selections_with_primary_clipboard` | Replace selections by primary clipboard |  |
    | `paste_after` | Paste after selection | normal: `` p ``, select: `` p `` |
    | `paste_before` | Paste before selection | normal: `` P ``, select: `` P `` |
    | `paste_clipboard_after` | Paste clipboard after selections | normal: `` <space>p ``, select: `` <space>p `` |
    | `paste_clipboard_before` | Paste clipboard before selections | normal: `` <space>P ``, select: `` <space>P `` |
    | `paste_primary_clipboard_after` | Paste primary clipboard after selections |  |
    | `paste_primary_clipboard_before` | Paste primary clipboard before selections |  |
    | `indent` | Indent selection | normal: `` <gt> ``, select: `` <gt> `` |
    | `unindent` | Unindent selection | normal: `` <lt> ``, select: `` <lt> `` |
    | `format_selections` | Format selection | normal: `` = ``, select: `` = `` |
    | `join_selections` | Join lines inside selection | normal: `` J ``, select: `` J `` |
  documentationQuestion1: What are the primary purposes of the text manipulation features provided by the `static-cmd` module in Helix?
  documentationQuestion2: How can you use the `format_selections` command to format selected text in Helix?
  documentationQuestion3: What is the difference between the `paste_after` and `paste_clipboard_after` commands in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `join_selections_space` | Join lines inside selection and select spaces | normal: `` <A-J> ``, select: `` <A-J> `` |
    | `keep_selections` | Keep selections matching regex | normal: `` K ``, select: `` K `` |
    | `remove_selections` | Remove selections matching regex | normal: `` <A-K> ``, select: `` <A-K> `` |
    | `align_selections` | Align selections in column | normal: `` & ``, select: `` & `` |
    | `keep_primary_selection` | Keep primary selection | normal: `` , ``, select: `` , `` |
    | `remove_primary_selection` | Remove primary selection | normal: `` <A-,> ``, select: `` <A-,> `` |
    | `completion` | Invoke completion popup | insert: `` <C-x> `` |
    | `hover` | Show docs for item under cursor | normal: `` <space>k ``, select: `` <space>k `` |
    | `toggle_comments` | Comment/uncomment selections | normal: `` <C-c> ``, `` <space>c ``, select: `` <C-c> ``, `` <space>c `` |
    | `toggle_line_comments` | Line comment/uncomment selections | normal: `` <space><A-c> ``, select: `` <space><A-c> `` |
    | `toggle_block_comments` | Block comment/uncomment selections | normal: `` <space>C ``, select: `` <space>C `` |
  documentationQuestion1: What is the primary purpose of the `align_selections` feature in Helix, and in what scenarios would it be particularly useful?
  documentationQuestion2: How can you use the `toggle_comments` command in Helix to comment out a selected block of code, and what are the key parameters or flags involved?
  documentationQuestion3: What is the function of the `completion` command in Helix, and how does it assist users during text editing or coding tasks?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `rotate_selections_forward` | Rotate selections forward | normal: `` ) ``, select: `` ) `` |
    | `rotate_selections_backward` | Rotate selections backward | normal: `` ( ``, select: `` ( `` |
    | `rotate_selection_contents_forward` | Rotate selection contents forward | normal: `` <A-)> ``, select: `` <A-)> `` |
    | `rotate_selection_contents_backward` | Rotate selections contents backward | normal: `` <A-(> ``, select: `` <A-(> `` |
    | `reverse_selection_contents` | Reverse selections contents |  |
    | `expand_selection` | Expand selection to parent syntax node | normal: `` <A-o> ``, `` <A-up> ``, select: `` <A-o> ``, `` <A-up> `` |
    | `shrink_selection` | Shrink selection to previously expanded syntax node | normal: `` <A-i> ``, `` <A-down> ``, select: `` <A-i> ``, `` <A-down> `` |
    | `select_next_sibling` | Select next sibling in the syntax tree | normal: `` <A-n> ``, `` <A-right> ``, select: `` <A-n> ``, `` <A-right> `` |
    | `select_prev_sibling` | Select previous sibling the in syntax tree | normal: `` <A-p> ``, `` <A-left> ``, select: `` <A-p> ``, `` <A-left> `` |
  documentationQuestion1: What are the primary purposes of the selection manipulation commands in Helix, as described in the documentation?
  documentationQuestion2: How can you rotate the contents of a selection forward in Helix, and what is the corresponding keybinding for this action?
  documentationQuestion3: Provide an example of how to use the `expand_selection` and `shrink_selection` commands in Helix to navigate through the syntax tree.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `select_all_siblings` | Select all siblings of the current node | normal: `` <A-a> ``, select: `` <A-a> `` |
    | `select_all_children` | Select all children of the current node | normal: `` <A-I> ``, `` <S-A-down> ``, select: `` <A-I> ``, `` <S-A-down> `` |
    | `jump_forward` | Jump forward on jumplist | normal: `` <C-i> ``, `` <tab> ``, select: `` <C-i> ``, `` <tab> `` |
    | `jump_backward` | Jump backward on jumplist | normal: `` <C-o> ``, select: `` <C-o> `` |
    | `save_selection` | Save current selection to jumplist | normal: `` <C-s> ``, select: `` <C-s> `` |
    | `jump_view_right` | Jump to right split | normal: `` <C-w>l ``, `` <space>wl ``, `` <C-w><C-l> ``, `` <C-w><right> ``, `` <space>w<C-l> ``, `` <space>w<right> ``, select: `` <C-w>l ``, `` <space>wl ``, `` <C-w><C-l> ``, `` <C-w><right> ``, `` <space>w<C-l> ``, `` <space>w<right> `` |
    | `jump_view_left` | Jump to left split | normal: `` <C-w>h ``, `` <space>wh ``, `` <C-w><C-h> ``, `` <C-w><left> ``, `` <space>w<C-h> ``, `` <space>w<left> ``, select: `` <C-w>h ``, `` <space>wh ``, `` <C-w><C-h> ``, `` <C-w><left> ``, `` <space>w<C-h> ``, `` <space>w<left> `` |
  documentationQuestion1: What are the common use cases for the `select_all_siblings` and `select_all_children` commands in Helix?
  documentationQuestion2: How can a user efficiently navigate between splits using the `jump_view_left` and `jump_view_right` commands in Helix?
  documentationQuestion3: What is the purpose of the `save_selection` command, and how is it typically used in a Helix workflow?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `jump_view_up` | Jump to split above | normal: `` <C-w>k ``, `` <C-w><up> ``, `` <space>wk ``, `` <C-w><C-k> ``, `` <space>w<up> ``, `` <space>w<C-k> ``, select: `` <C-w>k ``, `` <C-w><up> ``, `` <space>wk ``, `` <C-w><C-k> ``, `` <space>w<up> ``, `` <space>w<C-k> `` |
    | `jump_view_down` | Jump to split below | normal: `` <C-w>j ``, `` <space>wj ``, `` <C-w><C-j> ``, `` <C-w><down> ``, `` <space>w<C-j> ``, `` <space>w<down> ``, select: `` <C-w>j ``, `` <space>wj ``, `` <C-w><C-j> ``, `` <C-w><down> ``, `` <space>w<C-j> ``, `` <space>w<down> `` |
    | `swap_view_right` | Swap with right split | normal: `` <C-w>L ``, `` <space>wL ``, select: `` <C-w>L ``, `` <space>wL `` |
    | `swap_view_left` | Swap with left split | normal: `` <C-w>H ``, `` <space>wH ``, select: `` <C-w>H ``, `` <space>wH `` |
    | `swap_view_up` | Swap with split above | normal: `` <C-w>K ``, `` <space>wK ``, select: `` <C-w>K ``, `` <space>wK `` |
    | `swap_view_down` | Swap with split below | normal: `` <C-w>J ``, `` <space>wJ ``, select: `` <C-w>J ``, `` <space>wJ `` |
  documentationQuestion1: What are the primary purposes of the view navigation commands in Helix, as described in the documentation?
  documentationQuestion2: How can a user navigate to the split above using the default keybindings in Helix?
  documentationQuestion3: Provide an example of how to swap the current view with the split below using the default keybindings in Helix.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `transpose_view` | Transpose splits | normal: `` <C-w>t ``, `` <space>wt ``, `` <C-w><C-t> ``, `` <space>w<C-t> ``, select: `` <C-w>t ``, `` <space>wt ``, `` <C-w><C-t> ``, `` <space>w<C-t> `` |
    | `rotate_view` | Goto next window | normal: `` <C-w>w ``, `` <space>ww ``, `` <C-w><C-w> ``, `` <space>w<C-w> ``, select: `` <C-w>w ``, `` <space>ww ``, `` <C-w><C-w> ``, `` <space>w<C-w> `` |
    | `rotate_view_reverse` | Goto previous window |  |
    | `hsplit` | Horizontal bottom split | normal: `` <C-w>s ``, `` <space>ws ``, `` <C-w><C-s> ``, `` <space>w<C-s> ``, select: `` <C-w>s ``, `` <space>ws ``, `` <C-w><C-s> ``, `` <space>w<C-s> `` |
    | `hsplit_new` | Horizontal bottom split scratch buffer | normal: `` <C-w>ns ``, `` <space>wns ``, `` <C-w>n<C-s> ``, `` <space>wn<C-s> ``, select: `` <C-w>ns ``, `` <space>wns ``, `` <C-w>n<C-s> ``, `` <space>wn<C-s> `` |
    | `vsplit` | Vertical right split | normal: `` <C-w>v ``, `` <space>wv ``, `` <C-w><C-v> ``, `` <space>w<C-v> ``, select: `` <C-w>v ``, `` <space>wv ``, `` <C-w><C-v> ``, `` <space>w<C-v> `` |
  documentationQuestion1: What is the primary purpose of the split and view management features in Helix as described in the documentation?
  documentationQuestion2: How can a user create a horizontal split at the bottom of the current window in Helix using the default keybindings?
  documentationQuestion3: What is the difference between the `hsplit` and `hsplit_new` commands in Helix, and how can they be invoked using the keybindings provided?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `vsplit_new` | Vertical right split scratch buffer | normal: `` <C-w>nv ``, `` <space>wnv ``, `` <C-w>n<C-v> ``, `` <space>wn<C-v> ``, select: `` <C-w>nv ``, `` <space>wnv ``, `` <C-w>n<C-v> ``, `` <space>wn<C-v> `` |
    | `wclose` | Close window | normal: `` <C-w>q ``, `` <space>wq ``, `` <C-w><C-q> ``, `` <space>w<C-q> ``, select: `` <C-w>q ``, `` <space>wq ``, `` <C-w><C-q> ``, `` <space>w<C-q> `` |
    | `wonly` | Close windows except current | normal: `` <C-w>o ``, `` <space>wo ``, `` <C-w><C-o> ``, `` <space>w<C-o> ``, select: `` <C-w>o ``, `` <space>wo ``, `` <C-w><C-o> ``, `` <space>w<C-o> `` |
    | `select_register` | Select register | normal: `` " ``, select: `` " `` |
    | `insert_register` | Insert register | insert: `` <C-r> `` |
    | `copy_between_registers` | Copy between two registers |  |
    | `align_view_middle` | Align view middle | normal: `` Zm ``, `` zm ``, select: `` Zm ``, `` zm `` |
    | `align_view_top` | Align view top | normal: `` Zt ``, `` zt ``, select: `` Zt ``, `` zt `` |
    | `align_view_center` | Align view center | normal: `` Zc ``, `` Zz ``, `` zc ``, `` zz ``, select: `` Zc ``, `` Zz ``, `` zc ``, `` zz `` |
  documentationQuestion1: What is the primary purpose of the `align_view_middle`, `align_view_top`, and `align_view_center` commands in the Helix editor?
  documentationQuestion2: How can a user close all windows except the current one using the Helix editor's `wonly` command?
  documentationQuestion3: What is the correct command to vertically split the current window into a new scratch buffer in Helix, and what are the associated key mappings?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `align_view_bottom` | Align view bottom | normal: `` Zb ``, `` zb ``, select: `` Zb ``, `` zb `` |
    | `scroll_up` | Scroll view up | normal: `` Zk ``, `` zk ``, `` Z<up> ``, `` z<up> ``, select: `` Zk ``, `` zk ``, `` Z<up> ``, `` z<up> `` |
    | `scroll_down` | Scroll view down | normal: `` Zj ``, `` zj ``, `` Z<down> ``, `` z<down> ``, select: `` Zj ``, `` zj ``, `` Z<down> ``, `` z<down> `` |
    | `match_brackets` | Goto matching bracket | normal: `` mm ``, select: `` mm `` |
    | `surround_add` | Surround add | normal: `` ms ``, select: `` ms `` |
    | `surround_replace` | Surround replace | normal: `` mr ``, select: `` mr `` |
    | `surround_delete` | Surround delete | normal: `` md ``, select: `` md `` |
    | `select_textobject_around` | Select around object | normal: `` ma ``, select: `` ma `` |
    | `select_textobject_inner` | Select inside object | normal: `` mi ``, select: `` mi `` |
    | `goto_next_function` | Goto next function | normal: `` ]f ``, select: `` ]f `` |
    | `goto_prev_function` | Goto previous function | normal: `` [f ``, select: `` [f `` |
  documentationQuestion1: What is the primary purpose of the text object selection and manipulation features in Helix?
  documentationQuestion2: How can you quickly navigate to the next function definition in a file using Helix?
  documentationQuestion3: What command would you use in Helix to delete the surrounding characters around a selected text object?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `goto_next_class` | Goto next type definition | normal: `` ]t ``, select: `` ]t `` |
    | `goto_prev_class` | Goto previous type definition | normal: `` [t ``, select: `` [t `` |
    | `goto_next_parameter` | Goto next parameter | normal: `` ]a ``, select: `` ]a `` |
    | `goto_prev_parameter` | Goto previous parameter | normal: `` [a ``, select: `` [a `` |
    | `goto_next_comment` | Goto next comment | normal: `` ]c ``, select: `` ]c `` |
    | `goto_prev_comment` | Goto previous comment | normal: `` [c ``, select: `` [c `` |
    | `goto_next_test` | Goto next test | normal: `` ]T ``, select: `` ]T `` |
    | `goto_prev_test` | Goto previous test | normal: `` [T ``, select: `` [T `` |
    | `goto_next_entry` | Goto next pairing | normal: `` ]e ``, select: `` ]e `` |
    | `goto_prev_entry` | Goto previous pairing | normal: `` [e ``, select: `` [e `` |
    | `goto_next_paragraph` | Goto next paragraph | normal: `` ]p ``, select: `` ]p `` |
    | `goto_prev_paragraph` | Goto previous paragraph | normal: `` [p ``, select: `` [p `` |
  documentationQuestion1: What is the primary purpose of the `goto_next_class` and `goto_prev_class` commands in the Helix editor's static-cmd page?
  documentationQuestion2: How can a user navigate to the next parameter definition in a code file using Helix's static-cmd commands?
  documentationQuestion3: Provide an example of how to use the `goto_next_comment` command in Helix to quickly move between comments in a code file.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `dap_launch` | Launch debug target | normal: `` <space>Gl ``, select: `` <space>Gl `` |
    | `dap_restart` | Restart debugging session | normal: `` <space>Gr ``, select: `` <space>Gr `` |
    | `dap_toggle_breakpoint` | Toggle breakpoint | normal: `` <space>Gb ``, select: `` <space>Gb `` |
    | `dap_continue` | Continue program execution | normal: `` <space>Gc ``, select: `` <space>Gc `` |
    | `dap_pause` | Pause program execution | normal: `` <space>Gh ``, select: `` <space>Gh `` |
    | `dap_step_in` | Step in | normal: `` <space>Gi ``, select: `` <space>Gi `` |
    | `dap_step_out` | Step out | normal: `` <space>Go ``, select: `` <space>Go `` |
    | `dap_next` | Step to next | normal: `` <space>Gn ``, select: `` <space>Gn `` |
    | `dap_variables` | List variables | normal: `` <space>Gv ``, select: `` <space>Gv `` |
    | `dap_terminate` | End debug session | normal: `` <space>Gt ``, select: `` <space>Gt `` |
    | `dap_edit_condition` | Edit breakpoint condition on current line | normal: `` <space>G<C-c> ``, select: `` <space>G<C-c> `` |
  documentationQuestion1: What are the primary purposes of the DAP (Debug Adapter Protocol) commands in the Helix editor's `static-cmd` page documentation?
  documentationQuestion2: How can a user toggle a breakpoint in Helix using the DAP commands, and what is the key combination for this action?
  documentationQuestion3: Provide an example of how to step into a function call in Helix using the DAP commands, including the appropriate key combination.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `dap_edit_log` | Edit breakpoint log message on current line | normal: `` <space>G<C-l> ``, select: `` <space>G<C-l> `` |
    | `dap_switch_thread` | Switch current thread | normal: `` <space>Gst ``, select: `` <space>Gst `` |
    | `dap_switch_stack_frame` | Switch stack frame | normal: `` <space>Gsf ``, select: `` <space>Gsf `` |
    | `dap_enable_exceptions` | Enable exception breakpoints | normal: `` <space>Ge ``, select: `` <space>Ge `` |
    | `dap_disable_exceptions` | Disable exception breakpoints | normal: `` <space>GE ``, select: `` <space>GE `` |
    | `shell_pipe` | Pipe selections through shell command | normal: `` \| ``, select: `` \| `` |
    | `shell_pipe_to` | Pipe selections into shell command ignoring output | normal: `` <A-\|> ``, select: `` <A-\|> `` |
    | `shell_insert_output` | Insert shell command output before selections | normal: `` ! ``, select: `` ! `` |
    | `shell_append_output` | Append shell command output after selections | normal: `` <A-!> ``, select: `` <A-!> `` |
    | `shell_keep_pipe` | Filter selections with shell predicate | normal: `` $ ``, select: `` $ `` |
  documentationQuestion1: What are the primary purposes of the shell-related commands in the Helix editor's static-cmd page documentation?
  documentationQuestion2: How can you pipe selected text through a shell command in Helix, and what is the command for this action?
  documentationQuestion3: Explain the difference between `shell_pipe` and `shell_pipe_to` in Helix, and provide an example of each.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `static-cmd page of the documentation provided by Helix`.



    Documentation text:

    | `suspend` | Suspend and return to shell | normal: `` <C-z> ``, select: `` <C-z> `` |
    | `rename_symbol` | Rename symbol | normal: `` <space>r ``, select: `` <space>r `` |
    | `increment` | Increment item under cursor | normal: `` <C-a> ``, select: `` <C-a> `` |
    | `decrement` | Decrement item under cursor | normal: `` <C-x> ``, select: `` <C-x> `` |
    | `record_macro` | Record macro | normal: `` Q ``, select: `` Q `` |
    | `replay_macro` | Replay macro | normal: `` q ``, select: `` q `` |
    | `command_palette` | Open command palette | normal: `` <space>? ``, select: `` <space>? `` |
    | `goto_word` | Jump to a two-character label | normal: `` gw `` |
    | `extend_to_word` | Extend to a two-character label | select: `` gw `` |
    | `goto_next_tabstop` | goto next snippet placeholder |  |
    | `goto_prev_tabstop` | goto next snippet placeholder |  |
  documentationQuestion1: What is the primary purpose of the command palette feature in Helix, as described in the documentation?
  documentationQuestion2: How would you increment the value of a number in the current buffer using Helix's normal mode?
  documentationQuestion3: Can you provide an example of how to record and replay a macro in Helix using its default keybindings?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `title-page page of the documentation provided by Helix`.



    Documentation text:

    # Helix

    Docs for bleeding edge master can be found at
    [https://docs.helix-editor.com/master](https://docs.helix-editor.com/master).

    See the [usage] section for a quick overview of the editor, [keymap]
    section for all available keybindings and the [configuration] section
    for defining custom keybindings, setting themes, etc.
    For everything else (e.g., how to install supported language servers), see the [Helix Wiki].

    Refer the [FAQ] for common questions.

    [FAQ]: https://github.com/helix-editor/helix/wiki/FAQ
    [usage]: ./usage.md
    [keymap]: ./keymap.md
    [configuration]: ./configuration.md
    [Helix Wiki]: https://github.com/helix-editor/helix/wiki
  documentationQuestion1: What are the primary purposes of the Helix editor as described in the documentation?
  documentationQuestion2: How can a user customize keybindings in Helix, and what are the common configuration parameters involved?
  documentationQuestion3: What are the recommended steps for configuring a custom theme in Helix, and how does the configuration file structure support this?

- prompt: "You are playing the role of a college professor. Here is some text copied from the `other-software page of the documentation provided by Helix`.\n\n\n\nDocumentation text:\n\n# Helix mode in other software\n\nHelix' keymap and interaction model ([Using Helix](#usage.md)) is easier to adopt if it can be used consistently in many editing contexts. Yet, certain use cases cannot easily be addressed directly in Helix. Similar to vim, this leads to the creation of \"Helix mode\" in various other software products, allowing Helix-style editing for a greater variety of use cases.\n\n\"Helix mode\" is frequently still in early stages or missing entirely. For such cases, we also link to relevant bugs or discussions.\n\n## Other editors\n\n| Editor | Plugin or feature providing Helix editing | Comments\n| --- | --- | --- |\n| [Vim](https://www.vim.org/) | [helix.vim](https://github.com/chtenb/helix.vim) config |\n| [IntelliJ IDEA](https://www.jetbrains.com/idea/) / [Android Studio](https://developer.android.com/studio)| [IdeaVim](https://plugins.jetbrains.com/plugin/164-ideavim) plugin + [helix.idea.vim](https://github.com/chtenb/helix.vim) config | Minimum recommended version is IdeaVim 2.19.0.\n| [Visual Studio](https://visualstudio.microsoft.com/) | [VsVim](https://marketplace.visualstudio.com/items?itemName=JaredParMSFT.VsVim) plugin + [helix.vs.vim](https://github.com/chtenb/helix.vim) config | \n| [Visual Studio Code](https://code.visualstudio.com/) | [Dance](https://marketplace.visualstudio.com/items?itemName=gregoire.dance) extension, or its [Helix fork](https://marketplace.visualstudio.com/items?itemName=kend.dancehelixkey) | The Helix fork has diverged. You can also use the original Dance and tweak its keybindings directly (try [this config](https://github.com/71/dance/issues/299#issuecomment-1655509531)).\n| [Visual Studio Code](https://code.visualstudio.com/) | [Helix for VS Code](https://marketplace.visualstudio.com/items?itemName=jasew.vscode-helix-emulation) extension|\n| [Zed](https://zed.dev/) | native via keybindings ([Bug](https://github.com/zed-industries/zed/issues/4642)) |\n| [CodeMirror](https://codemirror.net/) | [codemirror-helix](https://gitlab.com/_rvidal/codemirror-helix) |\n\n\n## Shells\n\n| Shell | Plugin or feature providing Helix editing \n| --- | --- \n| Fish | [Feature Request](https://github.com/fish-shell/fish-shell/issues/7748) \n| Fish | [fish-helix](https://github.com/sshilovsky/fish-helix/tree/main) \n| Zsh | [helix-zsh](https://github.com/john-h-k/helix-zsh) or [zsh-helix-mode](https://github.com/Multirious/zsh-helix-mode)\n| Nushell | [Feature Request](https://github.com/nushell/reedline/issues/639) \n\n## Other software\n\n| Software | Plugin or feature providing Helix editing. | Comments\n| --- | --- | --- |\n| [Obsidian](https://obsidian.md/) | [Obsidian-Helix](https://github.com/Sinono3/obsidian-helix) | Uses `codemirror-helix` listed above."
  documentationQuestion1: What are the common purposes of implementing Helix mode in other software, according to the documentation?
  documentationQuestion2: How can a user enable Helix mode in Visual Studio Code using the Helix fork of the Dance extension?
  documentationQuestion3: What is the current status of Helix mode support in the Fish shell, and how can it be implemented?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `SUMMARY page of the documentation provided by Helix`.



    Documentation text:

    # Summary

    [Helix](./title-page.md)

    - [Installation](./install.md)
      - [Package Managers](./package-managers.md)
      - [Building from source](./building-from-source.md)
    - [Usage](./usage.md)
      - [Registers](./registers.md)
      - [Surround](./surround.md)
      - [Textobjects](./textobjects.md)
      - [Syntax aware motions](./syntax-aware-motions.md)
      - [Pickers](./pickers.md)
      - [Keymap](./keymap.md)
      - [Command line](./command-line.md)
      - [Commands](./commands.md)
      - [Language support](./lang-support.md)
    - [Ecosystem](./ecosystem.md)
      - [Migrating from Vim](./from-vim.md)
      - [Helix mode in other software](./other-software.md)
    - [Configuration](./configuration.md)
      - [Editor](./editor.md)
      - [Themes](./themes.md)
      - [Key remapping](./remapping.md)
      - [Languages](./languages.md)
    - [Guides](./guides/README.md)
      - [Adding languages](./guides/adding_languages.md)
      - [Adding textobject queries](./guides/textobject.md)
      - [Adding indent queries](./guides/indent.md)
      - [Adding injection queries](./guides/injection.md)
  documentationQuestion1: What are the primary purposes of the Helix text editor as described in its documentation summary?
  documentationQuestion2: How can a user customize the keybindings in Helix to perform a specific action, such as changing the default key for saving a file?
  documentationQuestion3: What is the purpose of the `registers` feature in Helix, and how can it be utilized for efficient text manipulation?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `commands page of the documentation provided by Helix`.



    Documentation text:

    # Commands

    - [Typable commands](#typable-commands)
    - [Static commands](#static-commands)

    ## Typable commands

    Typable commands are used from command mode and may take arguments. Command mode can be activated by pressing `:`. The built-in typable commands are:

    {{#include ./generated/typable-cmd.md}}

    ## Static Commands

    Static commands take no arguments and can be bound to keys. Static commands can also be executed from the command picker (`<space>?`). The built-in static commands are:

    {{#include ./generated/static-cmd.md}}
  documentationQuestion1: What is the primary purpose of typable commands in Helix, and how do they differ from static commands?
  documentationQuestion2: How can a user execute a typable command in Helix, and what is the syntax for providing arguments to it?
  documentationQuestion3: What are some common use cases for static commands in Helix, and how can they be triggered for quick access?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `usage page of the documentation provided by Helix`.



    Documentation text:

    # Using Helix

    For a full interactive introduction to Helix, refer to the
    [tutor](https://github.com/helix-editor/helix/blob/master/runtime/tutor) which
    can be accessed via the command `hx --tutor` or `:tutor`.

    > 💡 Currently, not all functionality is fully documented, please refer to the
    > [key mappings](./keymap.md) list.

    ## Modes

    Helix is a modal editor, meaning it has different modes for different tasks. The main modes are:

    * [Normal mode](./keymap.md#normal-mode): For navigation and editing commands. This is the default mode.
    * [Insert mode](./keymap.md#insert-mode): For typing text directly into the document. Access by typing `i` in normal mode.
    * [Select/extend mode](./keymap.md#select--extend-mode): For making selections and performing operations on them. Access by typing `v` in normal mode.

    ## Buffers

    Buffers are in-memory representations of files. You can have multiple buffers open at once. Use [pickers](./pickers.md) or commands like `:buffer-next` and `:buffer-previous` to open buffers or switch between them.

    ## Selection-first editing

    Inspired by [Kakoune](http://kakoune.org/), Helix follows the `selection → action` model. This means that whatever you are going to act on (a word, a paragraph, a line, etc.) is selected first and the action itself (delete, change, yank, etc.) comes second. A cursor is simply a single width selection.

    ## Multiple selections

    Also inspired by Kakoune, multiple selections are a core mode of interaction in Helix. For example, the standard way of replacing multiple instances of a word is to first select all instances (so there is one selection per instance) and then use the change action (`c`) to edit them all at the same time.

    ## Motions

    Motions are commands that move the cursor or modify selections. They're used for navigation and text manipulation. Examples include `w` to move to the next word, or `f` to find a character. See the [Movement](./keymap.md#movement) section of the keymap for more motions.
  documentationQuestion1: What are the primary purposes of Helix's modal editing system and how does it enhance productivity?
  documentationQuestion2: How can a user efficiently replace multiple instances of a word in a document using Helix's multiple selection feature?
  documentationQuestion3: What are the common use cases for the `:buffer-next` and `:buffer-plain` commands in managing open files within Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `languages page of the documentation provided by Helix`.



    Documentation text:

    ## Languages

    Language-specific settings and settings for language servers are configured
    in `languages.toml` files.

    ## `languages.toml` files

    There are three possible locations for a `languages.toml` file:

    1. In the Helix source code, which lives in the
       [Helix repository](https://github.com/helix-editor/helix/blob/master/languages.toml).
       It provides the default configurations for languages and language servers.

    2. In your [configuration directory](./configuration.md). This overrides values
       from the built-in language configuration. For example, to disable
       auto-formatting for Rust:

       ```toml
       # in <config_dir>/helix/languages.toml

       [language-server.mylang-lsp]
       command = "mylang-lsp"

       [[language]]
       name = "rust"
       auto-format = false
       ```

    3. In a `.helix` folder in your project. Language configuration may also be
       overridden local to a project by creating a `languages.toml` file in a
       `.helix` folder. Its settings will be merged with the language configuration
       in the configuration directory and the built-in configuration.
  documentationQuestion1: What are the primary purposes of the `languages.toml` files in Helix?
  documentationQuestion2: How can a user disable auto-formatting for the Rust language in Helix?
  documentationQuestion3: What is the correct way to configure a custom language server for a specific language in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `languages page of the documentation provided by Helix`.



    Documentation text:

    ## Language configuration

    Each language is configured by adding a `[[language]]` section to a
    `languages.toml` file. For example:

    ```toml
    [[language]]
    name = "mylang"
    scope = "source.mylang"
    injection-regex = "mylang"
    file-types = ["mylang", "myl"]
    comment-tokens = "#"
    indent = { tab-width = 2, unit = "  " }
    formatter = { command = "mylang-formatter" , args = ["--stdin"] }
    language-servers = [ "mylang-lsp" ]
    ```

    These configuration keys are available:

    | Key                   | Description                                                   |
    | ----                  | -----------                                                   |
    | `name`                | The name of the language                                      |
    | `language-id`         | The language-id for language servers, checkout the table at [TextDocumentItem](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentItem) for the right id |
    | `scope`               | A string like `source.js` that identifies the language. Currently, we strive to match the scope names used by popular TextMate grammars and by the Linguist library. Usually `source.<name>` or `text.<name>` in case of markup languages |
    | `injection-regex`     | regex pattern that will be tested against a language name in order to determine whether this language should be used for a potential [language injection][treesitter-language-injection] site. |
    | `file-types`          | The filetypes of the language, for example `["yml", "yaml"]`. See the file-type detection section below. |
    | `shebangs`            | The interpreters from the shebang line, for example `["sh", "bash"]` |
    | `roots`               | A set of marker files to look for when trying to find the workspace root. For example `Cargo.lock`, `yarn.lock` |
    | `auto-format`         | Whether to autoformat this language when saving               |
    | `diagnostic-severity` | Minimal severity of diagnostic for it to be displayed. (Allowed values: `error`, `warning`, `info`, `hint`) |
    | `comment-tokens`      | The tokens to use as a comment token, either a single token `"//"` or an array `["//", "///", "//!"]` (the first token will be used for commenting). Also configurable as `comment-token` for backwards compatibility|
    | `block-comment-tokens`| The start and end tokens for a multiline comment either an array or single table of `{ start = "/*", end = "*/"}`. The first set of tokens will be used for commenting, any pairs in the array can be uncommented |
    | `indent`              | The indent to use. Has sub keys `unit` (the text inserted into the document when indenting; usually set to N spaces or `"\t"` for tabs) and `tab-width` (the number of spaces rendered for a tab) |
    | `language-servers`    | The Language Servers used for this language. See below for more information in the section [Configuring Language Servers for a language](#configuring-language-servers-for-a-language)   |
    | `grammar`             | The tree-sitter grammar to use (defaults to the value of `name`) |
    | `formatter`           | The formatter for the language, it will take precedence over the lsp when defined. The formatter must be able to take the original file as input from stdin and write the formatted file to stdout. The filename of the current buffer can be passed as argument by using the `%{buffer_name}` expansion variable. See below for more information in the [Configuring the formatter command](#configuring-the-formatter-command) |
    | `soft-wrap`           | [editor.softwrap](./editor.md#editorsoft-wrap-section)
    | `text-width`          |  Maximum line length. Used for the `:reflow` command and soft-wrapping if `soft-wrap.wrap-at-text-width` is set, defaults to `editor.text-width`   |
    | `rulers`              | Overrides the `editor.rulers` config key for the language. |
    | `path-completion`     | Overrides the `editor.path-completion` config key for the language. |
    | `workspace-lsp-roots`     | Directories relative to the workspace root that are treated as LSP roots. Should only be set in `.helix/config.toml`. Overwrites the setting of the same name in `config.toml` if set. |
    | `persistent-diagnostic-sources` | An array of LSP diagnostic sources assumed unchanged when the language server resends the same set of diagnostics. Helix can track the position for these diagnostics internally instead. Useful for diagnostics that are recomputed on save.

    ### File-type detection and the `file-types` key

    Helix determines which language configuration to use based on the `file-types` key
    from the above section. `file-types` is a list of strings or tables, for
    example:

    ```toml
    file-types = ["toml", { glob = "Makefile" }, { glob = ".git/config" }, { glob = ".github/workflows/*.yaml" } ]
    ```

    When determining a language configuration to use, Helix searches the file-types
    with the following priorities:

    1. Glob: values in `glob` tables are checked against the full path of the given
       file. Globs are standard Unix-style path globs (e.g. the kind you use in Shell)
       and can be used to match paths for a specific prefix, suffix, directory, etc.
       In the above example, the `{ glob = "Makefile" }` config would match files
       with the name `Makefile`, the `{ glob = ".git/config" }` config would match
       `config` files in `.git` directories, and the `{ glob = ".github/workflows/*.yaml" }`
       config would match any `yaml` files in `.github/workflow` directories. Note
       that globs should always use the Unix path separator `/` even on Windows systems;
       the matcher will automatically take the machine-specific separators into account.
       If the glob isn't an absolute path or doesn't already start with a glob prefix,
       `*/` will automatically be added to ensure it matches for any subdirectory.
    2. Extension: if there are no glob matches, any `file-types` string that matches
       the file extension of a given file wins. In the example above, the `"toml"`
       config matches files like `Cargo.toml` or `languages.toml`.

    ### Configuring the formatter command

    [Command line expansions](./command-line.md#expansions) are supported in the arguments
    of the formatter command. In particular, the `%{buffer_name}` variable can be passed as
    argument to the formatter:

    ```toml
    formatter = { command = "mylang-formatter" , args = ["--stdin", "--stdin-filename %{buffer_name}"] }
    ```
  documentationQuestion1: What are the primary purposes of the language configuration system in Helix, and what types of languages does it support?
  documentationQuestion2: How can you configure Helix to automatically format a file when saving, and what is the correct syntax for specifying a custom formatter command?
  documentationQuestion3: Provide an example of how to define a language configuration for a custom language called 'mylang' with specific file types, comment tokens, and a formatter command.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `languages page of the documentation provided by Helix`.



    Documentation text:

    ## Language Server configuration

    Language servers are configured separately in the table `language-server` in the same file as the languages `languages.toml`

    For example:

    ```toml
    [language-server.mylang-lsp]
    command = "mylang-lsp"
    args = ["--stdio"]
    config = { provideFormatter = true }
    environment = { "ENV1" = "value1", "ENV2" = "value2" }

    [language-server.efm-lsp-prettier]
    command = "efm-langserver"

    [language-server.efm-lsp-prettier.config]
    documentFormatting = true
    languages = { typescript = [ { formatCommand ="prettier --stdin-filepath ${INPUT}", formatStdin = true } ] }
    ```

    These are the available options for a language server.

    | Key                        | Description                                                                                                                       |
    | ----                       | -----------                                                                                                                       |
    | `command`                  | The name or path of the language server binary to execute. Binaries must be in `$PATH`                                            |
    | `args`                     | A list of arguments to pass to the language server binary                                                                         |
    | `config`                   | Language server initialization options                                                                                            |
    | `timeout`                  | The maximum time a request to the language server may take, in seconds. Defaults to `20`                                          |
    | `environment`              | Any environment variables that will be used when starting the language server `{ "KEY1" = "Value1", "KEY2" = "Value2" }`          |
    | `required-root-patterns`   | A list of `glob` patterns to look for in the working directory. The language server is started if at least one of them is found.  |

    A `format` sub-table within `config` can be used to pass extra formatting options to
    [Document Formatting Requests](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_formatting).
    For example, with typescript:

    ```toml
    [language-server.typescript-language-server]
    # pass format options according to https://github.com/typescript-language-server/typescript-language-server#workspacedidchangeconfiguration omitting the "[language].format." prefix.
    config = { format = { "semicolons" = "insert", "insertSpaceBeforeFunctionParenthesis" = true } }
    ```

    ### Configuring Language Servers for a language

    The `language-servers` attribute in a language tells helix which language servers are used for this language.

    They have to be defined in the `[language-server]` table as described in the previous section.

    Different languages can use the same language server instance, e.g. `typescript-language-server` is used for javascript, jsx, tsx and typescript by default.

    The definition order of language servers affects the order in the results list of code action menu.

    In case multiple language servers are specified in the `language-servers` attribute of a `language`,
    it's often useful to only enable/disable certain language-server features for these language servers.

    As an example, `efm-lsp-prettier` of the previous example is used only with a formatting command `prettier`,
    so everything else should be handled by the `typescript-language-server` (which is configured by default).
    The language configuration for typescript could look like this:

    ```toml
    [[language]]
    name = "typescript"
    language-servers = [ { name = "efm-lsp-prettier", only-features = [ "format" ] }, "typescript-language-server" ]
    ```

    or equivalent:

    ```toml
    [[language]]
    name = "typescript"
    language-servers = [ { name = "typescript-language-server", except-features = [ "format" ] }, "efm-lsp-prettier" ]
    ```

    Each requested LSP feature is prioritized in the order of the `language-servers` array.
    For example, the first `goto-definition` supported language server (in this case `typescript-language-server`) will be taken for the relevant LSP request (command `goto_definition`).
    The features `diagnostics`, `code-action`, `completion`, `document-symbols` and `workspace-symbols` are an exception to that rule, as they are working for all language servers at the same time and are merged together, if enabled for the language.
    If no `except-features` or `only-features` is given, all features for the language server are enabled.
    If a language server itself doesn't support a feature, the next language server array entry will be tried (and so on).

    The list of supported features is:

    - `format`
    - `goto-definition`
    - `goto-declaration`
    - `goto-type-definition`
    - `goto-reference`
    - `goto-implementation`
    - `signature-help`
    - `hover`
    - `document-highlight`
    - `completion`
    - `code-action`
    - `workspace-command`
    - `document-symbols`
    - `workspace-symbols`
    - `diagnostics`
    - `rename-symbol`
    - `inlay-hints`
  documentationQuestion1: What is the primary purpose of configuring language servers in Helix, and what are the key settings involved in this configuration?
  documentationQuestion2: How can you configure Helix to use the `efm-lsp-prettier` language server only for formatting TypeScript files while using the default `typescript-language-server` for other features?
  documentationQuestion3: What is the significance of the `language-servers` attribute in a language configuration and how does the order of language servers affect feature prioritization in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `languages page of the documentation provided by Helix`.



    Documentation text:

    ## Tree-sitter grammar configuration

    The source for a language's tree-sitter grammar is specified in a `[[grammar]]`
    section in `languages.toml`. For example:

    ```toml
    [[grammar]]
    name = "mylang"
    source = { git = "https://github.com/example/mylang", rev = "a250c4582510ff34767ec3b7dcdd3c24e8c8aa68" }
    ```

    Grammar configuration takes these keys:

    | Key      | Description                                                              |
    | ---      | -----------                                                              |
    | `name`   | The name of the tree-sitter grammar                                      |
    | `source` | The method of fetching the grammar - a table with a schema defined below |

    Where `source` is a table with either these keys when using a grammar from a
    git repository:

    | Key    | Description                                               |
    | ---    | -----------                                               |
    | `git`  | A git remote URL from which the grammar should be cloned  |
    | `rev`  | The revision (commit hash or tag) which should be fetched |
    | `subpath` | A path within the grammar directory which should be built. Some grammar repositories host multiple grammars (for example `tree-sitter-typescript` and `tree-sitter-ocaml`) in subdirectories. This key is used to point `hx --grammar build` to the correct path for compilation. When omitted, the root of repository is used |

    ### Choosing grammars

    You may use a top-level `use-grammars` key to control which grammars are
    fetched and built when using `hx --grammar fetch` and `hx --grammar build`.

    ```toml
    # Note: this key must come **before** the [[language]] and [[grammar]] sections
    use-grammars = { only = [ "rust", "c", "cpp" ] }
    # or
    use-grammars = { except = [ "yaml", "json" ] }
    ```

    When omitted, all grammars are fetched and built.

    [treesitter-language-injection]: https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#language-injection
  documentationQuestion1: What is the primary purpose of the Tree-sitter grammar configuration in Helix's languages page documentation?
  documentationQuestion2: How can a user configure a custom Tree-sitter grammar for a language named 'mylang' using a specific git repository and commit hash?
  documentationQuestion3: What is the significance of the `subpath` key in the Tree-sitter grammar configuration and how can it be used to specify the correct grammar directory?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `surround page of the documentation provided by Helix`.



    Documentation text:

    ## Surround

    Helix includes built-in functionality similar to [vim-surround](https://github.com/tpope/vim-surround).
    The keymappings have been inspired from [vim-sandwich](https://github.com/machakann/vim-sandwich):

    ![Surround demo](https://user-images.githubusercontent.com/23398472/122865801-97073180-d344-11eb-8142-8f43809982c6.gif)

    | Key Sequence                      | Action                                  |
    | --------------------------------- | --------------------------------------- |
    | `ms<char>` (after selecting text) | Add surround characters to selection    |
    | `mr<char_to_replace><new_char>`   | Replace the closest surround characters |
    | `md<char_to_delete>`              | Delete the closest surround characters  |

    You can use counts to act on outer pairs.

    Surround can also act on multiple selections. For example, to change every occurrence of `(use)` to `[use]`:

    1. `%` to select the whole file
    2. `s` to split the selections on a search term
    3. Input `use` and hit Enter
    4. `mr([` to replace the parentheses with square brackets

    Multiple characters are currently not supported, but planned for future release.
  documentationQuestion1: What is the primary purpose of the Surround feature in Helix, and how does it compare to Vim's surround plugin?
  documentationQuestion2: How can you use the Surround feature in Helix to replace all instances of parentheses with square brackets in a file?
  documentationQuestion3: What are the key mappings and their functions in the Surround feature of Helix, and how can they be used in practical text editing scenarios?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `pickers page of the documentation provided by Helix`.



    Documentation text:

    ## Using pickers

    Helix has a variety of pickers, which are interactive windows used to select various kinds of items. These include a file picker, global search picker, and more. Most pickers are accessed via keybindings in [space mode](./keymap.md#space-mode). Pickers have their own [keymap](./keymap.md#picker) for navigation.

    ### Filtering Picker Results

    Most pickers perform fuzzy matching using [fzf syntax](https://github.com/junegunn/fzf?tab=readme-ov-file#search-syntax). Two exceptions are the global search picker, which uses regex, and the workspace symbol picker, which passes search terms to the language server. Note that OR operations (`|`) are not currently supported.

    If a picker shows multiple columns, you may apply the filter to a specific column by prefixing the column name with `%`. Column names can be shortened to any prefix, so `%p`, `%pa` or `%pat` all mean the same as `%path`. For example, a query of `helix %p .toml !lang` in the global search picker searches for the term "helix" within files with paths ending in ".toml" but not including "lang".

    You can insert the contents of a [register](./registers.md) using `Ctrl-r` followed by a register name. For example, one could insert the currently selected text using `Ctrl-r`-`.`, or the directory of the current file using `Ctrl-r`-`%` followed by `Ctrl-w` to remove the last path section. The global search picker will use the contents of the [search register](./registers.md#default-registers) if you press `Enter` without typing a filter. For example, pressing `*`-`Space-/`-`Enter` will start a global search for the currently selected text.
  documentationQuestion1: What are the main purposes of using pickers in Helix, and what types of items can be selected through them?
  documentationQuestion2: How can you filter picker results in Helix to search for specific file types, such as TOML files, while excluding certain keywords like 'lang'?
  documentationQuestion3: What is the process for inserting the contents of a register into a picker filter in Helix, and how can this be used to quickly perform a global search with previously selected text?

- prompt: "You are playing the role of a college professor. Here is some text copied from the `remapping page of the documentation provided by Helix`.\n\n\n\nDocumentation text:\n\n## Key remapping\n\nHelix currently supports one-way key remapping through a simple TOML configuration\nfile. (More powerful solutions such as rebinding via commands will be\navailable in the future).\n\nThere are three kinds of commands that can be used in keymaps:\n\n* Static commands: commands like `move_char_right` which are usually bound to\n  keys and used for movement and editing. A list of static commands is\n  available in the [Keymap](./keymap.html) documentation and in the source code\n  in [`helix-term/src/commands.rs`](https://github.com/helix-editor/helix/blob/master/helix-term/src/commands.rs)\n  at the invocation of `static_commands!` macro.\n* Typable commands: commands that can be executed from command mode (`:`), for\n  example `:write!`. See the [Commands](./commands.md) documentation for a\n  list of available typeable commands or the `TypableCommandList` declaration in\n  the source code at [`helix-term/src/commands/typed.rs`](https://github.com/helix-editor/helix/blob/master/helix-term/src/commands/typed.rs).\n* Macros: sequences of keys that are executed in order. These keybindings\n  start with `@` and then list any number of keys to be executed. For example\n  `@miw` can be used to select the surrounding word. For now, macro keybindings\n  are not allowed in keybinding sequences due to limitations in the way that\n  command sequences are executed. Modifier keys (e.g. Alt+o) can be used\n  like `\"<A-o>\"`, e.g. `\"@miw<A-o>\"`\n\nTo remap keys, create a `config.toml` file in your `helix` configuration\ndirectory (default `~/.config/helix` on Linux systems) with a structure like\nthis:\n\n> 💡 To set a modifier + key as a keymap, type `A-X = ...` or  `C-X = ...` for Alt + X or Ctrl + X. Combine with Shift using a dash, e.g. `C-S-esc`. \n> Within macros, wrap them in `<>`, e.g. `<A-X>` and `<C-X>` to distinguish from the `A` or `C` keys.\n\n```toml\n# At most one section each of 'keys.normal', 'keys.insert' and 'keys.select'\n[keys.normal]\nC-s = \":w\" # Maps Ctrl-s to the typable command :w which is an alias for :write (save file)\nC-o = \":open ~/.config/helix/config.toml\" # Maps Ctrl-o to opening of the helix config file\na = \"move_char_left\" # Maps the 'a' key to the move_char_left command\nw = \"move_line_up\" # Maps the 'w' key move_line_up\n\"C-S-esc\" = \"extend_line\" # Maps Ctrl-Shift-Escape to extend_line\ng = { a = \"code_action\" } # Maps `ga` to show possible code actions\n\"ret\" = [\"open_below\", \"normal_mode\"] # Maps the enter key to open_below then re-enter normal mode\n\"A-x\" = \"@x<A-d>\" # Maps Alt-x to a macro selecting the whole line and deleting it without yanking it\n\n[keys.insert]\n\"A-x\" = \"normal_mode\"     # Maps Alt-X to enter normal mode\nj = { k = \"normal_mode\" } # Maps `jk` to exit insert mode\n```"
  documentationQuestion1: What are the primary purposes of key remapping in Helix as described in the documentation?
  documentationQuestion2: How can a user remap the Alt+X key to enter normal mode in insert mode using Helix's key remapping feature?
  documentationQuestion3: Provide an example of how to create a macro in Helix's key remapping configuration that selects the entire line and deletes it without yanking.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `remapping page of the documentation provided by Helix`.



    Documentation text:

    ## Minor modes

    Minor modes are accessed by pressing a key (usually from normal mode), giving access to dedicated bindings. Bindings
    can be modified or added by nesting definitions.

    ```toml
    [keys.insert.j]
    k = "normal_mode" # Maps `jk` to exit insert mode

    [keys.normal.g]
    a = "code_action" # Maps `ga` to show possible code actions

    # invert `j` and `k` in view mode
    [keys.normal.z]
    j = "scroll_up"
    k = "scroll_down"

    # create a new minor mode bound to `+`
    [keys.normal."+"]
    m = ":run-shell-command make"
    c = ":run-shell-command cargo build"
    t = ":run-shell-command cargo test"
    ```

    ## Special keys and modifiers

    Ctrl, Shift and Alt modifiers are encoded respectively with the prefixes `C-`, `S-` and `A-`.

    The [Super key](https://en.wikipedia.org/wiki/Super_key_(keyboard_button)) - the Windows/Linux
    key or the Command key on Mac keyboards - is also supported when using a terminal emulator that
    supports the [enhanced keyboard protocol](https://github.com/helix-editor/helix/wiki/Terminal-Support#enhanced-keyboard-protocol).
    The super key is encoded with prefixes `Meta-`, `Cmd-` or `Win-`. These are all synonyms for the
    super modifier - binding a key with a `Win-` modifier will mean it can be used with the
    Windows/Linux key or the Command key.

    ```toml
    [keys.normal]
    C-s = ":write" # Ctrl and 's' to write
    Cmd-s = ":write" # Cmd or Win or Meta and 's' to write
    ```

    Special keys are encoded as follows:

    | Key name     | Representation |
    | ---          | ---            |
    | Backspace    | `"backspace"`  |
    | Space        | `"space"`      |
    | Return/Enter | `"ret"`        |
    | Left         | `"left"`       |
    | Right        | `"right"`      |
    | Up           | `"up"`         |
    | Down         | `"down"`       |
    | Home         | `"home"`       |
    | End          | `"end"`        |
    | Page Up      | `"pageup"`     |
    | Page Down    | `"pagedown"`   |
    | Tab          | `"tab"`        |
    | Delete       | `"del"`        |
    | Insert       | `"ins"`        |
    | Null         | `"null"`       |
    | Escape       | `"esc"`        |

    Keys can be disabled by binding them to the `no_op` command.

    All other keys such as `?`, `!`, `-` etc. can be used literally:

    ```toml
    [keys.normal]
    "?" = ":write"
    "!" = ":write"
    "-" = ":write"
    ```

    Note: `-` can't be used when combined with a modifier, for example `Alt` + `-` should be written as `A-minus`. `A--` is not accepted.
  documentationQuestion1: What is the primary purpose of minor modes in Helix, and how do they enhance the editor's functionality?
  documentationQuestion2: How can you configure Helix to map `jk` to exit insert mode and `ga` to show code actions using the key binding syntax described in the documentation?
  documentationQuestion3: What is the correct syntax to bind the `+` key to run different shell commands (make, cargo build, cargo test) in Helix, and how does this demonstrate the flexibility of minor modes?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ## Editor

    - [`[editor]` Section](#editor-section)
    - [`[editor.clipboard-provider]` Section](#editorclipboard-provider-section)
    - [`[editor.statusline]` Section](#editorstatusline-section)
    - [`[editor.lsp]` Section](#editorlsp-section)
    - [`[editor.cursor-shape]` Section](#editorcursor-shape-section)
    - [`[editor.file-picker]` Section](#editorfile-picker-section)
    - [`[editor.auto-pairs]` Section](#editorauto-pairs-section)
    - [`[editor.auto-save]` Section](#editorauto-save-section)
    - [`[editor.search]` Section](#editorsearch-section)
    - [`[editor.whitespace]` Section](#editorwhitespace-section)
    - [`[editor.indent-guides]` Section](#editorindent-guides-section)
    - [`[editor.gutters]` Section](#editorgutters-section)
      - [`[editor.gutters.line-numbers]` Section](#editorguttersline-numbers-section)
      - [`[editor.gutters.diagnostics]` Section](#editorguttersdiagnostics-section)
      - [`[editor.gutters.diff]` Section](#editorguttersdiff-section)
      - [`[editor.gutters.spacer]` Section](#editorguttersspacer-section)
    - [`[editor.soft-wrap]` Section](#editorsoft-wrap-section)
    - [`[editor.smart-tab]` Section](#editorsmart-tab-section)
    - [`[editor.inline-diagnostics]` Section](#editorinline-diagnostics-section)
  documentationQuestion1: What are the primary purposes of the editor configuration sections in the Helix documentation?
  documentationQuestion2: How can a user enable line numbers in the editor using the configuration file?
  documentationQuestion3: What is the purpose of the `editor.auto-save` section, and how can it be configured to save files automatically when changes are detected?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor]` Section

    | Key | Description | Default |
    |--|--|---------|
    | `scrolloff` | Number of lines of padding around the edge of the screen when scrolling | `5` |
    | `mouse` | Enable mouse mode | `true` |
    | `default-yank-register` | Default register used for yank/paste | `"` |
    | `middle-click-paste` | Middle click paste support | `true` |
    | `scroll-lines` | Number of lines to scroll per scroll wheel step | `3` |
    | `shell` | Shell to use when running external commands | Unix: `["sh", "-c"]`<br/>Windows: `["cmd", "/C"]` |
    | `line-number` | Line number display: `absolute` simply shows each line's number, while `relative` shows the distance from the current line. When unfocused or in insert mode, `relative` will still show absolute line numbers | `absolute` |
    | `cursorline` | Highlight all lines with a cursor | `false` |
    | `cursorcolumn` | Highlight all columns with a cursor | `false` |
    | `continue-comments` | if helix should automatically add a line comment token if you create a new line inside a comment. | `true` |
    | `gutters` | Gutters to display: Available are `diagnostics` and `diff` and `line-numbers` and `spacer`, note that `diagnostics` also includes other features like breakpoints, 1-width padding will be inserted if gutters is non-empty | `["diagnostics", "spacer", "line-numbers", "spacer", "diff"]` |
    | `auto-completion` | Enable automatic pop up of auto-completion | `true` |
    | `path-completion` | Enable filepath completion. Show files and directories if an existing path at the cursor was recognized, either absolute or relative to the current opened document or current working directory (if the buffer is not yet saved). Defaults to true. | `true` |
    | `auto-format` | Enable automatic formatting on save | `true` |
    | `idle-timeout` | Time in milliseconds since last keypress before idle timers trigger. | `250` |
    | `completion-timeout` | Time in milliseconds after typing a word character before completions are shown, set to 5 for instant.  | `250` |
    | `preview-completion-insert` | Whether to apply completion item instantly when selected | `true` |
    | `completion-trigger-len` | The min-length of word under cursor to trigger autocompletion | `2` |
    | `completion-replace` | Set to `true` to make completions always replace the entire word and not just the part before the cursor | `false` |
    | `auto-info` | Whether to display info boxes | `true` |
    | `true-color` | Set to `true` to override automatic detection of terminal truecolor support in the event of a false negative | `false` |
    | `undercurl` | Set to `true` to override automatic detection of terminal undercurl support in the event of a false negative | `false` |
    | `rulers` | List of column positions at which to display the rulers. Can be overridden by language specific `rulers` in `languages.toml` file | `[]` |
    | `bufferline` | Renders a line at the top of the editor displaying open buffers. Can be `always`, `never` or `multiple` (only shown if more than one buffer is in use) | `never` |
    | `color-modes` | Whether to color the mode indicator with different colors depending on the mode itself | `false` |
    | `text-width` | Maximum line length. Used for the `:reflow` command and soft-wrapping if `soft-wrap.wrap-at-text-width` is set | `80` |
    | `workspace-lsp-roots` | Directories relative to the workspace root that are treated as LSP roots. Should only be set in `.helix/config.toml` | `[]` |
    | `default-line-ending` | The line ending to use for new documents. Can be `native`, `lf`, `crlf`, `ff`, `cr` or `nel`. `native` uses the platform's native line ending (`crlf` on Windows, otherwise `lf`). | `native` |
    | `insert-final-newline` | Whether to automatically insert a trailing line-ending on write if missing | `true` |
    | `trim-final-newlines` | Whether to automatically remove line-endings after the final one on write | `false` |
    | `trim-trailing-whitespace` | Whether to automatically remove whitespace preceding line endings on write | `false` |
    | `popup-border` | Draw border around `popup`, `menu`, `all`, or `none` | `none` |
    | `indent-heuristic` | How the indentation for a newly inserted line is computed: `simple` just copies the indentation level from the previous line, `tree-sitter` computes the indentation based on the syntax tree and `hybrid` combines both approaches. If the chosen heuristic is not available, a different one will be used as a fallback (the fallback order being `hybrid` -> `tree-sitter` -> `simple`). | `hybrid`
    | `jump-label-alphabet` | The characters that are used to generate two character jump labels. Characters at the start of the alphabet are used first. | `"abcdefghijklmnopqrstuvwxyz"`
    | `end-of-line-diagnostics` | Minimum severity of diagnostics to render at the end of the line. Set to `disable` to disable entirely. Refer to the setting about `inline-diagnostics` for more details | "disable"
    | `clipboard-provider` | Which API to use for clipboard interaction. One of `pasteboard` (MacOS), `wayland`, `x-clip`, `x-sel`, `win-32-yank`, `termux`, `tmux`, `windows`, `termcode`, `none`, or a custom command set. | Platform and environment specific. |
    | `editor-config` | Whether to read settings from [EditorConfig](https://editorconfig.org) files | `true` |
  documentationQuestion1: What is the primary purpose of the `[editor]` section in Helix's configuration, and what are some of the key settings that can be customized within it?
  documentationQuestion2: How can you configure Helix to automatically format code on save, and what are the implications of enabling the `auto-format` setting?
  documentationQuestion3: What are the available options for the `shell` setting in Helix, and how does it affect the execution of external commands?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.clipboard-provider]` Section

    Helix can be configured either to use a builtin clipboard configuration or to use
    a provided command.

    For instance, setting it to use OSC 52 termcodes, the configuration would be:
    ```toml
    [editor]
    clipboard-provider = "termcode"
    ```

    Alternatively, Helix can be configured to use arbitrary commands for clipboard integration:

    ```toml
    [editor.clipboard-provider.custom]
    yank = { command = "cat",  args = ["test.txt"] }
    paste = { command = "tee",  args = ["test.txt"] }
    primary-yank = { command = "cat",  args = ["test-primary.txt"] } # optional
    primary-paste = { command = "tee",  args = ["test-primary.txt"] } # optional
    ```

    For custom commands the contents of the yank/paste is communicated over stdin/stdout.

    ### `[editor.statusline]` Section

    Allows configuring the statusline at the bottom of the editor.

    The configuration distinguishes between three areas of the status line:

    `[ ... ... LEFT ... ... | ... ... ... CENTER ... ... ... | ... ... RIGHT ... ... ]`

    Statusline elements can be defined as follows:

    ```toml
    [editor.statusline]
    left = ["mode", "spinner"]
    center = ["file-name"]
    right = ["diagnostics", "selections", "position", "file-encoding", "file-line-ending", "file-type"]
    separator = "│"
    mode.normal = "NORMAL"
    mode.insert = "INSERT"
    mode.select = "SELECT"
    diagnostics = ["warning", "error"]
    workspace-diagnostics = ["warning", "error"]
    ```
    The `[editor.statusline]` key takes the following sub-keys:

    | Key           | Description | Default |
    | ---           | ---         | ---     |
    | `left`        | A list of elements aligned to the left of the statusline | `["mode", "spinner", "file-name", "read-only-indicator", "file-modification-indicator"]` |
    | `center`      | A list of elements aligned to the middle of the statusline | `[]` |
    | `right`       | A list of elements aligned to the right of the statusline | `["diagnostics", "selections", "register", "position", "file-encoding"]` |
    | `separator`   | The character used to separate elements in the statusline | `"│"` |
    | `mode.normal` | The text shown in the `mode` element for normal mode | `"NOR"` |
    | `mode.insert` | The text shown in the `mode` element for insert mode | `"INS"` |
    | `mode.select` | The text shown in the `mode` element for select mode | `"SEL"` |
    | `diagnostics` | A list of severities which are displayed for the current buffer | `["warning", "error"]` |
    | `workspace-diagnostics` | A list of severities which are displayed for the workspace | `["warning", "error"]` |

    The following statusline elements can be configured:

    | Key    | Description |
    | ------ | ----------- |
    | `mode` | The current editor mode (`mode.normal`/`mode.insert`/`mode.select`) |
    | `spinner` | A progress spinner indicating LSP activity |
    | `file-name` | The path/name of the opened file |
    | `file-absolute-path` | The absolute path/name of the opened file |
    | `file-base-name` | The basename of the opened file |
    | `file-modification-indicator` | The indicator to show whether the file is modified (a `[+]` appears when there are unsaved changes) |
    | `file-encoding` | The encoding of the opened file if it differs from UTF-8 |
    | `file-line-ending` | The file line endings (CRLF or LF) |
    | `read-only-indicator` | An indicator that shows `[readonly]` when a file cannot be written |
    | `total-line-numbers` | The total line numbers of the opened file |
    | `file-type` | The type of the opened file |
    | `diagnostics` | The number of warnings and/or errors |
    | `workspace-diagnostics` | The number of warnings and/or errors on workspace |
    | `selections` | The number of active selections |
    | `primary-selection-length` | The number of characters currently in primary selection |
    | `position` | The cursor position |
    | `position-percentage` | The cursor position as a percentage of the total number of lines |
    | `separator` | The string defined in `editor.statusline.separator` (defaults to `"│"`) |
    | `spacer` | Inserts a space between elements (multiple/contiguous spacers may be specified) |
    | `version-control` | The current branch name or detached commit hash of the opened workspace |
    | `register` | The current selected register |
  documentationQuestion1: What is the primary purpose of the `editor.statusline` configuration in Helix?
  documentationQuestion2: How can a user configure custom clipboard commands in Helix using the `editor.clipboard-provider.custom` section?
  documentationQuestion3: What is the correct syntax to display the current file's absolute path and line number in the statusline of Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.lsp]` Section

    | Key                   | Description                                                 | Default |
    | ---                   | -----------                                                 | ------- |
    | `enable`              | Enables LSP integration. Setting to false will completely disable language servers regardless of language settings.| `true` |
    | `display-messages`    | Display LSP `window/showMessage` messages below statusline[^1] | `true` |
    | `display-progress-messages` | Display LSP progress messages below statusline[^1]    | `false` |
    | `auto-signature-help` | Enable automatic popup of signature help (parameter hints)  | `true`  |
    | `display-inlay-hints` | Display inlay hints[^2]                                     | `false` |
    | `display-color-swatches` | Show color swatches next to colors | `true` |
    | `display-signature-help-docs` | Display docs under signature help popup             | `true`  |
    | `snippets`      | Enables snippet completions. Requires a server restart (`:lsp-restart`) to take effect after `:config-reload`/`:set`. | `true`  |
    | `goto-reference-include-declaration` | Include declaration in the goto references popup. | `true`  |

    [^1]: By default, a progress spinner is shown in the statusline beside the file path.

    [^2]: You may also have to activate them in the language server config for them to appear, not just in Helix. Inlay hints in Helix are still being improved on and may be a little bit laggy/janky under some circumstances. Please report any bugs you see so we can fix them!
  documentationQuestion1: What is the primary purpose of the `[editor.lsp]` section in Helix's configuration?
  documentationQuestion2: How can a user enable snippet completions in Helix's LSP configuration, and what additional step is required to apply the change?
  documentationQuestion3: What is the effect of setting `display-inlay-hints` to `true` in the `[editor.lsp]` section, and how does it interact with language server configurations?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.cursor-shape]` Section

    Defines the shape of cursor in each mode.
    Valid values for these options are `block`, `bar`, `underline`, or `hidden`.

    > 💡 Due to limitations of the terminal environment, only the primary cursor can
    > change shape.

    | Key      | Description                                | Default |
    | ---      | -----------                                | ------- |
    | `normal` | Cursor shape in [normal mode][normal mode] | `block` |
    | `insert` | Cursor shape in [insert mode][insert mode] | `block` |
    | `select` | Cursor shape in [select mode][select mode] | `block` |

    [normal mode]: ./keymap.md#normal-mode
    [insert mode]: ./keymap.md#insert-mode
    [select mode]: ./keymap.md#select--extend-mode

    ### `[editor.file-picker]` Section

    Set options for file picker and global search. Ignoring a file means it is
    not visible in the Helix file picker and global search.

    All git related options are only enabled in a git repository.

    | Key | Description | Default |
    |--|--|---------|
    |`hidden` | Enables ignoring hidden files | `true`
    |`follow-symlinks` | Follow symlinks instead of ignoring them | `true`
    |`deduplicate-links` | Ignore symlinks that point at files already shown in the picker | `true`
    |`parents` | Enables reading ignore files from parent directories | `true`
    |`ignore` | Enables reading `.ignore` files | `true`
    |`git-ignore` | Enables reading `.gitignore` files | `true`
    |`git-global` | Enables reading global `.gitignore`, whose path is specified in git's config: `core.excludesfile` option | `true`
    |`git-exclude` | Enables reading `.git/info/exclude` files | `true`
    |`max-depth` | Set with an integer value for maximum depth to recurse | Unset by default

    Ignore files can be placed locally as `.ignore` or put in your home directory as `~/.ignore`. They support the usual ignore and negative ignore (unignore) rules used in `.gitignore` files.

    Additionally, you can use Helix-specific ignore files by creating a local `.helix/ignore` file in the current workspace or a global `ignore` file located in your Helix config directory:
    - Linux and Mac: `~/.config/helix/ignore`
    - Windows: `%AppData%\helix\ignore`

    Example:

    ```ini
    # unignore in file picker and global search
    !.github/
    !.gitignore
    !.gitattributes
    ```
  documentationQuestion1: What is the primary purpose of the `editor.file-picker` section in Helix's configuration, and which files are commonly used to control its behavior?
  documentationQuestion2: How can a user configure the file picker to exclude hidden files and follow symbolic links while reading gitignore and global ignore files?
  documentationQuestion3: What are the different cursor shapes available in Helix's editor and how can they be customized for different modes?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.auto-pairs]` Section

    Enables automatic insertion of pairs to parentheses, brackets, etc. Can be a
    simple boolean value, or a specific mapping of pairs of single characters.

    To disable auto-pairs altogether, set `auto-pairs` to `false`:

    ```toml
    [editor]
    auto-pairs = false # defaults to `true`
    ```

    The default pairs are <code>(){}[]''""``</code>, but these can be customized by
    setting `auto-pairs` to a TOML table:

    ```toml
    [editor.auto-pairs]
    '(' = ')'
    '{' = '}'
    '[' = ']'
    '"' = '"'
    '`' = '`'
    '<' = '>'
    ```

    Additionally, this setting can be used in a language config. Unless
    the editor setting is `false`, this will override the editor config in
    documents with this language.

    Example `languages.toml` that adds `<>` and removes `''`

    ```toml
    [[language]]
    name = "rust"

    [language.auto-pairs]
    '(' = ')'
    '{' = '}'
    '[' = ']'
    '"' = '"'
    '`' = '`'
    '<' = '>'
    ```

    ### `[editor.auto-save]` Section

    Control auto save behavior.

    | Key | Description | Default |
    |--|--|---------|
    | `focus-lost` | Enable automatic saving on the focus moving away from Helix. Requires [focus event support](https://github.com/helix-editor/helix/wiki/Terminal-Support) from your terminal | `false` |
    | `after-delay.enable` | Enable automatic saving after `auto-save.after-delay.timeout` milliseconds have passed since last edit. | `false` |
    | `after-delay.timeout` | Time in milliseconds since last edit before auto save timer triggers. | `3000` |
  documentationQuestion1: What is the primary purpose of the `editor.auto-pairs` feature in Helix, and what are its common use cases?
  documentationQuestion2: How can a user configure Helix to automatically insert matching pairs for parentheses, brackets, and quotes, while also customizing the pairs for a specific programming language like Rust?
  documentationQuestion3: What command or configuration would you use to enable auto-saving in Helix when the focus is lost from the terminal, and how does this interact with the `auto-save.after-delay` settings?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.search]` Section

    Search specific options.

    | Key | Description | Default |
    |--|--|---------|
    | `smart-case` | Enable smart case regex searching (case-insensitive unless pattern contains upper case characters) | `true` |
    | `wrap-around`| Whether the search should wrap after depleting the matches | `true` |

    ### `[editor.whitespace]` Section

    Options for rendering whitespace with visible characters. Use `:set whitespace.render all` to temporarily enable visible whitespace.

    | Key | Description | Default |
    |-----|-------------|---------|
    | `render` | Whether to render whitespace. May either be `all` or `none`, or a table with sub-keys `space`, `nbsp`, `nnbsp`, `tab`, and `newline` | `none` |
    | `characters` | Literal characters to use when rendering whitespace. Sub-keys may be any of `tab`, `space`, `nbsp`, `nnbsp`, `newline` or `tabpad` | See example below |

    Example

    ```toml
    [editor.whitespace]
    render = "all"
    # or control each character
    [editor.whitespace.render]
    space = "all"
    tab = "all"
    nbsp = "none"
    nnbsp = "none"
    newline = "none"

    [editor.whitespace.characters]
    space = "·"
    nbsp = "⍽"
    nnbsp = "␣"
    tab = "→"
    newline = "⏎"
    tabpad = "·" # Tabs will look like "→···" (depending on tab width)
    ```
  documentationQuestion1: What is the primary purpose of the `editor.search` and `editor.whitespace` sections in the Helix editor configuration?
  documentationQuestion2: How can you configure the editor to display all types of whitespace with custom characters, such as using '·' for spaces and '→' for tabs?
  documentationQuestion3: What command would you use to temporarily enable the rendering of all whitespace characters in the Helix editor, and what does this option do?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.indent-guides]` Section

    Options for rendering vertical indent guides.

    | Key           | Description                                             | Default |
    | ---           | ---                                                     | ---     |
    | `render`      | Whether to render indent guides                         | `false` |
    | `character`   | Literal character to use for rendering the indent guide | `│`     |
    | `skip-levels` | Number of indent levels to skip                         | `0`     |

    Example:

    ```toml
    [editor.indent-guides]
    render = true
    character = "╎" # Some characters that work well: "▏", "┆", "┊", "⸽"
    skip-levels = 1
    ```

    ### `[editor.gutters]` Section

    For simplicity, `editor.gutters` accepts an array of gutter types, which will
    use default settings for all gutter components.

    ```toml
    [editor]
    gutters = ["diff", "diagnostics", "line-numbers", "spacer"]
    ```

    To customize the behavior of gutters, the `[editor.gutters]` section must
    be used. This section contains top level settings, as well as settings for
    specific gutter components as subsections.

    | Key      | Description                    | Default                                                       |
    | ---      | ---                            | ---                                                           |
    | `layout` | A vector of gutters to display | `["diagnostics", "spacer", "line-numbers", "spacer", "diff"]` |

    Example:

    ```toml
    [editor.gutters]
    layout = ["diff", "diagnostics", "line-numbers", "spacer"]
    ```

    #### `[editor.gutters.line-numbers]` Section

    Options for the line number gutter

    | Key         | Description                             | Default |
    | ---         | ---                                     | ---     |
    | `min-width` | The minimum number of characters to use | `3`     |

    Example:

    ```toml
    [editor.gutters.line-numbers]
    min-width = 1
    ```

    #### `[editor.gutters.diagnostics]` Section

    Currently unused

    #### `[editor.gutters.diff]` Section

    The `diff` gutter option displays colored bars indicating whether a `git` diff represents that a line was added, removed or changed.
    These colors are controlled by the theme attributes `diff.plus`, `diff.minus` and `diff.delta`.

    Other diff providers will eventually be supported by a future plugin system.

    There are currently no options for this section.

    #### `[editor.gutters.spacer]` Section

    Currently unused
  documentationQuestion1: What are the primary purposes of the `editor.indent-guides` and `editor.gutters` sections in the Helix editor configuration?
  documentationQuestion2: How can you enable and customize the display of indent guides in Helix, including changing the character used and skipping certain indent levels?
  documentationQuestion3: What is the purpose of the `editor.gutters.line-numbers` section, and how can you adjust the minimum width of the line number gutter in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.soft-wrap]` Section

    Options for soft wrapping lines that exceed the view width:

    | Key                  | Description                                                  | Default |
    | ---                  | ---                                                          | ---     |
    | `enable`             | Whether soft wrapping is enabled.                            | `false` |
    | `max-wrap`           | Maximum free space left at the end of the line.              | `20`    |
    | `max-indent-retain`  | Maximum indentation to carry over when soft wrapping a line. | `40`    |
    | `wrap-indicator`     | Text inserted before soft wrapped lines, highlighted with `ui.virtual.wrap` | `↪ `    |
    | `wrap-at-text-width` | Soft wrap at `text-width` instead of using the full viewport size. | `false` |

    Example:

    ```toml
    [editor.soft-wrap]
    enable = true
    max-wrap = 25 # increase value to reduce forced mid-word wrapping
    max-indent-retain = 0
    wrap-indicator = ""  # set wrap-indicator to "" to hide it
    ```
  documentationQuestion1: What are the primary purposes of the `editor.soft-wrap` configuration in Helix, and how does it affect the editing experience?
  documentationQuestion2: How can a user configure soft wrapping in Helix to hide the wrap indicator and adjust the maximum wrap value to 30?
  documentationQuestion3: In what scenarios would setting `max-indent-retain` to `0` be beneficial for a developer working with code formatting?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.smart-tab]` Section

    Options for navigating and editing using tab key.

    | Key        | Description | Default |
    |------------|-------------|---------|
    | `enable` | If set to true, then when the cursor is in a position with non-whitespace to its left, instead of inserting a tab, it will run `move_parent_node_end`. If there is only whitespace to the left, then it inserts a tab as normal. With the default bindings, to explicitly insert a tab character, press Shift-tab. | `true` |
    | `supersede-menu` | Normally, when a menu is on screen, such as when auto complete is triggered, the tab key is bound to cycling through the items. This means when menus are on screen, one cannot use the tab key to trigger the `smart-tab` command. If this option is set to true, the `smart-tab` command always takes precedence, which means one cannot use the tab key to cycle through menu items. One of the other bindings must be used instead, such as arrow keys or `C-n`/`C-p`. | `false` |


    Due to lack of support for S-tab in some terminals, the default keybindings don't fully embrace smart-tab editing experience. If you enjoy smart-tab navigation and a terminal that supports the [Enhanced Keyboard protocol](https://github.com/helix-editor/helix/wiki/Terminal-Support#enhanced-keyboard-protocol), consider setting extra keybindings:

    ```
    [keys.normal]
    tab = "move_parent_node_end"
    S-tab = "move_parent_node_start"

    [keys.insert]
    S-tab = "move_parent_node_start"

    [keys.select]
    tab = "extend_parent_node_end"
    S-tab = "extend_parent_node_start"
    ```
  documentationQuestion1: What is the primary purpose of the smart-tab feature in Helix editor as described in the documentation?
  documentationQuestion2: How can a user configure the keybindings for smart-tab to enable both tab and shift-tab actions in the Helix editor?
  documentationQuestion3: In what scenarios would setting `supersede-menu` to true be beneficial for smart-tab navigation in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `editor page of the documentation provided by Helix`.



    Documentation text:

    ### `[editor.inline-diagnostics]` Section

    Options for rendering diagnostics inside the text like shown below

    ```
    fn main() {
      let foo = bar;
                └─ no such value in this scope
    }
    ````

    | Key        | Description | Default |
    |------------|-------------|---------|
    | `cursor-line` | The minimum severity that a diagnostic must have to be shown inline on the line that contains the primary cursor. Set to `disable` to not show any diagnostics inline. This option does not have any effect when in insert-mode and will only take effect 350ms after moving the cursor to a different line. | `"disable"` |
    | `other-lines` | The minimum severity that a diagnostic must have to be shown inline on a line that does not contain the cursor-line. Set to `disable` to not show any diagnostics inline. | `"disable"` |
    | `prefix-len` | How many horizontal bars `─` are rendered before the diagnostic text.  | `1` |
    | `max-wrap` | Equivalent of the `editor.soft-wrap.max-wrap` option for diagnostics.  | `20` |
    | `max-diagnostics` | Maximum number of diagnostics to render inline for a given line  | `10` |

    The allowed values for `cursor-line` and `other-lines` are: `error`, `warning`, `info`, `hint`.

    The (first) diagnostic with the highest severity that is not shown inline is rendered at the end of the line (as long as its severity is higher than the `end-of-line-diagnostics` config option):

    ```
    fn main() {
      let baz = 1;
      let foo = bar; a local variable with a similar name exists: baz
                └─ no such value in this scope
    }
    ```


    The new diagnostic rendering is not yet enabled by default. As soon as end of line or inline diagnostics are enabled the old diagnostics rendering is automatically disabled. The recommended default setting are:

    ```toml
    [editor]
    end-of-line-diagnostics = "hint"
    [editor.inline-diagnostics]
    cursor-line = "warning" # show warnings and errors on the cursorline inline
    ```
  documentationQuestion1: What is the primary purpose of the `editor.inline-diagnostics` feature in the Helix editor?
  documentationQuestion2: How can you configure the `editor.inline-diagnostics` settings to display warnings and errors on the cursor line in Helix?
  documentationQuestion3: Provide a code example that demonstrates how to set the `prefix-len` and `max-wrap` options for inline diagnostics in Helix.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `install page of the documentation provided by Helix`.



    Documentation text:

    # Installing Helix

    The typical way to install Helix is via [your operating system's package manager](./package-managers.md).

    Note that:

    - To get the latest nightly version of Helix, you need to
      [build from source](./building-from-source.md).

    - To take full advantage of Helix, install the language servers for your
      preferred programming languages. See the
      [wiki](https://github.com/helix-editor/helix/wiki/Language-Server-Configurations)
      for instructions.

    ## Pre-built binaries

    Download pre-built binaries from the [GitHub Releases page](https://github.com/helix-editor/helix/releases).
    The tarball contents include an `hx` binary and a `runtime` directory.
    To set up Helix:

    1. Add the `hx` binary to your system's `$PATH` to allow it to be used from the command line.
    2. Copy the `runtime` directory to a location that `hx` searches for runtime files. A typical location on Linux/macOS is `~/.config/helix/runtime`.

    To see the runtime directories that `hx` searches, run `hx --health`. If necessary, you can override the default runtime location by setting the `HELIX_RUNTIME` environment variable.
  documentationQuestion1: What is the primary purpose of the runtime directory in Helix and how does it contribute to the editor's functionality?
  documentationQuestion2: How can a user install Helix using their operating system's package manager and set up the runtime directory for optimal performance?
  documentationQuestion3: What are the steps to configure the HELIX_RUNTIME environment variable to override the default runtime directory location in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `ecosystem page of the documentation provided by Helix`.



    Documentation text:

    # Ecosystem

    This section has information related to the wider Helix ecosystem.
  documentationQuestion1: What is the primary purpose of the Helix ecosystem as described in the documentation?
  documentationQuestion2: How can a user integrate external tools or plugins into the Helix editor using its ecosystem features?
  documentationQuestion3: What are the common use cases for leveraging the Helix ecosystem's package management system?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `from-vim page of the documentation provided by Helix`.



    Documentation text:

    # Migrating from Vim

    Helix's editing model is strongly inspired from Vim and Kakoune, and a notable
    difference from Vim (and the most striking similarity to Kakoune) is that Helix
    follows the `selection → action` model. This means that whatever you are
    going to act on (a word, a paragraph, a line, etc.) is selected first and the
    action itself (delete, change, yank, etc.) comes second. A cursor is simply a
    single width selection.

    See also Kakoune's [Migrating from Vim](https://github.com/mawww/kakoune/wiki/Migrating-from-Vim) and Helix's [Migrating from Vim](https://github.com/helix-editor/helix/wiki/Migrating-from-Vim).

    > TODO: Mention textobjects, surround, registers
  documentationQuestion1: What is the primary purpose of the selection → action model in Helix, and how does it differ from Vim's approach?
  documentationQuestion2: How can a user delete a selected word in Helix using the selection → action model?
  documentationQuestion3: What is the significance of the cursor being described as a 'single width selection' in Helix, and how does this affect editing workflows?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `command-line page of the documentation provided by Helix`.



    Documentation text:

    # Command line

    - [Quoting](#quoting)
    - [Flags](#flags)
    - [Expansions](#expansions)
    - [Exceptions](#exceptions)

    The command line is used for executing [typable commands](./commands.md#typable-commands) like `:write` or `:quit`. Press `:` to activate the command line.

    Typable commands optionally accept arguments. `:write` for example accepts an optional path to write the file contents. The command line also supports a quoting syntax for arguments, flags to modify command behaviors, and _expansions_ - a way to insert values from the editor. Most commands support these features but some have custom parsing rules (see the [exceptions](#exceptions) below).

    ## Quoting

    By default, command arguments are split on tabs and space characters. `:open README.md CHANGELOG.md` for example should open two files, `README.md` and `CHANGELOG.md`. Arguments that contain spaces can be surrounded in single quotes (`'`) or backticks (`` ` ``) to prevent the space from separating the argument, like `:open 'a b.txt'`.

    Double quotes may be used the same way, but double quotes _expand_ their inner content. `:echo "%{cursor_line}"` for example may print `1` because of the expansion for the `cursor_line` variable. `:echo '%{cursor_line}'` though prints `%{cursor_line}` literally: content within single quotes or backticks is interpreted as-is.

    On Unix systems the backslash character may be used to escape certain characters depending on where it is used. Within an argument which isn't surround in quotes, the backslash can be used to escape the space or tab characters: `:open a\ b.txt` is equivalent to `:open 'a b.txt'`. The backslash may also be used to escape quote characters (`'`, `` ` ``, `"`) or the percent token (`%`) when used at the beginning of an argument. `:echo \%%sh{foo}` for example prints `%sh{foo}` instead of invoking a `foo` shell command and `:echo \"quote` prints `"quote`. The backslash character is treated literally in any other situation on Unix systems and always on Windows: `:echo \n` always prints `\n`.

    ## Flags

    Command flags are optional switches that can be used to alter the behavior of a command. For example the `:sort` command accepts an optional `--reverse` (or `-r` for short) flag which causes the sort command to reverse the sorting direction. Typing the `-` character shows completions for the current command's flags, if any.

    The `--` flag specifies the end of flags. All arguments after `--` are treated as positional arguments: `:open -- -a.txt` opens a file called `-a.txt`.

    ## Expansions

    Expansions are patterns that Helix recognizes and replaces within the command line. Helix recognizes anything starting with a percent token (`%`) as an expansion, for example `%sh{echo hi!}`. Expansions are particularly useful when used in commands like `:echo` or `:noop` for executing simple scripts. For example:

    ```toml
    [keys.normal]
    # Print the current line's git blame information to the statusline.
    space.B = ":echo %sh{git blame -L %{cursor_line},+1 %{buffer_name}}"
    ```

    Expansions take the form `%[<kind>]<open><contents><close>`. In `%sh{echo hi!}`, for example, the kind is `sh` - the shell expansion - and the contents are "echo hi!", with `{` and `}` acting as opening and closing delimiters. The following open/close characters are recognized as expansion delimiter pairs: `(`/`)`, `[`/`]`, `{`/`}` and `<`/`>`. Plus the single characters `'`, `"` or `|` may be used instead: `%{cursor_line}` is equivalent to `%<cursor_line>`, `%[cursor_line]` or `%|cursor_line|`.

    To escape a percent character instead of treating it as an expansion, use two percent characters consecutively. To execute a shell command like `date -u +'%Y-%m-%d'`, double the percent characters: `:echo %sh{date -u +'%%Y-%%m-%%d'}`.

    When no `<kind>` is provided, Helix will expand a **variable**. For example `%{cursor_line}` can be used as in argument to insert the line number. `:echo %{cursor_line}` for instance may print `1` to the statusline.

    The following variables are supported:

    | Name | Description |
    |---   |---          |
    | `cursor_line` | The line number of the primary cursor in the currently focused document, starting at 1. |
    | `cursor_column` | The column number of the primary cursor in the currently focused document, starting at 1. This is counted as the number of grapheme clusters from the start of the line rather than bytes or codepoints. |
    | `buffer_name` | The relative path of the currently focused document. `[scratch]` is expanded instead for scratch buffers. |
    | `line_ending` | A string containing the line ending of the currently focused document. For example on Unix systems this is usually a line-feed character (`\n`) but on Windows systems this may be a carriage-return plus a line-feed (`\r\n`). The line ending kind of the currently focused document can be inspected with the `:line-ending` command. |
    | `language` | A string containing the language name of the currently focused document.|
    | `selection` | A string containing the contents of the primary selection of the currently focused document. |

    Aside from editor variables, the following expansions may be used:

    * Unicode `%u{..}`. The contents may contain up to six hexadecimal numbers corresponding to a Unicode codepoint value. For example `:echo %u{25CF}` prints `●` to the statusline.
    * Shell `%sh{..}`. The contents are passed to the configured shell command. For example `:echo %sh{echo "20 * 5" | bc}` may print `100` on the statusline on when using a shell with `echo` and the `bc` calculator installed. Shell expansions are evaluated recursively. `%sh{echo '%{buffer_name}:%{cursor_line}'}` for example executes a command like `echo 'README.md:1'`: the variables within the `%sh{..}` expansion are evaluated before executing the shell command.

    As mentioned above, double quotes can be used to surround arguments containing spaces but also support expansions within the quoted content unlike singe quotes or backticks. For example `:echo "circle: %u{25CF}"` prints `circle: ●` to the statusline while `:echo 'circle: %u{25CF}'` prints `circle: %u{25CF}`.

    Note that expansions are only evaluated once the Enter key is pressed in command mode.

    ## Exceptions

    The following commands support expansions but otherwise pass the given argument directly to the shell program without interpreting quotes:

    * `:insert-output`
    * `:append-output`
    * `:pipe`
    * `:pipe-to`
    * `:run-shell-command`

    For example executing `:sh echo "%{buffer_name}:%{cursor_column}"` would pass text like `echo "README.md:1"` as an argument to the shell program: the expansions are evaluated but not the quotes. As mentioned above, percent characters can be used in shell commands by doubling the percent character. To insert the output of a command like `date -u +'%Y-%m-%d'` use `:insert-output date -u +'%%Y-%%m-%%d'`.

    The `:set-option` and `:toggle-option` commands use regular parsing for the first argument - the config option name - and parse the rest depending on the config option's type. `:set-option` interprets the second argument as a string for string config options and parses everything else as JSON.

    `:toggle-option`'s behavior depends on the JSON type of the config option supplied as the first argument:

    * Booleans: only the config option name should be provided. For example `:toggle-option auto-format` will flip the `auto-format` option.
    * Strings: the rest of the command line is parsed with regular quoting rules. For example `:toggle-option indent-heuristic hybrid tree-sitter simple` cycles through "hybrid", "tree-sitter" and "simple" values on each invocation of the command.
    * Numbers, arrays and objects: the rest of the command line is parsed as a stream of JSON values. For example `:toggle-option rulers [81] [51, 73]` cycles through `[81]` and `[51, 73]`.

    When providing multiple values to `:toggle-option` there should be no duplicates. `:toggle-option indent-heuristic hybrid simple tree-sitter simple` for example would only toggle between "hybrid" and "tree-sitter" values.

    `:lsp-workspace-command` works similarly to `:toggle-option`. The first argument (if present) is parsed according to normal rules. The rest of the line is parsed as JSON values. Unlike `:toggle-option`, string arguments for a command must be quoted. For example `:lsp-workspace-command lsp.Command "foo" "bar"`.
  documentationQuestion1: What are the primary purposes of the command line interface in Helix, and how does it support advanced text processing features?
  documentationQuestion2: How can you use expansions in the Helix command line to dynamically insert variable values like the current line number or buffer name into a command such as `:echo`?
  documentationQuestion3: Provide an example of using quoting and flags in the Helix command line to execute a shell command that prints the current buffer name and cursor line number.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `configuration page of the documentation provided by Helix`.



    Documentation text:

    # Configuration

    To override global configuration parameters, create a `config.toml` file located in your config directory:

    - Linux and Mac: `~/.config/helix/config.toml`
    - Windows: `%AppData%\helix\config.toml`

    > 💡 You can easily open the config file by typing `:config-open` within Helix normal mode.

    Example config:

    ```toml
    theme = "onedark"

    [editor]
    line-number = "relative"
    mouse = false

    [editor.cursor-shape]
    insert = "bar"
    normal = "block"
    select = "underline"

    [editor.file-picker]
    hidden = false
    ```

    You can use a custom configuration file by specifying it with the `-c` or
    `--config` command line argument, for example `hx -c path/to/custom-config.toml`.
    You can reload the config file by issuing the `:config-reload` command. Alternatively, on Unix operating systems, you can reload it by sending the USR1
    signal to the Helix process, such as by using the command `pkill -USR1 hx`.

    Finally, you can have a `config.toml` local to a project by putting it under a `.helix` directory in your repository.
    Its settings will be merged with the configuration directory `config.toml` and the built-in configuration.
  documentationQuestion1: What is the primary purpose of the configuration system in Helix as described in the documentation?
  documentationQuestion2: How can a user override the default theme in Helix using a custom configuration file?
  documentationQuestion3: What is the process for reloading the Helix configuration without restarting the application?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `indent page of the documentation provided by Helix`.



    Documentation text:

    ## Adding indent queries

    Helix uses tree-sitter to correctly indent new lines. This requires a tree-
    sitter grammar and an `indent.scm` query file placed in `runtime/queries/
    {language}/indents.scm`. The indentation for a line is calculated by traversing
    the syntax tree from the lowest node at the beginning of the new line (see
    [Indent queries](#indent-queries)). Each of these nodes contributes to the total
    indent when it is captured by the query (in what way depends on the name of
    the capture.

    Note that it matters where these added indents begin. For example,
    multiple indent level increases that start on the same line only increase
    the total indent level by 1. See [Capture types](#capture-types).

    By default, Helix uses the `hybrid` indentation heuristic. This means that
    indent queries are not used to compute the expected absolute indentation of a
    line but rather the expected difference in indentation between the new and an
    already existing line. This difference is then added to the actual indentation
    of the already existing line. Since this makes errors in the indent queries
    harder to find, it is recommended to disable it when testing via
    `:set indent-heuristic tree-sitter`. The rest of this guide assumes that
    the `tree-sitter` heuristic is used.
  documentationQuestion1: What is the primary purpose of indent queries in Helix, and how do they contribute to the editor's functionality?
  documentationQuestion2: How can a user configure Helix to use tree-sitter for indentation calculations instead of the default hybrid heuristic?
  documentationQuestion3: Provide an example of an indent query for a specific programming language, explaining how the capture names influence the indentation levels.

- prompt: "You are playing the role of a college professor. Here is some text copied from the `indent page of the documentation provided by Helix`.\n\n\n\nDocumentation text:\n\n## Indent queries\n\nWhen Helix is inserting a new line through `o`, `O`, or `<ret>`, to determine\nthe indent level for the new line, the query in `indents.scm` is run on the\ndocument. The starting position of the query is the end of the line above where\na new line will be inserted.\n\nFor `o`, the inserted line is the line below the cursor, so that starting\nposition of the query is the end of the current line.\n\n```rust\nfn need_hero(some_hero: Hero, life: Life) -> {\n    matches!(some_hero, Hero { // ←─────────────────╮\n        strong: true,//←╮  ↑  ↑                     │\n        fast: true,  // │  │  ╰── query start       │\n        sure: true,  // │  ╰───── cursor            ├─ traversal \n        soon: true,  // ╰──────── new line inserted │  start node\n    }) &&            //                             │\n//  ↑                                               │\n//  ╰───────────────────────────────────────────────╯\n    some_hero > life\n}\n```\n\nFor `O`, the newly inserted line is the *current* line, so the starting position\nof the query is the end of the line above the cursor.\n\n```rust\nfn need_hero(some_hero: Hero, life: Life) -> { // ←─╮\n    matches!(some_hero, Hero { // ←╮          ↑     │\n        strong: true,//    ↑   ╭───╯          │     │\n        fast: true,  //    │   │ query start ─╯     │\n        sure: true,  //    ╰───┼ cursor             ├─ traversal\n        soon: true,  //        ╰ new line inserted  │  start node\n    }) &&            //                             │\n    some_hero > life //                             │\n} // ←──────────────────────────────────────────────╯\n```\n\nFrom this starting node, the syntax tree is traversed up until the root node.\nEach indent capture is collected along the way, and then combined according to\ntheir [capture types](#capture-types) and [scopes](#scopes) to a final indent\nlevel for the line.\n\n### Capture types\n\n- `@indent` (default scope `tail`):\n  Increase the indent level by 1. Multiple occurrences in the same line *do not*\n  stack. If there is at least one `@indent` and one `@outdent` capture on the\n  same line, the indent level isn't changed at all.\n- `@outdent` (default scope `all`):\n  Decrease the indent level by 1. The same rules as for `@indent` apply.\n- `@indent.always` (default scope `tail`):\n  Increase the indent level by 1. Multiple occurrences on the same line *do*\n  stack. The final indent level is `@indent.always` – `@outdent.always`. If\n  an `@indent` and an `@indent.always` are on the same line, the `@indent` is\n  ignored.\n- `@outdent.always` (default scope `all`):\n  Decrease the indent level by 1. The same rules as for `@indent.always` apply.\n- `@align` (default scope `all`):\n  Align everything inside this node to some anchor. The anchor is given\n  by the start of the node captured by `@anchor` in the same pattern.\n  Every pattern with an `@align` should contain exactly one `@anchor`.\n  Indent (and outdent) for nodes below (in terms of their starting line)\n  the `@align` node is added to the indentation required for alignment.\n- `@extend`:\n  Extend the range of this node to the end of the line and to lines that are\n  indented more than the line that this node starts on. This is useful for\n  languages like Python, where for the purpose of indentation some nodes (like\n  functions or classes) should also contain indented lines that follow them.\n- `@extend.prevent-once`:\n  Prevents the first extension of an ancestor of this node. For example, in Python\n  a return expression always ends the block that it is in. Note that this only\n  stops the extension of the next `@extend` capture. If multiple ancestors are\n  captured, only the extension of the innermost one is prevented. All other\n  ancestors are unaffected (regardless of whether the innermost ancestor would\n  actually have been extended).\n\n#### `@indent` / `@outdent`\n\nConsider this example:\n\n```rust\nfn shout(things: Vec<Thing>) {\n    //                       ↑\n    //                       ├───────────────────────╮ indent level\n    //                    @indent                    ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄\n    //                                               │\n    let it_all = |out| { things.filter(|thing| { //  │      1\n    //                 ↑                       ↑     │\n    //                 ├───────────────────────┼─────┼┄┄┄┄┄┄┄┄┄┄┄┄┄┄\n    //              @indent                 @indent  │\n    //                                               │      2\n        thing.can_do_with(out) //                    │\n    })}; //                                          ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄\n  //↑↑↑                                              │      1\n} //╰┼┴──────────────────────────────────────────────┴┄┄┄┄┄┄┄┄┄┄┄┄┄┄\n// 3x @outdent\n```\n\n```scm\n((block) @indent)\n[\"}\" \")\"] @outdent\n```\n\nNote how on the second line, we have two blocks begin on the same line. In this\ncase, since both captures occur on the same line, they are combined and only\nresult in a net increase of 1. Also note that the closing `}`s are part of the\n`@indent` captures, but the 3 `@outdent`s also combine into 1 and result in that\nline losing one indent level.\n\n#### `@extend` / `@extend.prevent-once`\n\nFor an example of where `@extend` can be useful, consider Python, which is\nwhitespace-sensitive.\n\n```scm\n]\n  (parenthesized_expression)\n  (function_definition)\n  (class_definition)\n] @indent\n\n```\n\n```python\nclass Hero:\n    def __init__(self, strong, fast, sure, soon):#  ←─╮\n        self.is_strong = strong #                     │\n        self.is_fast = fast     # ╭─── query start    │\n        self.is_sure = sure     # │ ╭─ cursor         │\n        self.is_soon = soon     # │ │                 │\n        #     ↑            ↑      │ │                 │\n        #     │            ╰──────╯ │                 │\n        #     ╰─────────────────────╯                 │\n        #                                             ├─ traversal\n    def need_hero(self, life):         #              │  start node\n        return (                       #              │\n            self.is_strong             #              │\n            and self.is_fast           #              │\n            and self.is_sure           #              │\n            and self.is_soon           #              │\n            and self > life            #              │\n        ) # ←─────────────────────────────────────────╯\n```\n\nWithout braces to catch the scope of the function, the smallest descendant of\nthe cursor on a line feed ends up being the entire inside of the class. Because\nof this, it will miss the entire function node and its indent capture, leading\nto an indent level one too small.\n\nTo address this case, `@extend` tells helix to \"extend\" the captured node's span\nto the line feed and every consecutive line that has a greater indent level than\nthe line of the node.\n\n```scm\n(parenthesized_expression) @indent\n\n]\n  (function_definition)\n  (class_definition)\n] @indent @extend\n\n```\n\n```python\nclass Hero:\n    def __init__(self, strong, fast, sure, soon):#  ←─╮\n        self.is_strong = strong #                     │\n        self.is_fast = fast     # ╭─── query start    ├─ traversal\n        self.is_sure = sure     # │ ╭─ cursor         │  start node\n        self.is_soon = soon     # │ │ ←───────────────╯\n        #     ↑            ↑      │ │                 \n        #     │            ╰──────╯ │\n        #     ╰─────────────────────╯\n    def need_hero(self, life):\n        return (\n            self.is_strong\n            and self.is_fast\n            and self.is_sure\n            and self.is_soon\n            and self > life\n        )\n```\n\nFurthermore, there are some cases where extending to everything with a greater\nindent level may not be desirable. Consider the `need_hero` function above. If\nour cursor is on the last line of the returned expression.\n\n```python\nclass Hero:\n    def __init__(self, strong, fast, sure, soon):\n        self.is_strong = strong\n        self.is_fast = fast\n        self.is_sure = sure\n        self.is_soon = soon\n\n    def need_hero(self, life):\n        return (\n            self.is_strong\n            and self.is_fast\n            and self.is_sure\n            and self.is_soon\n            and self > life\n        ) # ←─── cursor\n    #←────────── where cursor should go on new line\n```\n\nIn Python, the are a few tokens that will always end a scope, such as a return\nstatement. Since the scope ends, so should the indent level. But because the\nfunction span is extended to every line with a greater indent level, a new line\nwould just continue on the same level. And an `@outdent` would not help us here\neither, since it would cause everything in the parentheses to become outdented\nas well.\n\nTo help, we need to signal an end to the extension. We can do this with\n`@extend.prevent-once`.\n\n```scm\n(parenthesized_expression) @indent\n\n]\n  (function_definition)\n  (class_definition)\n] @indent @extend\n\n(return_statement) @extend.prevent-once\n```\n\n#### `@indent.always` / `@outdent.always`\n\nAs mentioned before, normally if there is more than one `@indent` or `@outdent`\ncapture on the same line, they are combined.\n\nSometimes, there are cases when you may want to ensure that every indent capture\nis additive, regardless of how many occur on the same line. Consider this\nexample in YAML.\n\n```yaml\n  - foo: bar\n# ↑ ↑\n# │ ╰─────────────── start of map\n# ╰───────────────── start of list element\n    baz: quux # ←─── cursor\n    # ←───────────── where the cursor should go on a new line\n    garply: waldo\n  - quux:\n      bar: baz\n    xyzzy: thud\n    fred: plugh\n```\n\nIn YAML, you often have lists of maps. In these cases, the syntax is such that\nthe list element and the map both start on the same line. But we really do want\nto start an indentation for each of these so that subsequent keys in the map\nhang over the list and align properly. This is where `@indent.always` helps.\n\n```scm\n((block_sequence_item) @item @indent.always @extend\n  (#not-one-line? @item))\n\n((block_mapping_pair\n    key: (_) @key\n    value: (_) @val\n    (#not-same-line? @key @val)\n  ) @indent.always @extend\n)\n```"
  documentationQuestion1: What is the primary purpose of the indent query system in Helix, and how does it determine the indent level for newly inserted lines?
  documentationQuestion2: How can the `@extend` and `@extend.prevent-once` capture types be used to handle indentation in Python's class and function definitions?
  documentationQuestion3: Provide a code example demonstrating the use of `@indent.always` and `@outdent.always` in a YAML configuration to ensure proper indentation of nested structures.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `indent page of the documentation provided by Helix`.



    Documentation text:

    ## Predicates

    In some cases, an S-expression cannot express exactly what pattern should be matched.
    For that, tree-sitter allows for predicates to appear anywhere within a pattern,
    similar to how `#set!` declarations work:

    ```scm
    (some_kind
      (child_kind) @indent
      (#predicate? arg1 arg2 ...)
    )
    ```

    The number of arguments depends on the predicate that's used.
    Each argument is either a capture (`@name`) or a string (`"some string"`).
    The following predicates are supported by tree-sitter:

    - `#eq?`/`#not-eq?`:
    The first argument (a capture) must/must not be equal to the second argument
    (a capture or a string).

    - `#match?`/`#not-match?`:
    The first argument (a capture) must/must not match the regex given in the
    second argument (a string).

    - `#any-of?`/`#not-any-of?`:
    The first argument (a capture) must/must not be one of the other arguments
    (strings).

    Additionally, we support some custom predicates for indent queries:

    - `#not-kind-eq?`:
    The kind of the first argument (a capture) must not be equal to the second
    argument (a string).

    - `#same-line?`/`#not-same-line?`:
    The captures given by the 2 arguments must/must not start on the same line.

    - `#one-line?`/`#not-one-line?`:
    The captures given by the fist argument must/must span a total of one line.

    ### Scopes

    Added indents don't always apply to the whole node. For example, in most
    cases when a node should be indented, we actually only want everything
    except for its first line to be indented. For this, there are several
    scopes (more scopes may be added in the future if required):

    - `tail`:
    This scope applies to everything except for the first line of the
    captured node.
    - `all`:
    This scope applies to the whole captured node. This is only different from
    `tail` when the captured node is the first node on its line.

    For example, imagine we have the following function

    ```rust
    fn aha() { // ←─────────────────────────────────────╮
      let take = "on me";  // ←──────────────╮  scope:  │
      let take = "me on";             //     ├─ "tail"  ├─ (block) @indent
      let ill = be_gone_days(1 || 2); //     │          │
    } // ←───────────────────────────────────┴──────────┴─ "}" @outdent
                                             //                scope: "all"
    ```

    We can write the following query with the `#set!` declaration:

      ```scm
      ((block) @indent
       (#set! "scope" "tail"))
      ("}" @outdent
       (#set! "scope" "all"))
      ```

    As we can see, the "tail" scope covers the node, except for the first line.
    Everything up to and including the closing brace gets an indent level of 1.
    Then, on the closing brace, we encounter an outdent with a scope of "all", which
    means the first line is included, and the indent level is cancelled out on this
    line. (Note these scopes are the defaults for `@indent` and `@outdent`—they are
    written explicitly for demonstration.)
  documentationQuestion1: What are the primary purposes of predicates in tree-sitter's indent page documentation?
  documentationQuestion2: How can you use the `#same-line?` predicate to ensure two captures are on the same line in a query?
  documentationQuestion3: Provide an example of using the `tail` scope in a tree-sitter query to apply indentation to all lines except the first line of a block.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `textobject page of the documentation provided by Helix`.



    Documentation text:

    ## Adding textobject queries

    Helix supports textobjects that are language specific, such as functions, classes, etc.
    These textobjects require an accompanying tree-sitter grammar and a `textobjects.scm` query file
    to work properly. Tree-sitter allows us to query the source code syntax tree
    and capture specific parts of it. The queries are written in a lisp dialect.
    More information on how to write queries can be found in the [official tree-sitter
    documentation][tree-sitter-queries].

    Query files should be placed in `runtime/queries/{language}/textobjects.scm`
    when contributing to Helix. Note that to test the query files locally you should put
    them under your local runtime directory (`~/.config/helix/runtime` on Linux
    for example).

    The following [captures][tree-sitter-captures] are recognized:

    | Capture Name       |
    | ---                |
    | `function.inside`  |
    | `function.around`  |
    | `class.inside`     |
    | `class.around`     |
    | `test.inside`      |
    | `test.around`      |
    | `parameter.inside` |
    | `parameter.around` |
    | `comment.inside`   |
    | `comment.around`   |
    | `entry.inside`     |
    | `entry.around`     |

    [Example query files][textobject-examples] can be found in the helix GitHub repository.
  documentationQuestion1: What is the primary purpose of textobject queries in Helix, and how do they enhance the editor's functionality?
  documentationQuestion2: How can a user create a custom textobject query for functions in a specific programming language, such as Python, using Helix?
  documentationQuestion3: Provide an example of how to configure Helix to recognize and highlight function definitions in a source code file using a textobject query.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `textobject page of the documentation provided by Helix`.



    Documentation text:

    ## Queries for textobject based navigation

    Tree-sitter based navigation in Helix is done using captures in the
    following order:

    - `object.movement`
    - `object.around`
    - `object.inside`

    For example if a `function.around` capture has been already defined for a language
    in its `textobjects.scm` file, function navigation should also work automatically.
    `function.movement` should be defined only if the node captured by `function.around`
    doesn't make sense in a navigation context.

    [tree-sitter-queries]: https://tree-sitter.github.io/tree-sitter/using-parsers/queries/1-syntax.html
    [tree-sitter-captures]: https://tree-sitter.github.io/tree-sitter/using-parsers/queries/2-operators.html#capturing-nodes
    [textobject-examples]: https://github.com/search?q=repo%3Ahelix-editor%2Fhelix+path%3A%2A%2A/textobjects.scm&type=Code&ref=advsearch&l=&l=
  documentationQuestion1: What is the primary purpose of textobject-based navigation in Helix, and how does it leverage Tree-sitter for improved code navigation?
  documentationQuestion2: How can a user define a custom textobject for function navigation in Helix, and what is the correct syntax for specifying the capture order in the `textobjects.scm` file?
  documentationQuestion3: What are the key differences between `function.around` and `function.movement` captures in Helix's textobject system, and when should each be used?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `README page of the documentation provided by Helix`.



    Documentation text:

    # Guides

    This section contains guides for adding new language server configurations,
    tree-sitter grammars, textobject queries, and other similar items.
  documentationQuestion1: What are the primary purposes of the Guides section in the Helix documentation?
  documentationQuestion2: How can a user add a new language server configuration in Helix, and what is the typical structure of the required configuration file?
  documentationQuestion3: What steps are involved in creating a custom textobject query for a specific programming language in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `adding_languages page of the documentation provided by Helix`.



    Documentation text:

    ## Adding new languages to Helix

    In order to add a new language to Helix, you will need to follow the steps
    below.

    ## Language configuration

    1. Add a new `[[language]]` entry in the `languages.toml` file and provide the
       necessary configuration for the new language. For more information on
       language configuration, refer to the
       [language configuration section](../languages.md) of the documentation.
       A new language server can be added by extending the `[language-server]` table in the same file.
    2. If you are adding a new language or updating an existing language server
       configuration, run the command `cargo xtask docgen` to update the
       [Language Support](../lang-support.md) documentation.

    > 💡 If you are adding a new Language Server configuration, make sure to update
    > the
    > [Language Server Wiki](https://github.com/helix-editor/helix/wiki/Language-Server-Configurations)
    > with the installation instructions.

    ## Grammar configuration

    1. If a tree-sitter grammar is available for the new language, add a new
       `[[grammar]]` entry to the `languages.toml` file.
    2. If you are testing the grammar locally, you can use the `source.path` key
       with an absolute path to the grammar. However, before submitting a pull
       request, make sure to switch to using `source.git`.
  documentationQuestion1: What is the primary purpose of the language configuration process in Helix as described in the documentation?
  documentationQuestion2: How can a user add a new language to Helix by modifying the `languages.toml` file and what command is needed to update the Language Support documentation?
  documentationQuestion3: What is the correct way to specify a tree-sitter grammar for a new language in Helix's `languages.toml` file when testing locally versus when preparing for a pull request?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `adding_languages page of the documentation provided by Helix`.



    Documentation text:

    ## Queries

    1. In order to provide syntax highlighting and indentation for the new language,
       you will need to add queries.
    2. Create a new directory for the language with the path
       `runtime/queries/<name>/`.
    3. Refer to the
       [tree-sitter website](https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#highlights)
       for more information on writing queries.
    4. A list of highlight captures can be found [on the themes page](https://docs.helix-editor.com/themes.html#scopes).

    ## Common issues

    - If you encounter errors when running Helix after switching branches, you may
      need to update the tree-sitter grammars. Run the command `hx --grammar fetch`
      to fetch the grammars and `hx --grammar build` to build any out-of-date
      grammars.
    - If a parser is causing a segfault, or you want to remove it, make sure to
      remove the compiled parser located at `runtime/grammars/<name>.so`.
    - If you are attempting to add queries and Helix is unable to locate them, ensure that the environment variable `HELIX_RUNTIME` is set to the location of the `runtime` folder you're developing in.
  documentationQuestion1: What is the primary purpose of adding queries for a new language in Helix according to the documentation?
  documentationQuestion2: How can a user resolve the issue where Helix is unable to locate newly added queries for a language?
  documentationQuestion3: What should a user do if they encounter a segfault related to a parser in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `injection page of the documentation provided by Helix`.



    Documentation text:

    ## Adding Injection Queries

    Writing language injection queries allows one to highlight a specific node as a different language.
    In addition to the [standard][upstream-docs] language injection options used by tree-sitter, there
    are a few Helix specific extensions that allow for more control.

    An example of a simple query that would highlight all strings as bash in Nix:
    ```scm
    ((string_expression (string_fragment) @injection.content)
      (#set! injection.language "bash"))
    ```
    Another example is this query, which highlights links in comments and keywords like "TODO", by reusing the dedicated "comment" language:
    ```
    ((comment) @injection.content
      (#set! injection.language "comment"))
    ```

    ## Capture Types

    - `@injection.language` (standard):
    The captured node may contain the language name used to highlight the node captured by
    `@injection.content`.

    - `@injection.content` (standard):
    Marks the content to be highlighted as the language captured with `@injection.language` _et al_.

    - `@injection.filename` (extension):
    The captured node may contain a filename with a file-extension known to Helix,
    highlighting `@injection.content` as that language. This uses the language extensions defined in
    both the default languages.toml distributed with Helix, as well as user defined languages.

    - `@injection.shebang` (extension):
    The captured node may contain a shebang used to choose a language to highlight as. This also uses
    the shebangs defined in the default and user `languages.toml`.
  documentationQuestion1: What are the primary purposes of language injection queries in Helix, as described in the documentation?
  documentationQuestion2: How can a user create a Helix injection query to highlight all strings as bash in a Nix file?
  documentationQuestion3: What is the purpose and usage of the @injection.filename capture type in Helix's language injection system?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `injection page of the documentation provided by Helix`.



    Documentation text:

    ## Settings

    - `injection.combined` (standard):
    Indicates that all the matching nodes in the tree should have their content parsed as one
    nested document.

    - `injection.language` (standard):
    Forces the captured content to be highlighted as the given language

    - `injection.include-children` (standard):
    Indicates that the content node’s entire text should be re-parsed, including the text of its child
    nodes. By default, child nodes’ text will be excluded from the injected document.

    - `injection.include-unnamed-children` (extension):
    Same as `injection.include-children` but only for unnamed child nodes.

    ## Predicates

    - `#eq?` (standard):
    The first argument (a capture) must be equal to the second argument
    (a capture or a string).

    - `#match?` (standard):
    The first argument (a capture) must match the regex given in the
    second argument (a string).

    - `#any-of?` (standard):
    The first argument (a capture) must be one of the other arguments (strings).

    [upstream-docs]: https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#language-injection
  documentationQuestion1: What is the primary purpose of the injection settings in the Tree-sitter language injection feature?
  documentationQuestion2: How can you configure Tree-sitter to highlight a specific language within a code block using the injection.language setting?
  documentationQuestion3: 'Provide an example of using the #match? predicate to filter nodes in a Tree-sitter grammar that match a specific regex pattern.'

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `themes page of the documentation provided by Helix`.



    Documentation text:

    ## Themes

    To use a theme add `theme = "<name>"` to the top of your [`config.toml`](./configuration.md) file, or select it during runtime using `:theme <name>`.

    ## Creating a theme

    Create a file with the name of your theme as the file name (i.e `mytheme.toml`) and place it in your `themes` directory (i.e `~/.config/helix/themes` or `%AppData%\helix\themes` on Windows). The directory might have to be created beforehand.

    > 💡 The names "default" and "base16_default" are reserved for built-in themes
    > and cannot be overridden by user-defined themes.

    ### Overview

    Each line in the theme file is specified as below:

    ```toml
    key = { fg = "#ffffff", bg = "#000000", underline = { color = "#ff0000", style = "curl"}, modifiers = ["bold", "italic"] }
    ```

    Where `key` represents what you want to style, `fg` specifies the foreground color, `bg` the background color, `underline` the underline `style`/`color`, and `modifiers` is a list of style modifiers. `bg`, `underline` and `modifiers` can be omitted to defer to the defaults.

    To specify only the foreground color:

    ```toml
    key = "#ffffff"
    ```

    If the key contains a dot `'.'`, it must be quoted to prevent it being parsed as a [dotted key](https://toml.io/en/v1.0.0#keys).

    ```toml
    "key.key" = "#ffffff"
    ```

    For inspiration, you can find the default `theme.toml`
    [here](https://github.com/helix-editor/helix/blob/master/theme.toml) and
    user-submitted themes
    [here](https://github.com/helix-editor/helix/blob/master/runtime/themes).
  documentationQuestion1: What is the primary purpose of the theme system in Helix as described in the documentation?
  documentationQuestion2: How can a user apply a custom theme in Helix, and what is the syntax for defining a theme file?
  documentationQuestion3: What are the common use cases for specifying foreground and background colors in a Helix theme file?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `themes page of the documentation provided by Helix`.



    Documentation text:

    ## The details of theme creation

    ### Color palettes

    It's recommended to define a palette of named colors, and refer to them in the
    configuration values in your theme. To do this, add a table called
    `palette` to your theme file:

    ```toml
    "ui.background" = "white"
    "ui.text" = "black"

    [palette]
    white = "#ffffff"
    black = "#000000"
    ```

    Keep in mind that the `[palette]` table includes all keys after its header,
    so it should be defined after the normal theme options.

    The default palette uses the terminal's default 16 colors, and the colors names
    are listed below. The `[palette]` section in the config file takes precedence
    over it and is merged into the default palette.

    | Color Name      |
    | ---             |
    | `default`       |
    | `black`         |
    | `red`           |
    | `green`         |
    | `yellow`        |
    | `blue`          |
    | `magenta`       |
    | `cyan`          |
    | `gray`          |
    | `light-red`     |
    | `light-green`   |
    | `light-yellow`  |
    | `light-blue`    |
    | `light-magenta` |
    | `light-cyan`    |
    | `light-gray`    |
    | `white`         |

    ### Modifiers

    The following values may be used as modifier, provided they are supported by
    your terminal emulator.

    | Modifier             |
    | ---                  |
    | `bold`               |
    | `dim`                |
    | `italic`             |
    | `underlined`         |
    | `slow_blink`         |
    | `rapid_blink`        |
    | `reversed`           |
    | `hidden`             |
    | `crossed_out`        |

    > 💡 The `underlined` modifier is deprecated and only available for backwards compatibility.
    > Its behavior is equivalent to setting `underline.style="line"`.

    ### Underline style

    One of the following values may be used as a value for `underline.style`, providing it is
    supported by your terminal emulator.

    | Modifier       |
    | ---            |
    | `line`         |
    | `curl`         |
    | `dashed`       |
    | `dotted`       |
    | `double_line`  |


    ### Inheritance

    Extend other themes by setting the `inherits` property to an existing theme.

    ```toml
    inherits = "boo_berry"

    # Override the theming for "keyword"s:
    "keyword" = { fg = "gold" }

    # Override colors in the palette:
    [palette]
    berry = "#2A2A4D"
    ```

    ### Scopes

    The following is a list of scopes available to use for styling:

    #### Syntax highlighting

    These keys match [tree-sitter scopes](https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#highlights).

    When determining styling for a highlight, the longest matching theme key will be used. For example, if the highlight is `function.builtin.static`, the key `function.builtin` will be used instead of `function`.

    We use a similar set of scopes as
    [Sublime Text](https://www.sublimetext.com/docs/scope_naming.html). See also
    [TextMate](https://macromates.com/manual/en/language_grammars) scopes.

    - `attribute` - Class attributes, HTML tag attributes

    - `type` - Types
      - `builtin` - Primitive types provided by the language (`int`, `usize`)
      - `parameter` - Generic type parameters (`T`)
      - `enum`
        - `variant`
    - `constructor`

    - `constant` (TODO: constant.other.placeholder for `%v`)
      - `builtin` Special constants provided by the language (`true`, `false`, `nil` etc)
        - `boolean`
      - `character`
        - `escape`
      - `numeric` (numbers)
        - `integer`
        - `float`

    - `string` (TODO: string.quoted.{single, double}, string.raw/.unquoted)?
      - `regexp` - Regular expressions
      - `special`
        - `path`
        - `url`
        - `symbol` - Erlang/Elixir atoms, Ruby symbols, Clojure keywords

    - `comment` - Code comments
      - `line` - Single line comments (`//`)
      - `block` - Block comments (e.g. (`/* */`)
        - `documentation` - Documentation comments (e.g. `///` in Rust)

    - `variable` - Variables
      - `builtin` - Reserved language variables (`self`, `this`, `super`, etc.)
      - `parameter` - Function parameters
      - `other`
        - `member` - Fields of composite data types (e.g. structs, unions)
          - `private` - Private fields that use a unique syntax (currently just ECMAScript-based languages)

    - `label` - `.class`, `#id` in CSS, etc.

    - `punctuation`
      - `delimiter` - Commas, colons
      - `bracket` - Parentheses, angle brackets, etc.
      - `special` - String interpolation brackets.

    - `keyword`
      - `control`
        - `conditional` - `if`, `else`
        - `repeat` - `for`, `while`, `loop`
        - `import` - `import`, `export`
        - `return`
        - `exception`
      - `operator` - `or`, `in`
      - `directive` - Preprocessor directives (`#if` in C)
      - `function` - `fn`, `func`
      - `storage` - Keywords describing how things are stored
        - `type` - The type of something, `class`, `function`, `var`, `let`, etc.
        - `modifier` - Storage modifiers like `static`, `mut`, `const`, `ref`, etc.

    - `operator` - `||`, `+=`, `>`

    - `function`
      - `builtin`
      - `method`
        - `private` - Private methods that use a unique syntax (currently just ECMAScript-based languages)
      - `macro`
      - `special` (preprocessor in C)

    - `tag` - Tags (e.g. `<body>` in HTML)
      - `builtin`

    - `namespace`

    - `special` - `derive` in Rust, etc.

    - `markup`
      - `heading`
        - `marker`
        - `1`, `2`, `3`, `4`, `5`, `6` - heading text for h1 through h6
      - `list`
        - `unnumbered`
        - `numbered`
        - `checked`
        - `unchecked`
      - `bold`
      - `italic`
      - `strikethrough`
      - `link`
        - `url` - URLs pointed to by links
        - `label` - non-URL link references
        - `text` - URL and image descriptions in links
      - `quote`
      - `raw`
        - `inline`
        - `block`

    - `diff` - version control changes
      - `plus` - additions
        - `gutter` - gutter indicator
      - `minus` - deletions
        - `gutter` - gutter indicator
      - `delta` - modifications
        - `moved` - renamed or moved files/changes
        - `conflict` - merge conflicts
        - `gutter` - gutter indicator

    #### Interface

    These scopes are used for theming the editor interface:

    - `markup`
      - `normal`
        - `completion` - for completion doc popup UI
        - `hover` - for hover popup UI
      - `heading`
        - `completion` - for completion doc popup UI
        - `hover` - for hover popup UI
      - `raw`
        - `inline`
          - `completion` - for completion doc popup UI
          - `hover` - for hover popup UI


    | Key                               | Notes                                                                                          |
    | ---                               | ---                                                                                            |
    | `ui.background`                   |                                                                                                |
    | `ui.background.separator`         | Picker separator below input line                                                              |
    | `ui.cursor`                       |                                                                                                |
    | `ui.cursor.normal`                |                                                                                                |
    | `ui.cursor.insert`                |                                                                                                |
    | `ui.cursor.select`                |                                                                                                |
    | `ui.cursor.match`                 | Matching bracket etc.                                                                          |
    | `ui.cursor.primary`               | Cursor with primary selection                                                                  |
    | `ui.cursor.primary.normal`        |                                                                                                |
    | `ui.cursor.primary.insert`        |                                                                                                |
    | `ui.cursor.primary.select`        |                                                                                                |
    | `ui.debug.breakpoint`             | Breakpoint indicator, found in the gutter                                                      |
    | `ui.debug.active`                 | Indicator for the line at which debugging execution is paused at, found in the gutter          |
    | `ui.gutter`                       | Gutter                                                                                         |
    | `ui.gutter.selected`              | Gutter for the line the cursor is on                                                           |
    | `ui.linenr`                       | Line numbers                                                                                   |
    | `ui.linenr.selected`              | Line number for the line the cursor is on                                                      |
    | `ui.statusline`                   | Statusline                                                                                     |
    | `ui.statusline.inactive`          | Statusline (unfocused document)                                                                |
    | `ui.statusline.normal`            | Statusline mode during normal mode ([only if `editor.color-modes` is enabled][editor-section]) |
    | `ui.statusline.insert`            | Statusline mode during insert mode ([only if `editor.color-modes` is enabled][editor-section]) |
    | `ui.statusline.select`            | Statusline mode during select mode ([only if `editor.color-modes` is enabled][editor-section]) |
    | `ui.statusline.separator`         | Separator character in statusline                                                              |
    | `ui.bufferline`                   | Style for the buffer line                                                                      |
    | `ui.bufferline.active`            | Style for the active buffer in buffer line                                                     |
    | `ui.bufferline.background`        | Style for bufferline background                                                                |
    | `ui.popup`                        | Documentation popups (e.g. Space + k)                                                          |
    | `ui.popup.info`                   | Prompt for multiple key options                                                                |
    | `ui.picker.header`                | Header row area in pickers with multiple columns                                               |
    | `ui.picker.header.column`         | Column names in pickers with multiple columns                                                  |
    | `ui.picker.header.column.active`  | The column name in pickers with multiple columns where the cursor is entering into.            |
    | `ui.window`                       | Borderlines separating splits                                                                  |
    | `ui.help`                         | Description box for commands                                                                   |
    | `ui.text`                         | Default text style, command prompts, popup text, etc.                                          |
    | `ui.text.focus`                   | The currently selected line in the picker                                                      |
    | `ui.text.inactive`                | Same as `ui.text` but when the text is inactive (e.g. suggestions)                             |
    | `ui.text.info`                    | The key: command text in `ui.popup.info` boxes                                                 |
    | `ui.text.directory`               | Directory names in prompt completion                                                           |
    | `ui.virtual.ruler`                | Ruler columns (see the [`editor.rulers` config][editor-section])                               |
    | `ui.virtual.whitespace`           | Visible whitespace characters                                                                  |
    | `ui.virtual.indent-guide`         | Vertical indent width guides                                                                   |
    | `ui.virtual.inlay-hint`           | Default style for inlay hints of all kinds                                                     |
    | `ui.virtual.inlay-hint.parameter` | Style for inlay hints of kind `parameter` (language servers are not required to set a kind)    |
    | `ui.virtual.inlay-hint.type`      | Style for inlay hints of kind `type` (language servers are not required to set a kind)         |
    | `ui.virtual.wrap`                 | Soft-wrap indicator (see the [`editor.soft-wrap` config][editor-section])                      |
    | `ui.virtual.jump-label`           | Style for virtual jump labels                                                                  |
    | `ui.menu`                         | Code and command completion menus                                                              |
    | `ui.menu.selected`                | Selected autocomplete item                                                                     |
    | `ui.menu.scroll`                  | `fg` sets thumb color, `bg` sets track color of scrollbar                                      |
    | `ui.selection`                    | For selections in the editing area                                                             |
    | `ui.selection.primary`            |                                                                                                |
    | `ui.highlight`                    | Highlighted lines in the picker preview                                                        |
    | `ui.highlight.frameline`          | Line at which debugging execution is paused at                                                 |
    | `ui.cursorline.primary`           | The line of the primary cursor ([if cursorline is enabled][editor-section])                    |
    | `ui.cursorline.secondary`         | The lines of any other cursors ([if cursorline is enabled][editor-section])                    |
    | `ui.cursorcolumn.primary`         | The column of the primary cursor ([if cursorcolumn is enabled][editor-section])                |
    | `ui.cursorcolumn.secondary`       | The columns of any other cursors ([if cursorcolumn is enabled][editor-section])                |
    | `warning`                         | Diagnostics warning (gutter)                                                                   |
    | `error`                           | Diagnostics error (gutter)                                                                     |
    | `info`                            | Diagnostics info (gutter)                                                                      |
    | `hint`                            | Diagnostics hint (gutter)                                                                      |
    | `diagnostic`                      | Diagnostics fallback style (editing area)                                                      |
    | `diagnostic.hint`                 | Diagnostics hint (editing area)                                                                |
    | `diagnostic.info`                 | Diagnostics info (editing area)                                                                |
    | `diagnostic.warning`              | Diagnostics warning (editing area)                                                             |
    | `diagnostic.error`                | Diagnostics error (editing area)                                                               |
    | `diagnostic.unnecessary`          | Diagnostics with unnecessary tag (editing area)                                                |
    | `diagnostic.deprecated`           | Diagnostics with deprecated tag (editing area)                                                 |
    | `tabstop`                         | Snippet placeholder                                                                            |

    [editor-section]: ./configuration.md#editor-section
  documentationQuestion1: What is the primary purpose of the theme creation system in Helix, as described in the documentation?
  documentationQuestion2: How can a user define a custom color palette for a theme in Helix, and what is the correct syntax for specifying colors in the configuration file?
  documentationQuestion3: Provide an example of how to extend an existing theme in Helix by inheriting from another theme and overriding specific color settings.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `registers page of the documentation provided by Helix`.



    Documentation text:

    ## Registers

    - [User-defined registers](#user-defined-registers)
    - [Default registers](#default-registers)
    - [Special registers](#special-registers)

    In Helix, registers are storage locations for text and other data, such as the
    result of a search. Registers can be used to cut, copy, and paste text, similar
    to the clipboard in other text editors. Usage is similar to Vim, with `"` being
    used to select a register.

    ### User-defined registers

    Helix allows you to create your own named registers for storing text, for
    example:

    - `"ay` - Yank the current selection to register `a`.
    - `"op` - Paste the text in register `o` after the selection.

    If a register is selected before invoking a change or delete command, the selection will be stored in the register and the action will be carried out:

    - `"hc` - Store the selection in register `h` and then change it (delete and enter insert mode).
    - `"md` - Store the selection in register `m` and delete it.

    ### Default registers

    Commands that use registers, like yank (`y`), use a default register if none is specified.
    These registers are used as defaults:

    | Register character | Contains              |
    | ---                | ---                   |
    | `/`                | Last search           |
    | `:`                | Last executed command |
    | `"`                | Last yanked text      |
    | `@`                | Last recorded macro   |

    ### Special registers

    Some registers have special behavior when read from and written to.

    | Register character | When read              | When written             |
    | ---                | ---                    | ---                      |
    | `_`                | No values are returned | All values are discarded |
    | `#`                | Selection indices (first selection is `1`, second is `2`, etc.) | This register is not writable |
    | `.`                | Contents of the current selections | This register is not writable |
    | `%`                | Name of the current file | This register is not writable |
    | `+`                | Reads from the system clipboard | Joins and yanks to the system clipboard |
    | `*`                | Reads from the primary clipboard | Joins and yanks to the primary clipboard |

    When yanking multiple selections to the clipboard registers, the selections
    are joined with newlines. Pasting from these registers will paste multiple
    selections if the clipboard was last yanked to by the Helix session. Otherwise
    the clipboard contents are pasted as one selection.
  documentationQuestion1: What is the primary purpose of registers in Helix, and what are the common use cases for using them?
  documentationQuestion2: How can you yank the current selection into a user-defined register named 'a' and then paste it later using the same register?
  documentationQuestion3: What is the behavior of the special register `+` when reading from and writing to it, and how does it interact with the system clipboard?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `textobjects page of the documentation provided by Helix`.



    Documentation text:

    ## Selecting and manipulating text with textobjects

    In Helix, textobjects are a way to select, manipulate and operate on a piece of
    text in a structured way. They allow you to refer to blocks of text based on
    their structure or purpose, such as a word, sentence, paragraph, or even a
    function or block of code.

    ![Textobject demo](https://user-images.githubusercontent.com/23398472/124231131-81a4bb00-db2d-11eb-9d10-8e577ca7b177.gif)
    ![Textobject tree-sitter demo](https://user-images.githubusercontent.com/23398472/132537398-2a2e0a54-582b-44ab-a77f-eb818942203d.gif)

    - `ma` - Select around the object (`va` in Vim, `<alt-a>` in Kakoune)
    - `mi` - Select inside the object (`vi` in Vim, `<alt-i>` in Kakoune)

    | Key after `mi` or `ma` | Textobject selected      |
    | ---                    | ---                      |
    | `w`                    | Word                     |
    | `W`                    | WORD                     |
    | `p`                    | Paragraph                |
    | `(`, `[`, `'`, etc.    | Specified surround pairs |
    | `m`                    | The closest surround pair    |
    | `f`                    | Function                 |
    | `t`                    | Type (or Class)          |
    | `a`                    | Argument/parameter       |
    | `c`                    | Comment                  |
    | `T`                    | Test                     |
    | `g`                    | Change                   |

    > 💡 `f`, `t`, etc. need a tree-sitter grammar active for the current
    document and a special tree-sitter query file to work properly. [Only
    some grammars](./lang-support.md) currently have the query file implemented.
    Contributions are welcome!
  documentationQuestion1: What are the primary purposes of textobjects in Helix, and how do they differ from traditional text selection methods?
  documentationQuestion2: How can a user select an entire function in a code file using Helix's textobjects, and what are the necessary conditions for this to work?
  documentationQuestion3: Provide a command example that demonstrates how to select and delete a comment block in a script file using Helix's textobjects.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `textobjects page of the documentation provided by Helix`.



    Documentation text:

    ## Navigating using tree-sitter textobjects

    Navigating between functions, classes, parameters, and other elements is
    possible using tree-sitter and textobject queries. For
    example to move to the next function use `]f`, to move to previous
    type use `[t`, and so on.

    ![Tree-sitter-nav-demo](https://user-images.githubusercontent.com/23398472/152332550-7dfff043-36a2-4aec-b8f2-77c13eb56d6f.gif)

    For the full reference see the [unimpaired](./keymap.html#unimpaired) section of the key bind
    documentation.

    > 💡 This feature relies on tree-sitter textobjects
    > and requires the corresponding query file to work properly.
  documentationQuestion1: What is the primary purpose of the Tree-sitter textobjects feature in Helix?
  documentationQuestion2: How can a user navigate to the next function in Helix using the Tree-sitter textobjects feature?
  documentationQuestion3: What are the key bindings used for navigating between different code elements such as functions and classes in Helix with Tree-sitter textobjects?

- prompt: "You are playing the role of a college professor. Here is some text copied from the `syntax-aware-motions page of the documentation provided by Helix`.\n\n\n\nDocumentation text:\n\n## Moving the selection with syntax-aware motions\n\n`Alt-p`, `Alt-o`, `Alt-i`, and `Alt-n` (or `Alt` and arrow keys) allow you to move the \nselection according to its location in the syntax tree. For example, many languages have the\nfollowing syntax for function calls:\n\n```js\nfunc(arg1, arg2, arg3);\n```\n\nA function call might be parsed by tree-sitter into a tree like the following.\n\n```tsq\n(call\n  function: (identifier) ; func\n  arguments:\n    (arguments           ; (arg1, arg2, arg3)\n      (identifier)       ; arg1\n      (identifier)       ; arg2\n      (identifier)))     ; arg3\n```\n\nUse `:tree-sitter-subtree` to view the syntax tree of the primary selection. In\na more intuitive tree format:\n\n```\n            ┌────┐\n            │call│\n      ┌─────┴────┴─────┐\n      │                │\n┌─────▼────┐      ┌────▼────┐\n│identifier│      │arguments│\n│  \"func\"  │ ┌────┴───┬─────┴───┐\n└──────────┘ │        │         │\n             │        │         │\n   ┌─────────▼┐  ┌────▼─────┐  ┌▼─────────┐\n   │identifier│  │identifier│  │identifier│\n   │  \"arg1\"  │  │  \"arg2\"  │  │  \"arg3\"  │\n   └──────────┘  └──────────┘  └──────────┘\n```\n\nIf you have a selection that wraps `arg1` (see the tree above), and you use\n`Alt-n`, it will select the next sibling in the syntax tree: `arg2`.\n\n```js\n// before\nfunc([arg1], arg2, arg3)\n// after\nfunc(arg1, [arg2], arg3);\n```\n\nSimilarly, `Alt-o` will expand the selection to the parent node, in this case, the\narguments node.\n\n```js\nfunc[(arg1, arg2, arg3)];\n```\n\nThere is also some nuanced behavior that prevents you from getting stuck on a\nnode with no sibling. When using `Alt-p` with a selection on `arg1`, the previous\nchild node will be selected. In the event that `arg1` does not have a previous\nsibling, the selection will move up the syntax tree and select the previous\nelement. As a result, using `Alt-p` with a selection on `arg1` will move the\nselection to the \"func\" `identifier`.\n\n[lang-support]: ./lang-support.md"
  documentationQuestion1: What are the primary purposes of syntax-aware motions in Helix, as described in the documentation?
  documentationQuestion2: How can you use syntax-aware motions to navigate between function arguments in a JavaScript function call?
  documentationQuestion3: What is the effect of using the `Alt-p` motion on a selection that wraps the first argument of a function call in JavaScript?

- prompt: "You are playing the role of a college professor. Here is some text copied from the `building-from-source page of the documentation provided by Helix`.\n\n\n\nDocumentation text:\n\n## Building from source\n\n- [Configuring Helix's runtime files](#configuring-helixs-runtime-files)\n  - [Linux and macOS](#linux-and-macos)\n  - [Windows](#windows)\n  - [Multiple runtime directories](#multiple-runtime-directories)\n  - [Note to packagers](#note-to-packagers)\n- [Validating the installation](#validating-the-installation)\n- [Configure the desktop shortcut](#configure-the-desktop-shortcut)\n- [Building the Debian package](#building-the-debian-package)\n\nRequirements:\n\nClone the Helix GitHub repository into a directory of your choice. The\nexamples in this documentation assume installation into either `~/src/` on\nLinux and macOS, or `%userprofile%\\src\\` on Windows.\n\n- The [Rust toolchain](https://www.rust-lang.org/tools/install)\n- The [Git version control system](https://git-scm.com/)\n- A C++14 compatible compiler to build the tree-sitter grammars, for example GCC or Clang\n\nIf you are using the `musl-libc` standard library instead of `glibc` the following environment variable must be set during the build to ensure tree-sitter grammars can be loaded correctly:\n\n```sh\nRUSTFLAGS=\"-C target-feature=-crt-static\"\n```\n\n1. Clone the repository:\n\n   ```sh\n   git clone https://github.com/helix-editor/helix\n   cd helix\n   ```\n\n2. Compile from source:\n\n   ```sh\n   cargo install --path helix-term --locked\n   ```\n\n   This command will create the `hx` executable and construct the tree-sitter\n   grammars in the local `runtime` folder.\n\n> 💡 If you do not want to fetch or build grammars, set an environment variable `HELIX_DISABLE_AUTO_GRAMMAR_BUILD`\n\n> 💡 Tree-sitter grammars can be fetched and compiled if not pre-packaged. Fetch\n> grammars with `hx --grammar fetch` and compile them with\n> `hx --grammar build`. This will install them in\n> the `runtime` directory within the user's helix config directory (more\n> [details below](#multiple-runtime-directories)).\n\n### Configuring Helix's runtime files\n\n#### Linux and macOS\n\nThe **runtime** directory is one below the Helix source, so either export a\n`HELIX_RUNTIME` environment variable to point to that directory and add it to\nyour `~/.bashrc` or equivalent:\n\n```sh\nexport HELIX_RUNTIME=~/src/helix/runtime\n```\n\nOr, create a symbolic link:\n\n```sh\nln -Tsf $PWD/runtime ~/.config/helix/runtime\n```\n\n#### Windows\n\nEither set the `HELIX_RUNTIME` environment variable to point to the runtime files using the Windows setting (search for\n`Edit environment variables for your account`) or use the `setx` command in\nCmd:\n\n```sh\nsetx HELIX_RUNTIME \"%userprofile%\\src\\helix\\runtime\"\n```\n\n> 💡 `%userprofile%` resolves to your user directory like\n> `C:\\Users\\Your-Name\\` for example.\n\nOr, create a symlink in `%appdata%\\helix\\` that links to the source code directory:\n\n| Method     | Command                                                                                |\n| ---------- | -------------------------------------------------------------------------------------- |\n| PowerShell | `New-Item -ItemType Junction -Target \"runtime\" -Path \"$Env:AppData\\helix\\runtime\"`     |\n| Cmd        | `cd %appdata%\\helix` <br/> `mklink /D runtime \"%userprofile%\\src\\helix\\runtime\"`       |\n\n> 💡 On Windows, creating a symbolic link may require running PowerShell or\n> Cmd as an administrator.\n\n#### Multiple runtime directories\n\nWhen Helix finds multiple runtime directories it will search through them for files in the\nfollowing order:\n\n1. `runtime/` sibling directory to `$CARGO_MANIFEST_DIR` directory (this is intended for\n  developing and testing helix only).\n2. `runtime/` subdirectory of OS-dependent helix user config directory.\n3. `$HELIX_RUNTIME`\n4. Distribution-specific fallback directory (set at compile time—not run time—\n   with the `HELIX_DEFAULT_RUNTIME` environment variable)\n5. `runtime/` subdirectory of path to Helix executable.\n\nThis order also sets the priority for selecting which file will be used if multiple runtime\ndirectories have files with the same name.\n\n#### Note to packagers\n\nIf you are making a package of Helix for end users, to provide a good out of\nthe box experience, you should set the `HELIX_DEFAULT_RUNTIME` environment\nvariable at build time (before invoking `cargo build`) to a directory which\nwill store the final runtime files after installation. For example, say you want\nto package the runtime into `/usr/lib/helix/runtime`. The rough steps a build\nscript could follow are:\n\n1. `export HELIX_DEFAULT_RUNTIME=/usr/lib/helix/runtime`\n1. `cargo build --profile opt --locked`\n1. `cp -r runtime $BUILD_DIR/usr/lib/helix/`\n1. `cp target/opt/hx $BUILD_DIR/usr/bin/hx`\n\nThis way the resulting `hx` binary will always look for its runtime directory in\n`/usr/lib/helix/runtime` if the user has no custom runtime in `~/.config/helix`\nor `HELIX_RUNTIME`.\n\n### Validating the installation\n\nTo make sure everything is set up as expected you should run the Helix health\ncheck:\n\n```sh\nhx --health\n```\n\nFor more information on the health check results refer to\n[Health check](https://github.com/helix-editor/helix/wiki/Healthcheck).\n\n### Configure the desktop shortcut\n\nIf your desktop environment supports the\n[XDG desktop menu](https://specifications.freedesktop.org/menu-spec/menu-spec-latest.html)\nyou can configure Helix to show up in the application menu by copying the\nprovided `.desktop` and icon files to their correct folders:\n\n```sh\ncp contrib/Helix.desktop ~/.local/share/applications\ncp contrib/helix.png ~/.icons # or ~/.local/share/icons\n```\nIt is recommended to convert the links in the `.desktop` file to absolute paths to avoid potential problems:\n\n```sh\nsed -i -e \"s|Exec=hx %F|Exec=$(readlink -f ~/.cargo/bin/hx) %F|g\" \\\n  -e \"s|Icon=helix|Icon=$(readlink -f ~/.icons/helix.png)|g\" ~/.local/share/applications/Helix.desktop\n```\n\nTo use another terminal than the system default, you can modify the `.desktop`\nfile. For example, to use `kitty`:\n\n```sh\nsed -i \"s|Exec=hx %F|Exec=kitty hx %F|g\" ~/.local/share/applications/Helix.desktop\nsed -i \"s|Terminal=true|Terminal=false|g\" ~/.local/share/applications/Helix.desktop\n```\n\n### Building the Debian package\n\nIf the `.deb` file provided on the release page uses a `libc` version higher\nthan that used by your Debian, Ubuntu, or Mint system, you can build the package\nfrom source to match your system's dependencies.\n\nInstall `cargo-deb`, the tool used for building the `.deb` file:\n\n```sh\ncargo install cargo-deb\n```\n\nAfter cloning and entering the Helix repository as previously described,\nuse the following command to build the release binary and package it into a `.deb` file in a single step.\n\n```sh\ncargo deb -- --locked\n```\n\n> 💡 This locks you into the `--release` profile. But you can also build helix in any way you like.\n> As long as you leave a `target/release/hx` file, it will get packaged with `cargo deb --no-build` \n\n> 💡 Don't worry about the following:\n> ```\n> warning: Failed to find dependency specification\n> ```\n> Cargo deb just reports which packaged files it didn't derive dependencies for. But\n> so far the dependency deriving seams very good, even if some of the grammar files are skipped.\n\nYou can find the resulted `.deb` in `target/debian/`. It should contain everything it needs, including the\n\n- completions for bash, fish, zsh\n- .desktop file\n- icon (though desktop environments might use their own since the name of the package is correctly `helix`)\n- launcher to the binary with the runtime"
  documentationQuestion1: What are the primary purposes of the Helix source building process as described in the documentation?
  documentationQuestion2: How can a user configure the runtime directory location for Helix on Linux or macOS, and what are the common methods for doing so?
  documentationQuestion3: What are the steps to build a Debian package for Helix that is compatible with a specific system's libc version, and what are the key considerations during this process?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ## Keymap

    - [Normal mode](#normal-mode)
      - [Movement](#movement)
      - [Changes](#changes)
        - [Shell](#shell)
      - [Selection manipulation](#selection-manipulation)
      - [Search](#search)
      - [Minor modes](#minor-modes)
        - [View mode](#view-mode)
        - [Goto mode](#goto-mode)
        - [Match mode](#match-mode)
        - [Window mode](#window-mode)
        - [Space mode](#space-mode)
          - [Popup](#popup)
          - [Completion Menu](#completion-menu)
          - [Signature-help Popup](#signature-help-popup)
        - [Unimpaired](#unimpaired)
    - [Insert mode](#insert-mode)
    - [Select / extend mode](#select--extend-mode)
    - [Picker](#picker)
    - [Prompt](#prompt)

    > 💡 Mappings marked (**LSP**) require an active language server for the file.

    > 💡 Mappings marked (**TS**) require a tree-sitter grammar for the file type.

    > ⚠️ Some terminals' default key mappings conflict with Helix's. If any of the mappings described on this page do not work as expected, check your terminal's mappings to ensure they do not conflict. See the [wiki](https://github.com/helix-editor/helix/wiki/Terminal-Support) for known conflicts.
  documentationQuestion1: What are the primary purposes of the keymap system in Helix as described in the documentation?
  documentationQuestion2: How can a user navigate through a file in Normal mode using Helix's keymap system, and what are some common movement commands?
  documentationQuestion3: What are the key differences between Insert mode and Select / extend mode in Helix, and how do they affect text editing and selection?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ## Normal mode

    Normal mode is the default mode when you launch helix. You can return to it from other modes by pressing the `Escape` key.

    ### Movement

    > NOTE: Unlike Vim, `f`, `F`, `t` and `T` are not confined to the current line.

    | Key                   | Description                                        | Command                     |
    | -----                 | -----------                                        | -------                     |
    | `h`, `Left`           | Move left                                          | `move_char_left`            |
    | `j`, `Down`           | Move down                                          | `move_visual_line_down`     |
    | `k`, `Up`             | Move up                                            | `move_visual_line_up`       |
    | `l`, `Right`          | Move right                                         | `move_char_right`           |
    | `w`                   | Move next word start                               | `move_next_word_start`      |
    | `b`                   | Move previous word start                           | `move_prev_word_start`      |
    | `e`                   | Move next word end                                 | `move_next_word_end`        |
    | `W`                   | Move next WORD start                               | `move_next_long_word_start` |
    | `B`                   | Move previous WORD start                           | `move_prev_long_word_start` |
    | `E`                   | Move next WORD end                                 | `move_next_long_word_end`   |
    | `t`                   | Find 'till next char                               | `find_till_char`            |
    | `f`                   | Find next char                                     | `find_next_char`            |
    | `T`                   | Find 'till previous char                           | `till_prev_char`            |
    | `F`                   | Find previous char                                 | `find_prev_char`            |
    | `G`                   | Go to line number `<n>`                            | `goto_line`                 |
    | `Alt-.`               | Repeat last motion (`f`, `t`, `m`, `[` or `]`)     | `repeat_last_motion`        |
    | `Home`                | Move to the start of the line                      | `goto_line_start`           |
    | `End`                 | Move to the end of the line                        | `goto_line_end`             |
    | `Ctrl-b`, `PageUp`    | Move page up                                       | `page_up`                   |
    | `Ctrl-f`, `PageDown`  | Move page down                                     | `page_down`                 |
    | `Ctrl-u`              | Move cursor and page half page up                  | `page_cursor_half_up`       |
    | `Ctrl-d`              | Move cursor and page half page down                | `page_cursor_half_down`     |
    | `Ctrl-i`              | Jump forward on the jumplist                       | `jump_forward`              |
    | `Ctrl-o`              | Jump backward on the jumplist                      | `jump_backward`             |
    | `Ctrl-s`              | Save the current selection to the jumplist         | `save_selection`            |
  documentationQuestion1: What are the primary purposes of Normal mode in Helix, and how does it differ from Vim's Normal mode?
  documentationQuestion2: How can a user move the cursor to the start of the current line in Helix using both keybindings and commands?
  documentationQuestion3: What command and keybinding allow a user to move the cursor down by one line in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ### Changes

    | Key         | Description                                                          | Command                   |
    | -----       | -----------                                                          | -------                   |
    | `r`         | Replace with a character                                             | `replace`                 |
    | `R`         | Replace with yanked text                                             | `replace_with_yanked`     |
    | `~`         | Switch case of the selected text                                     | `switch_case`             |
    | `` ` ``     | Set the selected text to lower case                                  | `switch_to_lowercase`     |
    | `` Alt-` `` | Set the selected text to upper case                                  | `switch_to_uppercase`     |
    | `i`         | Insert before selection                                              | `insert_mode`             |
    | `a`         | Insert after selection (append)                                      | `append_mode`             |
    | `I`         | Insert at the start of the line                                      | `insert_at_line_start`    |
    | `A`         | Insert at the end of the line                                        | `insert_at_line_end`      |
    | `o`         | Open new line below selection                                        | `open_below`              |
    | `O`         | Open new line above selection                                        | `open_above`              |
    | `.`         | Repeat last insert                                                   | N/A                       |
    | `u`         | Undo change                                                          | `undo`                    |
    | `U`         | Redo change                                                          | `redo`                    |
    | `Alt-u`     | Move backward in history                                             | `earlier`                 |
    | `Alt-U`     | Move forward in history                                              | `later`                   |
    | `y`         | Yank selection                                                       | `yank`                    |
    | `p`         | Paste after selection                                                | `paste_after`             |
    | `P`         | Paste before selection                                               | `paste_before`            |
    | `"` `<reg>` | Select a register to yank to or paste from                           | `select_register`         |
    | `>`         | Indent selection                                                     | `indent`                  |
    | `<`         | Unindent selection                                                   | `unindent`                |
    | `=`         | Format selection (**LSP**)                                           | `format_selections`       |
    | `d`         | Delete selection                                                     | `delete_selection`        |
    | `Alt-d`     | Delete selection, without yanking                                    | `delete_selection_noyank` |
    | `c`         | Change selection (delete and enter insert mode)                      | `change_selection`        |
    | `Alt-c`     | Change selection (delete and enter insert mode, without yanking)     | `change_selection_noyank` |
    | `Ctrl-a`    | Increment object (number) under cursor                               | `increment`               |
    | `Ctrl-x`    | Decrement object (number) under cursor                               | `decrement`               |
    | `Q`         | Start/stop macro recording to the selected register (experimental)   | `record_macro`            |
    | `q`         | Play back a recorded macro from the selected register (experimental) | `replay_macro`            |

    #### Shell

    | Key     | Description                                                                      | Command               |
    | ------  | -----------                                                                      | -------               |
    | <code>&#124;</code>     | Pipe each selection through shell command, replacing with output                 | `shell_pipe`          |
    | <code>Alt-&#124;</code> | Pipe each selection into shell command, ignoring output                          | `shell_pipe_to`       |
    | `!`     | Run shell command, inserting output before each selection                        | `shell_insert_output` |
    | `Alt-!` | Run shell command, appending output after each selection                         | `shell_append_output` |
    | `$`     | Pipe each selection into shell command, keep selections where command returned 0 | `shell_keep_pipe`     |
  documentationQuestion1: What are the primary purposes of the keymap feature in Helix as described in the documentation?
  documentationQuestion2: How can you use the `shell_pipe` command in Helix to process each selection through a shell command and replace it with the output?
  documentationQuestion3: What is the difference between the `shell_pipe` and `shell_pipe_to` commands in Helix, and how would you use them in a practical scenario?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ### Selection manipulation

    | Key                      | Description                                                       | Command                              |
    | -----                    | -----------                                                       | -------                              |
    | `s`                      | Select all regex matches inside selections                        | `select_regex`                       |
    | `S`                      | Split selection into sub selections on regex matches              | `split_selection`                    |
    | `Alt-s`                  | Split selection on newlines                                       | `split_selection_on_newline`         |
    | `Alt-minus`              | Merge selections                                                  | `merge_selections`                   |
    | `Alt-_`                  | Merge consecutive selections                                      | `merge_consecutive_selections`       |
    | `&`                      | Align selection in columns                                        | `align_selections`                   |
    | `_`                      | Trim whitespace from the selection                                | `trim_selections`                    |
    | `;`                      | Collapse selection onto a single cursor                           | `collapse_selection`                 |
    | `Alt-;`                  | Flip selection cursor and anchor                                  | `flip_selections`                    |
    | `Alt-:`                  | Ensures the selection is in forward direction                     | `ensure_selections_forward`          |
    | `,`                      | Keep only the primary selection                                   | `keep_primary_selection`             |
    | `Alt-,`                  | Remove the primary selection                                      | `remove_primary_selection`           |
    | `C`                      | Copy selection onto the next line (Add cursor below)              | `copy_selection_on_next_line`        |
    | `Alt-C`                  | Copy selection onto the previous line (Add cursor above)          | `copy_selection_on_prev_line`        |
    | `(`                      | Rotate main selection backward                                    | `rotate_selections_backward`         |
    | `)`                      | Rotate main selection forward                                     | `rotate_selections_forward`          |
    | `Alt-(`                  | Rotate selection contents backward                                | `rotate_selection_contents_backward` |
    | `Alt-)`                  | Rotate selection contents forward                                 | `rotate_selection_contents_forward`  |
    | `%`                      | Select entire file                                                | `select_all`                         |
    | `x`                      | Select current line, if already selected, extend to next line     | `extend_line_below`                  |
    | `X`                      | Extend selection to line bounds (line-wise selection)             | `extend_to_line_bounds`              |
    | `Alt-x`                  | Shrink selection to line bounds (line-wise selection)             | `shrink_to_line_bounds`              |
    | `J`                      | Join lines inside selection                                       | `join_selections`                    |
    | `Alt-J`                  | Join lines inside selection and select the inserted space         | `join_selections_space`              |
    | `K`                      | Keep selections matching the regex                                | `keep_selections`                    |
    | `Alt-K`                  | Remove selections matching the regex                              | `remove_selections`                  |
    | `Ctrl-c`                 | Comment/uncomment the selections                                  | `toggle_comments`                    |
    | `Alt-o`, `Alt-up`        | Expand selection to parent syntax node (**TS**)                   | `expand_selection`                   |
    | `Alt-i`, `Alt-down`      | Shrink syntax tree object selection (**TS**)                      | `shrink_selection`                   |
    | `Alt-p`, `Alt-left`      | Select previous sibling node in syntax tree (**TS**)              | `select_prev_sibling`                |
    | `Alt-n`, `Alt-right`     | Select next sibling node in syntax tree (**TS**)                  | `select_next_sibling`                |
    | `Alt-a`                  | Select all sibling nodes in syntax tree (**TS**)                  | `select_all_siblings`                |
    | `Alt-I`, `Alt-Shift-down`| Select all children nodes in syntax tree (**TS**)                 | `select_all_children`                |
    | `Alt-e`                  | Move to end of parent node in syntax tree (**TS**)                | `move_parent_node_end`               |
    | `Alt-b`                  | Move to start of parent node in syntax tree (**TS**)              | `move_parent_node_start`             |
  documentationQuestion1: What are the primary purposes of the selection manipulation features in Helix, and how do they enhance the editing experience?
  documentationQuestion2: How can a user split a selection into sub selections based on regex matches, and what is the corresponding command for this action?
  documentationQuestion3: What is the function of the `Alt-o` and `Alt-up` key combination in Helix, and how does it interact with the syntax tree for code editing?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ### Search

    Search commands all operate on the `/` register by default. To use a different register, use `"<char>`.

    | Key   | Description                                 | Command              |
    | ----- | -----------                                 | -------              |
    | `/`   | Search for regex pattern                    | `search`             |
    | `?`   | Search for previous pattern                 | `rsearch`            |
    | `n`   | Select next search match                    | `search_next`        |
    | `N`   | Select previous search match                | `search_prev`        |
    | `*`   | Use current selection as the search pattern, automatically wrapping with `\b` on word boundaries | `search_selection_detect_word_boundaries` |
    | `Alt-*` | Use current selection as the search pattern | `search_selection` |

    ### Minor modes

    These sub-modes are accessible from normal mode and typically switch back to normal mode after a command.

    | Key      | Description                                        | Command        |
    | -----    | -----------                                        | -------        |
    | `v`      | Enter [select (extend) mode](#select--extend-mode) | `select_mode`  |
    | `g`      | Enter [goto mode](#goto-mode)                      | N/A            |
    | `m`      | Enter [match mode](#match-mode)                    | N/A            |
    | `:`      | Enter command mode                                 | `command_mode` |
    | `z`      | Enter [view mode](#view-mode)                      | N/A            |
    | `Z`      | Enter sticky [view mode](#view-mode)               | N/A            |
    | `Ctrl-w` | Enter [window mode](#window-mode)                  | N/A            |
    | `Space`  | Enter [space mode](#space-mode)                    | N/A            |

    These modes (except command mode) can be configured by
    [remapping keys](https://docs.helix-editor.com/remapping.html#minor-modes).

    #### View mode

    Accessed by typing `z` in [normal mode](#normal-mode).

    View mode is intended for scrolling and manipulating the view without changing
    the selection. The "sticky" variant of this mode (accessed by typing `Z` in
    normal mode) is persistent and can be exited using the escape key. This is
    useful when you're simply looking over text and not actively editing it.


    | Key                  | Description                                               | Command                 |
    | -----                | -----------                                               | -------                 |
    | `z`, `c`             | Vertically center the line                                | `align_view_center`     |
    | `t`                  | Align the line to the top of the screen                   | `align_view_top`        |
    | `b`                  | Align the line to the bottom of the screen                | `align_view_bottom`     |
    | `m`                  | Align the line to the middle of the screen (horizontally) | `align_view_middle`     |
    | `j`, `down`          | Scroll the view downwards                                 | `scroll_down`           |
    | `k`, `up`            | Scroll the view upwards                                   | `scroll_up`             |
    | `Ctrl-f`, `PageDown` | Move page down                                            | `page_down`             |
    | `Ctrl-b`, `PageUp`   | Move page up                                              | `page_up`               |
    | `Ctrl-u`             | Move cursor and page half page up                         | `page_cursor_half_up`   |
    | `Ctrl-d`             | Move cursor and page half page down                       | `page_cursor_half_down` |

    #### Goto mode

    Accessed by typing `g` in [normal mode](#normal-mode).

    Jumps to various locations.

    | Key   | Description                                      | Command                    |
    | ----- | -----------                                      | -------                    |
    | `g`   | Go to line number `<n>` else start of file       | `goto_file_start`          |
    | <code>&#124;</code>  | Go to column number `<n>` else start of line     | `goto_column`              |
    | `e`   | Go to the end of the file                        | `goto_last_line`           |
    | `f`   | Go to files in the selections                    | `goto_file`                |
    | `h`   | Go to the start of the line                      | `goto_line_start`          |
    | `l`   | Go to the end of the line                        | `goto_line_end`            |
    | `s`   | Go to first non-whitespace character of the line | `goto_first_nonwhitespace` |
    | `t`   | Go to the top of the screen                      | `goto_window_top`          |
    | `c`   | Go to the middle of the screen                   | `goto_window_center`       |
    | `b`   | Go to the bottom of the screen                   | `goto_window_bottom`       |
    | `d`   | Go to definition (**LSP**)                       | `goto_definition`          |
    | `y`   | Go to type definition (**LSP**)                  | `goto_type_definition`     |
    | `r`   | Go to references (**LSP**)                       | `goto_reference`           |
    | `i`   | Go to implementation (**LSP**)                   | `goto_implementation`      |
    | `a`   | Go to the last accessed/alternate file           | `goto_last_accessed_file`  |
    | `m`   | Go to the last modified/alternate file           | `goto_last_modified_file`  |
    | `n`   | Go to next buffer                                | `goto_next_buffer`         |
    | `p`   | Go to previous buffer                            | `goto_previous_buffer`     |
    | `.`   | Go to last modification in current file          | `goto_last_modification`   |
    | `j`   | Move down textual (instead of visual) line       | `move_line_down`           |
    | `k`   | Move up textual (instead of visual) line         | `move_line_up`             |
    | `w`   | Show labels at each word and select the word that belongs to the entered labels | `goto_word` |

    #### Match mode

    Accessed by typing `m` in [normal mode](#normal-mode).

    Please refer to the relevant sections for detailed explanations about [surround](./surround.md) and [textobjects](./textobjects.md).

    | Key              | Description                                     | Command                    |
    | -----            | -----------                                     | -------                    |
    | `m`              | Goto matching bracket (**TS**)                  | `match_brackets`           |
    | `s` `<char>`     | Surround current selection with `<char>`        | `surround_add`             |
    | `r` `<from><to>` | Replace surround character `<from>` with `<to>` | `surround_replace`         |
    | `d` `<char>`     | Delete surround character `<char>`              | `surround_delete`          |
    | `a` `<object>`   | Select around textobject                        | `select_textobject_around` |
    | `i` `<object>`   | Select inside textobject                        | `select_textobject_inner`  |

    TODO: Mappings for selecting syntax nodes (a superset of `[`).

    #### Window mode

    Accessed by typing `Ctrl-w` in [normal mode](#normal-mode).

    This layer is similar to Vim keybindings as Kakoune does not support windows.

    | Key                    | Description                                          | Command           |
    | -----                  | -------------                                        | -------           |
    | `w`, `Ctrl-w`          | Switch to next window                                | `rotate_view`     |
    | `v`, `Ctrl-v`          | Vertical right split                                 | `vsplit`          |
    | `s`, `Ctrl-s`          | Horizontal bottom split                              | `hsplit`          |
    | `f`                    | Go to files in the selections in horizontal splits   | `goto_file`       |
    | `F`                    | Go to files in the selections in vertical splits     | `goto_file`       |
    | `h`, `Ctrl-h`, `Left`  | Move to left split                                   | `jump_view_left`  |
    | `j`, `Ctrl-j`, `Down`  | Move to split below                                  | `jump_view_down`  |
    | `k`, `Ctrl-k`, `Up`    | Move to split above                                  | `jump_view_up`    |
    | `l`, `Ctrl-l`, `Right` | Move to right split                                  | `jump_view_right` |
    | `q`, `Ctrl-q`          | Close current window                                 | `wclose`          |
    | `o`, `Ctrl-o`          | Only keep the current window, closing all the others | `wonly`           |
    | `H`                    | Swap window to the left                              | `swap_view_left`  |
    | `J`                    | Swap window downwards                                | `swap_view_down`  |
    | `K`                    | Swap window upwards                                  | `swap_view_up`    |
    | `L`                    | Swap window to the right                             | `swap_view_right` |

    #### Space mode

    Accessed by typing `Space` in [normal mode](#normal-mode).

    This layer is a kludge of mappings, mostly pickers.

    | Key     | Description                                                             | Command                                    |
    | -----   | -----------                                                             | -------                                    |
    | `f`     | Open file picker at LSP workspace root                                  | `file_picker`                              |
    | `F`     | Open file picker at current working directory                           | `file_picker_in_current_directory`         |
    | `b`     | Open buffer picker                                                      | `buffer_picker`                            |
    | `j`     | Open jumplist picker                                                    | `jumplist_picker`                          |
    | `g`     | Open changed file picker                                                | `changed_file_picker`                      |
    | `G`     | Debug (experimental)                                                    | N/A                                        |
    | `k`     | Show documentation for item under cursor in a [popup](#popup) (**LSP**) | `hover`                                    |
    | `s`     | Open document symbol picker (**LSP**)                                   | `symbol_picker`                            |
    | `S`     | Open workspace symbol picker (**LSP**)                                  | `workspace_symbol_picker`                  |
    | `d`     | Open document diagnostics picker (**LSP**)                              | `diagnostics_picker`                       |
    | `D`     | Open workspace diagnostics picker (**LSP**)                             | `workspace_diagnostics_picker`             |
    | `r`     | Rename symbol (**LSP**)                                                 | `rename_symbol`                            |
    | `a`     | Apply code action (**LSP**)                                             | `code_action`                              |
    | `h`     | Select symbol references (**LSP**)                                      | `select_references_to_symbol_under_cursor` |
    | `'`     | Open last fuzzy picker                                                  | `last_picker`                              |
    | `w`     | Enter [window mode](#window-mode)                                       | N/A                                        |
    | `c`     | Comment/uncomment selections                                            | `toggle_comments`                          |
    | `C`     | Block comment/uncomment selections                                      | `toggle_block_comments`                    |
    | `Alt-c` | Line comment/uncomment selections                                       | `toggle_line_comments`                     |
    | `p`     | Paste system clipboard after selections                                 | `paste_clipboard_after`                    |
    | `P`     | Paste system clipboard before selections                                | `paste_clipboard_before`                   |
    | `y`     | Yank selections to clipboard                                            | `yank_to_clipboard`                        |
    | `Y`     | Yank main selection to clipboard                                        | `yank_main_selection_to_clipboard`         |
    | `R`     | Replace selections by clipboard contents                                | `replace_selections_with_clipboard`        |
    | `/`     | Global search in workspace folder                                       | `global_search`                            |
    | `?`     | Open command palette                                                    | `command_palette`                          |

    > 💡 Global search displays results in a fuzzy picker, use `Space + '` to bring it back up after opening a file.

    ##### Popup

    Displays documentation for item under cursor. Remapping currently not supported.

    | Key      | Description |
    | ----     | ----------- |
    | `Ctrl-u` | Scroll up   |
    | `Ctrl-d` | Scroll down |

    ##### Completion Menu

    Displays documentation for the selected completion item. Remapping currently not supported.

    | Key                         | Description                      |
    | ----                        | -----------                      |
    | `Shift-Tab`, `Ctrl-p`, `Up` | Previous entry                   |
    | `Tab`, `Ctrl-n`, `Down`     | Next entry                       |
    | `Enter`                     | Close menu and accept completion |
    | `Ctrl-c`                    | Close menu and reject completion |

    Any other keypresses result in the completion being accepted.

    ##### Signature-help Popup

    Displays the signature of the selected completion item. Remapping currently not supported.

    | Key     | Description        |
    | ----    | -----------        |
    | `Alt-p` | Previous signature |
    | `Alt-n` | Next signature     |

    #### Unimpaired

    These mappings are in the style of [vim-unimpaired](https://github.com/tpope/vim-unimpaired).

    | Key      | Description                                  | Command               |
    | -----    | -----------                                  | -------               |
    | `]d`     | Go to next diagnostic (**LSP**)              | `goto_next_diag`      |
    | `[d`     | Go to previous diagnostic (**LSP**)          | `goto_prev_diag`      |
    | `]D`     | Go to last diagnostic in document (**LSP**)  | `goto_last_diag`      |
    | `[D`     | Go to first diagnostic in document (**LSP**) | `goto_first_diag`     |
    | `]f`     | Go to next function (**TS**)                 | `goto_next_function`  |
    | `[f`     | Go to previous function (**TS**)             | `goto_prev_function`  |
    | `]t`     | Go to next type definition (**TS**)          | `goto_next_class`     |
    | `[t`     | Go to previous type definition (**TS**)      | `goto_prev_class`     |
    | `]a`     | Go to next argument/parameter (**TS**)       | `goto_next_parameter` |
    | `[a`     | Go to previous argument/parameter (**TS**)   | `goto_prev_parameter` |
    | `]c`     | Go to next comment (**TS**)                  | `goto_next_comment`   |
    | `[c`     | Go to previous comment (**TS**)              | `goto_prev_comment`   |
    | `]T`     | Go to next test (**TS**)                     | `goto_next_test`      |
    | `[T`     | Go to previous test (**TS**)                 | `goto_prev_test`      |
    | `]p`     | Go to next paragraph                         | `goto_next_paragraph` |
    | `[p`     | Go to previous paragraph                     | `goto_prev_paragraph` |
    | `]g`     | Go to next change                            | `goto_next_change`    |
    | `[g`     | Go to previous change                        | `goto_prev_change`    |
    | `]G`     | Go to last change                            | `goto_last_change`    |
    | `[G`     | Go to first change                           | `goto_first_change`   |
    | `]Space` | Add newline below                            | `add_newline_below`   |
    | `[Space` | Add newline above                            | `add_newline_above`   |
  documentationQuestion1: What is the primary purpose of the View mode in Helix, and how does it differ from normal mode?
  documentationQuestion2: How can a user navigate to the middle of the screen in View mode using Helix?
  documentationQuestion3: What command in Helix allows users to split the window horizontally and open a file in the new split?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ## Insert mode

    Accessed by typing `i` in [normal mode](#normal-mode).

    Insert mode bindings are minimal by default. Helix is designed to
    be a modal editor, and this is reflected in the user experience and internal
    mechanics. Changes to the text are only saved for undos when
    escaping from insert mode to normal mode.

    > 💡 New users are strongly encouraged to learn the modal editing paradigm
    > to get the smoothest experience.

    | Key                                         | Description                 | Command                  |
    | -----                                       | -----------                 | -------                  |
    | `Escape`                                    | Switch to normal mode       | `normal_mode`            |
    | `Ctrl-s`                                    | Commit undo checkpoint      | `commit_undo_checkpoint` |
    | `Ctrl-x`                                    | Autocomplete                | `completion`             |
    | `Ctrl-r`                                    | Insert a register content   | `insert_register`        |
    | `Ctrl-w`, `Alt-Backspace`                   | Delete previous word        | `delete_word_backward`   |
    | `Alt-d`, `Alt-Delete`                       | Delete next word            | `delete_word_forward`    |
    | `Ctrl-u`                                    | Delete to start of line     | `kill_to_line_start`     |
    | `Ctrl-k`                                    | Delete to end of line       | `kill_to_line_end`       |
    | `Ctrl-h`, `Backspace`, `Shift-Backspace`    | Delete previous char        | `delete_char_backward`   |
    | `Ctrl-d`, `Delete`                          | Delete next char            | `delete_char_forward`    |
    | `Ctrl-j`, `Enter`                           | Insert new line             | `insert_newline`         |

    These keys are not recommended, but are included for new users less familiar
    with modal editors.

    | Key                                         | Description                 | Command                  |
    | -----                                       | -----------                 | -------                  |
    | `Up`                                        | Move to previous line       | `move_line_up`           |
    | `Down`                                      | Move to next line           | `move_line_down`         |
    | `Left`                                      | Backward a char             | `move_char_left`         |
    | `Right`                                     | Forward a char              | `move_char_right`        |
    | `PageUp`                                    | Move one page up            | `page_up`                |
    | `PageDown`                                  | Move one page down          | `page_down`              |
    | `Home`                                      | Move to line start          | `goto_line_start`        |
    | `End`                                       | Move to line end            | `goto_line_end_newline`  |

    As you become more comfortable with modal editing, you may want to disable some
    insert mode bindings. You can do this by editing your `config.toml` file.

    ```toml
    [keys.insert]
    up = "no_op"
    down = "no_op"
    left = "no_op"
    right = "no_op"
    pageup = "no_op"
    pagedown = "no_op"
    home = "no_op"
    end = "no_op"
    ```
  documentationQuestion1: What are the primary purposes of Insert mode in Helix, and how does it differ from other modes in the editor?
  documentationQuestion2: How can a user disable the default insert mode keybindings for navigation keys like Up, Down, Left, and Right in Helix?
  documentationQuestion3: What are the common keybindings in Insert mode for text navigation and deletion, and how can they be customized?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ## Select / extend mode

    Accessed by typing `v` in [normal mode](#normal-mode).

    Select mode echoes Normal mode, but changes any movements to extend
    selections rather than replace them. Goto motions are also changed to
    extend, so that `vgl`, for example, extends the selection to the end of
    the line.

    Search is also affected. By default, `n` and `N` will remove the current
    selection and select the next instance of the search term. Toggling this
    mode before pressing `n` or `N` makes it possible to keep the current
    selection. Toggling it on and off during your iterative searching allows
    you to selectively add search terms to your selections.

    ## Picker

    Keys to use within picker. Remapping currently not supported.
    See the documentation page on [pickers](./pickers.md) for more info.
    [Prompt](#prompt) keybinds also work in pickers, except where they conflict with picker keybinds.

    | Key                          | Description                                                |
    | -----                        | -------------                                              |
    | `Shift-Tab`, `Up`, `Ctrl-p`  | Previous entry                                             |
    | `Tab`, `Down`, `Ctrl-n`      | Next entry                                                 |
    | `PageUp`, `Ctrl-u`           | Page up                                                    |
    | `PageDown`, `Ctrl-d`         | Page down                                                  |
    | `Home`                       | Go to first entry                                          |
    | `End`                        | Go to last entry                                           |
    | `Enter`                      | Open selected                                              |
    | `Alt-Enter`                  | Open selected in the background without closing the picker |
    | `Ctrl-s`                     | Open horizontally                                          |
    | `Ctrl-v`                     | Open vertically                                            |
    | `Ctrl-t`                     | Toggle preview                                             |
    | `Escape`, `Ctrl-c`           | Close picker                                               |
  documentationQuestion1: What is the primary purpose of the Select/Extend mode in Helix, and how does it differ from Normal mode?
  documentationQuestion2: How can a user navigate through a picker in Helix using keyboard shortcuts, and what are the key bindings for moving up and down the list?
  documentationQuestion3: What are the key differences between using `Enter` and `Alt-Enter` when interacting with a picker in Helix?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `keymap page of the documentation provided by Helix`.



    Documentation text:

    ## Prompt

    Keys to use within prompt, Remapping currently not supported.

    | Key                                         | Description                                                             |
    | -----                                       | -------------                                                           |
    | `Escape`, `Ctrl-c`                          | Close prompt                                                            |
    | `Alt-b`, `Ctrl-Left`                        | Backward a word                                                         |
    | `Ctrl-b`, `Left`                            | Backward a char                                                         |
    | `Alt-f`, `Ctrl-Right`                       | Forward a word                                                          |
    | `Ctrl-f`, `Right`                           | Forward a char                                                          |
    | `Ctrl-e`, `End`                             | Move prompt end                                                         |
    | `Ctrl-a`, `Home`                            | Move prompt start                                                       |
    | `Ctrl-w`, `Alt-Backspace`, `Ctrl-Backspace` | Delete previous word                                                    |
    | `Alt-d`, `Alt-Delete`, `Ctrl-Delete`        | Delete next word                                                        |
    | `Ctrl-u`                                    | Delete to start of line                                                 |
    | `Ctrl-k`                                    | Delete to end of line                                                   |
    | `Backspace`, `Ctrl-h`, `Shift-Backspace`    | Delete previous char                                                    |
    | `Delete`, `Ctrl-d`                          | Delete next char                                                        |
    | `Ctrl-s`                                    | Insert a word under doc cursor, may be changed to Ctrl-r Ctrl-w later   |
    | `Ctrl-p`, `Up`                              | Select previous history                                                 |
    | `Ctrl-n`, `Down`                            | Select next history                                                     |
    | `Ctrl-r`                                    | Insert the content of the register selected by following input char     |
    | `Tab`                                       | Select next completion item                                             |
    | `BackTab`                                   | Select previous completion item                                         |
    | `Enter`                                     | Open selected                                                           |
  documentationQuestion1: What are the primary purposes of the prompt key mappings in Helix, and how do they enhance the user experience?
  documentationQuestion2: How can a user navigate and edit text within the prompt in Helix using the key mappings, and what are some common commands for this?
  documentationQuestion3: Provide an example of how to use the `Ctrl-p` and `Ctrl-n` key mappings to navigate through the command history in Helix.

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `lang-support page of the documentation provided by Helix`.



    Documentation text:

    ## Language Support

    The following languages and Language Servers are supported. To use
    Language Server features, you must first [configure][lsp-config-wiki] the
    appropriate Language Server.

    You can check the language support in your installed helix version with `hx --health`.

    Also see the [Language Configuration][lang-config] docs and the [Adding
    Languages][adding-languages] guide for more language configuration information.

    {{#include ./generated/lang-support.md}}

    [lsp-config-wiki]: https://github.com/helix-editor/helix/wiki/Language-Server-Configurations
    [lang-config]: ./languages.md
    [adding-languages]: ./guides/adding_languages.md
  documentationQuestion1: What are the main purposes of the Language Support feature in Helix, and how does it enhance the development experience?
  documentationQuestion2: How can a user check the current language support status in their Helix installation, and what command is used for this?
  documentationQuestion3: What steps are required to configure a Language Server for a specific programming language in Helix, according to the documentation?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `package-managers page of the documentation provided by Helix`.



    Documentation text:

    ## Package managers

    - [Linux](#linux)
      - [Ubuntu/Debian](#ubuntudebian)
      - [Ubuntu (PPA)](#ubuntu-ppa)
      - [Fedora/RHEL](#fedorarhel)
      - [Arch Linux extra](#arch-linux-extra)
      - [NixOS](#nixos)
      - [Flatpak](#flatpak)
      - [Snap](#snap)
      - [AppImage](#appimage)
    - [macOS](#macos)
      - [Homebrew Core](#homebrew-core)
      - [MacPorts](#macports)
    - [Windows](#windows)
      - [Winget](#winget)
      - [Scoop](#scoop)
      - [Chocolatey](#chocolatey)
      - [MSYS2](#msys2)

    [![Packaging status](https://repology.org/badge/vertical-allrepos/helix-editor.svg)](https://repology.org/project/helix-editor/versions)

    ## Linux

    The following third party repositories are available:

    ### Ubuntu/Debian

    Install the Debian package from the release page.

    If you are running a system older than Ubuntu 22.04, Mint 21, or Debian 12, you can build the `.deb` file locally
    [from source](./building-from-source.md#building-the-debian-package).

    ### Ubuntu (PPA)

    Add the `PPA` for Helix:

    ```sh
    sudo add-apt-repository ppa:maveonair/helix-editor
    sudo apt update
    sudo apt install helix
    ```

    ### Fedora/RHEL

    ```sh
    sudo dnf install helix
    ```

    ### Arch Linux extra

    Releases are available in the `extra` repository:

    ```sh
    sudo pacman -S helix
    ```

    > 💡 When installed from the `extra` repository, run Helix with `helix` instead of `hx`.
    >
    > For example:
    > ```sh
    > helix --health
    > ```
    > to check health

    Additionally, a [helix-git](https://aur.archlinux.org/packages/helix-git/) package is available
    in the AUR, which builds the master branch.

    ### NixOS

    Helix is available in [nixpkgs](https://github.com/nixos/nixpkgs) through the `helix` attribute,
    the unstable channel usually carries the latest release.

    Helix is also available as a [flake](https://wiki.nixos.org/wiki/Flakes) in the project
    root. Use `nix develop` to spin up a reproducible development shell. Outputs are
    cached for each push to master using [Cachix](https://www.cachix.org/). The
    flake is configured to automatically make use of this cache assuming the user
    accepts the new settings on first use.

    If you are using a version of Nix without flakes enabled,
    [install Cachix CLI](https://docs.cachix.org/installation) and use
    `cachix use helix` to configure Nix to use cached outputs when possible.

    ### Flatpak

    Helix is available on [Flathub](https://flathub.org/en-GB/apps/com.helix_editor.Helix):

    ```sh
    flatpak install flathub com.helix_editor.Helix
    flatpak run com.helix_editor.Helix
    ```

    ### Snap

    Helix is available on [Snapcraft](https://snapcraft.io/helix) and can be installed with:

    ```sh
    snap install --classic helix
    ```

    This will install Helix as both `/snap/bin/helix` and `/snap/bin/hx`, so make sure `/snap/bin` is in your `PATH`.

    ### AppImage

    Install Helix using the Linux [AppImage](https://appimage.org/) format.
    Download the official Helix AppImage from the [latest releases](https://github.com/helix-editor/helix/releases/latest) page.

    ```sh
    chmod +x helix-*.AppImage # change permission for executable mode
    ./helix-*.AppImage # run helix
    ```

    You can optionally [add the `.desktop` file](./building-from-source.md#configure-the-desktop-shortcut). Helix must be installed in `PATH` with the name `hx`. For example:
    ```sh
    mkdir -p "$HOME/.local/bin"
    mv helix-*.AppImage "$HOME/.local/bin/hx"
    ```

    and make sure `~/.local/bin` is in your `PATH`.
  documentationQuestion1: What are the primary purposes of the package managers listed in the Helix documentation?
  documentationQuestion2: How can a user install Helix on Ubuntu using the PPA repository, and what are the key steps involved in this process?
  documentationQuestion3: What are the common use cases for the NixOS flake and Cachix integration in the context of Helix installation and development?

- prompt: |-
    You are playing the role of a college professor. Here is some text copied from the `package-managers page of the documentation provided by Helix`.



    Documentation text:

    ## macOS

    ### Homebrew Core

    ```sh
    brew install helix
    ```

    ### MacPorts

    ```sh
    sudo port install helix
    ```

    ## Windows

    Install on Windows using [Winget](https://learn.microsoft.com/en-us/windows/package-manager/winget/), [Scoop](https://scoop.sh/), [Chocolatey](https://chocolatey.org/)
    or [MSYS2](https://msys2.org/).

    ### Winget
    Windows Package Manager winget command-line tool is by default available on Windows 11 and modern versions of Windows 10 as a part of the App Installer.
    You can get [App Installer from the Microsoft Store](https://www.microsoft.com/p/app-installer/9nblggh4nns1#activetab=pivot:overviewtab). If it's already installed, make sure it is updated with the latest version.

    ```sh
    winget install Helix.Helix
    ```

    ### Scoop

    ```sh
    scoop install helix
    ```

    ### Chocolatey

    ```sh
    choco install helix
    ```

    ### MSYS2

    For 64-bit Windows 8.1 or above:

    ```sh
    pacman -S mingw-w64-ucrt-x86_64-helix
    ```
  documentationQuestion1: What is the primary purpose of the package managers (Homebrew, MacPorts, Winget, Scoop, Chocolatey, and MSYS2) in the context of installing Helix on different operating systems?
  documentationQuestion2: How would you install Helix on a Windows 10 system using the Winget package manager, and what command would you use?
  documentationQuestion3: Provide an example of how to install Helix on a macOS system using Homebrew, and explain the steps involved.

